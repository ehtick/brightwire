<assembly>
<enum name="BrightData.AggregationType">
	<summary>
		Types of aggregations
	</summary>
	<value name="Sum" value="0" summary="Sums values to a final value" />
	<value name="Average" value="1" summary="Averages values" />
	<value name="Max" value="2" summary="Finds the maximum value" />
</enum>
<enum name="BrightData.ColumnClass">
	<summary>
		Column classifications
	</summary>
	<value name="Unknown" value="0" summary="" />
	<value name="Categorical" value="1" summary="" />
	<value name="Numeric" value="2" summary="" />
	<value name="Decimal" value="4" summary="" />
	<value name="Structable" value="8" summary="" />
	<value name="Tensor" value="16" summary="" />
	<value name="IndexBased" value="32" summary="" />
	<value name="Continuous" value="64" summary="" />
	<value name="Integer" value="128" summary="" />
</enum>
<enum name="BrightData.ColumnConversionType">
	<summary>
		Single column conversion options
	</summary>
	<value name="Unchanged" value="0" summary="Leave the column unchanged (nop)" />
	<value name="ToBoolean" value="1" summary="Convert to boolean" />
	<value name="ToDate" value="2" summary="Convert to date" />
	<value name="ToNumeric" value="3" summary="Convert to numeric (best numeric size will be automatically determined)" />
	<value name="ToString" value="4" summary="Convert to string" />
	<value name="ToIndexList" value="5" summary="Convert to index list" />
	<value name="ToWeightedIndexList" value="6" summary="Convert to weighted index list" />
	<value name="ToVector" value="7" summary="Convert to vector" />
	<value name="ToCategoricalIndex" value="8" summary="Convert each value to an index within a dictionary" />
</enum>
<enum name="BrightData.ColumnType">
	<summary>
		Segment table column type
	</summary>
	<value name="Unknown" value="0" summary="Nothing" />
	<value name="Boolean" value="1" summary="Boolean values" />
	<value name="Byte" value="2" summary="Byte values (-128 to 128)" />
	<value name="Short" value="3" summary="Short values" />
	<value name="Int" value="4" summary="Integer values" />
	<value name="Long" value="5" summary="Long values" />
	<value name="Float" value="6" summary="Float values" />
	<value name="Double" value="7" summary="Double values" />
	<value name="Decimal" value="8" summary="Decimal values" />
	<value name="String" value="9" summary="String values" />
	<value name="Date" value="10" summary="Date values" />
	<value name="IndexList" value="11" summary="List of indices" />
	<value name="WeightedIndexList" value="12" summary="Weighted list of indices" />
	<value name="Vector" value="13" summary="Vector of floats" />
	<value name="Matrix" value="14" summary="Matrix of floats" />
	<value name="Tensor3D" value="15" summary="3D tensor of floats" />
	<value name="Tensor4D" value="16" summary="4D tensor of floats" />
	<value name="BinaryData" value="17" summary="Binary data" />
</enum>
<enum name="BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
	<summary>
		The type of data within the column
	</summary>
	<value name="ContinuousGaussian" value="0" summary="Continuous values" />
	<value name="Categorical" value="1" summary="Categorical values" />
</enum>
<enum name="BrightData.DataTableOrientation">
	<summary>
		Determines if the data table is oriented as either rows or columns
	</summary>
	<value name="Unknown" value="0" summary="Pathological case" />
	<value name="RowOriented" value="1" summary="Data table is a series of rows, optimised for per-row processing" />
	<value name="ColumnOriented" value="2" summary="Data table is a series of columns, optimised for column based processing" />
</enum>
<enum name="BrightData.DistanceMetric">
	<summary>
		Distance metrics
	</summary>
	<value name="Euclidean" value="0" summary="Euclidean Distance" />
	<value name="Cosine" value="1" summary="Cosine Distance Metric" />
	<value name="Manhattan" value="2" summary="Manhattan Distance" />
	<value name="MeanSquared" value="3" summary="Means Square Error" />
	<value name="SquaredEuclidean" value="4" summary="Square Euclidean" />
</enum>
<enum name="BrightWire.GaussianVarianceCalibration">
	<summary>
		Gaussian weight initialisation type
	</summary>
	<value name="SquareRootN" value="0" summary="Variances are calibrated by dividing by the square root of the connection count" />
	<value name="SquareRoot2N" value="1" summary="Variances are calibrated by multiplying by twice the square root of the connection count" />
</enum>
<enum name="BrightWire.GaussianVarianceCount">
	<summary>
		Gaussian variance count
	</summary>
	<value name="None" value="0" summary="No variance calibration is applied" />
	<value name="FanIn" value="1" summary="The count of incoming connections is used" />
	<value name="FanOut" value="2" summary="The count of outgoing connections is used" />
	<value name="FanInFanOut" value="3" summary="The count incoming and outgoing connections is used" />
</enum>
<enum name="BrightData.HybridBufferType">
	<summary>
		Type of hybrid buffer
	</summary>
	<value name="Unknown" value="0" summary="Unknown type" />
	<value name="Struct" value="1" summary="Buffer of structs" />
	<value name="String" value="2" summary="Buffer of strings" />
	<value name="EncodedStruct" value="3" summary="Buffer of encoded structs" />
	<value name="EncodedString" value="4" summary="Buffer of encoded strings" />
	<value name="Object" value="5" summary="Buffer of objects" />
</enum>
<enum name="BrightWire.MiniBatchSequenceType">
	<summary>
		Mini batch type
	</summary>
	<value name="Standard" value="0" summary="Standard batch type (non sequential batches have a single standard sequence item)" />
	<value name="SequenceStart" value="1" summary="Start of a sequence" />
	<value name="SequenceEnd" value="2" summary="End of a sequence" />
</enum>
<enum name="BrightData.NormalizationType">
	<summary>
		Types of data normalization
	</summary>
	<value name="None" value="0" summary="None" />
	<value name="Standard" value="1" summary="Standard deviation" />
	<value name="Euclidean" value="2" summary="Euclidean norm" />
	<value name="Manhattan" value="3" summary="Manhattan" />
	<value name="FeatureScale" value="4" summary="Between 0..1" />
</enum>

<interface name="BrightData.I3DFloatTensor" base="System.IDisposable">
	<summary>
		A list of matrices
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary>The number of rows in each matrix</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns in each matrix</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>The number of matrices</summary>
	</property>
	<property type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;" name="Data">
		<summary>Converts the current tensor</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrixAt">
		<summary>Returns a matrix at the specified depth</summary>
				<param type="System.UInt32" name="depth" summary="The depth to query" />
			</method>
	<method type="BrightData.IIndexable3DFloatTensor" name="AsIndexable">
		<summary>Returns an indexable 3D tensor</summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="AddPadding">
		<summary>Adds padding to each matrix</summary>
				<param type="System.UInt32" name="padding" summary="The padding (both vertical and horizontal)" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="RemovePadding">
		<summary>Removes padding from each matrix</summary>
				<param type="System.UInt32" name="padding" summary="The padding to remove" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Im2Col">
		<summary>Performs a convolution on each source matrix</summary>
				<param type="System.UInt32" name="filterWidth" summary="The filter width" />
				<param type="System.UInt32" name="filterHeight" summary="The filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Converts the tensor to a vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Converts the tensor to a matrix (each depth slice becomes a column in the new matrix)</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Reshapes the 3D tensor into a 4D tensor (the current depth becomes the count of 3D tensors and columns becomes the new depth)</summary>
				<param type="System.UInt32" name="rows" summary="Rows in each 4D tensor" />
				<param type="System.UInt32" name="columns" summary="Columns in each 4D tensor" />
			</method>
	<method type="(BrightData.I3DFloatTensor Result, BrightData.I3DFloatTensor Indices)" name="MaxPool">
		<summary>Performs a max pooling operation on the tensor</summary>
				<param type="System.UInt32" name="filterWidth" summary="The pooling filter width" />
				<param type="System.UInt32" name="filterHeight" summary="The pooling filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="saveIndices" summary="True to save the indices for a future reverse max pool operation" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseMaxPool">
		<summary>Reverses a max pooling operation</summary>
				<param type="BrightData.I3DFloatTensor" name="indices" summary="A tensor that contains the indices of each maximum value that was found per filter" />
				<param type="System.UInt32" name="outputRows" summary="Input rows" />
				<param type="System.UInt32" name="outputColumns" summary="Input columns" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseIm2Col">
		<summary>Reverses a im2col operation</summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="The rotated filters" />
				<param type="System.UInt32" name="outputRows" summary="Rows of the input tensor" />
				<param type="System.UInt32" name="outputColumns" summary="Columns of the input tensor" />
				<param type="System.UInt32" name="outputDepth" summary="Depth of the input tensor" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CombineDepthSlices">
		<summary>Adds each depth slice into a single matrix</summary>
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the other tensor to the current tensor</summary>
				<param type="BrightData.I3DFloatTensor" name="tensor" summary="Tensor to add" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Multiply">
		<summary>Multiplies the tensor with the other matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="Matrix to multiply with" />
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the vector to each row of the tensor</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="Vector to add to each row" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="TransposeThisAndMultiply">
		<summary>Transpose each sub matrix in the current tensor before multiplying it with each each sub tensor (converted to a matrix)</summary>
				<param type="BrightData.I4DFloatTensor" name="tensor" summary="Tensor to multiply with" />
			</method>
</interface>
<interface name="BrightData.I4DFloatTensor" base="System.IDisposable">
	<summary>
		A list of 3D tensors
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary>The number of rows in each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns in each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>The depth of each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>The count of 3D tensors</summary>
	</property>
	<method type="BrightData.I3DFloatTensor" name="GetTensorAt">
		<summary>Returns the tensor at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The index to query" />
			</method>
	<method type="BrightData.IIndexable4DFloatTensor" name="AsIndexable">
		<summary>Returns an indexable list of 3D tensors</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="AddPadding">
		<summary>Adds padding to the 4D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Padding to add to the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="RemovePadding">
		<summary>Removes padding from the 4D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Padding to remove from the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="(BrightData.I4DFloatTensor Result, BrightData.I4DFloatTensor Indices)" name="MaxPool">
		<summary>Applies a max pooling operation to the current tensor</summary>
				<param type="System.UInt32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="saveIndices" summary="True to save the indices for a future reverse pool operation" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReverseMaxPool">
		<summary>Reverses a max pool operation</summary>
				<param type="BrightData.I4DFloatTensor" name="indices" summary="Tensor of indices from MaxPool operation" />
				<param type="System.UInt32" name="outputRows" summary="Input tensor rows" />
				<param type="System.UInt32" name="outputColumns" summary="Input tensor columns" />
				<param type="System.UInt32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Im2Col">
		<summary>Applies the convolutional filter to each 3D tensor, producing a 3D tensor which can be multipled by the filter matrix</summary>
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReverseIm2Col">
		<summary>Reverse a previously applied im2Col</summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="List of filters that have been rotated 180 degrees" />
				<param type="System.UInt32" name="outputRows" summary="Rows of the input 4D tensor" />
				<param type="System.UInt32" name="outputColumns" summary="Columns of the input 4D tensor" />
				<param type="System.UInt32" name="outputDepth" summary="Depth of the input 4D tensor" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums">
		<summary>Sums the columns of each sub-tensor's sub matrix</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Converts the tensor to a vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Converts the tensor to a matrix (each 3D tensor becomes a column in the new matrix)</summary>
			</method>
	<property type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;[]" name="Data">
		<summary>Converts the current tensor</summary>
	</property>
</interface>
<interface name="BrightWire.IAction" base="">
	<summary>
		An action to perform when a signal reaches a node
	</summary>
		<method type="BrightWire.IGraphData" name="Execute">
		<summary>Executes the action</summary>
				<param type="BrightWire.IGraphData" name="input" summary="Current graph signal" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="Graph context" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="" />
			</method>
	<method type="System.String" name="Serialise">
		<summary>Serialises the action to a string</summary>
			</method>
	<method type="System.Void" name="Initialise">
		<summary>Initialises the action</summary>
				<param type="System.String" name="data" summary="Previously serialised data" />
			</method>
</interface>
<interface name="BrightWire.IAdaptiveDataSource" base="">
	<summary>
		Adaptive data sources apply the output from a preliminary graph
	</summary>
		<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="AdaptiveInput">
		<summary>The input node of the preliminary graph</summary>
	</property>
	<method type="BrightWire.Models.DataSourceModel" name="GetModel">
		<summary>Gets the serialised preliminary graph</summary>
				<param type="System.String" name="name" summary="Optional name to give the data source" />
			</method>
</interface>
<interface name="BrightData.IAppendableBuffer&lt;T&gt;" base="">
	<summary>
		Append only buffer
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a new item</summary>
				<param type="T" name="value" summary="Item to add" />
			</method>
</interface>
<interface name="BrightWire.IBackpropagate" base="System.IDisposable">
	<summary>
		Backpropagation handler
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphData Signal, BrightWire.IGraphSequenceContext Context, BrightWire.ExecutionGraph.Node.NodeBase ToNode)&gt;" name="Backward">
		<summary>Backpropagate</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="Graph context" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="" />
			</method>
</interface>
<interface name="BrightData.IBrightDataContext" base="System.IDisposable">
	<summary>
		Bright data context
	</summary>
		<property type="System.Random" name="Random">
		<summary>Random number generator</summary>
	</property>
	<property type="BrightData.ITensorPool" name="TensorPool">
		<summary>Tensor pool</summary>
	</property>
	<property type="BrightData.IDisposableLayers" name="MemoryLayer">
		<summary>Disposable memory layers</summary>
	</property>
	<property type="BrightData.IDataReader" name="DataReader">
		<summary>Data reader</summary>
	</property>
	<method type="BrightData.INumericComputation&lt;T&gt;" name="GetComputation">
		<summary>Typed computation</summary>
			</method>
	<property type="BrightData.IProvideTempStreams" name="TempStreamProvider">
		<summary>Temp Stream Provider</summary>
	</property>
	<method type="T" name="Get">
		<summary>Returns transient, context specific meta data</summary>
				<param type="System.String" name="name" summary="Name of value" />
				<param type="T" name="defaultValue" summary="Default value if not already set" />
			</method>
	<method type="T" name="Get">
		<summary>Returns optional context specific meta data</summary>
				<param type="System.String" name="name" summary="Name of value" />
			</method>
	<method type="T" name="Set">
		<summary>Sets transient, context specific meta data</summary>
				<param type="System.String" name="name" summary="Name of value" />
				<param type="T" name="value" summary="Value" />
			</method>
	<method type="T" name="Set">
		<summary>Sets transient, context specific meta data</summary>
				<param type="System.String" name="name" summary="Name of value" />
				<param type="System.Func&lt;T&gt;" name="valueCreator" summary="Function that will create value to set on demand if not already set" />
			</method>
	<property type="System.Boolean" name="IsStochastic">
		<summary>True if random generator has been initialized with a random initial seed</summary>
	</property>
	<method type="System.Void" name="ResetRandom">
		<summary>Resets the random number generator</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="seed" summary="Random seed (or null to randomly initialize)" />
			</method>
</interface>
<interface name="BrightData.ICanComplete" base="">
	<summary>
		Indicates that an operation can be completed
	</summary>
		<method type="System.Void" name="Complete">
		<summary>Complete the operation</summary>
			</method>
</interface>
<interface name="BrightData.ICanConvert" base="">
	<summary>
		Indicates that the type can convert different types
	</summary>
		<property type="System.Type" name="From">
		<summary>Type that is converted from</summary>
	</property>
	<property type="System.Type" name="To">
		<summary>Type that is converted to</summary>
	</property>
</interface>
<interface name="BrightData.ICanConvert&lt;TF, TT&gt;" base="BrightData.ICanConvert">
	<summary>
		Typed converter interface
	</summary>
		<method type="TT" name="Convert">
		<summary>Converts a type from one to another</summary>
				<param type="TF" name="data" summary="Object to convert" />
			</method>
</interface>
<interface name="BrightData.ICanEnumerate" base="BrightData.IHaveSize">
	<summary>
		Indicates that the type can enumerate items
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate">
		<summary>Enumerates all items</summary>
			</method>
</interface>
<interface name="BrightData.ICanEnumerate&lt;T&gt;" base="BrightData.IHaveSize">
	<summary>
		Indicates that the type can enumerate items of this type
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary>Enumerates all items</summary>
			</method>
</interface>
<interface name="BrightWire.ICanInitialiseNode" base="">
	<summary>
		Interface that allows the node to be initialised
	</summary>
		<method type="System.Void" name="Initialise">
		<summary>Initialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Node unique id" />
				<param type="System.String" name="name" summary="Friendly name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
</interface>
<interface name="BrightData.ICanInitializeFromBinaryReader" base="">
	<summary>
		Indicates that the type can initialize from a binary reader
	</summary>
		<method type="System.Void" name="Initialize">
		<summary>Initialize from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="System.IO.BinaryReader" name="reader" summary="Reader to read from to initialize" />
			</method>
</interface>
<interface name="BrightData.ICanReadSection" base="System.IDisposable">
	<summary>
		Implemented by types that can repeatedly read the same section of a stream
	</summary>
		<method type="System.IO.BinaryReader" name="GetReader">
		<summary>Creates a new reader for the readable section of the stream</summary>
			</method>
</interface>
<interface name="BrightWire.ICanSerialise" base="">
	<summary>
		Serialisation interface for graph components
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes the node state to the binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads the node state</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader that holds the node's state" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialiseToStream" base="">
	<summary>
		Standard serialisation interface
	</summary>
		<method type="System.Void" name="SerialiseTo">
		<summary>Writes the current object state to the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to write to" />
			</method>
	<method type="System.Void" name="DeserialiseFrom">
		<summary>Reads the current object state from the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="System.Boolean" name="clear" summary="True to clear the existing state" />
			</method>
</interface>
<interface name="BrightData.ICanWriteToBinaryWriter" base="">
	<summary>
		Indicates that the type can serialize to a binary writer
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Serialize to binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</interface>
<interface name="BrightData.ICloneStreams" base="">
	<summary>
		Clones streams
	</summary>
		<method type="BrightData.ICanReadSection" name="Clone">
		<summary>Creates a new repeatable section reader</summary>
			</method>
</interface>
<interface name="BrightData.IColumnInfo" base="BrightData.IHaveMetaData">
	<summary>
		Table column information
	</summary>
		<property type="System.UInt32" name="Index">
		<summary>Column index</summary>
	</property>
	<property type="BrightData.ColumnType" name="ColumnType">
		<summary>Column type</summary>
	</property>
	<property type="BrightData.IHaveDictionary" name="Dictionary">
		<summary>Encoded dictionary</summary>
	</property>
</interface>
<interface name="BrightData.IColumnOrientedDataTable" base="BrightData.IDataTable">
	<summary>
		Column oriented data table
	</summary>
		<method type="BrightData.IRowOrientedDataTable" name="AsRowOriented">
		<summary>Converts to a row oriented data table</summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="Convert">
		<summary>Creates a new table with columns that have been converted</summary>
				<param type="BrightData.IColumnTransformationParam[]" name="conversion" summary="Column conversion parameters" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="Convert">
		<summary>Creates a new table with columns that have been converted</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk" />
				<param type="BrightData.IColumnTransformationParam[]" name="conversion" summary="Column conversion parameters" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="Normalize">
		<summary>Normalizes the data in all columns of the table</summary>
				<param type="BrightData.NormalizationType" name="type" summary="Normalization type" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="Normalize">
		<summary>Normalizes the data in all columns of the table</summary>
				<param type="BrightData.IColumnTransformationParam[]" name="conversion" summary="Column normalization parameters" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="Normalize">
		<summary>Normalizes the data in all columns of the table</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk" />
				<param type="BrightData.IColumnTransformationParam[]" name="conversion" summary="Column normalization parameters" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="CopyColumns">
		<summary>Copies the selected columns to a new data table</summary>
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to copy" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="CopyColumns">
		<summary>Copies the selected columns to a new data table</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to copy" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="ConcatColumns">
		<summary>Creates a new data table with this concatenated with other column oriented data tables</summary>
				<param type="BrightData.IColumnOrientedDataTable[]" name="others" summary="Other tables to concatenate" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="ConcatColumns">
		<summary>Creates a new data table with this concatenated with other column oriented data tables</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk" />
				<param type="BrightData.IColumnOrientedDataTable[]" name="others" summary="Other tables to concatenate" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="FilterRows">
		<summary>Creates a new data table of the rows that match the predicate</summary>
				<param type="System.Predicate&lt;System.Object[]&gt;" name="predicate" summary="Predicate function to evaluate which rows to include in the new table" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="ReinterpretColumns">
		<summary>Many to one or one to many style column transformations</summary>
				<param type="BrightData.IReinterpretColumnsParam[]" name="columns" summary="Parameters to determine which columns are reinterpreted" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="ReinterpretColumns">
		<summary>Many to one or one to many style column transformations</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk" />
				<param type="BrightData.IReinterpretColumnsParam[]" name="columns" summary="Parameters to determine which columns are reinterpreted" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="Clone">
		<summary>Clones the current data table</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="BrightData.IMetaData" name="ColumnAnalysis">
		<summary>Returns the metadata for a single column after performing analysis on the column</summary>
				<param type="System.UInt32" name="columnIndex" summary="Column index to retrieve" />
				<param type="System.Boolean" name="force" summary="True to force metadata analysis" />
				<param type="System.UInt32" name="writeCount" summary="Maximum size of sequences to write in final meta data" />
				<param type="System.UInt32" name="maxCount" summary="Maximum number of distinct items to track" />
			</method>
</interface>
<interface name="BrightData.IColumnTransformationParam" base="">
	<summary>
		Informtion about a column transformation
	</summary>
		<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary>Column index</summary>
	</property>
	<method type="BrightData.ITransformColumn" name="GetTransformer">
		<summary>Gets a column transformer</summary>
				<param type="BrightData.ColumnType" name="fromType" summary="Convert from column type" />
				<param type="BrightData.ISingleTypeTableSegment" name="column" summary="Column to convert" />
				<param type="System.Func&lt;BrightData.IMetaData&gt;" name="analysedMetaData" summary="Function to produce analysed column meta data if needed" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="Temp stream provider" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="Number of rows to cache in memory" />
			</method>
</interface>
<interface name="BrightData.IConsumeColumnData" base="">
	<summary>
		Interface that
	</summary>
		<property type="System.UInt32" name="ColumnIndex">
		<summary>Column index that will be consumed</summary>
	</property>
	<property type="BrightData.ColumnType" name="ColumnType">
		<summary>Column type of incoming data</summary>
	</property>
</interface>
<interface name="BrightData.IConsumeColumnData&lt;T&gt;" base="BrightData.IConsumeColumnData">
	<summary>
		Typed column consumer that writes to a buffer
	</summary>
	</interface>
<interface name="BrightData.IContinuousDistribution" base="BrightData.IDistribution&lt;System.Single&gt;">
	<summary>
		Continuous data distribution
	</summary>
	</interface>
<interface name="BrightData.IConvertibleRow" base="BrightData.IHaveDataTable">
	<summary>
		A row that whose elements can be converted to other types
	</summary>
		<method type="System.Object" name="Get">
		<summary>Gets an element</summary>
				<param type="System.UInt32" name="index" summary="Column index" />
			</method>
	<property type="BrightData.IDataTableSegment" name="Segment">
		<summary>Returns the row segment</summary>
	</property>
	<method type="T" name="GetTyped">
		<summary>Returns a value (dynamic conversion to type T)</summary>
				<param type="System.UInt32" name="index" summary="Column index" />
			</method>
	<property type="System.UInt32" name="RowIndex">
		<summary>Row index</summary>
	</property>
</interface>
<interface name="BrightData.IConvertibleTable" base="">
	<summary>
		A table that is easily convertible to other types
	</summary>
		<method type="BrightData.IConvertibleRow" name="Row">
		<summary>Returns a row that can be easily converted</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IConvertibleRow&gt;" name="Rows">
		<summary>Returns rows that can be easily converted</summary>
				<param type="System.UInt32[]" name="rowIndices" summary="Row indices to return" />
			</method>
	<property type="BrightData.IRowOrientedDataTable" name="DataTable">
		<summary>The underlying data table</summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Map">
		<summary>Maps each row</summary>
				<param type="System.Func&lt;BrightData.IConvertibleRow, T&gt;" name="rowMapper" summary="Callback that will be invoked on each convertible row" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary>Invokes a callback on each convertible row</summary>
				<param type="System.Action&lt;BrightData.IConvertibleRow&gt;" name="action" summary="Callback" />
			</method>
</interface>
<interface name="BrightWire.ICreateGradientDescent" base="">
	<summary>
		Creates a gradient descent optimisation
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation</summary>
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightWire.ICreateGraphContext" base="">
	<summary>
		A type that can create a graph context
	</summary>
		<method type="BrightWire.IGraphSequenceContext" name="Create">
		<summary>Creates a graph context</summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Graph execution cointext" />
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="Mini batch sequence" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context (null if executing without training)" />
			</method>
</interface>
<interface name="BrightWire.ICreateTemplateBasedGradientDescent" base="">
	<summary>
		Creates gradient descent optimisations based on a matrix
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation for a particular target matrix</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="prev" summary="Any other previously created gradient descent optimisation in this context" />
				<param type="BrightData.IFloatMatrix" name="template" summary="The instance of the matrix that will be updated" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser" base="BrightData.IWriteToMetaData">
	<summary>
		Base data analyzer type
	</summary>
		<method type="System.Void" name="AddObject">
		<summary>Adds an object to analyze</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser&lt;T&gt;" base="BrightData.IDataAnalyser">
	<summary>
		Typed data analyser
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a typed object to analyze</summary>
				<param type="T" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataReader" base="">
	<summary>
		Typed data reader
	</summary>
		<method type="T" name="Read">
		<summary>Reads a typed value from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray">
		<summary>Reads a typed array from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.IDataSource" base="">
	<summary>
		Segment sources feed data into a graph
	</summary>
		<property type="System.UInt32" name="InputSize">
		<summary>The size of the input data</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary>The size of the output data</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get">
		<summary>Gets a mini batch with the specified rows</summary>
				<param type="System.UInt32[]" name="rows" summary="List of rows" />
			</method>
	<method type="System.UInt32[][]" name="GetSequentialBatches">
		<summary>For sequential data, returns the row indexes grouped by sequence length</summary>
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith">
		<summary>Creates a new data source, using the current as a template but replacing the data table</summary>
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="The new data table" />
			</method>
	<property type="BrightData.IDataTableVectoriser" name="InputVectoriser">
		<summary>Table vectoriser to create a feature vector</summary>
	</property>
	<property type="BrightData.IDataTableVectoriser" name="OutputVectoriser">
		<summary>Table vectoriser to create a target vector</summary>
	</property>
</interface>
<interface name="BrightData.IDataTable" base="BrightData.IHaveMetaData">
	<summary>
		A data table is an immutable collection of data with columns and rows (in which the columns have the same type of data)
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of columns</summary>
	</property>
	<property type="BrightData.ColumnType[]" name="ColumnTypes">
		<summary>The type of each column</summary>
	</property>
	<property type="BrightData.DataTableOrientation" name="Orientation">
		<summary>How the table is aligned (either row or column)</summary>
	</property>
	<method type="System.Void" name="ForEachRow">
		<summary>Invokes the callback on each row of the data table</summary>
				<param type="System.Action&lt;System.Object[], System.UInt32&gt;" name="callback" summary="Callback for each row" />
				<param type="System.UInt32" name="maxRows" summary="Maximum number of rows to process" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary>Invokes the callback on each row of the data table</summary>
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="Callback for each row" />
				<param type="System.UInt32" name="maxRows" summary="Maximum number of rows to process" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.ISingleTypeTableSegment&gt;" name="Columns">
		<summary>Enumerates the columns of the data table</summary>
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to retrieve" />
			</method>
	<method type="System.Void" name="ReadTyped">
		<summary>Consumes data in the table via an array of consumers, which will each consume data for each row in the table</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IConsumeColumnData&gt;" name="consumers" summary="Array of consumers, for each column in the table" />
				<param type="System.UInt32" name="maxRows" summary="Maximum number of rows to process" />
			</method>
	<method type="BrightData.ISingleTypeTableSegment" name="Column">
		<summary>Returns a single column from the table</summary>
				<param type="System.UInt32" name="columnIndex" summary="Column index to retrieve" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 ColumnIndex, BrightData.IMetaData MetaData)&gt;" name="ColumnAnalysis">
		<summary>Returns analysed metadata for the specified columns</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndices" summary="Column indices" />
			</method>
	<method type="BrightData.IMetaData" name="ColumnMetaData">
		<summary>Returns the metadata for a single column (without analysis)</summary>
				<param type="System.UInt32" name="columnIndex" summary="Column index to retrieve" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Project">
		<summary>Applies a projection function to each row of this data table</summary>
				<param type="System.Func&lt;System.Object[], System.Object[]&gt;" name="projector" summary="Mutates the rows of each row by changing values, types, or both" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="BrightData.IDataTable" name="WriteTo">
		<summary>Writes the data table to disk</summary>
				<param type="System.String" name="filePath" summary="File path" />
			</method>
</interface>
<interface name="BrightData.IDataTableSegment" base="">
	<summary>
		A series of values from a data table
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>Number of values (size of segment)</summary>
	</property>
	<property type="BrightData.ColumnType[]" name="Types">
		<summary>The column type of each value</summary>
	</property>
	<property type="System.Object" name="this">
		<summary>The value at each index (cast to object)</summary>
	</property>
</interface>
<interface name="BrightData.IDataTableSegment&lt;T&gt;" base="BrightData.ISingleTypeTableSegment">
	<summary>
		Typed data table segment (all of the same type)
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary>Enumerates the values</summary>
			</method>
</interface>
<interface name="BrightData.IDataTableVectoriser" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		Data table vectoriser
	</summary>
		<method type="System.Single[]" name="Vectorise">
		<summary>Vectorise a table row</summary>
				<param type="System.Object[]" name="row" summary="" />
			</method>
	<method type="System.Single[]" name="Vectorise">
		<summary>Vectorise a data table segment</summary>
				<param type="BrightData.IDataTableSegment" name="segment" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of the output vectors</summary>
	</property>
	<method type="System.String" name="GetOutputLabel">
		<summary>Returns the associated label from the one hot encoding dictionary</summary>
				<param type="System.UInt32" name="vectorIndex" summary="Index within one hot encoded vector" />
				<param type="System.UInt32" name="columnIndex" summary="Data table column index" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;System.Single&gt;&gt;" name="Enumerate">
		<summary>Returns a sequence of vectorised table rows</summary>
			</method>
</interface>
<interface name="BrightData.IDiscreteDistribution" base="BrightData.IDistribution&lt;System.Int32&gt;">
	<summary>
		Discrete data distribution
	</summary>
	</interface>
<interface name="BrightData.IDisposableLayers" base="">
	<summary>
		Collects a list of disposable objects that can all be disposed when the layer is disposed
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a new disposable object</summary>
				<param type="System.IDisposable" name="disposable" summary="" />
			</method>
	<method type="System.IDisposable" name="Push">
		<summary>Creates a new layer to add disposable objects to</summary>
			</method>
	<method type="System.Void" name="Pop">
		<summary>Disposes all objects in the top layer and removes this layer</summary>
			</method>
</interface>
<interface name="BrightData.IDistribution&lt;T&gt;" base="">
	<summary>
		Data distribution
	</summary>
		<method type="T" name="Sample">
		<summary>Samples a value from the distribution</summary>
			</method>
</interface>
<interface name="BrightWire.IErrorMetric" base="">
	<summary>
		Error metrics used to quantify machine learning
	</summary>
		<property type="System.Boolean" name="DisplayAsPercentage">
		<summary>True if the result should be formatted as a percentage</summary>
	</property>
	<method type="System.Single" name="Compute">
		<summary>Computes the error between the output vector and target vector</summary>
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="output" summary="The vector that was the output of the model" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="targetOutput" summary="The vector that the model was expected to output" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CalculateGradient">
		<summary>Calculates the gradient of the error function</summary>
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="The graph context" />
				<param type="BrightData.IFloatMatrix" name="output" summary="The mini batch of output vectors" />
				<param type="BrightData.IFloatMatrix" name="targetOutput" summary="The mini batch of expected target vectors" />
			</method>
</interface>
<interface name="BrightWire.IFeedForward" base="">
	<summary>
		Feed forward layer
	</summary>
		<property type="System.String" name="Id">
		<summary>Node id</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>Size of incoming connections</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of outgoing connections</summary>
	</property>
	<property type="BrightData.IFloatVector" name="Bias">
		<summary>Bias vector</summary>
	</property>
	<property type="BrightData.IFloatMatrix" name="Weight">
		<summary>Weight matrix</summary>
	</property>
	<method type="System.Void" name="UpdateWeights">
		<summary>Updates the weights</summary>
				<param type="BrightData.IFloatMatrix" name="delta" summary="Weight delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="Graph learning context" />
			</method>
</interface>
<interface name="BrightData.IFloatMatrix" base="System.IDisposable">
	<summary>
		A matrix
	</summary>
		<property type="System.Boolean" name="IsValid">
		<summary>Checks if the matrix has not been disposed</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="Multiply">
		<summary>Multiplies the current vector (without in place modification) with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Column">
		<summary>Returns a column as a vector</summary>
				<param type="System.UInt32" name="index" summary="The column index" />
			</method>
	<method type="BrightData.IFloatVector" name="Diagonal">
		<summary>Returns the matrix diagonal as a vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Row">
		<summary>Returns a row as a vector</summary>
				<param type="System.UInt32" name="index" summary="The row index" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Add">
		<summary>Returns the current matrix (without in place modification) added to the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Subtract">
		<summary>Returns the current matrix  (without in place modification) minus the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseMultiply">
		<summary>Returns the pointwise product of the current matrix (without in place modification) with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeAndMultiply">
		<summary>Returns the current matrix (without in place modification) and multipled with the transposed target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeThisAndMultiply">
		<summary>Returns the transpose of the current matrix (without in place modification) multipled with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="RowSums">
		<summary>Returns a vector that contains the sum of the elements in each row of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums">
		<summary>Returns a vector that contains the sum of the elements in each column of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Transpose">
		<summary>Returns the transpose of the current matrix</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiplies (in place) each element of the matrix by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The scalar to multiply each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Multiply">
		<summary>Returns the product of the current matrix (without in place modification) with the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the target matrix to the current matrix (in place)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts the target matrix from the current matrix (in place)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidActivation">
		<summary>Returns a new matrix with the sigmoid function applied to each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidDerivative">
		<summary>Returns a new matrix with the sigmoid derivative of each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhActivation">
		<summary>Returns a new matrix with the tanh function applied to each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhDerivative">
		<summary>Returns a new matrix with the tanh derivative of each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxActivation">
		<summary>Returns a new matrix with the softmax function applied to each row of the matrix</summary>
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the target vector to each row of the current matrix (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddToEachColumn">
		<summary>Adds the target vector to each column of the current matrix (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<property type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="Data">
		<summary>Converts the current matrix</summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="AsIndexable">
		<summary>Converts the matrix to an indexable matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromRows">
		<summary>Returns a new matrix from a subset of the current matrix's rows</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndexes" summary="The list of row indices" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromColumns">
		<summary>Returns a new matrix from a subset of the current matrix's columns</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndexes" summary="The list of column indices" />
			</method>
	<method type="System.Void" name="ClearRows">
		<summary>Set to zero the specified rows in the current matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="The list of row indices" />
			</method>
	<method type="System.Void" name="ClearColumns">
		<summary>Set to zero the specified columns in the current matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="The list of column indices" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluActivation">
		<summary>Returns the RELU function applied to each element of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluDerivative">
		<summary>Returns the RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluActivation">
		<summary>Returns the leaky RELU function applied to each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluDerivative">
		<summary>Returns the leaky RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Clone">
		<summary>Creates a copy of the current matrix</summary>
			</method>
	<method type="System.Void" name="Clear">
		<summary>Sets each element to zero</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Sqrt">
		<summary>Returns the square root of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Pow">
		<summary>Returns each element raised to specified power</summary>
				<param type="System.Single" name="power" summary="The power to apply to each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseDivide">
		<summary>Returns the current matrix (not modified in place) divided by the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="System.Void" name="L1Regularisation">
		<summary>L1 Regularisation applied to each element of the current matrix (in place)</summary>
				<param type="System.Single" name="coefficient" summary="The L1 coefficient" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnL2Norm">
		<summary>Returns a vector of the L2 norms of each column</summary>
			</method>
	<method type="BrightData.IFloatVector" name="RowL2Norm">
		<summary>Returns a vector of the L2 norms of each row</summary>
			</method>
	<method type="System.Void" name="PointwiseDivideRows">
		<summary>Pointwise divide each row by the target vector (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="PointwiseDivideColumns">
		<summary>Pointwise divide each column by the target vector (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="Constrain">
		<summary>Constrain each value within the specified min and max values (in place)</summary>
				<param type="System.Single" name="min" summary="The minimum allowed value" />
				<param type="System.Single" name="max" summary="The maximum allowed value" />
			</method>
	<method type="BrightData.IFloatVector" name="GetRowSegment">
		<summary>Returns a segment from a row of the current matrix</summary>
				<param type="System.UInt32" name="rowIndex" summary="The row index" />
				<param type="System.UInt32" name="columnIndex" summary="The start index to return" />
				<param type="System.UInt32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightData.IFloatVector" name="GetColumnSegment">
		<summary>Returns a segment from a column of the current matrix</summary>
				<param type="System.UInt32" name="columnIndex" summary="The column index" />
				<param type="System.UInt32" name="rowIndex" summary="The start index to return" />
				<param type="System.UInt32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatColumns">
		<summary>Returns a new matrix with the columns of the target matrix appended to each column of the current matrix</summary>
				<param type="BrightData.IFloatMatrix" name="bottom" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatRows">
		<summary>Returns a new matrix with the rows of the target matrix appended to each row of the current matrix</summary>
				<param type="BrightData.IFloatMatrix" name="right" summary="The target matrix" />
			</method>
	<method type="(BrightData.IFloatMatrix Left, BrightData.IFloatMatrix Right)" name="SplitAtColumn">
		<summary>Splits the rows of the current matrix into two matrices</summary>
				<param type="System.UInt32" name="columnIndex" summary="The column index at which to split" />
			</method>
	<method type="(BrightData.IFloatMatrix Top, BrightData.IFloatMatrix Bottom)" name="SplitAtRow">
		<summary>Splits the columns of the current matrix into two matrices</summary>
				<param type="System.UInt32" name="rowIndex" summary="The row index at which to split" />
			</method>
	<method type="(BrightData.IFloatMatrix U, BrightData.IFloatVector S, BrightData.IFloatMatrix VT)" name="Svd">
		<summary>Singular value decomposition</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Fast conversion to vector (the internal buffer is not modified)</summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor">
		<summary>Reshapes the matrix to a 3D tensor, treating each column as a depth slice in the new 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each sub matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each sub matrix" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Converts the matrix to a 4D tensor, treating each column as a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each sub matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each sub matrix" />
				<param type="System.UInt32" name="depth" summary="Depth of each 3D tensor" />
			</method>
	<method type="System.Single" name="GetAt">
		<summary>Returns the value at the specified row and column index</summary>
				<param type="System.UInt32" name="row" summary="Row index" />
				<param type="System.UInt32" name="column" summary="Column index" />
			</method>
	<method type="System.Void" name="SetAt">
		<summary>Updates the value at the specified row and column index</summary>
				<param type="System.UInt32" name="row" summary="Row index" />
				<param type="System.UInt32" name="column" summary="Column index" />
				<param type="System.Single" name="value" summary="Value to set" />
			</method>
	<method type="BrightData.IFloatVector[]" name="ColumnVectors">
		<summary>Returns the columns of the matrix as vectors</summary>
			</method>
	<method type="BrightData.IFloatVector[]" name="RowVectors">
		<summary>Returns the rows of the matrix as vectors</summary>
			</method>
</interface>
<interface name="BrightData.IFloatVector" base="System.IDisposable">
	<summary>
		A vector
	</summary>
		<property type="System.Boolean" name="IsValid">
		<summary>Checks if the vector has not been disposed</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsColumnMatrix">
		<summary>Converts the vector to a column matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsRowMatrix">
		<summary>Converts the vector to a row matrix</summary>
			</method>
	<property type="System.UInt32" name="Count">
		<summary>The number of elements in the vector</summary>
	</property>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Data">
		<summary>Converts the vector</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Add">
		<summary>Adds a vector (without in place modification)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The vector to add" />
			</method>
	<method type="BrightData.IFloatVector" name="Subtract">
		<summary>Subtracts a vector (without in place modification)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The vector to subtract" />
			</method>
	<method type="System.Single" name="L1Norm">
		<summary>Calculates the absolute values (L1) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.Single" name="L2Norm">
		<summary>Calculates the euclidean (L2) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.UInt32" name="MaximumIndex">
		<summary>Returns the index of the vector with the greatest value</summary>
			</method>
	<method type="System.UInt32" name="MinimumIndex">
		<summary>Returns the index of the vector with the smallest value</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiples (in place) by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to multiple each element" />
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds (in place) a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to add to each element" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a vector in place</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector to add to the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts a vector in place</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector to subtract from the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="BrightData.IIndexableFloatVector" name="AsIndexable">
		<summary>Converts the vector to an indexable vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="PointwiseMultiply">
		<summary>Pointwise multiplication (without in place modification) with a vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="DotProduct">
		<summary>The dot product of two vectors</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="BrightData.IFloatVector" name="GetNewVectorFromIndexes">
		<summary>Returns a new vector from a subset of the vector indices</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="A list of indexes to use as the source of the new vector" />
			</method>
	<method type="BrightData.IFloatVector" name="Clone">
		<summary>Creates a new copy of the vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sqrt">
		<summary>Creates a new vector in which each element is the square root of the current vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Abs">
		<summary>Creates a new vector in which each element is the absolute value of the current vector</summary>
			</method>
	<method type="System.Void" name="CopyFrom">
		<summary>Copies values from the target vector into the current vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance">
		<summary>Calculates the euclidean distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="CosineDistance">
		<summary>Calculates the cosine distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector>" />
			</method>
	<method type="System.Single" name="ManhattanDistance">
		<summary>Calculates the manhattan distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance">
		<summary>Calculates the mean squared distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="SquaredEuclidean">
		<summary>Calculates the squared euclidean distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="(System.Single Min, System.Single Max)" name="GetMinMax">
		<summary>Finds the minimum and maximum values in the current vector</summary>
			</method>
	<method type="System.Single" name="Average">
		<summary>Calculates the average value from the elements of the current vector</summary>
			</method>
	<method type="System.Single" name="StdDev">
		<summary>Calculates the standard deviation from the elements of the current vector</summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="(optional) pre calculated mean" />
			</method>
	<method type="System.Void" name="Normalize">
		<summary>Normalizes (in place) the values of the current vector</summary>
				<param type="BrightData.NormalizationType" name="type" summary="The type of normalisation" />
			</method>
	<method type="BrightData.IFloatVector" name="Softmax">
		<summary>Returns the softmax function (without in place modification) applied to the current vector
https://en.wikipedia.org/wiki/Softmax_function</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxDerivative">
		<summary>Returns the jacobian matrix of the softmax derivative</summary>
			</method>
	<method type="BrightData.IFloatVector" name="FindDistances">
		<summary>Returns a vector of distances between the current and target vectors</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="The list of target vectors" />
				<param type="BrightData.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="System.Single" name="FindDistance">
		<summary>Returns the distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="other" summary="The target vector" />
				<param type="BrightData.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="BrightData.IFloatVector" name="CosineDistance">
		<summary>Returns a vector of the cosine distance between the current and target vectors</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="The list of target vectors" />
				<param type="System.Single[]" name="dataNorm" summary="A buffer to hold the norms of the target vectors" />
			</method>
	<method type="BrightData.IFloatVector" name="Log">
		<summary>Returns a vector (without in place modification) in which each element is the natural log of each element in the current vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sigmoid">
		<summary>Returns the sigmoid function (without in place modification) applied to the current vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Fast conversion to matrix (internal buffer is used directly)</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows in the matrix" />
				<param type="System.UInt32" name="columns" summary="The number of columns in the matrix" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor">
		<summary>Converts the vector to a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Converts the vector to a 4D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
			</method>
	<method type="BrightData.IFloatVector[]" name="Split">
		<summary>Splits the vector into a list of vectors</summary>
				<param type="System.UInt32" name="blockCount" summary="The number of sub vectors to split into" />
			</method>
	<method type="System.Void" name="RotateInPlace">
		<summary>Rotates values in the vector (both horizontally and vertically within blocks)</summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Reverse">
		<summary>Returns a reversed copy of the vector's values</summary>
			</method>
	<method type="System.Single" name="GetAt">
		<summary>Returns the value at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The index of the vector to return" />
			</method>
	<method type="System.Void" name="SetAt">
		<summary>Updates the value at the specified index</summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary>Checks if every value in the vector is finite (not NaN or positive/negative infinity)</summary>
			</method>
</interface>
<interface name="BrightWire.IGradientDescentOptimisation" base="System.IDisposable">
	<summary>
		Gradient descent optimisation
	</summary>
		<method type="System.Void" name="Update">
		<summary>Updates the matrix with the delta</summary>
				<param type="BrightData.IFloatMatrix" name="source" summary="The matrix to update" />
				<param type="BrightData.IFloatMatrix" name="delta" summary="The delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="The graph learning context" />
			</method>
</interface>
<interface name="BrightWire.IGraphData" base="">
	<summary>
		Wrapper around the data that is used as a signal between nodes in the graph
	</summary>
		<property type="System.UInt32" name="Rows">
		<summary>Row count</summary>
	</property>
	<property type="System.UInt32" name="Columns">
		<summary>Column count</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>3D Tensor depth (1 if the signal is a matrix)</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>Count of 3D tensors (1 of the signal is a matrix or 3D tensor)</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrix">
		<summary>Gets the signal as a matrix</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="Get4DTensor">
		<summary>Gets the signal as a 4D tensor</summary>
			</method>
	<method type="BrightWire.IGraphData" name="ReplaceWith">
		<summary>Replaces the data with the specified matrix (but preserves any tensor meta data)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The matrix to use as a replacement" />
			</method>
	<property type="System.Boolean" name="HasValue">
		<summary>True if this graph data has been set (false for null)</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphEngine" base="BrightWire.ICreateGraphContext">
	<summary>
		Graph engines drive execution within a graph
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>Serialised version of the current graph and its parameters</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source that feeds into the graph</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="Start">
		<summary>The graph's single start node</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphExecutionContext" base="System.IDisposable">
	<summary>
		Graph execution context
	</summary>
		<method type="System.Void" name="SetMemory">
		<summary>Writes to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
				<param type="BrightData.IFloatMatrix" name="memory" summary="Segment" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetMemory">
		<summary>Reads from a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
			</method>
	<method type="BrightWire.IGraphOperation" name="GetNextOperation">
		<summary>Gets the next queued graph operation (if any)</summary>
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds a list of graph operations to the queue</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphOperation&gt;" name="operationList" summary="List of operations" />
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="System.Int32" name="RemainingOperationCount">
		<summary>How many operations remain queued</summary>
	</property>
	<method type="System.Void" name="RegisterContinuation">
		<summary>Registers a continuation that will be executed after the current sequence has been processed in full</summary>
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="Sequence index" />
				<param type="System.Action&lt;BrightWire.IGraphSequenceContext&gt;" name="callback" summary="Continuation" />
			</method>
	<method type="System.Void" name="RegisterAdditionalMiniBatch">
		<summary>Registers an additional mini batch to execute after the current mini batch has completed</summary>
				<param type="BrightWire.IMiniBatch" name="miniBatch" summary="Mini batch to execute" />
				<param type="BrightWire.IGraphData" name="data" summary="Initial data" />
				<param type="System.Action&lt;BrightWire.IGraphSequenceContext, BrightWire.IGraphData&gt;" name="startCallback" summary="Callback when starting the batch" />
				<param type="System.Action&lt;BrightWire.IGraphSequenceContext[]&gt;" name="endCallback" summary="Callback when ending the batch" />
			</method>
	<property type="System.Boolean" name="HasContinuations">
		<summary>True if there are registered continuations or additional mini batches to execute</summary>
	</property>
	<method type="System.Void" name="Continue">
		<summary>Execute any registered continuation for this context</summary>
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="Context with an associated IMiniBatchSequence" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphSequenceContext Context, System.Action&lt;BrightWire.IGraphSequenceContext[]&gt; Callback)&gt;" name="ExecuteAdditionalMiniBatch">
		<summary>Executes any additionally registered mini batches</summary>
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context (null if executing without training)" />
			</method>
</interface>
<interface name="BrightWire.IGraphExecutionEngine" base="BrightWire.IGraphEngine">
	<summary>
		Graph engine that is optimised for inference
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Execute">
		<summary>Executes a data source on the current graph</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source to process" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="Execute">
		<summary>Executes a single vector on the current graph</summary>
				<param type="System.Single[]" name="input" summary="Vector to execute" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="ExecuteSingleSequentialStep">
		<summary>Executes a sequential input on the current graph</summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Execution context" />
				<param type="System.UInt32" name="sequenceIndex" summary="Index of the current sequence (starting from 0)" />
				<param type="System.Single[]" name="input" summary="Input vector" />
				<param type="BrightWire.MiniBatchSequenceType" name="sequenceType" summary="The sequence type (start, standard, end)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="ExecuteSequential">
		<summary>Executes a sequence of inputs on the current graph</summary>
				<param type="System.Single[][]" name="input" summary="List of vector inputs" />
			</method>
	<method type="BrightWire.IGraphExecutionContext" name="CreateExecutionContext">
		<summary>Creates a graph execution context</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphOperation" base="">
	<summary>
		A pending graph operation (mini batch)
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphSequenceContext&gt;" name="Execute">
		<summary>Executes the operation</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphSequenceContext" base="System.IDisposable">
	<summary>
		Represents a single pass through the graph, from a single mini batch sequence
	</summary>
		<property type="BrightWire.IGraphData" name="Data">
		<summary>Current signal</summary>
	</property>
	<property type="BrightWire.IGraphExecutionContext" name="ExecutionContext">
		<summary>Current execution context</summary>
	</property>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Current learning context (optional)</summary>
	</property>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="BatchSequence">
		<summary>Current mini batch sequence</summary>
	</property>
	<method type="System.Void" name="AddForwardHistory">
		<summary>Records forward node execution</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="Node that was executed" />
				<param type="BrightWire.IGraphData" name="data" summary="Output from the node" />
				<param type="System.Func&lt;BrightWire.IBackpropagate&gt;" name="callback" summary="Optional callback to add backpropagation" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="prev" summary="Ancestors that fed input into the node" />
			</method>
	<method type="BrightWire.IGraphData" name="Backpropagate">
		<summary>Backpropagates the signal</summary>
				<param type="BrightWire.IGraphData" name="delta" summary="Error signal" />
			</method>
	<property type="BrightWire.IGraphData" name="ErrorSignal">
		<summary>Final error signal</summary>
	</property>
	<method type="System.Void" name="SetOutput">
		<summary>Saves the data as an output of the graph</summary>
				<param type="BrightWire.IGraphData" name="data" summary="Segment to save" />
				<param type="System.Int32" name="channel" summary="Channel to save against (optional)" />
			</method>
	<method type="BrightWire.IGraphData" name="GetOutput">
		<summary>Returns a saved output</summary>
				<param type="System.Int32" name="channel" summary="Output channel (optional)" />
			</method>
	<property type="BrightWire.IGraphData[]" name="Output">
		<summary>Returns all stored output</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Results">
		<summary>Execution results</summary>
	</property>
	<method type="System.Void" name="ClearForBackpropagation">
		<summary>Resets the context for another run of backpropagation</summary>
			</method>
	<method type="System.Void" name="SetData">
		<summary>Stores sequence specific data</summary>
				<param type="System.String" name="name" summary="Source node name" />
				<param type="System.String" name="type" summary="Data type" />
				<param type="BrightWire.IGraphData" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.String Name, BrightWire.IGraphData Data)&gt;" name="GetData">
		<summary>Retrieves sequence specific data</summary>
				<param type="System.String" name="type" summary="Data type" />
			</method>
</interface>
<interface name="BrightWire.IGraphTrainingEngine" base="BrightWire.IGraphEngine">
	<summary>
		A graph engine that can train the graph from training data
	</summary>
		<method type="System.Void" name="Train">
		<summary>Executes a training epoch on the graph</summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="System.Boolean" name="Test">
		<summary>Executes test data on the current graph</summary>
				<param type="BrightWire.IDataSource" name="testDataSource" summary="Segment source with test data" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
				<param type="System.Action&lt;System.Single, System.Boolean, System.Boolean&gt;" name="values" summary="Optional callback to get the (testError, trainingRate, isPercentage, isImprovedScore) data" />
			</method>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Graph learning context</summary>
	</property>
	<method type="System.Void" name="LoadParametersFrom">
		<summary>Loads model parameters into the existing graph</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Model to load parameters from" />
			</method>
	<method type="BrightWire.IGraphExecutionEngine" name="CreateExecutionEngine">
		<summary>Creates an inference only engine from the current graph</summary>
				<param type="BrightWire.Models.ExecutionGraphModel" name="model" summary="" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the learning context epoch and the best test result</summary>
			</method>
</interface>
<interface name="BrightWire.IHaveAction" base="">
	<summary>
		Node that exposes an action
	</summary>
		<property type="BrightWire.IAction" name="Action">
		<summary>The node's action</summary>
	</property>
</interface>
<interface name="BrightData.IHaveDataContext" base="">
	<summary>
		Indicates that the type has a data context
	</summary>
		<property type="BrightData.IBrightDataContext" name="Context">
		<summary>Bright data context</summary>
	</property>
</interface>
<interface name="BrightData.IHaveDataTable" base="">
	<summary>
		Indicates that the type has a data table
	</summary>
		<property type="BrightData.IDataTable" name="DataTable">
		<summary>Data table</summary>
	</property>
</interface>
<interface name="BrightData.IHaveDictionary" base="">
	<summary>
		Indicates that the type has a dictionary (string table)
	</summary>
		<property type="System.String[]" name="Dictionary">
		<summary>Current dictionary (string table)</summary>
	</property>
</interface>
<interface name="BrightData.IHaveIndexer" base="">
	<summary>
		Indicates that the type has string indexer
	</summary>
		<property type="BrightData.IIndexStrings" name="Indexer">
		<summary>String indexer</summary>
	</property>
</interface>
<interface name="BrightData.IHaveIndices" base="">
	<summary>
		Indicates that the type has a list of indices
	</summary>
		<property type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="Indices">
		<summary>Enumerates the indices</summary>
	</property>
</interface>
<interface name="BrightData.IHaveLinearAlgebraProvider" base="">
	<summary>
		Gives access to a linear algebra provider
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
</interface>
<interface name="BrightWire.IHaveMemoryNode" base="">
	<summary>
		Nodes that have a memory feeder sub-node
	</summary>
		<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="Memory">
		<summary>The memory feed sub node</summary>
	</property>
</interface>
<interface name="BrightData.IHaveMetaData" base="">
	<summary>
		Indicates that the type has a meta data store
	</summary>
		<property type="BrightData.IMetaData" name="MetaData">
		<summary>Meta data store</summary>
	</property>
</interface>
<interface name="BrightData.IHaveSize" base="">
	<summary>
		Indicates that the type has a size
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>Number of items</summary>
	</property>
</interface>
<interface name="BrightData.IHybridBuffer" base="BrightData.ICanEnumerate">
	<summary>
		Hybrid buffers write first to memory but then to disk once it's cache is exhausted
	</summary>
		<method type="System.Void" name="CopyTo">
		<summary>Copies the buffer to a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct items in the buffer (or null if not known)</summary>
	</property>
	<method type="System.Void" name="Add">
		<summary>Adds an object to the buffer</summary>
				<param type="System.Object" name="obj" summary="Object to add" />
			</method>
</interface>
<interface name="BrightData.IHybridBuffer&lt;T&gt;" base="BrightData.IHybridBuffer">
	<summary>
		Typed hybrid buffer
	</summary>
	</interface>
<interface name="BrightData.IIndexable3DFloatTensor" base="BrightData.I3DFloatTensor">
	<summary>
		A 3D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="BrightData.IIndexableFloatMatrix[]" name="Matrix">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the tensor as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexable4DFloatTensor" base="BrightData.I4DFloatTensor">
	<summary>
		A 4D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="BrightData.IIndexable3DFloatTensor[]" name="Tensors">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the tensor as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexableFloatMatrix" base="BrightData.IFloatMatrix">
	<summary>
		A matrix whose elements can be indexed directly
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element from the current matrix</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Rows">
		<summary>Returns the rows of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Columns">
		<summary>Returns the columns of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Returns each element in the current matrix as enumerable</summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="Map">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element" />
			</method>
	<method type="BrightData.IIndexableFloatMatrix" name="MapIndexed">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element (rowIndex: uint, columnIndex: uint, value: float) => float" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the matrix as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexableFloatVector" base="BrightData.IFloatVector">
	<summary>
		Returns an indexable vector (in which elements can be directly indexed)
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element at the specified index</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Gets the values as an enumerable</summary>
	</property>
	<method type="System.Single[]" name="ToArray">
		<summary>Converts the vector to an array</summary>
			</method>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the vector as well)</summary>
			</method>
	<method type="BrightData.IIndexableFloatVector" name="Append">
		<summary>Creates a new vector (without in place modification) in which new values are appended onto the end of the current vector</summary>
				<param type="System.Single[]" name="data" summary="The values to append" />
			</method>
</interface>
<interface name="BrightWire.IIndexListClassifier" base="">
	<summary>
		A classifier that classifies index lists
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary>Classifies the input data and returns the classifications with their weights</summary>
				<param type="BrightData.IndexList" name="indexList" summary="The index list to classify" />
			</method>
</interface>
<interface name="BrightWire.IIndexListEncoder" base="">
	<summary>
		Encodes index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the index lists to a dense vector</summary>
				<param type="BrightData.IndexList" name="indexList" summary="The index list to encode" />
			</method>
</interface>
<interface name="BrightData.IIndexStrings" base="">
	<summary>
		Indicates that the type can convert string to string indices
	</summary>
		<method type="System.UInt32" name="GetIndex">
		<summary>Returns the index for a string</summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>Gets the total number of possible string indices</summary>
	</property>
</interface>
<interface name="BrightWire.ILearningContext" base="">
	<summary>
		Graph learning context
	</summary>
		<property type="System.Double" name="EpochSeconds">
		<summary>The duration in seconds of the last epoch</summary>
	</property>
	<property type="System.Int64" name="EpochMilliseconds">
		<summary>The duration in milliseconds of the last epoch</summary>
	</property>
	<property type="System.UInt32" name="CurrentEpoch">
		<summary>The index of the current epoch (starting from one)</summary>
	</property>
	<property type="System.Single" name="LearningRate">
		<summary>The current learning/training rate</summary>
	</property>
	<property type="System.Single" name="BatchLearningRate">
		<summary>The learning rate adjusted with the current batch size</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>The current mini batch size</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The total number of rows per epoch</summary>
	</property>
	<method type="System.Void" name="StoreUpdate">
		<summary>Stores an update to the model parameters</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="fromNode" summary="The node that is affected by this update" />
				<param type="BrightData.IFloatMatrix" name="update" summary="The matrix update" />
				<param type="System.Action&lt;BrightData.IFloatMatrix&gt;" name="updater" summary="Callback to execute the update" />
			</method>
	<method type="System.Void" name="StoreUpdate">
		<summary>Stores an update to the model parameters</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="fromNode" summary="The node that is affected by this update" />
				<param type="BrightData.IFloatVector" name="update" summary="The vector update" />
				<param type="System.Action&lt;BrightData.IFloatVector&gt;" name="updater" summary="Callback to execute the update" />
			</method>
	<method type="System.Void" name="ApplyUpdates">
		<summary>Apply any deferred updates</summary>
			</method>
	<method type="System.Void" name="StartEpoch">
		<summary>Start a new epoch</summary>
			</method>
	<method type="System.Void" name="EndEpoch">
		<summary>End the current epoch</summary>
			</method>
	<method type="System.Void" name="SetRowCount">
		<summary>Sets the number of rows</summary>
				<param type="System.UInt32" name="rowCount" summary="The number of rows per epoch" />
			</method>
	<method type="System.Void" name="DeferBackpropagation">
		<summary>Register the backpropagation to be deferred</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The error signal associated with this backpropagation (optional, can be null)" />
				<param type="System.Func&lt;BrightWire.IGraphData, BrightWire.IGraphData&gt;" name="update" summary="The callback to execute the backpropagation" />
			</method>
	<method type="BrightWire.IGraphData" name="BackpropagateThroughTime">
		<summary>Backpropagates the error signal across all deferred backpropagations</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="The backpropagation signal" />
				<param type="System.Int32" name="maxDepth" summary="The maximum depth to backpropagate the signal" />
			</method>
	<method type="System.Void" name="ScheduleLearningRate">
		<summary>Schedules a change in the learning rate the specified epoch</summary>
				<param type="System.UInt32" name="atEpoch" summary="The epoch to change the learning rate" />
				<param type="System.Single" name="newLearningRate" summary="The learning rate to use at that epoch" />
			</method>
	<method type="System.Void" name="EnableNodeUpdates">
		<summary>Enable or disable node parameter updates</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to modify" />
				<param type="System.Boolean" name="enableUpdates" summary="True if the node can make updates via backpropagation" />
			</method>
	<property type="System.Action&lt;System.String&gt;" name="MessageLog">
		<summary>Sends the message to some output</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="ErrorMetric">
		<summary>Error metric to use when evaluating training progress</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory" name="GraphFactory">
		<summary>Graph factory</summary>
	</property>
	<method type="System.Void" name="ResetEpoch">
		<summary>Resets the epoch</summary>
			</method>
</interface>
<interface name="BrightData.ILinearAlgebraProvider" base="System.IDisposable">
	<summary>
		Linear algebra adaptor interfaces
	</summary>
		<property type="System.String" name="Name">
		<summary>Name of the linear algebra provider</summary>
	</property>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a new vector</summary>
				<param type="System.UInt32" name="length" summary="Length of the vector" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a vector</summary>
				<param type="System.UInt32" name="length" summary="Size of the vector" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="init" summary="Callback to initialise each element of the vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows" />
				<param type="System.UInt32" name="columns" summary="The number of columns" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows" />
				<param type="System.UInt32" name="columns" summary="The number of columns" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single&gt;" name="init" summary="Callback to initialise each element of the matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows">
		<summary>Creates a matrix from a list of vectors. Each vector will become a row in the new matrix</summary>
				<param type="BrightData.IFloatVector[]" name="vectorRows" summary="List of vectors for each row" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns">
		<summary>Creates a matrix from a list of vectors. Each vector will become a column in the new matrix</summary>
				<param type="BrightData.IFloatVector[]" name="vectorColumns" summary="List of vectors for each column" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.UInt32" name="depth" summary="Number of depth slices" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor from a list of matrices</summary>
				<param type="BrightData.IFloatMatrix[]" name="matrices" summary="List of matrices" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor from a list of 3D tensors</summary>
				<param type="BrightData.I3DFloatTensor[]" name="tensors" summary="List of 3D tensors" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor from a list of 3D tensors</summary>
				<param type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;[]" name="tensors" summary="List of 3D tensors" />
			</method>
	<method type="System.Void" name="PushLayer">
		<summary>Creates a save point in the allocation history</summary>
			</method>
	<method type="System.Void" name="PopLayer">
		<summary>Releases all allocated memory since the last save point</summary>
			</method>
	<property type="System.Boolean" name="IsGpu">
		<summary>True if the provider uses the GPU</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="CalculateDistances">
		<summary>Calculates the distance of each vector against the comparison vectors - the size of all vectors should be the same</summary>
				<param type="BrightData.IFloatVector[]" name="vectors" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IFloatVector&gt;" name="comparison" summary="" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a vector from a tensor segment</summary>
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionPredictor" base="System.IDisposable">
	<summary>
		Linear regression predictor
	</summary>
		<method type="System.Single" name="Predict">
		<summary>Predicts a value from input data</summary>
				<param type="System.Single[]" name="input" summary="The input data" />
			</method>
	<method type="System.Single[]" name="Predict">
		<summary>Bulk value prediction</summary>
				<param type="System.Single[][]" name="input" summary="List of data to predict" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionTrainer" base="">
	<summary>
		Trainer for linear regression models
	</summary>
		<method type="BrightWire.Models.Linear.LinearRegression" name="GradientDescent">
		<summary>Solves the model using gradient descent</summary>
				<param type="System.Int32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightData.IFloatVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionClassifier" base="System.IDisposable">
	<summary>
		Logistic regression classifier
	</summary>
		<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Predict">
		<summary>Outputs a list of values from 0 to 1 for each input data</summary>
				<param type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="input" summary="Input data" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionTrainer" base="">
	<summary>
		A logistic regression trainer
	</summary>
		<method type="BrightWire.Models.Linear.LogisticRegression" name="GradientDescent">
		<summary>Trains a model using gradient descent</summary>
				<param type="System.UInt32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightData.IFloatVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer&lt;T&gt;" base="BrightWire.ICanSerialiseToStream">
	<summary>
		Markov model trainer
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a sequence of items to the trainer</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer2&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 2)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer3&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 3)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMemoryNode" base="">
	<summary>
		Recurrent neural networks memory node
	</summary>
		<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Data">
		<summary>The current state of the memory node</summary>
	</property>
</interface>
<interface name="BrightData.IMetaData" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		Unstructured meta data store
	</summary>
		<method type="System.Object" name="Get">
		<summary>Returns a value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="GetNullable">
		<summary>Returns a typed nullable value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
			</method>
	<method type="T" name="Get">
		<summary>Returns a typed value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
				<param type="T" name="valueIfMissing" summary="Value to return if the value has not been set" />
			</method>
	<method type="T" name="Get">
		<summary>Returns an existing value (throws if not found)</summary>
				<param type="System.String" name="name" summary="Name of the value" />
			</method>
	<method type="T" name="Set">
		<summary>Sets a named value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
				<param type="T" name="value" summary="Value" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>XML representation of the meta data</summary>
	</property>
	<method type="System.Void" name="CopyTo">
		<summary>Copies this to another meta data store</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="Other meta data store" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary>Copies the specified values to another meta data store</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="Other meta data store" />
				<param type="System.String[]" name="keys" summary="Values to copy" />
			</method>
	<method type="System.Void" name="CopyAllExcept">
		<summary>Copies all except for the specified values to another meta data store</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="Other meta data store" />
				<param type="System.String[]" name="keys" summary="Values NOT to copy (i.e. skip)" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads values from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetStringsWithPrefix">
		<summary>Returns all value names with the specified prefix</summary>
				<param type="System.String" name="prefix" summary="Prefix to query" />
			</method>
	<method type="System.Boolean" name="Has">
		<summary>Checks if a value has been set</summary>
				<param type="System.String" name="key" summary="Name of the value" />
			</method>
	<method type="System.Void" name="Remove">
		<summary>Removes a value</summary>
				<param type="System.String" name="key" summary="Name of the value" />
			</method>
</interface>
<interface name="BrightWire.IMiniBatch" base="">
	<summary>
		Information about the current mini batch
	</summary>
		<property type="System.UInt32[]" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence">
		<summary>Gets the next item in the sequence</summary>
			</method>
	<property type="System.UInt32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex">
		<summary>Gets a sequence item</summary>
				<param type="System.UInt32" name="index" summary="The index to retrieve" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the sequence iterator</summary>
			</method>
	<property type="BrightWire.IMiniBatch" name="NextMiniBatch">
		<summary>Subsequent mini bach</summary>
	</property>
	<property type="BrightWire.IMiniBatch" name="PreviousMiniBatch">
		<summary>Previous mini batch</summary>
	</property>
</interface>
<interface name="BrightWire.IMiniBatchSequence" base="">
	<summary>
		A sequence within a mini batch
	</summary>
		<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary>Mini batch</summary>
	</property>
	<property type="System.UInt32" name="SequenceIndex">
		<summary>Index of the sequence</summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary>Sequence type</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Input">
		<summary>Input data</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary>Training target data</summary>
	</property>
	<property type="BrightWire.IGraphSequenceContext" name="GraphContext">
		<summary>Graph sequence context that has been executed for this sequence</summary>
	</property>
</interface>
<interface name="BrightData.INonNegativeDiscreteDistribution" base="BrightData.IDistribution&lt;System.UInt32&gt;">
	<summary>
		Positive discrete data distribution
	</summary>
	</interface>
<interface name="BrightData.INormalize" base="">
	<summary>
		Data normalizer
	</summary>
		<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary>Type of data normalization</summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary>Value to divide each value</summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary>Value to subtract from each value</summary>
	</property>
</interface>
<interface name="BrightData.INumericComputation&lt;T&gt;" base="">
	<summary>
		Typed generic computation
	</summary>
		<method type="BrightData.ITensorSegment&lt;T&gt;" name="Abs">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Add">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Add">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Add">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="ConstrainInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="maxValue" summary="" />
			</method>
	<method type="T" name="Average">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="T" name="CosineDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="T" name="DotProduct">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="T" name="EuclideanDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Exp">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="L1Norm">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="T" name="L2Norm">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Log">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="ManhattanDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Multiply">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="T" name="NextRandom">
		<summary></summary>
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="PointwiseDivide">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="PointwiseMultiply">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="Search">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Sqrt">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Squared">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="StdDev">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="mean" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Subtract">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Subtract">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="T" name="Sum">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="(T Min, T Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Reverse">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;BrightData.ITensorSegment&lt;T&gt;&gt;" name="Split">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Sigmoid">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="SigmoidDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Tanh">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="TanhDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Relu">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="ReluDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="LeakyRelu">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="LeakyReluDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Softmax">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="SoftmaxDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Pow">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="power" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.UInt32" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Decimal" name="val" summary="" />
			</method>
</interface>
<interface name="BrightWire.IPropertySet" base="">
	<summary>
		The current set of graph initialisation parameters
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider to use</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="WeightInitialisation">
		<summary>The weight initialiser to use</summary>
	</property>
	<property type="BrightWire.IGradientDescentOptimisation" name="GradientDescent">
		<summary>The gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="TemplateGradientDescentDescriptor">
		<summary>The template based gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="GradientDescentDescriptor">
		<summary>The descriptor to create new gradient descent optimisations</summary>
	</property>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified template based gradient descent optimisation</summary>
				<param type="BrightWire.ICreateTemplateBasedGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.ICreateGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="optimisation" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified weight initialiser</summary>
				<param type="BrightWire.IWeightInitialisation" name="weightInit" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Clone">
		<summary>Clones the current property set</summary>
			</method>
	<method type="T" name="Get">
		<summary>Gets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
	<method type="BrightWire.IPropertySet" name="Set">
		<summary>Sets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="obj" summary="The property value" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Clears the named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
</interface>
<interface name="BrightData.IProvideTempStreams" base="System.IDisposable">
	<summary>
		Temp stream provider
	</summary>
		<method type="System.IO.Stream" name="Get">
		<summary>Returns an existing or creates a new temporary stream</summary>
				<param type="System.String" name="uniqueId" summary="Id that uniquely identifies the context" />
			</method>
	<method type="System.Boolean" name="HasStream">
		<summary>Checks if a stream has been created</summary>
				<param type="System.String" name="uniqueId" summary="Id that uniquely identifies the context" />
			</method>
</interface>
<interface name="BrightWire.IRandomProjection" base="System.IDisposable">
	<summary>
		Random projection
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>The size to reduce to</summary>
	</property>
	<property type="BrightData.IFloatMatrix" name="Matrix">
		<summary>The transformation matrix</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Compute">
		<summary>Reduces a vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Compute">
		<summary>Reduces a matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
</interface>
<interface name="BrightData.IReferenceCountedMemory" base="">
	<summary>
		Reference counted memory block
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>Size of the memory block</summary>
	</property>
	<method type="System.Int32" name="AddRef">
		<summary>Adds a reference</summary>
			</method>
	<method type="System.Int32" name="Release">
		<summary>Removes a reference</summary>
			</method>
	<property type="System.Int64" name="AllocationIndex">
		<summary>Returns this block's allocation index</summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary>Checks if the block is valid</summary>
	</property>
</interface>
<interface name="BrightData.IReinterpretColumnsParam" base="">
	<summary>
		Reinterpret columns parameters
	</summary>
		<property type="System.UInt32[]" name="ColumnIndices">
		<summary>Source column indices</summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.ISingleTypeTableSegment&gt;" name="GetNewColumns">
		<summary>Gets new columns</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="Temp stream provider" />
				<param type="System.UInt32" name="initialColumnIndex" summary="First column index in the sequence" />
				<param type="(BrightData.IColumnInfo Info, BrightData.ISingleTypeTableSegment Segment)[]" name="columns" summary="Source column data" />
			</method>
</interface>
<interface name="BrightWire.IRowClassifier" base="">
	<summary>
		Classifies convertible rows
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary>Classifies a convertible row</summary>
				<param type="BrightData.IConvertibleRow" name="row" summary="Row to classify" />
			</method>
</interface>
<interface name="BrightData.IRowOrientedDataTable" base="BrightData.IDataTable">
	<summary>
		Row oriented data table
	</summary>
		<method type="BrightData.IColumnOrientedDataTable" name="AsColumnOriented">
		<summary>Converts to a column oriented data table</summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary>Invokes the callback on each specified row of the table</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndices" summary="Row indices to select" />
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="Callback to invoke on each selected row" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Bag">
		<summary>Samples (with replacement) from the data table</summary>
				<param type="System.UInt32" name="sampleCount" summary="Number of rows to sample" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="BrightData.IDataTableSegment" name="Row">
		<summary>Returns the row at the specified index</summary>
				<param type="System.UInt32" name="rowIndex" summary="Row index to retrieve" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IDataTableSegment&gt;" name="Rows">
		<summary>Returns the rows at the specified indices</summary>
				<param type="System.UInt32[]" name="rowIndices" summary="Row indices to retrieve" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Concat">
		<summary>Creates a new table of this concatenated with other row oriented data tables</summary>
				<param type="BrightData.IRowOrientedDataTable[]" name="others" summary="Other row oriented data tables to concatenate" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Concat">
		<summary>Creates a new table of this concatenated with other row oriented data tables</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
				<param type="BrightData.IRowOrientedDataTable[]" name="others" summary="Other row oriented data tables to concatenate" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="CopyRows">
		<summary>Copy specified rows from this to a new data table</summary>
				<param type="System.UInt32[]" name="rowIndices" summary="Row indices to copy" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="CopyRows">
		<summary>Copy specified rows from this to a new data table</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
				<param type="System.UInt32[]" name="rowIndices" summary="Row indices to copy" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Shuffle">
		<summary>Creates a new data table from the randomly shuffled rows of this data table</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Sort">
		<summary>Creates a new sorted data table</summary>
				<param type="System.UInt32" name="columnIndex" summary="Column index to sort" />
				<param type="System.Boolean" name="ascending" summary="True to sort ascending" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.String Label, BrightData.IRowOrientedDataTable Table)&gt;" name="GroupBy">
		<summary>Splits this table into many data tables based on the value from a column</summary>
				<param type="System.UInt32" name="columnIndex" summary="Column index to group on" />
			</method>
	<property type="System.String" name="FirstRow">
		<summary>Returns the first row as a string</summary>
	</property>
	<property type="System.String" name="SecondRow">
		<summary>Returns the second row as a string</summary>
	</property>
	<property type="System.String" name="ThirdRow">
		<summary>Returns the third row as a string</summary>
	</property>
	<property type="System.String" name="LastRow">
		<summary>Returns the last row as a string</summary>
	</property>
	<method type="BrightData.IRowOrientedDataTable" name="Clone">
		<summary>Clones the current data table</summary>
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
			</method>
</interface>
<interface name="BrightData.ISerializable" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		Supports both writing and reading from binary
	</summary>
	</interface>
<interface name="BrightData.ISetLinearAlgebraProvider" base="">
	<summary>
		Indicates that the type can set a linear algebra provider
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
</interface>
<interface name="BrightData.ISingleTypeTableSegment" base="BrightData.IHaveMetaData">
	<summary>
		A segment (series of values) in a table of which each element has the same type
	</summary>
		<property type="BrightData.ColumnType" name="SingleType">
		<summary>The single type of the segment</summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate">
		<summary>Enumerate each item (casting to object)</summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary>Number of values (size of segment)</summary>
	</property>
</interface>
<interface name="BrightWire.ITableClassifier" base="">
	<summary>
		Classifies a data table
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, (System.String Classification, System.Single Weight)[] Predictions)&gt;" name="Classify">
		<summary>Classifies each row of a data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="Table to classify" />
			</method>
</interface>
<interface name="BrightData.ITensor" base="System.IDisposable">
	<summary>
		Tensor base interface
	</summary>
		<property type="System.UInt32[]" name="Shape">
		<summary>The shape of the tensor (array of each dimension)</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Total number of elements in tensor</summary>
	</property>
	<property type="System.UInt32" name="Rank">
		<summary>Size of the Shape array</summary>
	</property>
</interface>
<interface name="BrightData.ITensor&lt;T&gt;" base="BrightData.ITensor">
	<summary>
		Typed tensor base interface
	</summary>
		<method type="BrightData.ITensorSegment&lt;T&gt;" name="GetDataCopy">
		<summary>Returns a copy of the underlying data segment</summary>
			</method>
	<property type="BrightData.ITensorSegment&lt;T&gt;" name="Segment">
		<summary>Underlying data segment</summary>
	</property>
	<property type="BrightData.INumericComputation&lt;T&gt;" name="Computation">
		<summary>Typed computation interface</summary>
	</property>
</interface>
<interface name="BrightData.ITensorPool" base="">
	<summary>
		A memory pool of tensors
	</summary>
		<method type="T[]" name="Get">
		<summary>Returns an existing cached array if available or allocates a new array otherwise</summary>
				<param type="System.UInt32" name="size" summary="Size of the tensor to allocate" />
			</method>
	<method type="System.Void" name="Reuse">
		<summary>Indicates that this array can be reused</summary>
				<param type="T[]" name="block" summary="" />
			</method>
	<property type="System.Int64" name="MaxCacheSize">
		<summary>Maximum size to cache for reusable arrays</summary>
	</property>
	<property type="System.Int64" name="CacheSize">
		<summary>Current size of cached arrays</summary>
	</property>
</interface>
<interface name="BrightData.ITensorSegment&lt;T&gt;" base="BrightData.IReferenceCountedMemory">
	<summary>
		Typed indexable data
	</summary>
		<property type="System.Boolean" name="IsContiguous">
		<summary>True if the data values are contiguous in memory</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at an index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at an index</summary>
	</property>
	<method type="T[]" name="ToArray">
		<summary>Converts the segment to an array</summary>
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Values">
		<summary>All values</summary>
	</property>
	<method type="System.Void" name="InitializeFrom">
		<summary>Initialize the segment from a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Void" name="InitializeFrom">
		<summary>Initialize the segment from a callback</summary>
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="Functions that returns values for each indexed value" />
			</method>
	<method type="System.Void" name="InitializeTo">
		<summary>Initialize the segment to a single value</summary>
				<param type="T" name="initialValue" summary="Initial value" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary>Initialize from an array</summary>
				<param type="T[]" name="initialData" summary="" />
			</method>
	<method type="System.Void" name="WriteTo">
		<summary>Writes to a stream</summary>
				<param type="System.IO.Stream" name="writerBaseStream" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary>Copies all values to an existing array</summary>
				<param type="T[]" name="array" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary>Copies all values to another segment</summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
</interface>
<interface name="BrightData.ITransformColumn" base="BrightData.ICanConvert">
	<summary>
		Transforms columns
	</summary>
		<method type="System.Void" name="Finalise">
		<summary>Complete the transformation</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store to receive transformation information" />
			</method>
</interface>
<interface name="BrightData.ITransformColumn&lt;TF, TT&gt;" base="BrightData.ITransformColumn">
	<summary>
		Typed column transformer
	</summary>
		<method type="System.Boolean" name="Convert">
		<summary>Writes the converted input to the buffer</summary>
				<param type="TF" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;TT&gt;" name="buffer" summary="" />
			</method>
</interface>
<interface name="BrightWire.IVolumeDataSource" base="">
	<summary>
		Volume (3D tensor) based data sources
	</summary>
		<property type="System.UInt32" name="Width">
		<summary>Width of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Height">
		<summary>Height of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>Depth of each input volume</summary>
	</property>
</interface>
<interface name="BrightWire.IWeightedIndexListEncoder" base="">
	<summary>
		Encodes weighted index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the weighted index list to a dense vector</summary>
				<param type="BrightData.WeightedIndexList" name="indexList" summary="" />
			</method>
</interface>
<interface name="BrightWire.IWeightInitialisation" base="">
	<summary>
		Neural network weight initialiser
	</summary>
		<method type="BrightData.IFloatVector" name="CreateBias">
		<summary>Creates the bias vector</summary>
				<param type="System.UInt32" name="size" summary="The size of the vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateWeight">
		<summary>Creates the weight matrix</summary>
				<param type="System.UInt32" name="rows" summary="Row count" />
				<param type="System.UInt32" name="columns" summary="Column count" />
			</method>
</interface>
<interface name="BrightData.IWriteToMetaData" base="">
	<summary>
		Indicates that the type can write values to meta data
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes values to meta data</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="Meta data store" />
			</method>
</interface>

<class name="BrightWire.Models.ConfusionMatrix.ActualClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.And" base="" is-static="true" is-abstract="false">
	<summary>
		Simple AND training data
	</summary>
	<method type="BrightData.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing AND training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for node backpropagation
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Dispose</summary>
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphData Signal, BrightWire.IGraphSequenceContext Context, BrightWire.ExecutionGraph.Node.NodeBase ToNode)&gt;" name="Backward" is-static="false">
		<summary>Backpropagates the error</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A bernoulli naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class[]" name="ClassData">
		<summary>Classification data</summary>
	</property>
	<property type="System.UInt32[]" name="Vocabulary">
		<summary>The list of string indexes that were in the training set</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.BigEndianBinaryReader" base="System.IO.BinaryReader" is-static="false" is-abstract="false">
	<summary>
		Binary reader for big endian streams
	</summary>
	<method type="System.Void" name="BigEndianBinaryReader" is-static="false">
		<summary>Creates a new big endian binary reader</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Int32" name="ReadInt32" is-static="false">
		<summary>Reads an int</summary>
			</method>
	<method type="System.Int16" name="ReadInt16" is-static="false">
		<summary>Reads a short</summary>
			</method>
	<method type="System.Int64" name="ReadInt64" is-static="false">
		<summary>Reads a long</summary>
			</method>
	<method type="System.UInt32" name="ReadUInt32" is-static="false">
		<summary>Reads a ulong</summary>
			</method>
</class>
<class name="BrightData.BinaryData" base="" is-static="false" is-abstract="false">
	<summary>
		Blob of binary data
	</summary>
	<method type="System.Void" name="BinaryData" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Byte[]" name="data" summary="Binary data" />
			</method>
	<method type="System.Void" name="BinaryData" is-static="false">
		<summary>Constructor</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader to read binary data from" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="System.Byte[]" name="Data">
		<summary>Byte array of binary data</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept two input signals and output one signal
	</summary>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.BinaryIntegers" base="" is-static="false" is-abstract="false">
	<summary>
		Creates random integers and returns feature vectors against binary mathematical logic
	</summary>
	<method type="BrightData.IRowOrientedDataTable" name="Addition" is-static="true">
		<summary>Creates random integers added together as feature vectors
The input feature contains two features, one for each bit at that position
The output feature contains a single feature: 1 or 0 if that bit is set in the result</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="sampleCount" summary="How many samples to generate" />
			</method>
</class>
<class name="BrightData.BrightDataContext" base="" is-static="false" is-abstract="false">
	<summary>
		Bright data context
	</summary>
	<method type="System.Void" name="BrightDataContext" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="Initial value of random seed (or null to randomly initialize)" />
				<param type="System.Int64" name="maxCacheSize" summary="Max size of cache to store in memory" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Random" name="Random">
		<summary></summary>
	</property>
	<property type="BrightData.ITensorPool" name="TensorPool">
		<summary></summary>
	</property>
	<property type="BrightData.IDisposableLayers" name="MemoryLayer">
		<summary></summary>
	</property>
	<property type="BrightData.IDataReader" name="DataReader">
		<summary></summary>
	</property>
	<method type="BrightData.INumericComputation&lt;T&gt;" name="GetComputation" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightData.IProvideTempStreams" name="TempStreamProvider">
		<summary></summary>
	</property>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="defaultValue" summary="" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="System.Func&lt;T&gt;" name="valueCreator" summary="" />
			</method>
	<property type="System.Boolean" name="IsStochastic">
		<summary></summary>
	</property>
	<method type="System.Void" name="ResetRandom" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="seed" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability" base="" is-static="false" is-abstract="false">
	<summary>
		A category and its associated log probability
	</summary>
	<property type="System.String" name="Category">
		<summary>The category label</summary>
	</property>
	<property type="System.Double" name="LogProbability">
		<summary>The natural log of the category's probability</summary>
	</property>
	<property type="System.Double" name="Probability">
		<summary>The category's probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		A classification
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The log of the prior probablilty for this classification</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The log of the missing probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of probabilities for each string index</summary>
	</property>
	<property type="System.Double" name="InverseMissingProbability">
		<summary>The log of the inverse missing probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		Classification data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification's prior log probability</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The classifications missing log probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of string indexes and their probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary" base="" is-static="false" is-abstract="false">
	<summary>
		A classification and its associated data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="LogPrior">
		<summary>The natural log of the prior</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.Column[]" name="ColumnSummary">
		<summary>The column data associated with this classification</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification prior probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.Column" base="" is-static="false" is-abstract="false">
	<summary>
		A column within the naive bayes model
	</summary>
	<property type="System.UInt32" name="ColumnIndex">
		<summary>Index within the data set</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>Type of column (categorical or continuous)</summary>
	</property>
	<property type="System.Double" name="Variance">
		<summary>The variance of the column values (continuous only)</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>The mean of the column values (continuous only)</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability[]" name="Probability">
		<summary>The list of categories within the column and their probability (categorical only)</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.Helper.ColumnTypeClassifier" base="" is-static="true" is-abstract="false">
	<summary>
		Classifies data table column types
	</summary>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary>Checks for a decimal type (floating point)</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary>Checks for a numeric type (floating point or integer)</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary>Checks for a continuous type (non categorical)</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary>Checks for a categorical type (non continuous)</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsBlittable" is-static="true">
		<summary>Checks if the type has an independent memory layout across managed and unmanaged code</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="Column type to check" />
			</method>
	<method type="BrightData.ColumnClass" name="GetClass" is-static="true">
		<summary>Returns the set of possible column classifications</summary>
				<param type="BrightData.ColumnType" name="type" summary="Column type to check" />
				<param type="BrightData.IMetaData" name="metaData" summary="Column metadata" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" base="" is-static="false" is-abstract="false">
	<summary>
		Decision tree configuration
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="FeatureBagCount">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MinDataPerNode">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MaxDepth">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="MinInformationGain">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxAttributes">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.ConfusionMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.String[]" name="ClassificationLabels">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ExpectedClassification[]" name="Classifications">
		<summary></summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="GetCount" is-static="false">
		<summary>Returns the count of the expected vs actual classifications</summary>
				<param type="System.String" name="expected" summary="Expected classification label" />
				<param type="System.String" name="actual" summary="Actual classification label" />
			</method>
</class>
<class name="BrightData.Consts" base="" is-static="false" is-abstract="false">
	<summary>
		Constants
	</summary>
</class>
<class name="BrightData.Helper.ConvolutionHelper" base="" is-static="true" is-abstract="false">
	<summary>
		Helper class to calculate convolutional indices
	</summary>
	<method type="System.Collections.Generic.List&lt;(System.UInt32 X, System.UInt32 Y)&gt;" name="LeftToRight" is-static="true">
		<summary>Generates convolution indices from left to right</summary>
				<param type="System.UInt32" name="width" summary="Input width" />
				<param type="System.UInt32" name="height" summary="Input height" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="X Stride" />
				<param type="System.UInt32" name="yStride" summary="Y Stride" />
			</method>
	<method type="System.Collections.Generic.List&lt;(System.UInt32 X, System.UInt32 Y)&gt;" name="TopToBottom" is-static="true">
		<summary>Generates convolution indices from top to bottom</summary>
				<param type="System.UInt32" name="width" summary="Input width" />
				<param type="System.UInt32" name="height" summary="Input height" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="X Stride" />
				<param type="System.UInt32" name="yStride" summary="Y Stride" />
			</method>
</class>
<class name="BrightData.Transformation.ColumnConversion.CustomConverter&lt;TF, TT&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CustomConverter" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;TF, TT&gt;" name="converter" summary="" />
				<param type="System.Action&lt;BrightData.IMetaData&gt;" name="finalise" summary="" />
			</method>
	<method type="System.Boolean" name="Convert" is-static="false">
		<summary></summary>
				<param type="TF" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;TT&gt;" name="buffer" summary="" />
			</method>
	<property type="System.Type" name="From">
		<summary></summary>
	</property>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
	<method type="System.Void" name="Finalise" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
</class>
<class name="BrightData.Helper.DataEncoder" base="" is-static="false" is-abstract="false">
	<summary>
		Encodes types from/to bytes
	</summary>
	<method type="T" name="Read" is-static="false">
		<summary>Generic method to read from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Source" />
			</method>
	<method type="T[]" name="ReadArray" is-static="false">
		<summary>Generic method to read an array from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Source" />
			</method>
	<method type="System.Void" name="Write" is-static="true">
		<summary>Generic method to write to binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Destination" />
				<param type="T" name="val" summary="Item to write" />
			</method>
	<method type="System.Void" name="Write" is-static="true">
		<summary>Generic method to write an array to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Destination" />
				<param type="T[]" name="values" summary="Array to write" />
			</method>
</class>
<class name="BrightWire.Models.DataSourceModel" base="" is-static="false" is-abstract="false">
	<summary>
		Serialises an adaptive data source - that is, a data source that takes the output from a preliminary output graph and sends it to the primary graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the data source</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>The size of each input training data item</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>The size of each training item output (classification label)</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>The preliminary graph</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for data table based data adapters
	</summary>
	<property type="System.UInt32" name="InputSize">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get" is-static="false">
		<summary></summary>
				<param type="System.UInt32[]" name="rows" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith" is-static="false">
		<summary></summary>
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="" />
			</method>
	<property type="BrightData.IDataTableVectoriser" name="InputVectoriser">
		<summary></summary>
	</property>
	<property type="BrightData.IDataTableVectoriser" name="OutputVectoriser">
		<summary></summary>
	</property>
	<method type="System.UInt32[][]" name="GetSequentialBatches" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.DataTableBuilder" base="" is-static="true" is-abstract="false">
	<summary>
		Creates standard data table builders
	</summary>
	<method type="BrightData.DataTable.Builders.InMemoryTableBuilder" name="CreateTwoColumnMatrixTableBuilder" is-static="true">
		<summary>Creates a data table builder with one feature matrix column and one target matrix column</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputRows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputColumns" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputRows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputColumns" summary="" />
			</method>
	<method type="BrightData.DataTable.Builders.InMemoryTableBuilder" name="CreateTwoColumnVectorTableBuilder" is-static="true">
		<summary>Creates a data table builder with one feature vector column and one target vector column</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputSize" summary="Size of the input vector" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputSize" summary="Size of the output vector" />
			</method>
	<method type="BrightData.DataTable.Builders.InMemoryTableBuilder" name="Create3DTensorToVectorTableBuilder" is-static="true">
		<summary>Creates a data table builder with one feature tensor 3D columns and one target vector column</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputDepth" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputRows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputColumns" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputSize" summary="Size of the output vector" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DateAnalysis" base="BrightData.Analysis.Readers.FrequencyAnalysis" is-static="false" is-abstract="false">
	<summary>
		Date analysis results
	</summary>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MinDate">
		<summary>Minimum date (null if none)</summary>
	</property>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MaxDate">
		<summary>Maximum date (null if none)</summary>
	</property>
</class>
<class name="BrightWire.Helper.DebugHelpers" base="" is-static="true" is-abstract="false">
	<summary>
		Helper classes useful when debugging BW
	</summary>
	<method type="System.String" name="WriteComparison" is-static="true">
		<summary>Zips two tensors and writes the values side by side</summary>
				<param type="BrightData.IIndexable3DFloatTensor" name="t1" summary="First tensor" />
				<param type="BrightData.IIndexable3DFloatTensor" name="t2" summary="Second tensor" />
			</method>
	<method type="System.String" name="WriteComparison" is-static="true">
		<summary>Zips two tensors and writes the values side by side</summary>
				<param type="BrightData.IIndexable4DFloatTensor" name="t1" summary="First tensor" />
				<param type="BrightData.IIndexable4DFloatTensor" name="t2" summary="Second tensor" />
			</method>
	<method type="System.String" name="WriteComparison" is-static="true">
		<summary>Zips two matrices and writes the values side by side</summary>
				<param type="BrightData.IIndexableFloatMatrix" name="m1" summary="First matrix" />
				<param type="BrightData.IIndexableFloatMatrix" name="m2" summary="Second matrix" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.DecisionTree" base="" is-static="false" is-abstract="false">
	<summary>
		A decision tree model
	</summary>
	<property type="System.UInt32" name="ClassColumnIndex">
		<summary>The classification label column index</summary>
	</property>
	<property type="BrightWire.Models.TreeBased.DecisionTree.Node" name="Root">
		<summary>The root of the tree</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Converts the tree to XML</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer" base="" is-static="true" is-abstract="false">
	<summary>
		Decision tree classifier
https://en.wikipedia.org/wiki/Decision_tree_learning
	</summary>
	<method type="BrightWire.Models.TreeBased.DecisionTree" name="Train" is-static="true">
		<summary>Trains a decision tree</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="Training data" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="Decision tree configuration" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DictionaryValues" base="" is-static="false" is-abstract="false">
	<summary>
		Dictionary that holds category string indices
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetValues" is-static="false">
		<summary>Converts from category indices to string</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="categoryIndices" summary="" />
			</method>
	<method type="System.String" name="GetValue" is-static="false">
		<summary>Gets the string associated with a category index</summary>
				<param type="System.Int32" name="categoryIndex" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DimensionAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Dimension analysis results
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="XDimension">
		<summary>Max size of the x dimension</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="YDimension">
		<summary>Max size of the y dimension</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ZDimension">
		<summary>Max size of the z dimension</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct size combinations</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Total size across all dimensions</summary>
	</property>
</class>
<class name="BrightData.Helper.DoubleMath" base="" is-static="true" is-abstract="false">
	<summary>
		Helpers for double based math
	</summary>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary>True if the numbers are approximately equal</summary>
				<param type="System.Double" name="value1" summary="First value to compare" />
				<param type="System.Double" name="value2" summary="Second value to compare" />
				<param type="System.Double" name="tolerance" summary="How close to compare" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary>True if the numbers are approximately equal</summary>
				<param type="System.Nullable&lt;System.Double&gt;" name="value1" summary="First value to compare" />
				<param type="System.Nullable&lt;System.Double&gt;" name="value2" summary="Second value to compare" />
				<param type="System.Double" name="tolerance" summary="How close to compare" />
			</method>
</class>
<class name="BrightData.Buffer.EncodedStreamWriter" base="" is-static="true" is-abstract="false">
	<summary>
		Writes hybrid buffers to binary writers, potentially encoding along the way
	</summary>
	<method type="System.Void" name="CopyTo" is-static="true">
		<summary>Writes the hybrid buffer to a stream</summary>
				<param type="BrightData.IHybridBuffer&lt;T&gt;" name="buffer" summary="Buffer to write" />
				<param type="System.IO.Stream" name="stream" summary="Stream to write to" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Error metrics
	</summary>
	<property type="BrightWire.IErrorMetric" name="BinaryClassification">
		<summary>Binary classification error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="CrossEntropy">
		<summary>Cross entropy error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="OneHotEncoding">
		<summary>One hot encoding error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="Quadratic">
		<summary>Quadratic error metric</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised execution graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Node" name="InputNode">
		<summary>The primary input node</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Node[]" name="OtherNodes">
		<summary>Other connected nodes</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Wire[]" name="Wires">
		<summary>A list of the wires that connect the nodes in the graph</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="VisitNodes" is-static="false">
		<summary>Visits each node in the graph</summary>
				<param type="T" name="param" summary="" />
				<param type="System.Action&lt;T, BrightWire.Models.ExecutionGraphModel.Node, System.UInt32&gt;" name="onEnter" summary="" />
				<param type="System.Action&lt;T, BrightWire.Models.ExecutionGraphModel.Node&gt;" name="onLeave" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>XML representation of the graph</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.ExecutionHistory" base="" is-static="false" is-abstract="false">
	<summary>
		Record of graph execution
	</summary>
	<method type="System.Void" name="ExecutionHistory" is-static="false">
		<summary>Creates a training action history from a single optional parent</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="The node that executed" />
				<param type="BrightWire.IGraphData" name="data" summary="The output of the node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="parent" summary="The single parent that contributed to the output (optional)" />
			</method>
	<method type="System.Void" name="ExecutionHistory" is-static="false">
		<summary>Creates a training action history from multiple parents</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="The node that executed" />
				<param type="BrightWire.IGraphData" name="data" summary="The output of the node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="The parent nodes that contributed to the output" />
			</method>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="Source">
		<summary>Node that was executed</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Node output signal</summary>
	</property>
	<property type="BrightWire.IBackpropagate" name="Backpropagation">
		<summary>Optional backpropagation</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="Parents">
		<summary>The node's ancestors</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.ExecutionResult" base="" is-static="false" is-abstract="false">
	<summary>
		The output from a mini batch
	</summary>
	<method type="System.Void" name="ExecutionResult" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.IMiniBatchSequence" name="miniBatch" summary="The mini batch sequence" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="output" summary="The mini batch output" />
			</method>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="Output">
		<summary>The list of output rows</summary>
	</property>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="Target">
		<summary>The list of target rows</summary>
	</property>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="Input">
		<summary>The list of input rows</summary>
	</property>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="Error">
		<summary>Optional list of errors</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="MiniBatchSequence">
		<summary>The mini batch</summary>
	</property>
	<method type="System.Single" name="CalculateError" is-static="false">
		<summary>Calculates the error of the output against the target</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="The error metric to calculate with" />
			</method>
</class>
<class name="BrightWire.Models.ConfusionMatrix.ExpectedClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ActualClassification[]" name="ActualClassifications">
		<summary></summary>
	</property>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Extension methods to attach analyser creation to the bright data context
	</summary>
	<method type="BrightData.IDataAnalyser&lt;System.DateTime&gt;" name="GetDateAnalyser" is-static="true">
		<summary>Creates a date analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="GetNumericAnalyser" is-static="true">
		<summary>Creates a numeric analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="GetConvertToStringAnalyser" is-static="true">
		<summary>Creates a frequency analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;BrightData.ITensor&lt;System.Single&gt;&gt;" name="GetDimensionAnalyser" is-static="true">
		<summary>Creates a dimension analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="GetFrequencyAnalyser" is-static="true">
		<summary>Creates a frequency analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;BrightData.IHaveIndices&gt;" name="GetIndexAnalyser" is-static="true">
		<summary>Creates an index analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;System.Double&gt;" name="GetNumericAnalyser" is-static="true">
		<summary>Creates a numeric analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;System.String&gt;" name="GetStringAnalyser" is-static="true">
		<summary>Creates a string analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IDataAnalyser" name="GetFrequencyAnalyser" is-static="true">
		<summary>Creates a frequency analyzer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.Type" name="type" summary="" />
				<param type="System.UInt32" name="maxCount" summary="Max distinct items" />
				<param type="System.UInt32" name="writeCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.Analysis.Readers.DateAnalysis" name="GetDateAnalysis" is-static="true">
		<summary>Gets the date analysis that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.DimensionAnalysis" name="GetDimensionAnalysis" is-static="true">
		<summary>Gets the dimension analysis that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.FrequencyAnalysis" name="GetFrequencyAnalysis" is-static="true">
		<summary>Gets the frequency analysis that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.IndexAnalysis" name="GetIndexAnalysis" is-static="true">
		<summary>Gets the index analysis that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.NumericAnalysis" name="GetNumericAnalysis" is-static="true">
		<summary>Gets the numeric analysis that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.StringAnalysis" name="GetStringAnalysis" is-static="true">
		<summary>Gets the string analysis that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.DictionaryValues" name="GetDictionaryValues" is-static="true">
		<summary>Gets the categories that was stored in meta data</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Transformation.NormalizeTransformation" name="GetNormalization" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.NumericAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes numbers in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DateAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes dates in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.DateTime&gt;" name="dates" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DimensionAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes tensors in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.ITensor&lt;System.Single&gt;&gt;" name="tensors" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.IndexAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes indices in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IHaveIndices&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.StringAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes a sequence of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.FrequencyAnalysis" name="AnalyzeFrequency" is-static="true">
		<summary>Analyzes the frequency of items</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.IHybridBuffer&lt;T&gt;" name="CreateHybridStructBuffer" is-static="true">
		<summary>Creates a struct buffer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="Temp stream provider" />
				<param type="System.UInt32" name="bufferSize" summary="Max items to cache in memory" />
				<param type="System.UInt16" name="maxDistinct" summary="Maximum number of distinct items (to encode)" />
			</method>
	<method type="BrightData.IHybridBuffer" name="CreateHybridStructBuffer" is-static="true">
		<summary>Creates a struct buffer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="System.Type" name="type" summary="Type of structs" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="Temp stream provider" />
				<param type="System.UInt32" name="bufferSize" summary="Max items to cache in memory" />
				<param type="System.UInt16" name="maxDistinct" summary="Maximum number of distinct items (to encode)" />
			</method>
	<method type="BrightData.IHybridBuffer&lt;System.String&gt;" name="CreateHybridStringBuffer" is-static="true">
		<summary>Creates a string buffer</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="Temp stream provider" />
				<param type="System.UInt32" name="bufferSize" summary="Max items to cache in memory" />
				<param type="System.UInt16" name="maxDistinct" summary="Maximum number of distinct items (to encode)" />
			</method>
	<method type="BrightData.IHybridBuffer&lt;T&gt;" name="CreateHybridObjectBuffer" is-static="true">
		<summary>Creates an object buffer</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="Temp stream provider" />
				<param type="System.UInt32" name="bufferSize" summary="Max items to cache in memory" />
			</method>
	<method type="BrightData.IHybridBuffer" name="CreateHybridObjectBuffer" is-static="true">
		<summary>Creates an object buffer</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Type" name="type" summary="Type of objects" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="Temp stream provider" />
				<param type="System.UInt32" name="bufferSize" summary="Max items to cache in memory" />
			</method>
	<method type="BrightData.ICanEnumerate&lt;T&gt;" name="GetBufferReader" is-static="true">
		<summary>Returns a reader that buffers items in memory</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader" />
				<param type="System.UInt32" name="inMemorySize" summary="Number of bytes to use as an in memory buffer" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="ToType" is-static="true">
		<summary>Converts a type code to a type</summary>
				<param type="System.TypeCode" name="code" summary="Type code" />
			</method>
	<method type="BrightData.IndexList" name="CreateIndexList" is-static="true">
		<summary>Creates an index list from indices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32[]" name="indices" summary="Indices" />
			</method>
	<method type="BrightData.IndexList" name="CreateIndexList" is-static="true">
		<summary>Creates an index list from indices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="Indices" />
			</method>
	<method type="BrightData.IndexList" name="CreateIndexList" is-static="true">
		<summary>Creates an index list from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<method type="BrightData.WeightedIndexList" name="CreateWeightedIndexList" is-static="true">
		<summary>Creates a weighted index list from weighted indices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="(System.UInt32 Index, System.Single Weight)[]" name="indexList" summary="Weighted indices" />
			</method>
	<method type="BrightData.WeightedIndexList" name="CreateWeightedIndexList" is-static="true">
		<summary>Creates a weighted index list from weighted indices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 Index, System.Single Weight)&gt;" name="indexList" summary="Weighted indices" />
			</method>
	<method type="BrightData.WeightedIndexList" name="CreateWeightedIndexList" is-static="true">
		<summary>Creates a weighted index list from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<method type="System.Boolean" name="SetIfNotNull" is-static="true">
		<summary>Sets a value only if the value is not null</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="SetIfNotNull" is-static="true">
		<summary>Sets a value only if the value is not null</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="HasConversionOperator" is-static="true">
		<summary>Checks if one type can be implicitly cast to another</summary>
				<param type="System.Type" name="from" summary="" />
				<param type="System.Type" name="to" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Shuffle" is-static="true">
		<summary>Randomly shuffles the items in the sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="seq" summary="" />
				<param type="System.Random" name="rnd" summary="Random number generator to use" />
			</method>
	<method type="(T[] Training, T[] Test)" name="Split" is-static="true">
		<summary>Randomly splits the sequence into a two arrays (either "training" or "test")</summary>
				<param type="T[]" name="seq" summary="" />
				<param type="System.Double" name="trainPercentage" summary="Percentage of items to add to the training array" />
			</method>
	<method type="T[]" name="Bag" is-static="true">
		<summary>Sample with replacement</summary>
				<param type="T[]" name="list" summary="" />
				<param type="System.UInt32" name="count" summary="Number of samples" />
				<param type="System.Random" name="rnd" summary="Random number generator to use" />
			</method>
	<method type="System.String" name="GetName" is-static="true">
		<summary>Item name</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="true">
		<summary>Item index</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary>True if the item is numeric</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsTarget" is-static="true">
		<summary>True if the item is a target</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary>True if the item is categorical</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsSequential" is-static="true">
		<summary>True if the item is sequential</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="GetMetaData" is-static="true">
		<summary>Writes available meta data to a new meta data store</summary>
				<param type="BrightData.IWriteToMetaData" name="writer" summary="" />
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Single&gt;" name="GetFloatConverter" is-static="true">
		<summary>Lazy create a float converter per context</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightData.ICanConvert" name="GetConverter" is-static="true">
		<summary>Creates a type converter</summary>
				<param type="System.Type" name="toType" summary="Type converter type" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.UInt32" name="count" summary="Upper bound" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.Int32" name="count" summary="Upper bound" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.UInt32" name="start" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.Int32" name="count" summary="" />
				<param type="System.Int32" name="start" summary="" />
			</method>
	<method type="System.Single" name="Aggregate" is-static="true">
		<summary>Aggregates a list of floats</summary>
				<param type="BrightData.AggregationType" name="operation" summary="" />
				<param type="System.Collections.Generic.List&lt;System.Single&gt;" name="data" summary="Data to aggregate" />
			</method>
	<method type="BrightData.IMetaData" name="SetTarget" is-static="true">
		<summary>Sets this as a target</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="isTarget" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="SetIsCategorical" is-static="true">
		<summary>Sets this as categorical</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="isCategorical" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="ConvertToWeightedIndexList" is-static="true">
		<summary>Converts the indexed classifications to weighted indexed classifications</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Boolean" name="groupByClassification" summary="True to group by classification (i.e convert the bag to a set)" />
			</method>
	<method type="System.Single" name="GetMaxWeight" is-static="true">
		<summary>Finds the greatest weight within the weighted index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the weighted index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="Tfidf" is-static="true">
		<summary>Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
https://en.wikipedia.org/wiki/Tf%E2%80%93idf</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="Normalize" is-static="true">
		<summary>Normalizes the weighted index classification list to fit between 0 and 1</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(T Item, System.UInt32 Count)&gt;" name="GroupAndCount" is-static="true">
		<summary>Groups items and counts each group</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
	<method type="System.String" name="Format" is-static="true">
		<summary>Formats groups of items</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(T Item, System.UInt32 Count)&gt;" name="items" summary="" />
				<param type="System.Char" name="separator" summary="Group separator" />
			</method>
	<method type="System.Void" name="UseLegacySerializationInput" is-static="true">
		<summary>Enables or disables legacy (version 2) binary serialization - only when reading</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Boolean" name="use" summary="True to enable" />
			</method>
	<method type="BrightData.Helper.DataEncoder" name="GetDataEncoder" is-static="true">
		<summary>Creates a data encoder</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Byte[]" name="GetData" is-static="true">
		<summary>Converts the object to a serialized buffer</summary>
				<param type="BrightData.ICanWriteToBinaryWriter" name="writable" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="GetDataType" is-static="true">
		<summary>Converts from a column type to a Type</summary>
				<param type="BrightData.ColumnType" name="type" summary="Column type" />
			</method>
	<method type="BrightData.ColumnType" name="GetColumnType" is-static="true">
		<summary>Converts from a Type to a ColumnType</summary>
				<param type="System.Type" name="dataType" summary="" />
			</method>
	<method type="System.Boolean" name="IsStructable" is-static="true">
		<summary>Checks if the column type is blittable</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary>Checks if the column type is numeric</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary>Checks if the column type is decimal</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary>Checks if the column type is continuous</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsInteger" is-static="true">
		<summary>Checks if the column type is an integer</summary>
				<param type="BrightData.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Boolean" name="IsIndexedList" is-static="true">
		<summary>Checks if the column type is an indexed list (or weighted index list)</summary>
				<param type="BrightData.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Boolean" name="IsTensor" is-static="true">
		<summary>Checks if the column type is a tensor</summary>
				<param type="BrightData.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Type" name="DataType" is-static="true">
		<summary>Returns the underlying Type for a data table segment</summary>
				<param type="BrightData.IDataTableSegment" name="segment" summary="" />
			</method>
	<method type="System.Type" name="GetDataType" is-static="true">
		<summary>Returns the underlying Type for a data table segment</summary>
				<param type="BrightData.IDataTableSegment&lt;T&gt;" name="_" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="RowIndices" is-static="true">
		<summary>Returns all row indices as an enumerable</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="ColumnIndices" is-static="true">
		<summary>Returns all column indices as an enumerable</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary>Invokes a callback on each row of a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary>Invokes a typed callback on each row of a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary>Invokes a typed callback on each row of a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0, T1&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary>Invokes a typed callback on each row of a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0, T1, T2&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary>Invokes a typed callback on each row of a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0, T1, T2, T3&gt;" name="callback" summary="" />
			</method>
	<method type="BrightData.IMetaData[]" name="AllColumnsMetaData" is-static="true">
		<summary>Returns meta data for all columns</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IMetaData&gt;" name="ColumnMetaData" is-static="true">
		<summary>Enumerates metadata for each specified column</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to retrieve" />
			</method>
	<method type="BrightData.IDataAnalyser" name="GetColumnAnalyser" is-static="true">
		<summary>Creates a column analyser</summary>
				<param type="BrightData.ColumnType" name="type" summary="Column type" />
				<param type="BrightData.IMetaData" name="metaData" summary="Column meta data" />
				<param type="System.UInt32" name="writeCount" summary="Maximum size of sequences to write in final meta data" />
				<param type="System.UInt32" name="maxCount" summary="Maximum number of distinct items to track" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="ParseCsv" is-static="true">
		<summary>Parse CSV into a column oriented data table</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="System.IO.StreamReader" name="reader" summary="CSV" />
				<param type="System.Boolean" name="hasHeader" summary="True if the CSV has a text based header" />
				<param type="System.Char" name="delimiter" summary="CSV delimiter" />
				<param type="System.String" name="fileOutputPath" summary="Optional path to save final table" />
				<param type="System.Boolean" name="writeProgress" summary="" />
				<param type="System.Int32" name="maxRows" summary="Maximum number of rows of CSV to read" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="Number of rows to cache in memory" />
				<param type="System.UInt16" name="maxDistinct" summary="Maximum number of distinct items to track" />
				<param type="System.String" name="tempBasePath" summary="" />
			</method>
	<method type="System.Void" name="WriteProgress" is-static="true">
		<summary>Writes a progress bar to the console</summary>
				<param type="System.Int32" name="newProgress" summary="Current progress" />
				<param type="System.Int32" name="oldProgress" summary="Previous progress" />
				<param type="System.Int32" name="max" summary="Maximum progress" />
			</method>
	<method type="System.Collections.Generic.List&lt;System.Object[]&gt;" name="Head" is-static="true">
		<summary>Returns the head (first few rows) of the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="size" summary="Number of rows to return" />
			</method>
	<method type="BrightData.IDataTable" name="LoadTable" is-static="true">
		<summary>Loads a data table from disk</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.String" name="filePath" summary="File path on disk" />
			</method>
	<method type="System.UInt32" name="CopyToFloatSegment" is-static="true">
		<summary>Copies a data table segment to a tensor segment</summary>
				<param type="BrightData.IDataTableSegment&lt;T&gt;" name="column" summary="Data table segment" />
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="vector" summary="Tensor segment" />
			</method>
	<method type="System.UInt32" name="CopyTo" is-static="true">
		<summary>Copies a data table segment to tensor segment</summary>
				<param type="BrightData.ISingleTypeTableSegment" name="column" summary="Data table segment" />
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="vector" summary="Tensor segment" />
			</method>
	<method type="System.Void" name="SetTargetColumn" is-static="true">
		<summary>Sets the target column of the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="Column index to make target (or null to set no target)" />
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="GetTargetColumn" is-static="true">
		<summary>Returns the target column of the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
			</method>
	<method type="System.UInt32" name="GetTargetColumnOrThrow" is-static="true">
		<summary>Returns the target column or throws an exception if none set</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="ColumnIndicesOfFeatures" is-static="true">
		<summary>Returns the feature (non target) columns of the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="SetType" is-static="true">
		<summary>Sets the column type in a meta data store</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="BrightData.ColumnType" name="type" summary="" />
			</method>
	<method type="BrightData.IHybridBuffer" name="GetGrowableSegment" is-static="true">
		<summary>Creates an appendable buffer for a column type</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="BrightData.ColumnType" name="type" summary="Column type" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="In memory cache size" />
				<param type="System.UInt16" name="maxDistinct" summary="Maximum number of distinct items to track" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="BuildColumnOrientedTable" is-static="true">
		<summary>Creates a column oriented data table from a list of segments</summary>
				<param type="System.Collections.Generic.List&lt;BrightData.ISingleTypeTableSegment&gt;" name="segments" summary="" />
				<param type="BrightData.IMetaData" name="metaData" summary="Table meta data" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rowCount" summary="Number of rows" />
				<param type="System.String" name="filePath" summary="File path to save on disk (optional)" />
				<param type="System.Action&lt;BrightData.ISingleTypeTableSegment&gt;" name="onBeforeWrite" summary="Callback before writing each column (optional)" />
				<param type="System.Action&lt;System.Int64&gt;" name="onAfterWrite" summary="Callback after writing each column (optional)" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="BuildRowOrientedTable" is-static="true">
		<summary>Creates a row oriented data table from a list of segments</summary>
				<param type="System.Collections.Generic.List&lt;BrightData.ISingleTypeTableSegment&gt;" name="segments" summary="" />
				<param type="BrightData.IMetaData" name="metaData" summary="Table meta data" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rowCount" summary="Number of rows" />
				<param type="System.String" name="filePath" summary="File path to save on disk (optional)" />
			</method>
	<method type="BrightData.IColumnInfo" name="ChangeColumnType" is-static="true">
		<summary>Creates a column info with a new column type</summary>
				<param type="BrightData.IColumnInfo" name="column" summary="Column info source" />
				<param type="BrightData.ColumnType" name="newType" summary="New column type" />
			</method>
	<method type="BrightData.IConvertibleTable" name="AsConvertible" is-static="true">
		<summary>Creates a convertible data table</summary>
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="Data table to use as basis" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.LinearAlgebra.Vector&lt;System.Single&gt; Numeric, System.String Label)&gt;" name="GetVectorisedFeatures" is-static="true">
		<summary>Converts the data table to a sequence of labeled vectors (feature columns are vectorised, target column is converted to a string)</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightData.ColumnType" name="GetColumnType" is-static="true">
		<summary>Gets the column type</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.UInt32" name="GetNumDistinct" is-static="true">
		<summary>Gets the number of distinct items</summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="BrightData.DataTable.Builders.InMemoryTableBuilder" name="BuildTable" is-static="true">
		<summary>Creates a table builder</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="(BrightData.IRowOrientedDataTable Training, BrightData.IRowOrientedDataTable Test)" name="Split" is-static="true">
		<summary>Splits a data table into training and test tables (rows are randomly selected for either)</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="" />
				<param type="System.Double" name="trainingFraction" summary="Fraction (0..1) of rows to add to the training table" />
				<param type="System.String" name="trainingFilePath" summary="Path to write training table to disk (optional)" />
				<param type="System.String" name="testFilePath" summary="Path to write test table to disk (optional)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IRowOrientedDataTable Training, BrightData.IRowOrientedDataTable Validation)&gt;" name="Fold" is-static="true">
		<summary>Folds the data table into k buckets (for k fold cross validation)</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="" />
				<param type="System.Int32" name="k" summary="Number of buckets to create" />
				<param type="System.Boolean" name="shuffle" summary="True to shuffle the table before folding" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;System.Single&gt;&gt;" name="GetColumnsAsVectors" is-static="true">
		<summary>Returns columns as vectors</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to return as vectors" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 ColumnIndex, BrightData.IMetaData MetaData)&gt;" name="ColumnAnalysis" is-static="true">
		<summary>Returns analysed column meta data</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices" />
			</method>
	<method type="BrightData.IMetaData[]" name="AllColumnAnalysis" is-static="true">
		<summary>Returns analysed column meta data for all columns in the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="true">
		<summary>Strongly typed enumeration of items in segment</summary>
				<param type="BrightData.ISingleTypeTableSegment" name="segment" summary="" />
			</method>
	<method type="T[]" name="ToArray" is-static="true">
		<summary>Reads the segment as a strongly typed array</summary>
				<param type="BrightData.ISingleTypeTableSegment" name="segment" summary="" />
			</method>
	<method type="(BrightData.LinearAlgebra.Matrix&lt;System.Single&gt; Features, BrightData.LinearAlgebra.Matrix&lt;System.Single&gt; Target)" name="AsMatrices" is-static="true">
		<summary>Converts the data table to feature and target matrices</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="AsMatrix" is-static="true">
		<summary>Converts data table columns to a matrix</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to include in the matrix" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="Vectorise" is-static="true">
		<summary>Creates a new data table that has two vector columns, one for the features and the other for the target</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="oneHotEncodeToMultipleColumns" summary="" />
				<param type="System.String" name="filePath" summary="Optional path to save data table to disk" />
			</method>
	<method type="BrightData.IDataTableSegment&lt;T&gt;" name="Column" is-static="true">
		<summary>Returns a data table segment from the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="T[]" name="ToArray" is-static="true">
		<summary>Converts a data table segment to an array</summary>
				<param type="BrightData.IDataTableSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts indexed classifications to a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts weighted index classifications to a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightData.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts the vector classifications into a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.LinearAlgebra.Vector&lt;System.Single&gt; Data)&gt;" name="data" summary="" />
				<param type="System.Boolean" name="preserveVectors" summary="True to create a data table with a vector column type, false to to convert to columns of floats" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Classification, BrightData.LinearAlgebra.Vector&lt;System.Single&gt; Data)&gt;" name="Vectorise" is-static="true">
		<summary>Converts the weighted index classification list to a list of dense vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Object" name="GetDefaultValue" is-static="true">
		<summary>Returns a default value for a column type</summary>
				<param type="BrightData.ColumnType" name="columnType" summary="" />
			</method>
	<method type="BrightData.IDataTableVectoriser" name="GetVectoriser" is-static="true">
		<summary>Returns a vectoriser</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.Boolean" name="oneHotEncodeToMultipleColumns" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to vectorise" />
			</method>
	<method type="BrightData.IDataTableVectoriser" name="LoadVectoriser" is-static="true">
		<summary>Loads a previously created data table vectoriser</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="Reader to load parameters from" />
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="ConvertTable" is-static="true">
		<summary>Converts columns</summary>
				<param type="BrightData.IColumnOrientedDataTable" name="dataTable" summary="" />
				<param type="BrightData.ColumnConversionType[]" name="conversions" summary="" />
			</method>
	<method type="BrightData.IColumnTransformationParam" name="ConvertColumn" is-static="true">
		<summary>Creates a column conversion parameter</summary>
				<param type="BrightData.ColumnConversionType" name="type" summary="Type of column conversion" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IColumnTransformationParam" name="ConvertColumn" is-static="true">
		<summary>Creates a column normalization parameter</summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IReinterpretColumnsParam" name="ReinterpretColumns" is-static="true">
		<summary>Creates a reinterpret columns parameter</summary>
				<param type="System.UInt32[]" name="sourceColumnIndices" summary="" />
				<param type="BrightData.ColumnType" name="newColumnType" summary="" />
				<param type="System.String" name="newColumnName" summary="" />
			</method>
	<method type="System.Object[]" name="ToArray" is-static="true">
		<summary>Converts the segment to an array</summary>
				<param type="BrightData.IDataTableSegment" name="row" summary="" />
			</method>
	<method type="BrightData.IDataTableSegment&lt;T&gt;" name="GetColumn" is-static="true">
		<summary>Returns a strongly typed column from the data table</summary>
				<param type="BrightData.IColumnOrientedDataTable" name="table" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="Column index to retrieve" />
			</method>
	<method type="T" name="Get" is-static="true">
		<summary>Casts the value at column index to type T</summary>
				<param type="BrightData.IDataTableSegment" name="segment" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IDataTableSegment&gt;" name="Sample" is-static="true">
		<summary>Samples rows from the data table</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="" />
				<param type="System.UInt32" name="sampleSize" summary="Number of rows to sample" />
			</method>
	<method type="BrightData.IColumnTransformationParam" name="CreateCustomColumnConverter" is-static="true">
		<summary>Creates a custom column converter</summary>
				<param type="BrightData.IColumnOrientedDataTable" name="table" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="Column index to convert" />
				<param type="System.Func&lt;TF, TT&gt;" name="converter" summary="Column converter" />
				<param type="System.Action&lt;BrightData.IMetaData&gt;" name="columnFinaliser" summary="Called after each row " />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Single" name="NextRandomFloat" is-static="true">
		<summary>Returns a randomly initialized float</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.UInt32" name="RandomIndex" is-static="true">
		<summary>Returns a randomly initialized positive number</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="length" summary="Exclusive upper bound" />
			</method>
	<method type="System.UInt32" name="RandomIndex" is-static="true">
		<summary>Returns a randomly initialized positive number</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="length" summary="Exclusive upper bound" />
			</method>
	<method type="BrightData.INonNegativeDiscreteDistribution" name="CreateBernoulliDistribution" is-static="true">
		<summary>Create a bernoulli distribution</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
			</method>
	<method type="BrightData.INonNegativeDiscreteDistribution" name="CreateBinomialDistribution" is-static="true">
		<summary>Create a binomial distribution</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
				<param type="System.UInt32" name="numTrials" summary="" />
			</method>
	<method type="BrightData.INonNegativeDiscreteDistribution" name="CreateCategoricalDistribution" is-static="true">
		<summary>Create a categorical distribution</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="categoricalValues" summary="" />
			</method>
	<method type="BrightData.IContinuousDistribution" name="CreateContinuousDistribution" is-static="true">
		<summary>Create a continuous distribution</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="inclusiveLowerBound" summary="" />
				<param type="System.Single" name="exclusiveUpperBound" summary="" />
			</method>
	<method type="BrightData.IDiscreteDistribution" name="CreateDiscreteUniformDistribution" is-static="true">
		<summary>Create a discrete uniform distribution</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="inclusiveLowerBound" summary="" />
				<param type="System.Int32" name="exclusiveUpperBound" summary="" />
			</method>
	<method type="BrightData.IContinuousDistribution" name="CreateNormalDistribution" is-static="true">
		<summary>Create a normal distribution</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="mean" summary="" />
				<param type="System.Single" name="stdDev" summary="Standard deviation" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="size" summary="Size of vector" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="Callback to initialize each value (optional)" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="size" summary="Size of vector" />
				<param type="T" name="initialValue" summary="Initial value of each element" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[]" name="initialData" summary="Initial data" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary>Creates a vector from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrix" is-static="true">
		<summary>Creates a matrix</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, T&gt;" name="initializer" summary="Callback to initialize each value (optional)" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrix" is-static="true">
		<summary>Creates a matrix</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="T" name="initialValue" summary="Initial value of each element" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrix" is-static="true">
		<summary>Creates a matrix from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrixFromRows" is-static="true">
		<summary>Creates a matrix from vectors (each will become a row)</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.LinearAlgebra.Vector&lt;T&gt;[]" name="rows" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrixFromRows" is-static="true">
		<summary>Creates a matrix from rows (each will become a row)</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[][]" name="rows" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from vectors (each will become a column)</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.LinearAlgebra.Vector&lt;T&gt;[]" name="columns" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="CreateMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from vectors (each will become a column)</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[][]" name="columns" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor3D&lt;T&gt;" name="CreateTensor3D" is-static="true">
		<summary>Creates a 3D tensor</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in each matrix" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor3D&lt;T&gt;" name="CreateTensor3D" is-static="true">
		<summary>Creates a 3D tensor from matrices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.LinearAlgebra.Matrix&lt;T&gt;[]" name="slices" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor3D&lt;T&gt;" name="CreateTensor3D" is-static="true">
		<summary>Create a 3D tensor from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor4D&lt;T&gt;" name="CreateTensor4D" is-static="true">
		<summary>Creates a 4D tensor</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in each matrix" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor4D&lt;T&gt;" name="CreateTensor4D" is-static="true">
		<summary>Creates a 4D tensor from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.UInt32" name="GetColumnCount" is-static="true">
		<summary>Returns the number of columns in this tensor</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetRowCount" is-static="true">
		<summary>Returns the number of rows in this tensor</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetDepth" is-static="true">
		<summary>Returns the number of matrices in this tensor</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetCount" is-static="true">
		<summary>Returns the number of 3D tensors in this tensor</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector from an enumerable of floats</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="data" summary="The initial values in the vector" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatVector" name="data" summary="Indexable vector to copy" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IFloatVector" name="data" summary="Vector to copy" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="data" summary="Vector to copy" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Single[]" name="data" summary="List of values" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="length" summary="Vector size" />
				<param type="System.Single" name="value" summary="Constant value" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateZeroMatrix" is-static="true">
		<summary>Creates a matrix with every element initialized to zero</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix" is-static="true">
		<summary>Creates a matrix from an existing matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="matrix" summary="Matrix to copy" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary>Creates a matrix from row vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="rowList" summary="List of vectors (each vector becomes a row in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary>Creates a matrix from row vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatVector[]" name="rowList" summary="List of indexable vectors (each vector becomes a row in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from column vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="columnList" summary="List of vectors (each vector becomes a column in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary>Creates a matrix column vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatVector[]" name="columnList" summary="List of indexable vectors (each vector becomes a column in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix" is-static="true">
		<summary>Creates a matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.Single" name="value" summary="Constant value to initialize each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix" is-static="true">
		<summary>Creates a matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatMatrix" name="matrix" summary="Indexable matrix to copy" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateIdentityMatrix" is-static="true">
		<summary>Creates an identity matrix (each diagonal element is 1, each other element is 0)</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="size" summary="Width and height of the new matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateDiagonalMatrix" is-static="true">
		<summary>Creates a diagonal matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Single[]" name="values" summary="Diagonal values" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor" is-static="true">
		<summary>Creates a 3D tensor</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;" name="tensor" summary="The tensor to copy from" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor" is-static="true">
		<summary>Creates a 3D tensor from matrices</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;[]" name="matrices" summary="Matrices to copy fropm" />
			</method>
	<method type="BrightData.IFloatVector" name="Calculate" is-static="true">
		<summary>Calculates the distance between two matrices</summary>
				<param type="BrightData.DistanceMetric" name="distance" summary="Distance metric (either euclidean or square euclidean)" />
				<param type="BrightData.IFloatMatrix" name="matrix1" summary="First matrix" />
				<param type="BrightData.IFloatMatrix" name="matrix2" summary="Second matrix" />
			</method>
	<method type="System.Single" name="Calculate" is-static="true">
		<summary>Calculates the distance between two vectors</summary>
				<param type="BrightData.DistanceMetric" name="distance" summary="Distance metric" />
				<param type="BrightData.IFloatVector" name="vector1" summary="First vector" />
				<param type="BrightData.IFloatVector" name="vector2" summary="Second vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary>Creates a matrix from row vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;System.Single&gt;&gt;" name="rows" summary="Row vectors" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary>Creates a matrix from row vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="rows" summary="Row vectors" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from column vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;System.Single&gt;&gt;" name="columns" summary="Column vectors" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from column vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="columns" summary="Column vectors" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="AsFloatVectors" is-static="true">
		<summary>Converts vectors to float vectors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;System.Single&gt;&gt;" name="vectors" summary="" />
			</method>
	<method type="System.Void" name="Set" is-static="true">
		<summary>Sets each element in a tensor</summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="vector" summary="" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="getValue" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="CreateSegment" is-static="true">
		<summary>Creates a tensor segment from an existing array</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[]" name="block" summary="Array to copy values from" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="CreateSegment" is-static="true">
		<summary>Creates a tensor segment</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="size" summary="Size of new segment" />
			</method>
	<method type="System.Void" name="InitializeRandomly" is-static="true">
		<summary>Randomly initialize a tensor</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="true">
		<summary>Initialize a tensor to a single value</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
				<param type="T" name="value" summary="Value to initialize each element of the tensor" />
			</method>
	<method type="System.Void" name="Initialize" is-static="true">
		<summary>Initialize a tensor using a callback</summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="Callback for each element" />
			</method>
	<method type="System.Single" name="CosineDistance" is-static="true">
		<summary>Calculates the cosine distance between two vectors</summary>
				<param type="System.Single[]" name="vector" summary="" />
				<param type="System.Single[]" name="other" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance" is-static="true">
		<summary>Calculates euclidean distance between two vectors</summary>
				<param type="System.Single[]" name="vector" summary="" />
				<param type="System.Single[]" name="other" summary="" />
			</method>
	<method type="System.Single" name="ManhattanDistance" is-static="true">
		<summary>Calculates manhattan distance between two vectors</summary>
				<param type="System.Single[]" name="vector" summary="" />
				<param type="System.Single[]" name="other" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Mutate" is-static="true">
		<summary>Mutates a vector via a callback</summary>
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="vector" summary="Vector to mutate" />
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="Callback that can mutate each value of the vector" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="MutateWith" is-static="true">
		<summary>Mutates a vector by combining it with another vector</summary>
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="vector" summary="Vector to mutate" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="other" summary="Other vector" />
				<param type="System.Func&lt;System.Single, System.Single, System.Single&gt;" name="mutator" summary="Callback that can mutate each value of the vector" />
			</method>
	<method type="BrightData.WeightedIndexList" name="ToSparse" is-static="true">
		<summary>Converts the tensor segment to a sparse format (only non zero entries are preserved)</summary>
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="ReadVectorFrom" is-static="true">
		<summary>Reads a vector from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="ReadMatrixFrom" is-static="true">
		<summary>Reads a matrix from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Static extension methods
	</summary>
	<method type="BrightWire.IMarkovModelTrainer2&lt;T&gt;" name="CreateMarkovTrainer2" is-static="true">
		<summary>Create a markov model trainer of window size 2</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="T" name="empty" summary="Null value for T" />
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="BrightWire.IMarkovModelTrainer3&lt;T&gt;" name="CreateMarkovTrainer3" is-static="true">
		<summary>Create a markov model trainer of window size 3</summary>
				<param type="BrightData.IBrightDataContext" name="_" summary="" />
				<param type="T" name="empty" summary="Null value for T" />
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="T[]" name="GetFields" is-static="true">
		<summary>Gets the strongly typed fields from a convertible row as an array</summary>
				<param type="BrightData.IConvertibleRow" name="row" summary="" />
				<param type="System.UInt32[]" name="indices" summary="Column indices to retrieve" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IConvertibleRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row in the data table</summary>
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IConvertibleRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row in the data table</summary>
				<param type="BrightData.IConvertibleTable" name="convertible" summary="" />
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IFloatVector Vector, System.UInt32 RowIndex, System.String Label)&gt;" name="GetRowsAsLabeledFeatures" is-static="true">
		<summary>Enumerates rows in the table as vectorized rows</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="HierarchicalCluster" is-static="true">
		<summary>Clusters the rows in the data table using hierarchical clustering</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="Number of clusters" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="KMeans" is-static="true">
		<summary>Clusters the rows in the data table using k-means clustering</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="Number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="Maximum number of iterations" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric to use" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="NonNegativeMatrixFactorisation" is-static="true">
		<summary>Clusters the rows in the data table using non negative matrix factorisation clustering</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="Number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="Maximum number of iterations" />
			</method>
	<method type="System.UInt32" name="GetOutputSizeOrThrow" is-static="true">
		<summary>Returns the output size (throw exception if not set)</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.GraphFactory" name="CreateGraphFactory" is-static="true">
		<summary>Creates a graph factory</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.GraphFactory" name="CreateGraphFactory" is-static="true">
		<summary>Creates a graph factory</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="CreateSequentialWindow" is-static="true">
		<summary>Creates a matrix to vector training table in which the matrix contains a window of sequentially ordered rows</summary>
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="windowSize" summary="The number of rows in each matrix" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to select" />
			</method>
	<method type="BrightWire.Models.ConfusionMatrix" name="CreateConfusionMatrix" is-static="true">
		<summary>Creates a confusion matrix from two columns of a data table</summary>
				<param type="BrightData.IConvertibleTable" name="dataTable" summary="Data table" />
				<param type="System.UInt32" name="actualClassificationColumnIndex" summary="The column index of the actual classifications" />
				<param type="System.UInt32" name="expectedClassificationColumnIndex" summary="The column index of the expected classifications" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, System.String Classification, System.Single Score)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row of the index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="The classifier to classify each item in the list" />
			</method>
	<method type="BrightWire.IRowClassifier" name="AsRowClassifier" is-static="true">
		<summary>Converts the index list classifier to a row classifier</summary>
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="Index list classifier" />
				<param type="System.UInt32" name="columnIndex" summary="Column index to classify" />
				<param type="BrightData.IIndexStrings" name="indexer" summary="String indexer (optional)" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.Models.GraphModel" name="Train" is-static="true">
		<summary>Trains a graph for a fixed number of iterations</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="The graph training engine" />
				<param type="System.UInt32" name="numIterations" summary="The number of iterations to train for" />
				<param type="BrightWire.IDataSource" name="testData" summary="The test data source to use" />
				<param type="System.Action&lt;BrightWire.Models.GraphModel&gt;" name="onImprovement" summary="Optional callback for when the test data score has improved against the error metric" />
				<param type="System.Int32" name="testCadence" summary="Determines how many epochs elapse before the test data is evaluated" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IConvertibleRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classifiy" is-static="true">
		<summary>Classifies each row of the data table</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel" name="GetGraph" is-static="true">
		<summary>Serialises the node and any other connected nodes to an execution graph</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input" summary="" />
				<param type="System.String" name="name" summary="Name of the graph (optional)" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateFrom" is-static="true">
		<summary>Creates a node and any other connected nodes from a serialised execution graph</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Serialised graph" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[][]" name="OrderSequentialOutput" is-static="true">
		<summary>Aligns the output of sequential graph execution into an ordered list of results</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="results" summary="Output from sequential graph execution" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the matrix to a generic IGraphData</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="Matrix to convert" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the 3D tensor to a generic IGraphData</summary>
				<param type="BrightData.I3DFloatTensor" name="tensor" summary="Tensor to convert" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the 4D tensor to a generic IGraphData</summary>
				<param type="BrightData.I4DFloatTensor" name="tensor" summary="Tensor to convert" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphSequenceContext&gt;" name="GetGraphContexts" is-static="true">
		<summary>Finds the graph sequence contexts that have been executed in this mini batch</summary>
				<param type="BrightWire.IMiniBatch" name="miniBatch" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.IRandomProjection" name="CreateRandomProjection" is-static="true">
		<summary>Random projections allow you to reduce the dimensions of a matrix while still preserving significant information</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="fixedSize" summary="The vector size to reduce from" />
				<param type="System.UInt32" name="reducedSize" summary="The vector size to reduce to" />
				<param type="System.Int32" name="s" summary="" />
			</method>
	<method type="BrightWire.Models.Linear.LogisticRegression" name="TrainLogisticRegression" is-static="true">
		<summary>Trains a logistic regression model on a data table</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="The training data" />
				<param type="System.UInt32" name="iterations" summary="Number of iterations to train for" />
				<param type="System.Single" name="learningRate" summary="The learning rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Optional callback that is called after each iteration with the current cost" />
			</method>
	<method type="BrightWire.ILogisticRegressionTrainer" name="CreateLogisticRegressionTrainer" is-static="true">
		<summary>Logistic regression learns a sigmoid function over a set of data that learns to classify future values into positive or negative samples</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="The training data provider" />
			</method>
	<method type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a pair of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
			</method>
	<method type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a tuple of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
				<param type="T" name="item3" summary="The third observation" />
			</method>
	<method type="BrightData.IFloatVector[][]" name="Nnmf" is-static="true">
		<summary>Non negative matrix factorisation - clustering based on matrix factorisation. Only applicable for training data that is non-negative.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="data" summary="The training data" />
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear alegbra provider" />
				<param type="System.UInt32" name="k" summary="The number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="The maximum number of iterations" />
			</method>
	<method type="BrightData.IFloatVector[][]" name="HierachicalCluster" is-static="true">
		<summary>Hierachical clustering successively finds the closest distance between pairs of centroids until k is reached</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="data" summary="The list of vectors to cluster" />
				<param type="System.UInt32" name="k" summary="The number of clusters to find" />
			</method>
	<method type="BrightData.IFloatVector[][]" name="KMeans" is-static="true">
		<summary>K Means uses coordinate descent and a distance metric between randomly selected centroids to cluster the data</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="data" summary="The list of vectors to cluster" />
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="System.UInt32" name="k" summary="The number of clusters to find" />
				<param type="System.UInt32" name="maxIterations" summary="The maximum number of iterations" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric to use to compare centroids" />
			</method>
	<method type="BrightWire.Models.InstanceBased.KNearestNeighbours" name="TrainKNearestNeighbours" is-static="true">
		<summary>K Nearest Neighbours is an instance based classification method that uses examples from training data to predict classifications</summary>
				<param type="BrightData.IDataTable" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.Linear.MultinomialLogisticRegression" name="TrainMultinomialLogisticRegression" is-static="true">
		<summary>Multinomial Logistic Regression generalises Logistic Regression to multi-class classification</summary>
				<param type="BrightData.IRowOrientedDataTable" name="data" summary="The training data" />
				<param type="System.UInt32" name="trainingIterations" summary="Number of training iterations" />
				<param type="System.Single" name="trainingRate" summary="Training rate" />
				<param type="System.Single" name="lambda" summary="L2 regularisation" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Optional callback that is called after each iteration with the current cost" />
			</method>
	<method type="BrightWire.Models.TreeBased.RandomForest" name="TrainRandomForest" is-static="true">
		<summary>Random forests are built on a bagged collection of features to try to capture the most salient points of the training data without overfitting</summary>
				<param type="BrightData.IRowOrientedDataTable" name="data" summary="The training data" />
				<param type="System.UInt32" name="b" summary="The number of trees in the forest" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="baggedRowCount" summary="" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
	<method type="BrightWire.Models.TreeBased.DecisionTree" name="TrainDecisionTree" is-static="true">
		<summary>Decision trees build a logical tree to classify data. Various measures can be specified to prevent overfitting.</summary>
				<param type="BrightData.IRowOrientedDataTable" name="data" summary="The training data" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
	<method type="BrightWire.Models.Bayesian.MultinomialNaiveBayes" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Classification, BrightData.IndexList Data)&gt;" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.Bayesian.MultinomialNaiveBayes" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="The training data table that must have a index-list based column to classify against" />
			</method>
	<method type="BrightWire.Models.Bayesian.BernoulliNaiveBayes" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Classification, BrightData.IndexList Data)&gt;" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.Bayesian.BernoulliNaiveBayes" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="BrightData.IRowOrientedDataTable" name="table" summary="The training data table that must have an index-list based column" />
			</method>
	<method type="BrightWire.Models.Bayesian.NaiveBayes" name="TrainNaiveBayes" is-static="true">
		<summary>Naive bayes is a classifier that assumes conditional independence between all features</summary>
				<param type="BrightData.IDataTable" name="table" summary="The training data provider" />
			</method>
	<method type="BrightWire.ILinearRegressionTrainer" name="CreateLinearRegressionTrainer" is-static="true">
		<summary>Linear regression fits a line to a set of data that allows you predict future values</summary>
				<param type="BrightData.IDataTable" name="table" summary="The training data table" />
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.String" name="GetBestClassification" is-static="true">
		<summary>Finds the classification with the highest weight</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Label, System.Single Weight)&gt;" name="classifications" summary="List of weighted classifications" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel" name="TrainSimpleNeuralNetwork" is-static="true">
		<summary>Trains a neural network with a single hidden layer</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="graph" summary="" />
				<param type="BrightData.IRowOrientedDataTable" name="trainingTable" summary="" />
				<param type="BrightData.IRowOrientedDataTable" name="testTable" summary="" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="" />
				<param type="System.Single" name="learningRate" summary="" />
				<param type="System.UInt32" name="batchSize" summary="" />
				<param type="System.UInt32" name="hiddenLayerSize" summary="" />
				<param type="System.UInt32" name="numIterations" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory, BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="activation" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider, BrightWire.ICreateTemplateBasedGradientDescent&gt;" name="gradientDescent" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider, BrightWire.IWeightInitialisation&gt;" name="weightInitialisation" summary="" />
			</method>
</class>
<class name="BrightData.Helper.FloatMath" base="" is-static="true" is-abstract="false">
	<summary>
		Constrained float math helpers - if the value is too small or too big it will be capped. Also NaN values are replaced with zero.
	</summary>
	<method type="System.Single" name="Log" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Exp" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Sqrt" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
				<param type="System.Single" name="adjustment" summary="" />
			</method>
	<method type="System.Single" name="Pow" is-static="true">
		<summary></summary>
				<param type="System.Single" name="x" summary="" />
				<param type="System.Single" name="y" summary="" />
			</method>
	<method type="System.Boolean" name="IsZero" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsNotZero" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="AreEqual" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value1" summary="" />
				<param type="System.Single" name="value2" summary="" />
				<param type="System.Single" name="tolerance" summary="" />
			</method>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Next" is-static="true">
		<summary></summary>
				<param type="System.Random" name="rand" summary="" />
			</method>
	<method type="System.Collections.Generic.IEqualityComparer&lt;System.Single&gt;" name="GetEqualityComparer" is-static="true">
		<summary></summary>
				<param type="System.Single" name="tolerance" summary="" />
			</method>
	<method type="System.Int32" name="FloatToInt32Bits" is-static="true">
		<summary></summary>
				<param type="System.Single" name="f" summary="" />
			</method>
	<method type="System.Boolean" name="AlmostEqual2SComplement" is-static="true">
		<summary></summary>
				<param type="System.Single" name="a" summary="" />
				<param type="System.Single" name="b" summary="" />
				<param type="System.Int32" name="maxDeltaBits" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="System.Single" name="v1" summary="" />
				<param type="System.Single" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexable4DFloatTensor" name="t1" summary="" />
				<param type="BrightData.IIndexable4DFloatTensor" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexable3DFloatTensor" name="t1" summary="" />
				<param type="BrightData.IIndexable3DFloatTensor" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexableFloatMatrix" name="m1" summary="" />
				<param type="BrightData.IIndexableFloatMatrix" name="m2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexableFloatVector" name="v1" summary="" />
				<param type="BrightData.IIndexableFloatVector" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.Tensor4D&lt;System.Single&gt;" name="t1" summary="" />
				<param type="BrightData.LinearAlgebra.Tensor4D&lt;System.Single&gt;" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;" name="t1" summary="" />
				<param type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="m1" summary="" />
				<param type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="m2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="v1" summary="" />
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.FrequencyAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Frequency analysis results
	</summary>
	<property type="System.UInt64" name="Total">
		<summary>Total number of items observed</summary>
	</property>
	<property type="System.String" name="MostFrequent">
		<summary>Most frequent item</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct items</summary>
	</property>
	<property type="(System.String Label, System.Double Value)[]" name="Frequency">
		<summary>Ranked histogram</summary>
	</property>
</class>
<class name="BrightData.Helper.GenericActivator" base="" is-static="true" is-abstract="false">
	<summary>
		Generic object creator
	</summary>
	<method type="T" name="Create" is-static="true">
		<summary>Creates a new object</summary>
				<param type="System.Type" name="type" summary="Type of object to create" />
				<param type="System.Object[]" name="args" summary="Arguments to pass to constructor" />
			</method>
	<method type="(T1, T2)" name="Create" is-static="true">
		<summary>Creates a new object</summary>
				<param type="System.Type" name="type" summary="Type of object to create" />
				<param type="System.Object[]" name="args" summary="Arguments to pass to constructor" />
			</method>
	<method type="T" name="Create" is-static="true">
		<summary>Creates a new object (via default constructor)</summary>
			</method>
	<method type="T" name="CreateUninitialized" is-static="true">
		<summary>Creates a new unitialized object (constructor is not invoked)</summary>
			</method>
	<method type="T" name="CreateUninitialized" is-static="true">
		<summary>Creates a new unitialized object (constructor is not invoked)</summary>
				<param type="System.Type" name="type" summary="Type to create" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt gradient descent optimisers
	</summary>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad">
		<summary>Adagrad gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam">
		<summary>Adam gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum">
		<summary>Momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum">
		<summary>Nesterov momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp">
		<summary>Rms prop gradient descent</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Provides standard graph actions
	</summary>
	<method type="BrightWire.IAction" name="Constrain" is-static="false">
		<summary>Constrains the signal through the graph (either forward or backward)</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Helper.GraphData" base="" is-static="true" is-abstract="false">
	<summary>
		Graph data constants
	</summary>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory" base="" is-static="false" is-abstract="false">
	<summary>
		Creates graph nodes
	</summary>
	<method type="System.Void" name="GraphFactory" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider to use" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="A property set with initialisation data (optional)" />
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary>Bright data context</summary>
	</property>
	<property type="BrightWire.IPropertySet" name="CurrentPropertySet">
		<summary>The current property set</summary>
	</property>
	<method type="System.Void" name="PushPropertySet" is-static="false">
		<summary>Clones the current property set with an optional mutator and then pushes it onto the stack</summary>
				<param type="System.Action&lt;BrightWire.IPropertySet&gt;" name="mutator" summary="Callback that can modify the cloned property set" />
			</method>
	<method type="System.Void" name="PopPropertyStack" is-static="false">
		<summary>Pops the last property set from the stack</summary>
			</method>
	<method type="BrightWire.IGradientDescentOptimisation" name="CreateWeightUpdater" is-static="false">
		<summary>Creates a gradient descent optimiser for the given matrix</summary>
				<param type="BrightData.IFloatMatrix" name="weight" summary="" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source with training data" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to train with" />
				<param type="System.Single" name="learningRate" summary="Initial learning rate" />
				<param type="System.UInt32" name="batchSize" summary="Mini batch size" />
			</method>
	<method type="BrightWire.IGraphExecutionEngine" name="CreateExecutionEngine" is-static="false">
		<summary>Creates a graph execution engine</summary>
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="The serialised graph to execute" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of vectors</summary>
				<param type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="vectorList" summary="The list of vectors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of matrices (sequential vectors)</summary>
				<param type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;[]" name="sequenceList" summary="The list of matrices that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of tensors</summary>
				<param type="BrightData.LinearAlgebra.Tensor3D&lt;System.Single&gt;[]" name="tensorList" summary="The list of tensors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a data table</summary>
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="The data table to convert" />
				<param type="System.UInt32[]" name="featureColumns" summary="Column indices to use as features (or none to use all non target columns)" />
			</method>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase RowClassifier, System.UInt32 OutputSize)" name="CreateClassifier" is-static="false">
		<summary>Create a row classifier node</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="The classifier for each row" />
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="The data table that contains the rows to classify (linked by mini batch index)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateFeedForward" is-static="false">
		<summary>Creates a feed forward layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateDropConnect" is-static="false">
		<summary>Creates a new drop connect layer (a feed forward layer with drop out applied to the weights)</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage of connections to drop (0..1)" />
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateTiedFeedForward" is-static="false">
		<summary>Creates a layer whose weights are shared with another layer (but transposed)</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer that shares weights" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateConvolutional" is-static="false">
		<summary>Creates a convolutional layer</summary>
				<param type="System.UInt32" name="inputDepth" summary="Input depth" />
				<param type="System.UInt32" name="filterCount" summary="Number of convolutional filters" />
				<param type="System.UInt32" name="padding" summary="Padding to apply before convolutions" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate the backpropagation error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateMaxPool" is-static="false">
		<summary>Creates a max pooling convolutional layer</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateRecurrentBridge" is-static="false">
		<summary>Creates a bridge between two recurrent nodes that will copy the hidden state from one to another and copy the error signal backwards between the two</summary>
				<param type="System.String" name="fromName" summary="Name of the first recurrent node" />
				<param type="System.String" name="toName" summary="Name of the second recurrent node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateSimpleRecurrent" is-static="false">
		<summary>Creates a simple recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="Activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateElman" is-static="false">
		<summary>Creates an Elman recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateJordan" is-static="false">
		<summary>Creates a Jordan recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateOneMinusInput" is-static="false">
		<summary>Creates a node that subtracts each input from 1 (1-x)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateSequenceReverser" is-static="false">
		<summary>Creates a node that outputs the reversed index of the current sequence (for bidirectional recurrent networks)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateBatchNormalisation" is-static="false">
		<summary>Creates a node that performs batch normalization</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateGru" is-static="false">
		<summary>Creates a GRU recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateRan" is-static="false">
		<summary>Creates a Recurrent Additive Layer (recurrent)</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateLstm" is-static="false">
		<summary>Creates a LSTM recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateDropOut" is-static="false">
		<summary>Creates a layer that drops random connections</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage to drop (0..1)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateOutputNode" is-static="false">
		<summary>Creates a node that writes the current forward signal as an output of the graph</summary>
				<param type="System.Int32" name="channel" summary="Output channel" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the engine's input node</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine to build with" />
				<param type="System.UInt32" name="inputIndex" summary="Input index to connect to" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the selected node</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of outgoing connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to build from" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="Wire to subtract from" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Wire to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input1" summary="The node to subtract from" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input2" summary="The node to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two nodes together into a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input1" summary="First node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two nodes together into a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input1" summary="First node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Concatenates two wires together into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Joins multiple wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder[]" name="wires" summary="Wires to join" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Joins multiple wires into a new wire</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
				<param type="BrightWire.ExecutionGraph.WireBuilder[]" name="wires" summary="Wires to join" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="BidirectionalJoin" is-static="false">
		<summary>Concatenates two wires together into a new wire, but reverses the sequence index of the second input to join</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="forwardInput" summary="Forward wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="backwardInput" summary="Backward wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateWrapper" is-static="false">
		<summary>Wraps an existing node, enabling that node to be used at multiple locations in the same graph</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="nodeToWrap" summary="Node to wrap" />
				<param type="System.String" name="name" summary="Optional name to give the wrapping node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="Create" is-static="false">
		<summary>Creates a node from it's serialised model</summary>
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="node" summary="The node model" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="LeakyReluActivation" is-static="false">
		<summary>Creates a new leaky relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="ReluActivation" is-static="false">
		<summary>Creates a new relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="SigmoidActivation" is-static="false">
		<summary>Creates a new sigmoid activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="TanhActivation" is-static="false">
		<summary>Creates a new tanh activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="SoftMaxActivation" is-static="false">
		<summary>Creates a new softmax activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="ConstantWeightInitialisation" is-static="false">
		<summary>Creates a constant weight initialiser</summary>
				<param type="System.Single" name="biasValue" summary="Single bias value" />
				<param type="System.Single" name="weightValue" summary="Single weight value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="GaussianWeightInitialisation" is-static="false">
		<summary>Creates a gaussian weight initialiser</summary>
				<param type="System.Boolean" name="zeroBias" summary="True to set bias values to zero, otherwise bias initialisation is treated the same as weight initialisation" />
				<param type="System.Single" name="stdDev" summary="Standard deviation of gaussian distribution" />
				<param type="BrightWire.GaussianVarianceCalibration" name="varianceCalibration" summary="How to calibrate the variance" />
				<param type="BrightWire.GaussianVarianceCount" name="varianceCount" summary="How to count connections while calibrating connections" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="IdentityWeightInitialisation" is-static="false">
		<summary>Creates an identity weight initialiser</summary>
				<param type="System.Single" name="identityValue" summary="The value to give to each diagonal value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="XavierWeightInitialisation" is-static="false">
		<summary>Creates a xavier weight initialiser</summary>
				<param type="System.Single" name="parameter" summary="Xavier parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad" is-static="false">
		<summary>Creates an AdaGrad gradient descent optimiser</summary>
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam" is-static="false">
		<summary>Creates an Adam gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Decay parameter" />
				<param type="System.Single" name="decay2" summary="Second decay parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L1" is-static="false">
		<summary>Creates a L1 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L1 parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L2" is-static="false">
		<summary>Creates a L2 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L2 parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum" is-static="false">
		<summary>Creats a momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum" is-static="false">
		<summary>Creates a nesterov momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Nesterov momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp" is-static="false">
		<summary>Creates a rms prop gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Rms decay" />
			</method>
	<property type="BrightWire.IGradientDescentOptimisation" name="SimpleGradientDescent">
		<summary>Uses vanilla stochastic gradient descent</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" name="Regularisation">
		<summary>Prebuilt regularisation</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" name="GradientDescent">
		<summary>Prebuilt gradient descent optimisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" name="ErrorMetric">
		<summary>Error metrics</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" name="WeightInitialisation">
		<summary>Prebuilt weight initialisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider" name="GraphOperation">
		<summary>Standard graph operations</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider" name="GraphAction">
		<summary>Standard graph actions</summary>
	</property>
</class>
<class name="BrightWire.Models.GraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>The primary execution graph</summary>
	</property>
	<property type="BrightWire.Models.DataSourceModel" name="DataSource">
		<summary>Optional data source associated with the model</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Provides standard graph operations
	</summary>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="OneDividedBy" is-static="false">
		<summary>Calculates inverse (1/x) of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="InputSquared" is-static="false">
		<summary>Calculates square (x^2) of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="SquareRootOf" is-static="false">
		<summary>Calculates square root of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="OneMinusInput" is-static="false">
		<summary>Caclculates one minus graph input (1-x)</summary>
				<param type="System.String" name="name" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.IndexAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Index analysis results
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MinIndex">
		<summary>Lowest observed index</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxIndex">
		<summary>Highest observed index</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct items</summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary>Ranked histogram</summary>
	</property>
</class>
<class name="BrightData.IndexList" base="" is-static="false" is-abstract="false">
	<summary>
		Contains a list of indices
	</summary>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Indices">
		<summary>The list of indices</summary>
	</property>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the list</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="BrightData.IndexList" name="Merge" is-static="true">
		<summary>Merges a sequence of index lists into a single index list</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IndexList&gt;" name="lists" summary="Lists to merge" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.String" name="ToXml" is-static="false">
		<summary>Converts the index list to XML</summary>
			</method>
	<method type="System.Single" name="JaccardSimilarity" is-static="false">
		<summary>Calculates the jaccard similarity between this and another index list</summary>
				<param type="BrightData.IndexList" name="other" summary="Index list to compare to" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="AsDense" is-static="false">
		<summary>Converts to a vector</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxIndex" summary="Maximum index to include" />
			</method>
	<method type="System.Boolean" name="HasIndex" is-static="false">
		<summary>Checks if the specified index has been set</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
</class>
<class name="BrightData.DataTable.Builders.InMemoryTableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Builds tables dynamically in memory
	</summary>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="BrightData.IMetaData" name="MetaData">
		<summary>Table meta data</summary>
	</property>
	<method type="System.Void" name="CopyColumnsFrom" is-static="false">
		<summary>Copies column definitions from an existing table</summary>
				<param type="BrightData.IDataTable" name="table" summary="Table to copy from" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to copy" />
			</method>
	<method type="BrightData.IMetaData" name="AddColumn" is-static="false">
		<summary>Adds a new column</summary>
				<param type="BrightData.ColumnType" name="type" summary="Type of the column" />
				<param type="System.String" name="name" summary="Name of the column" />
			</method>
	<method type="BrightData.IMetaData" name="AddFixedSizeVectorColumn" is-static="false">
		<summary>Adds a new fixed size vector column</summary>
				<param type="System.UInt32" name="size" summary="Size of the vector" />
				<param type="System.String" name="name" summary="Name of the column (optional)" />
			</method>
	<method type="BrightData.IMetaData" name="AddFixedSizeMatrixColumn" is-static="false">
		<summary>Adds a new fixed size matrix column</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each matrix" />
				<param type="System.String" name="name" summary="Name of the column (optional)" />
			</method>
	<method type="BrightData.IMetaData" name="AddFixedSize3DTensorColumn" is-static="false">
		<summary>Adds a new fixed size 3D tensor column</summary>
				<param type="System.UInt32" name="depth" summary="Depth of each 3D tensor" />
				<param type="System.UInt32" name="rows" summary="Row count of each matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each matrix" />
				<param type="System.String" name="name" summary="Name of the column (optional)" />
			</method>
	<method type="System.Void" name="AddRow" is-static="false">
		<summary>Adds a new row</summary>
				<param type="System.Object[]" name="data" summary="" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="BuildRowOriented" is-static="false">
		<summary>Creates a row oriented table</summary>
			</method>
	<method type="BrightData.IColumnOrientedDataTable" name="BuildColumnOriented" is-static="false">
		<summary>Creates a column oriented table</summary>
			</method>
</class>
<class name="BrightWire.Models.InstanceBased.KNearestNeighbours" base="" is-static="false" is-abstract="false">
	<summary>
		K Nearest Neighbour Model
	</summary>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;[]" name="Instance">
		<summary>The list of vectors to match against</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The corresponding list of classifications</summary>
	</property>
	<property type="System.UInt32[]" name="DataColumns">
		<summary>The vector indexes to use to encode a data table row as a vector</summary>
	</property>
	<property type="System.UInt32" name="TargetColumn">
		<summary>The vector indexes to use to encode the other column(s) as a classification target</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
				<param type="System.UInt32" name="k" summary="The number of instances to consider" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="The distance metric to compare each row with each instance" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Linear.LinearRegression" base="" is-static="false" is-abstract="false">
	<summary>
		A linear regression model
	</summary>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Theta">
		<summary>The model parameters</summary>
	</property>
	<method type="BrightWire.ILinearRegressionPredictor" name="CreatePredictor" is-static="false">
		<summary>Creates a predictor from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Linear.LogisticRegression" base="" is-static="false" is-abstract="false">
	<summary>
		A logistic regression model
	</summary>
	<property type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Theta">
		<summary>The model parameters</summary>
	</property>
	<method type="BrightWire.ILogisticRegressionClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing two items at a time
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;[]" name="Observations">
		<summary>The list of observations</summary>
	</property>
	<method type="System.Void" name="MarkovModel2" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;&gt;" name="observations" summary="" />
			</method>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing the last three observations
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;[]" name="Observations">
		<summary>The list of observations</summary>
	</property>
	<method type="System.Void" name="MarkovModel3" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;&gt;" name="observations" summary="" />
			</method>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding two items
	</summary>
	<property type="T" name="Item1">
		<summary>The second last preceding item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The last preceding item</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="Transition">
		<summary>The list of possible transitions from this state</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals overide</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hash code override</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding three instances
	</summary>
	<property type="T" name="Item1">
		<summary>The third last item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The second last item</summary>
	</property>
	<property type="T" name="Item3">
		<summary>The third last item</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="Transitions">
		<summary>The list of associated transitions</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals override</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hashcode override</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model state transition
	</summary>
	<property type="T" name="NextState">
		<summary>The next state</summary>
	</property>
	<property type="System.Single" name="Probability">
		<summary>The probability of this next state</summary>
	</property>
	<method type="System.Void" name="MarkovModelStateTransition" is-static="false">
		<summary>Constructor</summary>
				<param type="T" name="nextState" summary="" />
				<param type="System.Single" name="probability" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.LinearAlgebra.Matrix&lt;T&gt;" base="BrightData.LinearAlgebra.TensorBase&lt;T, BrightData.LinearAlgebra.Matrix&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		Matrix type
	</summary>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of columns</summary>
	</property>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="Row" is-static="false">
		<summary>Returns a row as a vector</summary>
				<param type="System.UInt32" name="index" summary="Row index" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="Column" is-static="false">
		<summary>Returns a column as a vector</summary>
				<param type="System.UInt32" name="index" summary="Column index" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;T&gt;&gt;" name="Rows">
		<summary>All rows</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Vector&lt;T&gt;&gt;" name="Columns">
		<summary>All columns</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="T[]" name="ToColumnMajor" is-static="false">
		<summary>Converts to a column major array format (default is row major)</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="Transpose" is-static="false">
		<summary>Transpose the matrix</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="Multiply" is-static="false">
		<summary>Multiply the matrix with another matrix</summary>
				<param type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="other" summary="Other matrix to multiply" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="GetDiagonal" is-static="false">
		<summary>Returns the diagonal of the matrix as a vector</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="RowSums" is-static="false">
		<summary>Returns the sum of each row as a vector</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="ColumnSums" is-static="false">
		<summary>Returns the sum of each column as a vector</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="Multiply" is-static="false">
		<summary>Multiplies the matrix with a vector</summary>
				<param type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="vector" summary="Vector to multiply" />
			</method>
</class>
<class name="BrightData.MetaData" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="Existing meta data to copy from" />
				<param type="System.String[]" name="keys" summary="Keys to copy (or all if none specified)" />
			</method>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metaData" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary>Creates meta data from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Reader" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keysToCopy" summary="" />
			</method>
	<method type="System.Void" name="CopyAllExcept" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Object" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="GetNullable" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="valueIfMissing" summary="" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetStringsWithPrefix" is-static="false">
		<summary></summary>
				<param type="System.String" name="prefix" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Has" is-static="false">
		<summary></summary>
				<param type="System.String" name="key" summary="" />
			</method>
	<method type="System.Void" name="Remove" is-static="false">
		<summary></summary>
				<param type="System.String" name="key" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Helper.MiniBatch" base="" is-static="false" is-abstract="false">
	<summary>
		Information about the current mini batch
	</summary>
	<method type="System.Void" name="MiniBatch" is-static="false">
		<summary>Creates a non sequential mini batch</summary>
				<param type="System.UInt32[]" name="rows" summary="The indices of the rows in this mini batch" />
				<param type="BrightWire.IDataSource" name="dataSource" summary="Associated data source" />
				<param type="BrightWire.IGraphData" name="input" summary="Mini batch input data" />
				<param type="BrightWire.IGraphData" name="output" summary="Expected output data (when training, otherwise null)" />
			</method>
	<method type="System.Void" name="MiniBatch" is-static="false">
		<summary>Creates a sequential mini batch</summary>
				<param type="System.UInt32[]" name="rows" summary="The indices of the rows in this mini batch" />
				<param type="BrightWire.IDataSource" name="dataSource" summary="Associated data source" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary>Adds another item to the sequential mini batch</summary>
				<param type="BrightWire.MiniBatchSequenceType" name="type" summary="Type of the sequential item" />
				<param type="BrightWire.IGraphData" name="input" summary="Mini batch input data" />
				<param type="BrightWire.IGraphData" name="output" summary="Expected output data (when training, otherwise null)" />
			</method>
	<property type="System.UInt32[]" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Data source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<property type="System.UInt32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="System.Void" name="Reset" is-static="false">
		<summary>Resets the sequence iterator</summary>
			</method>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence" is-static="false">
		<summary>Gets the next item in the sequence (or null if none)</summary>
			</method>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex" is-static="false">
		<summary>Gets a sequence item</summary>
				<param type="System.UInt32" name="index" summary="The index to retrieve" />
			</method>
	<property type="BrightWire.IMiniBatch" name="NextMiniBatch">
		<summary>Subsequent mini batch</summary>
	</property>
	<property type="BrightWire.IMiniBatch" name="PreviousMiniBatch">
		<summary>Previous mini batch</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.MultiGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept input on an arbitrary number of channels and output a single signal
	</summary>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Linear.MultinomialLogisticRegression" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial logistic regression model
	</summary>
	<property type="BrightWire.Models.Linear.LogisticRegression[]" name="Model">
		<summary>The list of logistic regression models</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The associated classification labels</summary>
	</property>
	<property type="System.UInt32[]" name="FeatureColumn">
		<summary>The columns used to build the dense input vectors</summary>
	</property>
	<method type="BrightWire.ITableClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class[]" name="ClassData">
		<summary>The list of possible classifications</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary[]" name="Class">
		<summary>A list of possible classifications and their data</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.DecisionTree.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node in the decision tree
	</summary>
	<property type="BrightWire.Models.TreeBased.DecisionTree.Node[]" name="Children">
		<summary>The nodes children</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary>The column index that is being split on</summary>
	</property>
	<property type="System.String" name="MatchLabel">
		<summary>The value to match this node</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Split">
		<summary>The value to split on</summary>
	</property>
	<property type="System.String" name="Classification">
		<summary>This node's classification label</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the node as XML</summary>
				<param type="System.Xml.XmlWriter" name="writer" summary="The XML writer" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.ExecutionGraphModel.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node within the graph
	</summary>
	<method type="System.Void" name="Node" is-static="false">
		<summary>Default constructor</summary>
			</method>
	<method type="System.Void" name="Node" is-static="false">
		<summary>Initialize from binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.String" name="TypeName">
		<summary>The .NET type name of the node type</summary>
	</property>
	<property type="System.String" name="Id">
		<summary>The unique id within the graph</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Node friendly name</summary>
	</property>
	<property type="System.String" name="Description">
		<summary>A short description of the node</summary>
	</property>
	<property type="System.Byte[]" name="Data">
		<summary>The node's parameters</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.NodeBase" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for graph nodes
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Disposal</summary>
			</method>
	<property type="System.String" name="Id">
		<summary>The node's unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The node's name in the graph</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.ExecutionGraph.Helper.WireToNode&gt;" name="Output">
		<summary>The list of outgoing wires along which the output signal will be sent</summary>
	</property>
	<method type="System.Void" name="Forward" is-static="false">
		<summary>Executes the graph</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="Initial data" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="Context" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="prev" summary="" />
			</method>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep" is-static="false">
		<summary>Executes a single forward step</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel.Node" name="SerialiseTo" is-static="false">
		<summary>Serialise this node and any connected nodes</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraphModel.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraphModel.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise" is-static="false">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="graph" summary="The complete graph" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Serialise the node</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Binary writer" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary>Deserialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader" />
			</method>
	<method type="System.Void" name="Initialise" is-static="false">
		<summary>Initialise the node from serialised data</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Unique id" />
				<param type="System.String" name="name" summary="Node name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="FindByName" is-static="false">
		<summary>Finds a connected node by friendly name</summary>
				<param type="System.String" name="name" summary="The node's name to search for" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="FindById" is-static="false">
		<summary>Finds a connected node by id</summary>
				<param type="System.String" name="id" summary="Unique id to find" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="SubNodes">
		<summary>The list of sub-nodes</summary>
	</property>
	<method type="System.Void" name="LoadParameters" is-static="false">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="FindSubNodeByNameOrThrow" is-static="false">
		<summary>Finds a sub node by name, or throws an exception if not found</summary>
				<param type="System.String" name="name" summary="Sub node name" />
			</method>
	<method type="System.Void" name="RemoveDirectDescendant" is-static="false">
		<summary>Removes the wire that connects this from a direct descendant</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="directDescendant" summary="" />
			</method>
</class>
<class name="BrightData.Transformation.NormalizeTransformation" base="" is-static="false" is-abstract="false">
	<summary>
		Normalization parameters
	</summary>
	<method type="System.Void" name="NormalizeTransformation" is-static="false">
		<summary>Creates a new set of parameters based on supplied the numeric analysis</summary>
				<param type="BrightData.NormalizationType" name="type" summary="Type of normalization" />
				<param type="BrightData.IMetaData" name="analysedMetaData" summary="Numeric analysis" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the normalization parameters to a meta data store</summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary>Type of normalization</summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary>Value that will be divided (after subtraction)</summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary>Value that will be subtracted</summary>
	</property>
	<method type="System.Double" name="Normalize" is-static="false">
		<summary>Normalizes a value with the parameters</summary>
				<param type="System.Double" name="val" summary="Value to normalize" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.NumericAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Numeric analysis results
	</summary>
	<property type="System.Double" name="L1Norm">
		<summary>L1 Norm</summary>
	</property>
	<property type="System.Double" name="L2Norm">
		<summary>L2 Norm</summary>
	</property>
	<property type="System.Double" name="Min">
		<summary>Minimum observed value</summary>
	</property>
	<property type="System.Double" name="Max">
		<summary>Maximum observed value</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>Mean of values</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="SampleVariance">
		<summary>Sample variance of values</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="SampleStdDev">
		<summary>Sample standard deviation</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="PopulationVariance">
		<summary>Population variance of values</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="PopulationStdDev">
		<summary>Population standard deviation</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Median">
		<summary>Median value</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Mode">
		<summary>Mode (most frequent value)</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct values</summary>
	</property>
	<property type="System.UInt64" name="Total">
		<summary>Total count of items</summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary>Ranked histogram</summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="FrequencyRange">
		<summary>Bucketed histogram</summary>
	</property>
</class>
<class name="BrightData.Buffer.EncodedStreamReader.ObjectReader&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ObjectReader" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32" name="inMemorySize" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.Or" base="" is-static="true" is-abstract="false">
	<summary>
		Simple OR training data
	</summary>
	<method type="BrightData.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing OR training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.RandomForest" base="" is-static="false" is-abstract="false">
	<summary>
		A random forest model
	</summary>
	<property type="BrightWire.Models.TreeBased.DecisionTree[]" name="Forest">
		<summary>The list of trees in the forest</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.ReberGrammar" base="" is-static="false" is-abstract="false">
	<summary>
		Generates Reber grammar sequences: https://www.willamette.edu/~gorr/classes/cs449/reber.html
	</summary>
	<method type="System.Char" name="GetChar" is-static="true">
		<summary>Gets the character at the specified index</summary>
				<param type="System.Int32" name="index" summary="Index to query" />
			</method>
	<method type="System.Int32" name="GetIndex" is-static="true">
		<summary>Gets the index for the specified character</summary>
				<param type="System.Char" name="ch" summary="The character to query" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="Encode" is-static="true">
		<summary>Encodes a reber sequence as a sequence of one hot encoded vectors</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.String" name="sequence" summary="The reber sequence to encode" />
			</method>
	<method type="BrightData.IRowOrientedDataTable" name="GetOneHot" is-static="true">
		<summary>One hot encodes the REBER strings</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="strList" summary="A list of REBER sequences" />
			</method>
	<property type="System.Int32" name="Size">
		<summary>The number of REBER characters</summary>
	</property>
	<method type="System.Void" name="ReberGrammar" is-static="false">
		<summary>Creates a reber grammar builder</summary>
				<param type="System.Random" name="random" summary="Random number provider" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Get" is-static="false">
		<summary>Generates an unlimited number of reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="minlength" summary="Minimum length of the sequences (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxLength" summary="Mimimum length of the sequences (optional)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetExtended" is-static="false">
		<summary>Generates an unlimited number of extended reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="minlength" summary="Minimum length of the sequences (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxLength" summary="Mimimum length of the sequences (optional)" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt regularisation
	</summary>
	<property type="BrightWire.ICreateGradientDescent" name="L1">
		<summary>L1 regularisation</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="L2">
		<summary>L2 regularisation</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.DataTableAdapter.RowBasedDataTableAdapterBase" base="BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase&lt;BrightData.IDataTableSegment&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for data tables that work with data table rows
	</summary>
</class>
<class name="BrightWire.TrainingData.Artificial.SequenceGenerator" base="" is-static="false" is-abstract="false">
	<summary>
		Generates random alphabetical sequences
	</summary>
	<method type="System.Void" name="SequenceGenerator" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="dictionarySize" summary="The number of letters to use" />
				<param type="System.UInt32" name="minSize" summary="The minimum size of each sequence" />
				<param type="System.UInt32" name="maxSize" summary="The maximum size of each sequence" />
				<param type="System.Boolean" name="noRepeat" summary="True to avoid repeating any previous character within each sequence" />
			</method>
	<property type="System.UInt32" name="DictionarySize">
		<summary>The number of letters to use</summary>
	</property>
	<method type="System.String" name="NextSequence" is-static="false">
		<summary>Generates a new sequence</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Encode" is-static="false">
		<summary>Converts the character to a one hot encoded vector</summary>
				<param type="System.Char" name="ch" summary="" />
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="Encode" is-static="false">
		<summary>Encodes the characters as a dense vector</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.Char, System.Single)&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;System.Single&gt;" name="Encode" is-static="false">
		<summary>Encodes the string as a list of dense vectors within a matrix (each character becomes a row in the matrix)</summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GenerateSequences" is-static="false">
		<summary>Generator function to generate new sequences</summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SequenceWindowBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Creates a new training feature vector using a window of surrounding features at each point in the input sequence
	</summary>
	<method type="System.Void" name="SequenceWindowBuilder" is-static="false">
		<summary>Creates a new sequence window builder</summary>
				<param type="System.Int32" name="before" summary="The number of previous items to include before each item" />
				<param type="System.Int32" name="after" summary="The number of following items to include after each item" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Single[]&gt;" name="Get" is-static="false">
		<summary>Augments a single sequence</summary>
				<param type="System.Single[][]" name="data" summary="The sequence to analyse" />
			</method>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of the generated training data</summary>
	</property>
</class>
<class name="BrightData.Serialisation.SerialisationHelper" base="" is-static="true" is-abstract="false">
	<summary>
		Serialisation helpers
	</summary>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the string</summary>
				<param type="System.String" name="str" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the integer</summary>
				<param type="System.Int32" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the uint</summary>
				<param type="System.UInt32" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the double</summary>
				<param type="System.Double" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the float</summary>
				<param type="System.Single" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Conditionally writes a nullable value</summary>
				<param type="System.Nullable&lt;T&gt;" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
				<param type="System.Action&lt;T&gt;" name="onWrite" summary="" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="ReadNullable" is-static="true">
		<summary>Conditionally reads a nullable value</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.Func&lt;T&gt;" name="onRead" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the collection of items</summary>
				<param type="System.Collections.Generic.IReadOnlyCollection&lt;BrightData.ICanWriteToBinaryWriter&gt;" name="list" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the array</summary>
				<param type="T[]" name="array" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the array of strings</summary>
				<param type="System.String[]" name="array" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="T" name="Create" is-static="true">
		<summary>Creates a new object after reading its serialized data from the reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray" is-static="true">
		<summary>Reads an array from the reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="T[]" name="ReadStructArray" is-static="true">
		<summary>Reads an array of structs from the reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.String[]" name="ReadStringArray" is-static="true">
		<summary>Reads an array of strings from the reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.Helper.ShapedBase" base="" is-static="false" is-abstract="false">
	<summary>
		Tensor shape
	</summary>
	<property type="System.UInt32[]" name="Shape">
		<summary>Array of sizes</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Total size of the shape</summary>
	</property>
	<property type="System.UInt32" name="Rank">
		<summary>Number of sizes within the shape</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SimpleTokeniser" base="" is-static="true" is-abstract="false">
	<summary>
		Finds strings of words and numbers in a larger string
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Tokenise" is-static="true">
		<summary>Splits the text into smaller word and number strings. Punctuation characters become single character strings.</summary>
				<param type="System.String" name="text" summary="The text to tokenise" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="JoinNegations" is-static="true">
		<summary>Simple token modification following "not".
Double not or punctuation stops the not mode</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="tokenList" summary="The list of tokens" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String[]&gt;" name="FindSentences" is-static="true">
		<summary>Finds sentences from a list of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="stringList" summary="The list of strings" />
			</method>
	<method type="System.Boolean" name="IsEndOfSentence" is-static="true">
		<summary>Checks if the string is an end of sentence token</summary>
				<param type="System.String" name="str" summary="The string to check" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.SingleBackpropagationBase&lt;T&gt;" base="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that back propagate to a single parent
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphData Signal, BrightWire.IGraphSequenceContext Context, BrightWire.ExecutionGraph.Node.NodeBase ToNode)&gt;" name="Backward" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="" />
				<param type="BrightWire.IGraphSequenceContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.StaticAnalysers" base="" is-static="true" is-abstract="false">
	<summary>
		Static methods to create analyzers
	</summary>
	<method type="BrightData.IDataAnalyser&lt;System.DateTime&gt;" name="CreateDateAnalyser" is-static="true">
		<summary>Creates a date analyzer</summary>
				<param type="System.UInt32" name="maxCount" summary="Maximum number of distinct items to track" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="CreateNumericAnalyser" is-static="true">
		<summary>Creates a numeric analyzer</summary>
				<param type="System.UInt32" name="maxCount" summary="Maximum number of distinct items to track" />
				<param type="System.UInt32" name="writeCount" summary="Number of items to write in histogram" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="CreateConvertToStringAnalyser" is-static="true">
		<summary>Creates an analyzer that will convert each item to a string</summary>
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;BrightData.ITensor&lt;System.Single&gt;&gt;" name="CreateDimensionAnalyser" is-static="true">
		<summary>Creates a dimension analyzer (to analyze the shape of tensors)</summary>
				<param type="System.UInt32" name="maxCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="CreateFrequencyAnalyser" is-static="true">
		<summary>Creates an analyzer that tracks observed frequency of items</summary>
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;BrightData.IHaveIndices&gt;" name="CreateIndexAnalyser" is-static="true">
		<summary>Creates an analyzer that tracks observed indices (for index lists and weighted index lists)</summary>
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;System.Double&gt;" name="CreateNumericAnalyser" is-static="true">
		<summary>Creates a numeric analyzer</summary>
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;System.String&gt;" name="CreateStringAnalyser" is-static="true">
		<summary>Creates a string analyzer</summary>
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser" name="CreateFrequencyAnalyser" is-static="true">
		<summary>Creates a frequency analyzer (each item will be converted to a string)</summary>
				<param type="System.Type" name="type" summary="" />
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
</class>
<class name="BrightData.Buffer.StaticBuffers" base="" is-static="true" is-abstract="false">
	<summary>
		Static methods to create hybrid buffers
	</summary>
	<method type="BrightData.IHybridBuffer&lt;T&gt;" name="CreateHybridStructBuffer" is-static="true">
		<summary>Creates a buffer to store structs</summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
			</method>
	<method type="BrightData.IHybridBuffer" name="CreateHybridStructBuffer" is-static="true">
		<summary>Creates a buffer to store structs</summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.Type" name="type" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
			</method>
	<method type="BrightData.IHybridBuffer&lt;System.String&gt;" name="CreateHybridStringBuffer" is-static="true">
		<summary>Creates a buffer to store strings</summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
			</method>
	<method type="BrightData.IHybridBuffer&lt;T&gt;" name="CreateHybridObjectBuffer" is-static="true">
		<summary>Creates a buffer to store objects</summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="" />
			</method>
	<method type="BrightData.IHybridBuffer" name="CreateHybridObjectBuffer" is-static="true">
		<summary>Creates a buffer to store objects</summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Type" name="type" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="" />
			</method>
</class>
<class name="BrightData.Converter.StaticConverters" base="" is-static="false" is-abstract="false">
	<summary>
		Static methods to create converters
	</summary>
	<method type="BrightData.ICanConvert&lt;T, System.Decimal&gt;" name="ConvertToDecimal" is-static="true">
		<summary>Creates a converter to decimals</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Double&gt;" name="ConvertToDouble" is-static="true">
		<summary>Creates a converter to doubles</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Single&gt;" name="ConvertToFloat" is-static="true">
		<summary>Creates a converter to floats</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Int32&gt;" name="ConvertToInt" is-static="true">
		<summary>Creates a converter to ints</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Int64&gt;" name="ConvertToLong" is-static="true">
		<summary>Creates a converter to longs (Int64)</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Int16&gt;" name="ConvertToShort" is-static="true">
		<summary>Creates a converter to shorts (Int16)</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.SByte&gt;" name="ConvertToSignedByte" is-static="true">
		<summary>Creates a convert to signed bytes</summary>
			</method>
</class>
<class name="BrightData.Analysis.Readers.StringAnalysis" base="BrightData.Analysis.Readers.FrequencyAnalysis" is-static="false" is-abstract="false">
	<summary>
		String analysis results
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MinLength">
		<summary>Length of smallest observed string</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxLength">
		<summary>Length of largest observed string</summary>
	</property>
</class>
<class name="BrightData.Buffer.EncodedStreamReader.StringDecoder" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StringDecoder" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32" name="inMemorySize" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="System.String[]" name="Dictionary">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Helper.StringIndexer" base="" is-static="false" is-abstract="false">
	<summary>
		Builds a string table
	</summary>
	<method type="BrightData.Helper.StringIndexer" name="Create" is-static="true">
		<summary>Creates a string indexer</summary>
				<param type="System.String[]" name="strings" summary="Initial strings in table" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Returns the index of a string (creates it if not already in table)</summary>
				<param type="System.String" name="str" summary="String to search" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of the string table</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The probabilities associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The log of the conditional probability</summary>
	</property>
	<property type="System.Double" name="InverseProbability">
		<summary>The log of the inverse conditional probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The conditional probability associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The conditional probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.Buffer.EncodedStreamReader.StringReader" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StringReader" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32" name="inMemorySize" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.Models.StringTable" base="" is-static="false" is-abstract="false">
	<summary>
		An array of indexed strings
	</summary>
	<property type="System.String[]" name="Data">
		<summary>The array of indexed strings</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Helper.StringTableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Assigns string indices to strings
	</summary>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates an empty string table builder</summary>
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="BrightWire.Models.StringTable" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="System.String[]" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Boolean" name="TryGetIndex" is-static="false">
		<summary>Returns true if the string has already been added</summary>
				<param type="System.String" name="str" summary="The string to check" />
				<param type="System.UInt32" name="ret" summary="The string index" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Gets a string index for a string (creates a new index if not found)</summary>
				<param type="System.String" name="str" summary="The string to look up" />
			</method>
	<property type="BrightWire.Models.StringTable" name="StringTable">
		<summary>Serialises the string table</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Returns the size of the string table</summary>
	</property>
	<method type="System.String" name="GetString" is-static="false">
		<summary>Returns the string at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The string index" />
			</method>
</class>
<class name="BrightData.Buffer.EncodedStreamReader.StructDecoder&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StructDecoder" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32" name="inMemorySize" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="System.String[]" name="Dictionary">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Buffer.EncodedStreamReader.StructReader&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StructReader" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32" name="inMemorySize" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightData.Helper.TempStreamManager" base="" is-static="false" is-abstract="false">
	<summary>
		Manages a collection of temp files
	</summary>
	<method type="System.Void" name="TempStreamManager" is-static="false">
		<summary>Constructor</summary>
				<param type="System.String" name="basePath" summary="Location on disk to write new temp files" />
			</method>
	<method type="System.IO.Stream" name="Get" is-static="false">
		<summary>Returns an existing (or creates a new) temp stream</summary>
				<param type="System.String" name="uniqueId" summary="Unique identifier" />
			</method>
	<method type="System.Boolean" name="HasStream" is-static="false">
		<summary>Checks if the the stream has been created</summary>
				<param type="System.String" name="uniqueId" summary="Unique identifier" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.Tensor3D&lt;T&gt;" base="BrightData.LinearAlgebra.TensorBase&lt;T, BrightData.LinearAlgebra.Tensor3D&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		3D tensor type
	</summary>
	<property type="System.UInt32" name="Depth">
		<summary>Number of matrices</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows within each matrix</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of columns within each matrix</summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary>Size of each matrix</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="Matrix" is-static="false">
		<summary>Returns a matrix at the specified index</summary>
				<param type="System.UInt32" name="index" summary="Matrix index" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Matrix&lt;T&gt;&gt;" name="Matrices">
		<summary>All matrices</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="T[]" name="GetAsRaw" is-static="false">
		<summary>Converts the segment to a column major vector (default is row major)</summary>
			</method>
</class>
<class name="BrightData.LinearAlgebra.Tensor4D&lt;T&gt;" base="BrightData.LinearAlgebra.TensorBase&lt;T, BrightData.LinearAlgebra.Tensor4D&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		4D tensor type
	</summary>
	<property type="System.UInt32" name="Count">
		<summary>Number of 3D tensors</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>Number of matrices within each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows within each matrix</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of columns within each matrix</summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary>Size of each matrix</summary>
	</property>
	<property type="System.UInt32" name="TensorSize">
		<summary>Size of each 3D tensor</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<method type="BrightData.LinearAlgebra.Tensor3D&lt;T&gt;" name="Tensor" is-static="false">
		<summary>Returns a nested 3D tensor</summary>
				<param type="System.UInt32" name="index" summary="Tensor index" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.LinearAlgebra.Tensor3D&lt;T&gt;&gt;" name="Tensors">
		<summary>All 3D tensors</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.LinearAlgebra.TensorBase&lt;T, DT&gt;" base="BrightData.Helper.ShapedBase" is-static="false" is-abstract="true">
	<summary>
		Base class for tensors
	</summary>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="BrightData.INumericComputation&lt;T&gt;" name="Computation">
		<summary></summary>
	</property>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="GetDataCopy" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="T[]" name="ToArray" is-static="false">
		<summary>Converts the data to an array</summary>
			</method>
	<method type="DT" name="Add" is-static="false">
		<summary>Adds this to another tensor (new tensor returned - this tensor is not changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="DT" name="Add" is-static="false">
		<summary>Adds this to another tensor (new tensor returned - this tensor is not changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
				<param type="T" name="coefficient1" summary="Value to multiply each element of this tensor" />
				<param type="T" name="coefficient2" summary="Value to multiply each element of the other tensor" />
			</method>
	<method type="DT" name="Add" is-static="false">
		<summary>Adds a scalar to this tensor (new tensor returned - this tensor is not changed)</summary>
				<param type="T" name="scalar" summary="Value to add to each element" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary>Adds another tensor to this in place (this tensor is changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary>Adds another tensor to this in place (this tensor is changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
				<param type="T" name="coefficient1" summary="Value to multiply each element of this tensor" />
				<param type="T" name="coefficient2" summary="Value to multiply each element of the other tensor" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary>Adds a scalar to this in place (this tensor is changed)</summary>
				<param type="T" name="scalar" summary="Value to add to each element" />
			</method>
	<method type="DT" name="Subtract" is-static="false">
		<summary>Subtracts another tensor from this (new tensor returned - this tensor is not changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="DT" name="Subtract" is-static="false">
		<summary>Subtracts another tensor from this (new tensor returned - this tensor is not changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
				<param type="T" name="coefficient1" summary="Value to multiply each element of this tensor" />
				<param type="T" name="coefficient2" summary="Value to multiply each element of the other tensor" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary>Subtracts another tensor from this in place (this tensor is changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary>Subtracts another tensor from this in place (this tensor is changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
				<param type="T" name="coefficient1" summary="Value to multiply each element of this tensor" />
				<param type="T" name="coefficient2" summary="Value to multiply each element of the other tensor" />
			</method>
	<method type="DT" name="PointwiseMultiply" is-static="false">
		<summary>Multiplies each element with the corresponding element from the other tensor (new tensor returned - this tensor is not changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace" is-static="false">
		<summary>Multiplies each element with the corresponding element from the other tensor (this tensor is changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="DT" name="Multiply" is-static="false">
		<summary>Multiplies each element with a value  (new tensor returned - this tensor is not changed)</summary>
				<param type="T" name="scalar" summary="Value to multiply" />
			</method>
	<method type="System.Void" name="MultiplyInPlace" is-static="false">
		<summary>Multiplies each element with a value (this tensor is changed)</summary>
				<param type="T" name="scalar" summary="Value to multiply" />
			</method>
	<method type="DT" name="PointwiseDivide" is-static="false">
		<summary>Divides each element with the corresponding element from the other tensor (new tensor returned - this tensor is not changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace" is-static="false">
		<summary>Divides each element with the corresponding element from the other tensor (this tensor is changed)</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="DT" name="Log" is-static="false">
		<summary>Creates a new tensor with each value set to the log of each element in this tensor</summary>
			</method>
	<method type="DT" name="Abs" is-static="false">
		<summary>Creates a new tensor with each value set to the absolute value of each element in this tensor</summary>
			</method>
	<method type="DT" name="Sqrt" is-static="false">
		<summary>Creates a new tensor with each value set to the square root of value of each element in this tensor</summary>
			</method>
	<method type="DT" name="Squared" is-static="false">
		<summary>Creates a new tensor with each value set to the squared value of each element in this tensor</summary>
			</method>
	<method type="DT" name="Pow" is-static="false">
		<summary>Creates a new tensor with each value set to pow(n) of element in this tensor</summary>
				<param type="T" name="power" summary="Power" />
			</method>
	<method type="T" name="DotProduct" is-static="false">
		<summary>Computes the dot product of this tensor and another tensor</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="Sum" is-static="false">
		<summary>Sums all elements of this tensor</summary>
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="Search" is-static="false">
		<summary>Finds the index of an element of this tensor</summary>
				<param type="T" name="value" summary="" />
			</method>
	<method type="System.Void" name="ConstrainInPlace" is-static="false">
		<summary>Mutates this tensor so that any value outside the range will be modified to fit within</summary>
				<param type="System.Nullable&lt;T&gt;" name="minValue" summary="Minimum allowed value" />
				<param type="System.Nullable&lt;T&gt;" name="maxValue" summary="Maximum allowed value" />
			</method>
	<method type="T" name="Average" is-static="false">
		<summary>Finds the average of all elements within this tensor</summary>
			</method>
	<method type="T" name="L1Norm" is-static="false">
		<summary>Computes the L1 norm of this tensor</summary>
			</method>
	<method type="T" name="L2Norm" is-static="false">
		<summary>Computes the L2 norm of this tensor</summary>
			</method>
	<method type="T" name="CosineDistance" is-static="false">
		<summary>Calculates the cosine distance between this and another tensor</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="EuclideanDistance" is-static="false">
		<summary>Computes the euclidean distance between this and another tensor</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="ManhattanDistance" is-static="false">
		<summary>Computes the manhattan distance between this and another tensor</summary>
				<param type="DT" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="Mean" is-static="false">
		<summary>Computes the average of the elements in this tensor</summary>
			</method>
	<method type="T" name="StdDev" is-static="false">
		<summary>Computes the standard deviation of the elements in this tensor</summary>
				<param type="System.Nullable&lt;T&gt;" name="mean" summary="" />
			</method>
	<method type="DT" name="Softmax" is-static="false">
		<summary>Computes the softmax</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="SoftmaxDerivative" is-static="false">
		<summary>Computes the softmax derivative</summary>
			</method>
	<method type="DT" name="Sigmoid" is-static="false">
		<summary>Computes the sigmoid function of each element</summary>
			</method>
	<method type="DT" name="SigmoidDerivative" is-static="false">
		<summary>Computes the sigmoid derivative of each element</summary>
			</method>
	<method type="DT" name="Tanh" is-static="false">
		<summary>Computes tanh of each element in this tensor</summary>
			</method>
	<method type="DT" name="TanhDerivative" is-static="false">
		<summary>Computes tanh derivative of each element in this tensor</summary>
			</method>
	<method type="DT" name="Relu" is-static="false">
		<summary>Computes the relu of each element in this tensor</summary>
			</method>
	<method type="DT" name="ReluDerivative" is-static="false">
		<summary>Computes the relu derivative of each element in this tensor</summary>
			</method>
	<method type="DT" name="LeakyRelu" is-static="false">
		<summary>Computes the leaky relu of each element in this tensor</summary>
			</method>
	<method type="DT" name="LeakyReluDerivative" is-static="false">
		<summary>Computes the leaky relu derivative of each element in this tensor</summary>
			</method>
	<method type="(T Min, T Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues" is-static="false">
		<summary>Finds the min and max values and indices from this tensnor</summary>
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite" is-static="false">
		<summary>Checks if each element is entirely finite (not infinity, NaN etc)</summary>
			</method>
	<method type="DT" name="Reverse" is-static="false">
		<summary>Reverse the order of the elements in this tensor</summary>
			</method>
	<method type="System.Collections.Generic.List&lt;BrightData.ITensorSegment&lt;T&gt;&gt;" name="Split" is-static="false">
		<summary>Splits this tensor into segments</summary>
				<param type="System.UInt32" name="blockCount" summary="Number of blocks to split into" />
			</method>
	<property type="BrightData.ITensorSegment&lt;T&gt;" name="Segment">
		<summary></summary>
	</property>
	<method type="DT" name="Clone" is-static="false">
		<summary>Clones this tensor</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;T&gt;" name="Reshape" is-static="false">
		<summary>Reshapes to a vector</summary>
			</method>
	<method type="BrightData.LinearAlgebra.Matrix&lt;T&gt;" name="Reshape" is-static="false">
		<summary>Reshapes to a matrix</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor3D&lt;T&gt;" name="Reshape" is-static="false">
		<summary>Reshapes to a 3D tensor</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="Number of matrices" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns" />
			</method>
	<method type="BrightData.LinearAlgebra.Tensor4D&lt;T&gt;" name="Reshape" is-static="false">
		<summary>Reshapes to a 4D tensor</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="count" summary="Number of 3D tensors" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="Number of matrices" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns" />
			</method>
	<method type="System.UInt32" name="MaximumIndex" is-static="false">
		<summary>Returns the index with the highest value</summary>
			</method>
	<method type="System.UInt32" name="MinimumIndex" is-static="false">
		<summary>Returns the index with the lowest value</summary>
			</method>
</class>
<class name="BrightData.LinearAlgebra.Vector&lt;T&gt;" base="BrightData.LinearAlgebra.TensorBase&lt;T, BrightData.LinearAlgebra.Vector&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		Generic vector
	</summary>
	<property type="System.UInt32" name="Size">
		<summary>Number of elements in the vector</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Values">
		<summary>The values in the vector</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary>Copies from an array into this vector</summary>
				<param type="T[]" name="array" summary="Array to copy from" />
			</method>
</class>
<class name="BrightWire.Helper.VectorBasedStatistics" base="" is-static="false" is-abstract="false">
	<summary>
		Calculate vector based statistics
	</summary>
	<method type="System.Void" name="VectorBasedStatistics" is-static="false">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="size" summary="" />
				<param type="System.Single[]" name="mean" summary="" />
				<param type="System.Single[]" name="m2" summary="" />
				<param type="System.UInt32" name="count" summary="" />
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
	<property type="BrightData.IFloatVector" name="Mean">
		<summary></summary>
	</property>
	<property type="BrightData.IFloatVector" name="M2">
		<summary></summary>
	</property>
	<method type="System.Void" name="Update" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="data" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="GetVariance" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="GetSampleVariance" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Helper.VectorDistanceHelper" base="" is-static="false" is-abstract="false">
	<summary>
		Calculates the distance between a list of vectors and a list of vectors to compare against
	</summary>
	<method type="System.Void" name="VectorDistanceHelper" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="List of vectors to compare" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric for comparison" />
			</method>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IFloatVector&gt;" name="CompareTo">
		<summary>The list of vectors to compare against</summary>
	</property>
	<property type="BrightData.DistanceMetric" name="Metric">
		<summary>Distance metric</summary>
	</property>
	<method type="System.Int32" name="AddComparison" is-static="false">
		<summary>Adds a comparison vector (will be owned and disposed by the helper class)</summary>
				<param type="BrightData.IFloatVector" name="comparison" summary="Vector to compare against" />
			</method>
	<method type="System.Void" name="UpdateComparisonVector" is-static="false">
		<summary>Updates the comparison vector at this index (disposes the old vector)</summary>
				<param type="System.Int32" name="index" summary="Index to update" />
				<param type="BrightData.IFloatVector" name="newVector" summary="Vector to replace with" />
			</method>
	<method type="System.Void" name="SetComparisonVectors" is-static="false">
		<summary>Updates the entire list of comparison vectors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="comparisonVectors" summary="List of vectors to compare against" />
			</method>
	<method type="System.UInt32[]" name="GetClosest" is-static="false">
		<summary>Returns the index of the closest comparison vector for each vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="GetAverageFromData" is-static="false">
		<summary>Returns a vector averaged from the data vectors</summary>
				<param type="System.UInt32[]" name="indices" summary="Indices of the data vectors to use in the averaged vector" />
			</method>
</class>
<class name="BrightData.WeightedIndexList" base="" is-static="false" is-abstract="false">
	<summary>
		A list of weighted indices is a sparse vector
	</summary>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="BrightData.WeightedIndexList.Item[]" name="Indices">
		<summary>The list of indices</summary>
	</property>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the list</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.WeightedIndexList" name="Merge" is-static="true">
		<summary>Merges a sequence of weighted index lists into one list</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.WeightedIndexList&gt;" name="lists" summary="Lists to merge" />
				<param type="BrightData.AggregationType" name="mergeOperation" summary="How to merge item weights" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.String" name="ToXml" is-static="false">
		<summary>Converts the weighted index list to XML</summary>
			</method>
	<method type="BrightData.IndexList" name="AsIndexList" is-static="false">
		<summary>Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)</summary>
			</method>
	<method type="System.Single" name="Dot" is-static="false">
		<summary>Dot product of this combined with the other weighted index list</summary>
				<param type="BrightData.WeightedIndexList" name="other" summary="Other weighted index list" />
			</method>
	<property type="System.Single" name="Magnitude">
		<summary>Magnitude of weights</summary>
	</property>
	<method type="System.Single" name="CosineSimilarity" is-static="false">
		<summary>Cosine similarity between this and another weighted index list</summary>
				<param type="BrightData.WeightedIndexList" name="other" summary="Other list to compare" />
			</method>
	<method type="System.Single" name="GetMaxWeight" is-static="false">
		<summary>Returns the index with the highest weight</summary>
			</method>
	<method type="System.Single" name="JaccardSimilarity" is-static="false">
		<summary>Computes the jaccard similarity between this and another weighted index list</summary>
				<param type="BrightData.WeightedIndexList" name="other" summary="Other list to compare" />
			</method>
	<method type="BrightData.LinearAlgebra.Vector&lt;System.Single&gt;" name="AsDense" is-static="false">
		<summary>Converts to a vector</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxIndex" summary="Inclusive highest index to copy (optional)" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt weight initialisers
	</summary>
	<property type="BrightWire.IWeightInitialisation" name="Ones">
		<summary>All weights are initialised to 1</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Zeroes">
		<summary>All weights are initialised to 0</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Gaussian">
		<summary>Weights are randomly initialised using a gaussian distribution</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Xavier">
		<summary>Weights are randomly initialised using the xavier algorithm</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity">
		<summary>Weights are initialised to the identity matrix</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity01">
		<summary>Weights are initialised to the identity matrix / 10</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraphModel.Wire" base="" is-static="false" is-abstract="false">
	<summary>
		Wires connect nodes (aka edges)
	</summary>
	<property type="System.String" name="FromId">
		<summary>The source node id</summary>
	</property>
	<property type="System.String" name="ToId">
		<summary>The target node id</summary>
	</property>
	<property type="System.UInt32" name="InputChannel">
		<summary>The channel on the target node to send the source node's output</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.WireBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Wires nodes together to build strands of a graph
	</summary>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.UInt32" name="size" summary="Initial wire size" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.UInt32" name="width" summary="Initial input width" />
				<param type="System.UInt32" name="height" summary="Initial input height" />
				<param type="System.UInt32" name="depth" summary="Initial input depth" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes to the engine output node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine" />
				<param type="System.UInt32" name="inputIndex" summary="Input index to connect" />
			</method>
	<property type="System.UInt32" name="CurrentSize">
		<summary>The current wire size</summary>
	</property>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="SetNewSize" is-static="false">
		<summary>Changes the current size of the builder</summary>
				<param type="System.UInt32" name="newSize" summary="New size" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="SetNewSize" is-static="false">
		<summary>Changes the current size of the builder</summary>
				<param type="System.UInt32" name="width" summary="New width" />
				<param type="System.UInt32" name="height" summary="New height" />
				<param type="System.UInt32" name="depth" summary="New depth" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddClassifier" is-static="false">
		<summary>Connects a row classifier</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightData.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddFeedForward" is-static="false">
		<summary>Adds a feed forward layer</summary>
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddTiedFeedForward" is-static="false">
		<summary>Adds a feed forward layer whose weights are tied to a previous layer</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer whose weights are tied" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropOut" is-static="false">
		<summary>Adds a drop out layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropConnect" is-static="false">
		<summary>Adds a drop connect layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddOutput" is-static="false">
		<summary>Creates a node that writes the current forward signal as an output of the graph</summary>
				<param type="System.Int32" name="channel" summary="Output channel" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds a node</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddForwardAction" is-static="false">
		<summary>Adds an action that will be executed in the forward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackwardAction" is-static="false">
		<summary>Adds an action that will be executed in the backward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBatchNormalisation" is-static="false">
		<summary>Adds a batch normalisation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRecurrentBridge" is-static="false">
		<summary>Creates a bridge between two recurrent nodes that will copy the hidden state from one to another and copy the error signal backwards between the two</summary>
				<param type="System.String" name="fromName" summary="Name of the first recurrent node" />
				<param type="System.String" name="toName" summary="Name of the second recurrent node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSimpleRecurrent" is-static="false">
		<summary>Adds a simple recurrent neural network layer</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="Activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddElman" is-static="false">
		<summary>Adds an Elman recurrent neural network layer</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddJordan" is-static="false">
		<summary>Adds a Jordan recurrent neural network layer</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddGru" is-static="false">
		<summary>Adds a gated recurrent unit recurrent neural network layer</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRan" is-static="false">
		<summary>Adds a recurrent additive layer (recurrent)</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddLstm" is-static="false">
		<summary>Adds a long short term memory recurrent neural network layer</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ReverseSequence" is-static="false">
		<summary>Adds a node that will reverse the sequence (for bidirectional recurrent neural networks)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddMaxPooling" is-static="false">
		<summary>Adds a max pooling convolutional layer</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of max pooliing filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of max pooling filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddConvolutional" is-static="false">
		<summary>Adds a convolutional layer</summary>
				<param type="System.UInt32" name="filterCount" summary="Number of filters in the layer" />
				<param type="System.UInt32" name="padding" summary="Padding to add before applying the convolutions" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate a backpropagation signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="TransposeFrom4DTensorToMatrix" is-static="false">
		<summary>Transposes the graph signal to move between convolutional and non-convolutional layers</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="TransposeAndCombine" is-static="false">
		<summary>Transposes the graph signal and merges each depth slice</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagation" is-static="false">
		<summary>Adds backpropagation - when executed an error signal will be calculated and flow backwards to previous nodes</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagationThroughTime" is-static="false">
		<summary>Adds backpropagation through time</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSequenceToSequencePivot" is-static="false">
		<summary>Pivots between the encoder and decoder sequences (seq2seq)</summary>
				<param type="System.String" name="encoderName" summary="Encoder node name" />
				<param type="System.String" name="decoderName" summary="Decoder node name" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainForwardSignal" is-static="false">
		<summary>Constrains the error signal in the forward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainBackwardSignal" is-static="false">
		<summary>Constrains the error signal in the backward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="WriteNodeMemoryToSlot" is-static="false">
		<summary>Writes node memory to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="System.String" name="nodeName" summary="The node name to read" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="JoinInputWithMemory" is-static="false">
		<summary>Concatenates the named memory slot with the input signal</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="Find" is-static="false">
		<summary>Tries to find the specified node</summary>
				<param type="System.String" name="name" summary="The friendly name of the node" />
			</method>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="LastNode">
		<summary>The last added node</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.WireToNode" base="" is-static="false" is-abstract="false">
	<summary>
		Wires connect nodes in the graph
	</summary>
	<method type="System.Void" name="WireToNode" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The destination node" />
				<param type="System.UInt32" name="channel" summary="The input channel on the node" />
			</method>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="SendTo">
		<summary>The node to send a signal to</summary>
	</property>
	<property type="System.UInt32" name="Channel">
		<summary>The channel to send the signal on</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.Xor" base="" is-static="true" is-abstract="false">
	<summary>
		Simple XOR training data
	</summary>
	<method type="BrightData.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing XOR training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
</assembly>
