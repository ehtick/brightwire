<assembly>
<enum name="BrightData.AggregationType">
	<summary>
		Types of aggregations
	</summary>
	<value name="Sum" value="0" summary="Sums values to a final value" />
	<value name="Average" value="1" summary="Averages values" />
	<value name="Max" value="2" summary="Finds the maximum value" />
	<value name="Min" value="3" summary="Finds the minimum value" />
</enum>
<enum name="BrightData.BrightDataType">
	<summary>
		Data types enumeration
	</summary>
	<value name="Unknown" value="0" summary="Nothing" />
	<value name="Boolean" value="1" summary="Boolean values" />
	<value name="SByte" value="2" summary="Signed byte values (-128 to 128)" />
	<value name="Short" value="3" summary="Short values" />
	<value name="Int" value="4" summary="Integer values" />
	<value name="Long" value="5" summary="Long values" />
	<value name="Float" value="6" summary="Float values" />
	<value name="Double" value="7" summary="Double values" />
	<value name="Decimal" value="8" summary="Decimal values" />
	<value name="String" value="9" summary="String values" />
	<value name="Date" value="10" summary="Date values" />
	<value name="IndexList" value="11" summary="List of indices" />
	<value name="WeightedIndexList" value="12" summary="Weighted list of indices" />
	<value name="Vector" value="13" summary="Vector of floats" />
	<value name="Matrix" value="14" summary="Matrix of floats" />
	<value name="Tensor3D" value="15" summary="3D tensor of floats" />
	<value name="Tensor4D" value="16" summary="4D tensor of floats" />
	<value name="BinaryData" value="17" summary="Binary data" />
	<value name="TimeOnly" value="18" summary="Time only" />
	<value name="DateOnly" value="19" summary="Date only" />
</enum>
<enum name="BrightData.ColumnClass">
	<summary>
		Column classifications
	</summary>
	<value name="Unknown" value="0" summary="Unknown category" />
	<value name="Categorical" value="1" summary="Forms a category - a set of possible values" />
	<value name="Numeric" value="2" summary="Numbers (float, int etc.)" />
	<value name="Decimal" value="4" summary="Floating point numbers (float, double, decimal)" />
	<value name="Struct" value="8" summary="Struct (blittable)" />
	<value name="Tensor" value="16" summary="Tensor (vector, matrix etc)" />
	<value name="IndexBased" value="32" summary="Has an index (index list, weighted index list)" />
	<value name="DateTime" value="64" summary="Date and time" />
	<value name="Integer" value="128" summary="Whole number" />
</enum>
<enum name="BrightData.ColumnConversion">
	<summary>
		Single column conversion options
	</summary>
	<value name="Unchanged" value="0" summary="Leave the column unchanged (nop)" />
	<value name="ToBoolean" value="1" summary="Convert to boolean" />
	<value name="ToDateTime" value="2" summary="Convert to date time" />
	<value name="ToDate" value="3" summary="Convert to date" />
	<value name="ToTime" value="4" summary="Convert to time" />
	<value name="ToNumeric" value="5" summary="Convert to numeric (best numeric size will be automatically determined)" />
	<value name="ToString" value="6" summary="Convert to string" />
	<value name="ToIndexList" value="7" summary="Convert to index list" />
	<value name="ToWeightedIndexList" value="8" summary="Convert to weighted index list" />
	<value name="ToVector" value="9" summary="Convert to vector" />
	<value name="ToCategoricalIndex" value="10" summary="Convert each value to an index within a dictionary" />
	<value name="ToByte" value="11" summary="Convert to signed byte" />
	<value name="ToShort" value="12" summary="Convert to short" />
	<value name="ToInt" value="13" summary="Convert to int" />
	<value name="ToLong" value="14" summary="Convert to long" />
	<value name="ToFloat" value="15" summary="Convert to float" />
	<value name="ToDouble" value="16" summary="Convert to double" />
	<value name="ToDecimal" value="17" summary="Convert to decimal" />
	<value name="Custom" value="18" summary="Custom conversion" />
</enum>
<enum name="BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
	<summary>
		The type of data within the column
	</summary>
	<value name="ContinuousGaussian" value="0" summary="Continuous values" />
	<value name="Categorical" value="1" summary="Categorical values" />
</enum>
<enum name="BrightData.DataSpecificationType">
	<summary>
		Type of data specification
	</summary>
	<value name="Field" value="0" summary="Represents a field of data" />
	<value name="Composite" value="1" summary="Represents an item that holds a set of other items" />
	<value name="FieldSet" value="2" summary="Represents a field that takes a value from one of a set of possibilities" />
</enum>
<enum name="BrightData.DataTableOrientation">
	<summary>
		Determines if the data table is oriented as either rows or columns
	</summary>
	<value name="Unknown" value="0" summary="Pathological case" />
	<value name="RowOriented" value="1" summary="Data table is stored as a series of rows" />
	<value name="ColumnOriented" value="2" summary="Data table is stored as aa series of columns" />
</enum>
<enum name="BrightData.DistanceMetric">
	<summary>
		Distance metrics
	</summary>
	<value name="Euclidean" value="0" summary="Euclidean Distance - https://en.wikipedia.org/wiki/Euclidean_distance" />
	<value name="Cosine" value="1" summary="Cosine Distance Metric - https://en.wikipedia.org/wiki/Cosine_similarity" />
	<value name="Manhattan" value="2" summary="Manhattan Distance - https://en.wikipedia.org/wiki/Taxicab_geometry" />
	<value name="MeanSquared" value="3" summary="Means Square Error" />
	<value name="SquaredEuclidean" value="4" summary="Square Euclidean - https://en.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance" />
	<value name="Angular" value="5" summary="Angular distance - https://en.wikipedia.org/wiki/Angular_distance" />
	<value name="InnerProductSpace" value="6" summary="Inner product distance - https://en.wikipedia.org/wiki/Inner_product_space" />
</enum>
<enum name="BrightWire.GaussianVarianceCalibration">
	<summary>
		Gaussian weight initialisation type
	</summary>
	<value name="SquareRootN" value="0" summary="Variances are calibrated by dividing by the square root of the connection count" />
	<value name="SquareRoot2N" value="1" summary="Variances are calibrated by multiplying by twice the square root of the connection count" />
</enum>
<enum name="BrightWire.GaussianVarianceCount">
	<summary>
		Gaussian variance count
	</summary>
	<value name="None" value="0" summary="No variance calibration is applied" />
	<value name="FanIn" value="1" summary="The count of incoming connections is used" />
	<value name="FanOut" value="2" summary="The count of outgoing connections is used" />
	<value name="FanInFanOut" value="3" summary="The count incoming and outgoing connections is used" />
</enum>
<enum name="BrightWire.MiniBatchSequenceType">
	<summary>
		Mini batch type
	</summary>
	<value name="Standard" value="0" summary="Standard batch type (non-sequential batches have a single standard sequence item)" />
	<value name="SequenceStart" value="1" summary="Start of a sequence" />
	<value name="SequenceEnd" value="2" summary="End of a sequence" />
</enum>
<enum name="BrightWire.NodeErrorType">
	<summary>
		Node error type
	</summary>
	<value name="Default" value="0" summary="Default error" />
	<value name="Bias" value="1" summary="Error in node bias" />
	<value name="Weight" value="2" summary="Error in node weights" />
</enum>
<enum name="BrightData.NormalizationType">
	<summary>
		Types of data normalization
	</summary>
	<value name="None" value="0" summary="None" />
	<value name="Standard" value="1" summary="Standard deviation" />
	<value name="Euclidean" value="2" summary="Euclidean norm" />
	<value name="Manhattan" value="3" summary="Manhattan" />
	<value name="FeatureScale" value="4" summary="Between 0..1" />
</enum>
<enum name="BrightData.Types.VectorSet.StorageType">
	<summary>
		Represents how the vectors should be stored
	</summary>
	<value name="Flat" value="0" summary="Flat storage" />
</enum>
<enum name="BrightData.VectorisationType">
	<summary>
		Type of vectorisation
	</summary>
	<value name="Unknown" value="0" summary="Undefined" />
	<value name="CategoricalIndex" value="1" summary="Maps values to an index (single offset)" />
	<value name="IndexList" value="2" summary="Index lists vectorisation" />
	<value name="Numeric" value="3" summary="Numeric vectorisation" />
	<value name="OneHot" value="4" summary="Maps values to an index (each value will have its own offset)" />
	<value name="Tensor" value="5" summary="Tensor vectorisation" />
	<value name="WeightedIndexList" value="6" summary="Weighted index list vectorisation" />
	<value name="Boolean" value="7" summary="Boolean vectorisation" />
</enum>

<interface name="BrightData.IAcceptSequentialTypedData&lt;T&gt;" base="">
	<summary>
		Typed data can be sequentially added
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a typed object</summary>
				<param type="T" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightWire.IAction" base="">
	<summary>
		An action to perform when a signal reaches a node
	</summary>
		<method type="BrightWire.IGraphData" name="Execute">
		<summary>Executes the action</summary>
				<param type="BrightWire.IGraphData" name="input" summary="Current graph signal" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="" />
			</method>
	<method type="System.String" name="Serialise">
		<summary>Serialises the action to a string</summary>
			</method>
	<method type="System.Void" name="Initialise">
		<summary>Initialises the action</summary>
				<param type="System.String" name="data" summary="Previously serialised data" />
			</method>
</interface>
<interface name="BrightWire.IAdaptiveDataSource" base="">
	<summary>
		Adaptive data sources apply the output from a preliminary graph
	</summary>
		<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="AdaptiveInput">
		<summary>The input node of the preliminary graph</summary>
	</property>
	<method type="BrightWire.Models.DataSourceModel" name="GetModel">
		<summary>Gets the serialised preliminary graph</summary>
				<param type="System.String" name="name" summary="Optional name to give the data source" />
			</method>
</interface>
<interface name="BrightData.IAmSerializable" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		Supports both writing and reading from binary
	</summary>
	</interface>
<interface name="BrightData.IAppendBlocks" base="">
	<summary>
		Appends blocks of items
	</summary>
	</interface>
<interface name="BrightData.IAppendBlocks&lt;T&gt;" base="BrightData.IAppendBlocks">
	<summary>
		Appends blocks of typed items
	</summary>
		<method type="System.Void" name="Append">
		<summary>Add a new block</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="block" summary="" />
			</method>
</interface>
<interface name="BrightData.IAppendToBuffer" base="">
	<summary>
		Appends an object to a buffer
	</summary>
		<method type="System.Void" name="AppendObject">
		<summary>Appends an object</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IAppendToBuffer&lt;T&gt;" base="BrightData.IAppendBlocks&lt;T&gt;">
	<summary>
		Appends a typed value to a buffer
	</summary>
		<method type="System.Void" name="Append">
		<summary>Appends a value</summary>
				<param type="T" name="item" summary="" />
			</method>
</interface>
<interface name="BrightWire.IBackpropagate" base="System.IDisposable">
	<summary>
		Backpropagation handler
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphData Signal, BrightWire.IGraphContext Context, BrightWire.ExecutionGraph.Node.NodeBase ToNode)&gt;" name="Backward">
		<summary>Backpropagate</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="" />
			</method>
</interface>
<interface name="BrightData.IBuildDataTables" base="BrightData.IHaveBrightDataContext">
	<summary>
		Builds data tables
	</summary>
		<property type="BrightData.Types.MetaData" name="TableMetaData">
		<summary>Table level meta data</summary>
	</property>
	<property type="BrightData.Types.MetaData[]" name="ColumnMetaData">
		<summary>Per column meta data</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of output rows</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of output columns</summary>
	</property>
	<method type="BrightData.ICompositeBuffer[]" name="CreateColumnsFrom">
		<summary>Copies existing column definitions from another table</summary>
				<param type="BrightData.IDataTable" name="table" summary="Other table" />
				<param type="System.UInt32[]" name="columnIndices" summary="Indices of column definitions to copy" />
			</method>
	<method type="BrightData.ICompositeBuffer[]" name="CreateColumnsFrom">
		<summary>Creates columns from buffers</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IReadOnlyBufferWithMetaData&gt;" name="buffers" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer" name="CreateColumn">
		<summary>Adds a new column</summary>
				<param type="BrightData.BrightDataType" name="type" summary="New column type" />
				<param type="System.String" name="name" summary="New column name" />
			</method>
	<method type="BrightData.ICompositeBuffer" name="CreateColumn">
		<summary>Adds a new column</summary>
				<param type="BrightData.BrightDataType" name="type" summary="New column type" />
				<param type="BrightData.Types.MetaData" name="metaData" summary="Column meta data" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;T&gt;" name="CreateColumn">
		<summary>Adds a new column</summary>
				<param type="System.String" name="name" summary="New column name" />
			</method>
	<method type="System.Void" name="AddRow">
		<summary>Adds a row to the table</summary>
				<param type="System.Object[]" name="items" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="AddRows">
		<summary>Adds rows from the buffers</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IReadOnlyBuffer&gt;" name="buffers" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="AddRows">
		<summary>Adds rows from the buffers</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IReadOnlyBufferWithMetaData&gt;" name="buffers" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="WriteTo">
		<summary>Writes the data table to a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector&gt;" name="CreateFixedSizeVectorColumn">
		<summary>Adds a fixed size vector column</summary>
				<param type="System.UInt32" name="size" summary="Size of the vector" />
				<param type="System.String" name="name" summary="New column name" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix&gt;" name="CreateFixedSizeMatrixColumn">
		<summary>Adds a fixed size matrix column</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.String" name="name" summary="New column name" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D&gt;" name="CreateFixedSize3DTensorColumn">
		<summary>Adds a fixed size 3D tensor column</summary>
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.String" name="name" summary="New column name" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D&gt;" name="CreateFixedSize4DTensorColumn">
		<summary>Adds a fixed size 4D tensor column</summary>
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.String" name="name" summary="New column name" />
			</method>
</interface>
<interface name="BrightData.IByteBlockReader" base="System.IDisposable">
	<summary>
		Reads blocks of data
	</summary>
		<method type="System.Threading.Tasks.Task&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" name="GetBlock">
		<summary>Reads a block of data</summary>
				<param type="System.UInt32" name="byteOffset" summary="Byte offset to read" />
				<param type="System.UInt32" name="numBytes" summary="Size in bytes to read" />
			</method>
	<method type="System.Threading.Tasks.Task" name="Update">
		<summary>Writes a block of data to the buffer</summary>
				<param type="System.UInt32" name="byteOffset" summary="Byte offset at which to write" />
				<param type="System.ReadOnlyMemory&lt;System.Byte&gt;" name="data" summary="Data to write" />
			</method>
</interface>
<interface name="BrightData.IByteBlockSource" base="System.IDisposable">
	<summary>
		Generic block byte data source
	</summary>
		<property type="System.Guid" name="Id">
		<summary>Unique id of the source</summary>
	</property>
	<method type="System.Void" name="Write">
		<summary>Writes data to the source</summary>
				<param type="System.ReadOnlySpan&lt;System.Byte&gt;" name="data" summary="" />
				<param type="System.UInt32" name="offset" summary="" />
			</method>
	<method type="System.Threading.Tasks.ValueTask" name="WriteAsync">
		<summary>Async writes data to the source</summary>
				<param type="System.ReadOnlyMemory&lt;System.Byte&gt;" name="data" summary="" />
				<param type="System.UInt32" name="offset" summary="" />
			</method>
	<method type="System.UInt32" name="Read">
		<summary>Reads data from the source</summary>
				<param type="System.Span&lt;System.Byte&gt;" name="data" summary="" />
				<param type="System.UInt32" name="offset" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.UInt32&gt;" name="ReadAsync">
		<summary>Async read from the source</summary>
				<param type="System.Memory&lt;System.Byte&gt;" name="data" summary="" />
				<param type="System.UInt32" name="offset" summary="" />
			</method>
</interface>
<interface name="BrightData.ICanConvert" base="">
	<summary>
		Indicates that the type can convert different types
	</summary>
		<property type="System.Type" name="From">
		<summary>Type that is converted from</summary>
	</property>
	<property type="System.Type" name="To">
		<summary>Type that is converted to</summary>
	</property>
</interface>
<interface name="BrightData.ICanConvert&lt;TF, TT&gt;" base="BrightData.ICanConvert">
	<summary>
		Typed converter interface
	</summary>
		<method type="TT" name="Convert">
		<summary>Converts a type from one to another</summary>
				<param type="TF" name="data" summary="Object to convert" />
			</method>
</interface>
<interface name="BrightData.ICanIndex&lt;T&gt;" base="BrightData.IHaveSize">
	<summary>
		Maps objects of type T to an index
	</summary>
		<method type="System.UInt32" name="GetIndex">
		<summary>Returns the index associated with the object</summary>
				<param type="T" name="item" summary="" />
			</method>
</interface>
<interface name="BrightWire.ICanInitialiseNode" base="">
	<summary>
		Interface that allows the node to be initialised
	</summary>
		<method type="System.Void" name="Initialise">
		<summary>Initialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Node unique id" />
				<param type="System.String" name="name" summary="Friendly name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
</interface>
<interface name="BrightData.ICanInitializeFromBinaryReader" base="">
	<summary>
		Indicates that the type can initialize from a binary reader
	</summary>
		<method type="System.Void" name="Initialize">
		<summary>Initialize from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
				<param type="System.IO.BinaryReader" name="reader" summary="Reader to read from to initialize" />
			</method>
</interface>
<interface name="BrightData.ICanRandomlyAccessData" base="System.IDisposable">
	<summary>
		Indicates that the type can randomly access untyped data
	</summary>
		<property type="System.Object" name="this">
		<summary>Returns the untyped item at this index</summary>
	</property>
	<property type="System.Object" name="this">
		<summary>Returns the untyped item at this index</summary>
	</property>
</interface>
<interface name="BrightWire.ICanSerialise" base="">
	<summary>
		Serialisation interface for graph components
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes the node state to the binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads the node state</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader that holds the node's state" />
			</method>
</interface>
<interface name="BrightData.ICanVectorise" base="BrightData.IWriteToMetaData">
	<summary>
		Object vectorisation
	</summary>
		<property type="BrightData.VectorisationType" name="Type">
		<summary>Type of vectorisation</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of the vectorisation output</summary>
	</property>
	<method type="System.Threading.Tasks.Task" name="WriteBlock">
		<summary>Vectorise a block from the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="System.UInt32" name="blockIndex" summary="" />
				<param type="System.UInt32" name="offset" summary="" />
				<param type="System.Single[,]" name="output" summary="" />
			</method>
	<method type="System.Void" name="Vectorise">
		<summary>Vectorise an object</summary>
				<param type="System.Object" name="obj" summary="" />
				<param type="System.Span&lt;System.Single&gt;" name="output" summary="" />
			</method>
	<method type="System.String" name="ReverseVectorise">
		<summary>Maps back from a vectorised index to the source value</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads vectorisation parameters from metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
			</method>
</interface>
<interface name="BrightData.ICanWriteToBinaryWriter" base="">
	<summary>
		Indicates that the type can serialize to a binary writer
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Serialize to binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</interface>
<interface name="BrightData.IClusteringStrategy" base="">
	<summary>
		A vector clustering strategy
	</summary>
		<method type="System.UInt32[][]" name="Cluster">
		<summary>Finds clusters from the array of vectors</summary>
				<param type="BrightData.IReadOnlyVector[]" name="vectors" summary="" />
				<param type="System.UInt32" name="numClusters" summary="" />
				<param type="BrightData.DistanceMetric" name="metric" summary="" />
			</method>
</interface>
<interface name="BrightData.ICompositeBuffer" base="BrightData.IReadOnlyBufferWithMetaData">
	<summary>
		Composite buffers are appendable buffers that track distinct items and are writeable to streams
	</summary>
		<property type="System.Guid" name="Id">
		<summary>Unique id</summary>
	</property>
	<method type="System.Threading.Tasks.Task" name="WriteTo">
		<summary>Writes all data to a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
</interface>
<interface name="BrightData.ICompositeBuffer&lt;T&gt;" base="BrightData.ICompositeBuffer">
	<summary>
		Composite buffers add data in memory until a pre-specified limit is reached and then stores the remainder in a temp file
	</summary>
		<property type="System.Collections.Generic.IReadOnlySet&lt;T&gt;" name="DistinctSet">
		<summary>The distinct (unique) set of items that have been added - null if the count exceeded the pre-defined limit</summary>
	</property>
	<property type="BrightData.IConstraintValidator&lt;T&gt;" name="ConstraintValidator">
		<summary>Optional constraint validator on items that are added to the buffer</summary>
	</property>
</interface>
<interface name="BrightData.IConstraintValidator&lt;T&gt;" base="">
	<summary>
		Checks if an item satisfies a constraint
	</summary>
		<method type="System.Boolean" name="Allow">
		<summary>Returns true if the item was valid</summary>
				<param type="T" name="item" summary="" />
			</method>
</interface>
<interface name="BrightData.IContinuousDistribution" base="BrightData.IDistribution&lt;System.Single&gt;">
	<summary>
		Continuous data distribution
	</summary>
	</interface>
<interface name="BrightData.ICountReferences" base="">
	<summary>
		Reference counter
	</summary>
		<method type="System.Int32" name="AddRef">
		<summary>Adds a reference</summary>
			</method>
	<method type="System.Int32" name="Release">
		<summary>Removes a reference (and might release the data)</summary>
			</method>
	<property type="System.Boolean" name="IsValid">
		<summary>Checks if there is still a valid reference count (and that the data has not been released)</summary>
	</property>
</interface>
<interface name="BrightWire.ICreateGradientDescent" base="">
	<summary>
		Creates a gradient descent optimisation
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation</summary>
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightWire.ICreateGraphContext" base="">
	<summary>
		A type that can create a graph context
	</summary>
		<method type="BrightWire.IGraphContext" name="Create">
		<summary>Creates a graph context</summary>
				<param type="BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="Mini batch sequence" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context (null if executing without training)" />
			</method>
</interface>
<interface name="BrightWire.ICreateTemplateBasedGradientDescent" base="">
	<summary>
		Creates gradient descent optimisations based on a matrix
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation for a particular target matrix</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="prev" summary="Any other previously created gradient descent optimisation in this context" />
				<param type="BrightData.IMatrix" name="template" summary="The instance of the matrix that will be updated" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser" base="BrightData.IWriteToMetaData">
	<summary>
		Base data analyzer type
	</summary>
		<method type="System.Void" name="AddObject">
		<summary>Adds an object to analyze</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser&lt;T&gt;" base="BrightData.IAcceptSequentialTypedData&lt;T&gt;">
	<summary>
		Typed data analyser
	</summary>
	</interface>
<interface name="BrightData.IDataReader" base="">
	<summary>
		Typed data reader
	</summary>
		<method type="T" name="Read">
		<summary>Reads a typed value from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray">
		<summary>Reads a typed array from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.IDataSource" base="">
	<summary>
		Segment sources feed data into a graph
	</summary>
		<property type="System.UInt32" name="InputSize">
		<summary>The size of the input data</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary>The size of the output data</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get">
		<summary>Gets a mini batch with the specified rows</summary>
				<param type="System.UInt32[]" name="rows" summary="List of rows" />
			</method>
	<method type="System.UInt32[][]" name="GetSequentialBatches">
		<summary>For sequential data, returns the row indexes grouped by sequence length</summary>
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith">
		<summary>Creates a new data source, using the current as a template but replacing the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="The new data table" />
			</method>
	<property type="BrightData.DataTable.VectorisationModel" name="InputVectoriser">
		<summary>Table vectoriser to create a feature vector</summary>
	</property>
	<property type="BrightData.DataTable.VectorisationModel" name="OutputVectoriser">
		<summary>Table vectoriser to create a target vector</summary>
	</property>
</interface>
<interface name="BrightData.IDataTable" base="System.IDisposable">
	<summary>
		Data table interface
	</summary>
		<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4, T5&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.UInt32" name="columnIndex5" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4, T5, T6&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.UInt32" name="columnIndex5" summary="" />
				<param type="System.UInt32" name="columnIndex6" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4, T5, T6, T7&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.UInt32" name="columnIndex5" summary="" />
				<param type="System.UInt32" name="columnIndex6" summary="" />
				<param type="System.UInt32" name="columnIndex7" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.UInt32" name="columnIndex5" summary="" />
				<param type="System.UInt32" name="columnIndex6" summary="" />
				<param type="System.UInt32" name="columnIndex7" summary="" />
				<param type="System.UInt32" name="columnIndex8" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.UInt32" name="columnIndex5" summary="" />
				<param type="System.UInt32" name="columnIndex6" summary="" />
				<param type="System.UInt32" name="columnIndex7" summary="" />
				<param type="System.UInt32" name="columnIndex8" summary="" />
				<param type="System.UInt32" name="columnIndex9" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.TableRow&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10&gt;&gt;" name="Enumerate">
		<summary>Enumerates typed data rows</summary>
				<param type="System.UInt32" name="columnIndex1" summary="" />
				<param type="System.UInt32" name="columnIndex2" summary="" />
				<param type="System.UInt32" name="columnIndex3" summary="" />
				<param type="System.UInt32" name="columnIndex4" summary="" />
				<param type="System.UInt32" name="columnIndex5" summary="" />
				<param type="System.UInt32" name="columnIndex6" summary="" />
				<param type="System.UInt32" name="columnIndex7" summary="" />
				<param type="System.UInt32" name="columnIndex8" summary="" />
				<param type="System.UInt32" name="columnIndex9" summary="" />
				<param type="System.UInt32" name="columnIndex10" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataTable" base="System.IDisposable">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary>Number of rows in the table</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of columns in the table</summary>
	</property>
	<property type="BrightData.DataTableOrientation" name="Orientation">
		<summary>Data table storage orientation</summary>
	</property>
	<property type="BrightData.BrightDataType[]" name="ColumnTypes">
		<summary>Array of the types of each column</summary>
	</property>
	<property type="BrightData.Types.MetaData[]" name="ColumnMetaData">
		<summary>Array of the column metadata</summary>
	</property>
	<method type="System.Void" name="PersistMetaData">
		<summary>Persists changes in the metadata to the underlying storage</summary>
			</method>
	<method type="BrightData.IReadOnlyBufferWithMetaData" name="GetColumn">
		<summary>Returns a column</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBufferWithMetaData&lt;T&gt;" name="GetColumn">
		<summary>Returns a typed column</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.Types.MetaData[]&gt;" name="GetColumnAnalysis">
		<summary>Returns column analysis of the specified columns (or all if none specified)</summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="SetTensorData">
		<summary>Sets an alternate tensor data provider</summary>
				<param type="BrightData.ITensorDataProvider" name="dataProvider" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T&gt;" name="Get">
		<summary>Returns a typed value from the data table</summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T[]&gt;" name="Get">
		<summary>Returns an array of column values</summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;BrightData.DataTable.TableRow&gt;" name="EnumerateRows">
		<summary>Enumerates all rows of the table</summary>
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBufferWithMetaData[]" name="GetColumns">
		<summary>Returns an array of columns</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndices" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="WriteColumnsTo">
		<summary>Writes the specified columns to a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="WriteRowsTo">
		<summary>Writes the specified rows to a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.TableRow[]&gt;" name="GetRows">
		<summary>Returns an array of rows</summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<property type="BrightData.DataTable.TableRow" name="this">
		<summary>Returns a row from the table</summary>
	</property>
</interface>
<interface name="BrightData.IDataTableVectoriser" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		Data table vectoriser
	</summary>
		<method type="System.Single[]" name="Vectorise">
		<summary>Vectorise a table row</summary>
				<param type="System.Object[]" name="row" summary="" />
			</method>
	<method type="System.Single[]" name="Vectorise">
		<summary>Vectorise a data table segment</summary>
				<param type="BrightData.ICanRandomlyAccessData" name="segment" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of the output vectors</summary>
	</property>
	<method type="System.String" name="GetOutputLabel">
		<summary>Returns the associated label from the one hot encoding dictionary</summary>
				<param type="System.UInt32" name="vectorIndex" summary="Index within one hot encoded vector" />
				<param type="System.UInt32" name="columnIndex" summary="Data table column index" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IVector&gt;" name="Enumerate">
		<summary>Returns a sequence of vectorised table rows</summary>
			</method>
</interface>
<interface name="BrightData.IDataTypeSpecification" base="">
	<summary>
		Data type specifications can validate a data source
	</summary>
		<property type="System.String" name="Name">
		<summary>Name of this item</summary>
	</property>
	<property type="BrightData.IDataTypeSpecification[]" name="Children">
		<summary>Children of this item (optional)</summary>
	</property>
	<property type="System.Type" name="UnderlyingType">
		<summary>Underlying .net type for this item</summary>
	</property>
	<property type="BrightData.DataSpecificationType" name="SpecificationType">
		<summary>Item type</summary>
	</property>
	<property type="System.Boolean" name="CanRepeat">
		<summary>True if the item can repeat</summary>
	</property>
</interface>
<interface name="BrightData.IDataTypeSpecification&lt;T&gt;" base="BrightData.IDataTypeSpecification">
	<summary>
		Typed data specification
	</summary>
		<method type="System.Boolean" name="IsValid">
		<summary>Checks if the typed instance is valid against the specification</summary>
				<param type="T" name="instance" summary="" />
			</method>
	<method type="System.Void" name="AddPredicate">
		<summary>Adds a predicate that must match to be considered valid</summary>
				<param type="System.Predicate&lt;T&gt;" name="predicate" summary="" />
			</method>
</interface>
<interface name="BrightData.IDiscreteDistribution" base="BrightData.IDistribution&lt;System.Int32&gt;">
	<summary>
		Discrete data distribution
	</summary>
	</interface>
<interface name="BrightData.IDistribution&lt;T&gt;" base="">
	<summary>
		Data distribution
	</summary>
		<method type="T" name="Sample">
		<summary>Samples a value from the distribution</summary>
			</method>
</interface>
<interface name="BrightWire.IErrorMetric" base="">
	<summary>
		Error metrics used to quantify machine learning
	</summary>
		<property type="System.Boolean" name="DisplayAsPercentage">
		<summary>True if the result should be formatted as a percentage</summary>
	</property>
	<method type="System.Single" name="Compute">
		<summary>Computes the error between the output vector and target vector</summary>
				<param type="BrightData.IReadOnlyVector" name="output" summary="The vector that was the output of the model" />
				<param type="BrightData.IReadOnlyVector" name="targetOutput" summary="The vector that the model was expected to output" />
			</method>
	<method type="System.Single" name="Compute">
		<summary>Computes the error between the output vector and target vector</summary>
				<param type="System.Single[]" name="output" summary="The vector that was the output of the model" />
				<param type="System.Single[]" name="targetOutput" summary="The vector that the model was expected to output" />
			</method>
	<method type="BrightData.IMatrix" name="CalculateGradient">
		<summary>Calculates the gradient of the error function</summary>
				<param type="BrightData.IMatrix" name="output" summary="The mini batch of output vectors" />
				<param type="BrightData.IMatrix" name="targetOutput" summary="The mini batch of expected target vectors" />
			</method>
</interface>
<interface name="BrightWire.IFeedForward" base="">
	<summary>
		Feed forward layer
	</summary>
		<property type="System.String" name="Id">
		<summary>Node id</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>Size of incoming connections</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of outgoing connections</summary>
	</property>
	<property type="BrightData.IVector" name="Bias">
		<summary>Bias vector</summary>
	</property>
	<property type="BrightData.IMatrix" name="Weight">
		<summary>Weight matrix</summary>
	</property>
	<method type="System.Void" name="UpdateWeights">
		<summary>Updates the weights</summary>
				<param type="BrightData.IMatrix" name="delta" summary="Weight delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="Graph learning context" />
			</method>
	<method type="System.Void" name="UpdateBias">
		<summary>Updates the bias</summary>
				<param type="BrightData.IMatrix" name="delta" summary="" />
				<param type="BrightWire.ILearningContext" name="context" summary="" />
			</method>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep">
		<summary>Executes the feed forward node</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
</interface>
<interface name="BrightWire.IGradientDescentOptimisation" base="System.IDisposable">
	<summary>
		Gradient descent optimisation
	</summary>
		<method type="System.Void" name="Update">
		<summary>Updates the matrix with the delta</summary>
				<param type="BrightData.IMatrix" name="source" summary="The matrix to update" />
				<param type="BrightData.IMatrix" name="delta" summary="The delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="The graph learning context" />
			</method>
</interface>
<interface name="BrightWire.IGraphContext" base="System.IDisposable">
	<summary>
		Represents a single pass through the graph
	</summary>
		<property type="BrightWire.IGraphData" name="Data">
		<summary>Current signal</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext" name="ExecutionContext">
		<summary>Current execution context</summary>
	</property>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Current learning context (optional)</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="BatchSequence">
		<summary>Current mini batch sequence</summary>
	</property>
	<method type="System.Void" name="AddForwardHistory">
		<summary>Records forward node execution</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="Node that was executed" />
				<param type="BrightWire.IGraphData" name="data" summary="Output from the node" />
				<param type="System.Func&lt;BrightWire.IBackpropagate&gt;" name="callback" summary="Optional callback to add backpropagation" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="prev" summary="Ancestors that fed input into the node" />
			</method>
	<method type="BrightWire.IGraphData" name="Backpropagate">
		<summary>Backpropagates the signal</summary>
				<param type="BrightWire.IGraphData" name="delta" summary="Error signal" />
			</method>
	<property type="BrightWire.IGraphData" name="ErrorSignal">
		<summary>Final error signal</summary>
	</property>
	<method type="System.Void" name="SetOutput">
		<summary>Saves the data as an output of the graph</summary>
				<param type="BrightWire.IGraphData" name="data" summary="Segment to save" />
				<param type="System.Int32" name="channel" summary="Channel to save against (optional)" />
			</method>
	<method type="BrightWire.IGraphData" name="GetOutput">
		<summary>Returns a saved output</summary>
				<param type="System.Int32" name="channel" summary="Output channel (optional)" />
			</method>
	<property type="BrightWire.IGraphData[]" name="Output">
		<summary>Returns all stored output</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Results">
		<summary>Execution results</summary>
	</property>
	<method type="System.Void" name="ClearForBackpropagation">
		<summary>Resets the context for another run of backpropagation</summary>
			</method>
	<method type="System.Void" name="SetData">
		<summary>Stores sequence specific data</summary>
				<param type="System.String" name="name" summary="Source node name" />
				<param type="System.String" name="type" summary="Data type" />
				<param type="BrightWire.IGraphData" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.String Name, BrightWire.IGraphData Data)&gt;" name="GetData">
		<summary>Retrieves sequence specific data</summary>
				<param type="System.String" name="type" summary="Data type" />
			</method>
</interface>
<interface name="BrightWire.IGraphData" base="">
	<summary>
		Wrapper around the data that is used as a signal between nodes in the graph
	</summary>
		<property type="System.UInt32" name="Rows">
		<summary>Row count</summary>
	</property>
	<property type="System.UInt32" name="Columns">
		<summary>Column count</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>3D Tensor depth (1 if the signal is a matrix)</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>Count of 3D tensors (1 if the signal is a matrix or 3D tensor)</summary>
	</property>
	<method type="BrightData.IMatrix" name="GetMatrix">
		<summary>Gets the signal as a matrix</summary>
			</method>
	<method type="BrightData.ITensor3D" name="Get3DTensor">
		<summary>Gets the signal as a 3D tensor</summary>
			</method>
	<method type="BrightData.ITensor4D" name="Get4DTensor">
		<summary>Gets the signal as a 4D tensor</summary>
			</method>
	<method type="BrightWire.IGraphData" name="ReplaceWith">
		<summary>Replaces the data with the specified matrix (but preserves any tensor metadata)</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="The matrix to use as a replacement" />
			</method>
	<property type="System.Single" name="this">
		<summary>Returns the value at the specified index</summary>
	</property>
	<property type="System.Boolean" name="HasValue">
		<summary>True if this graph data has been set (false for null)</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphEngine" base="BrightWire.ICreateGraphContext">
	<summary>
		Graph engines drive execution within a graph
	</summary>
		<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>Serialised version of the current graph and its parameters</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source that feeds into the graph</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="Start">
		<summary>The graph's single start node</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphExecutionEngine" base="BrightWire.IGraphEngine">
	<summary>
		Graph engine that is optimised for inference
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Execute">
		<summary>Executes a data source on the current graph</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source to process" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notified after each mini batch has completed" />
				<param type="System.Boolean" name="wantInputInExecutionResults" summary="True to write the input rows to the execution results" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Execute">
		<summary>Executes a single vector on the current graph</summary>
				<param type="System.Single[]" name="input" summary="Vector to execute" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="ExecuteSingleSequentialStep">
		<summary>Executes a sequential input on the current graph</summary>
				<param type="BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext" name="executionContext" summary="Execution context" />
				<param type="System.UInt32" name="sequenceIndex" summary="Index of the current sequence (starting from 0)" />
				<param type="System.Single[]" name="input" summary="Input vector" />
				<param type="BrightWire.MiniBatchSequenceType" name="sequenceType" summary="The sequence type (start, standard, end)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="ExecuteSequential">
		<summary>Executes a sequence of inputs on the current graph</summary>
				<param type="System.Single[][]" name="input" summary="List of vector inputs" />
			</method>
	<method type="BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext" name="CreateExecutionContext">
		<summary>Creates a graph execution context</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphOperation" base="">
	<summary>
		A pending graph operation (mini batch)
	</summary>
		<method type="BrightWire.IMiniBatch" name="GetMiniBatch">
		<summary>Creates the mini batch</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphTrainingEngine" base="BrightWire.IGraphEngine">
	<summary>
		A graph engine that can train the graph from training data
	</summary>
		<method type="System.Void" name="Train">
		<summary>Executes a training epoch on the graph</summary>
				<param type="BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notified after each mini batch has completed" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Boolean" name="Test">
		<summary>Executes test data on the current graph</summary>
				<param type="BrightWire.IDataSource" name="testDataSource" summary="Segment source with test data" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notified after each mini batch has completed" />
				<param type="System.Action&lt;System.Single, System.Boolean, System.Boolean&gt;" name="values" summary="Optional callback to get the (testError, trainingRate, isPercentage, isImprovedScore) data" />
			</method>
	<property type="BrightData.BrightDataContext" name="Context">
		<summary>Bright data context</summary>
	</property>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Graph learning context</summary>
	</property>
	<method type="System.Void" name="LoadParametersFrom">
		<summary>Loads model parameters into the existing graph (based on matching ids or names)
IMPORTANT: if loading into a different graph the node ids will not be the same and so node names will need to be assigned for any nodes to be copied</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Model to load parameters from" />
			</method>
	<method type="BrightWire.IGraphExecutionEngine" name="CreateExecutionEngine">
		<summary>Creates an inference only engine from the current graph</summary>
				<param type="BrightWire.Models.ExecutionGraphModel" name="model" summary="" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the learning context epoch and the best test result</summary>
			</method>
	<method type="System.Void" name="SetStartNode">
		<summary>Sets the engine's start node (can be used to load a previously saved graph)</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="startNode" summary="Node to use as the engine's start node" />
			</method>
</interface>
<interface name="BrightWire.IHaveAction" base="">
	<summary>
		Node that exposes an action
	</summary>
		<property type="BrightWire.IAction" name="Action">
		<summary>The node's action</summary>
	</property>
</interface>
<interface name="BrightData.IHaveBrightDataContext" base="">
	<summary>
		Indicates that the type has a data context
	</summary>
		<property type="BrightData.BrightDataContext" name="Context">
		<summary>Bright data context</summary>
	</property>
</interface>
<interface name="BrightData.IHaveDataAsReadOnlyByteSpan" base="">
	<summary>
		Returns the types data as a read only byte span
	</summary>
		<property type="System.ReadOnlySpan&lt;System.Byte&gt;" name="DataAsBytes">
		<summary>The data of the type as bytes</summary>
	</property>
</interface>
<interface name="BrightData.IHaveDistinctItemCount" base="">
	<summary>
		Indicates that the type counts distinct items
	</summary>
		<property type="System.Nullable&lt;System.UInt32&gt;" name="DistinctItems">
		<summary>Count of distinct items (or null if the count was not found)</summary>
	</property>
</interface>
<interface name="BrightWire.IHaveFeedForward" base="">
	<summary>
		Nodes that contain a feed forward layer
	</summary>
		<property type="BrightWire.IFeedForward" name="FeedForward">
		<summary>Feed forward layer</summary>
	</property>
</interface>
<interface name="BrightData.IHaveIndices" base="">
	<summary>
		Indicates that the type has a list of indices
	</summary>
		<property type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="Indices">
		<summary>Enumerates the indices</summary>
	</property>
</interface>
<interface name="BrightData.IHaveLinearAlgebraProvider" base="">
	<summary>
		Gives access to a linear algebra provider
	</summary>
		<property type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
</interface>
<interface name="BrightData.IHaveMatrixDimensions" base="BrightData.IHaveSize">
	<summary>
		Matrix dimensions
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>Number of columns</summary>
	</property>
</interface>
<interface name="BrightData.IHaveMemory&lt;T&gt;" base="">
	<summary>
		Indicates that the type exposes its data as typed memory
	</summary>
		<property type="System.ReadOnlyMemory&lt;T&gt;" name="ReadOnlyMemory">
		<summary>The typed memory of the data in the type</summary>
	</property>
</interface>
<interface name="BrightWire.IHaveMemoryNode" base="">
	<summary>
		Nodes that have a memory feeder sub-node
	</summary>
		<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="Memory">
		<summary>The memory feed sub node</summary>
	</property>
</interface>
<interface name="BrightData.IHaveMetaData" base="">
	<summary>
		Indicates that the type has a metadata store
	</summary>
		<property type="BrightData.Types.MetaData" name="MetaData">
		<summary>Meta data store</summary>
	</property>
</interface>
<interface name="BrightData.IHaveReadOnlyContiguousSpan&lt;T&gt;" base="">
	<summary>
		Indicates that the type has a contiguous read only float span
	</summary>
		<property type="System.ReadOnlySpan&lt;T&gt;" name="ReadOnlySpan">
		<summary>A read only span of floats</summary>
	</property>
</interface>
<interface name="BrightData.IHaveReadOnlyTensorSegment&lt;T&gt;" base="">
	<summary>
		Indicates that there is an underlying tensor segment
	</summary>
		<property type="BrightData.IReadOnlyNumericSegment&lt;T&gt;" name="ReadOnlySegment">
		<summary>Underlying tensor segment</summary>
	</property>
</interface>
<interface name="BrightData.IHaveSize" base="">
	<summary>
		Indicates that the type has a size
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>Number of items</summary>
	</property>
</interface>
<interface name="BrightData.IHaveSpanOf&lt;T&gt;" base="">
	<summary>
		Indicates that the type can create a readonly span of floats
	</summary>
		<method type="System.ReadOnlySpan&lt;T&gt;" name="GetSpan">
		<summary>Returns a span of floats</summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;T&gt;" name="temp" summary="Optional buffer that might be needed when creating the span" />
				<param type="System.Boolean" name="wasTempUsed" summary="True if the buffer was used" />
			</method>
</interface>
<interface name="BrightData.IHaveStringIndexer" base="">
	<summary>
		Indicates that the type has string indexer
	</summary>
		<property type="BrightData.IIndexStrings" name="Indexer">
		<summary>String indexer</summary>
	</property>
</interface>
<interface name="BrightData.IHaveTensor3DDimensions" base="BrightData.IHaveMatrixDimensions">
	<summary>
		3D tensor dimensions
	</summary>
		<property type="System.UInt32" name="Depth">
		<summary>Number of matrices</summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary>Rows * Columns</summary>
	</property>
</interface>
<interface name="BrightData.IHaveTensor4DDimensions" base="BrightData.IHaveTensor3DDimensions">
	<summary>
		4D tensor dimensions
	</summary>
		<property type="System.UInt32" name="Count">
		<summary>Number of 3D tensors</summary>
	</property>
	<property type="System.UInt32" name="TensorSize">
		<summary>MatrixSize * Depth</summary>
	</property>
</interface>
<interface name="BrightData.IHaveTensorSegment&lt;T&gt;" base="">
	<summary>
		Indicates that there is an underlying tensor segment
	</summary>
		<property type="BrightData.INumericSegment&lt;T&gt;" name="Segment">
		<summary>Underlying tensor segment</summary>
	</property>
</interface>
<interface name="BrightWire.IIndexListClassifier" base="">
	<summary>
		A classifier that classifies index lists
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary>Classifies the input data and returns the classifications with their weights</summary>
				<param type="BrightData.Types.IndexList" name="indexList" summary="The index list to classify" />
			</method>
</interface>
<interface name="BrightWire.IIndexListEncoder" base="">
	<summary>
		Encodes index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the index lists to a dense vector</summary>
				<param type="BrightData.Types.IndexList" name="indexList" summary="The index list to encode" />
			</method>
</interface>
<interface name="BrightData.IIndexStrings" base="">
	<summary>
		Indicates that the type can convert string to string indices
	</summary>
		<method type="System.UInt32" name="GetIndex">
		<summary>Returns the index for a string</summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>Gets the total number of possible string indices</summary>
	</property>
</interface>
<interface name="BrightWire.ILearningContext" base="">
	<summary>
		Graph learning context
	</summary>
		<property type="System.Double" name="EpochSeconds">
		<summary>The duration in seconds of the last epoch</summary>
	</property>
	<property type="System.Int64" name="EpochMilliseconds">
		<summary>The duration in milliseconds of the last epoch</summary>
	</property>
	<property type="System.UInt32" name="CurrentEpoch">
		<summary>The index of the current epoch (starting from one)</summary>
	</property>
	<property type="System.Single" name="LearningRate">
		<summary>The current learning/training rate</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>The current mini batch size</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The total number of rows per epoch</summary>
	</property>
	<method type="System.Void" name="AddError">
		<summary>Adds an error to the node</summary>
				<param type="BrightWire.NodeErrorType" name="errorType" summary="Error type" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="fromNode" summary="The node that created the error" />
				<param type="BrightData.ITensor" name="error" summary="Error" />
			</method>
	<method type="System.Void" name="ApplyUpdates">
		<summary>Apply any deferred updates</summary>
			</method>
	<method type="System.Void" name="StartEpoch">
		<summary>Start a new epoch</summary>
			</method>
	<method type="System.Void" name="EndEpoch">
		<summary>End the current epoch</summary>
			</method>
	<method type="System.Void" name="SetRowCount">
		<summary>Sets the number of rows</summary>
				<param type="System.UInt32" name="rowCount" summary="The number of rows per epoch" />
			</method>
	<method type="System.Void" name="DeferBackpropagation">
		<summary>Register the backpropagation to be deferred</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The error signal associated with this backpropagation (optional, can be null)" />
				<param type="System.Func&lt;BrightWire.IGraphData, BrightWire.IGraphData&gt;" name="update" summary="The callback to execute the backpropagation" />
			</method>
	<method type="BrightWire.IGraphData" name="BackpropagateThroughTime">
		<summary>Backpropagates the error signal across all deferred backpropagations</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="The backpropagation signal" />
				<param type="System.Int32" name="maxDepth" summary="The maximum depth to backpropagate the signal" />
			</method>
	<method type="System.Void" name="ScheduleLearningRate">
		<summary>Schedules a change in the learning rate the specified epoch</summary>
				<param type="System.UInt32" name="atEpoch" summary="The epoch to change the learning rate" />
				<param type="System.Single" name="newLearningRate" summary="The learning rate to use at that epoch" />
			</method>
	<method type="System.Void" name="EnableNodeUpdates">
		<summary>Enable or disable node parameter updates</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to modify" />
				<param type="System.Boolean" name="enableUpdates" summary="True if the node can make updates via backpropagation" />
			</method>
	<property type="BrightWire.IErrorMetric" name="ErrorMetric">
		<summary>Error metric to use when evaluating training progress</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory" name="GraphFactory">
		<summary>Graph factory</summary>
	</property>
	<method type="System.Void" name="ResetEpoch">
		<summary>Resets the epoch</summary>
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionPredictor" base="System.IDisposable">
	<summary>
		Linear regression predictor
	</summary>
		<method type="System.Single" name="Predict">
		<summary>Predicts a value from input data</summary>
				<param type="System.Single[]" name="input" summary="The input data" />
			</method>
	<method type="System.Single[]" name="Predict">
		<summary>Bulk value prediction</summary>
				<param type="System.Single[][]" name="input" summary="List of data to predict" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionClassifier" base="System.IDisposable">
	<summary>
		Logistic regression classifier
	</summary>
		<method type="BrightData.IVector" name="Predict">
		<summary>Outputs a list of values from 0 to 1 for each input data</summary>
				<param type="BrightData.IMatrix" name="input" summary="Input data" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer&lt;T&gt;" base="">
	<summary>
		Markov model trainer
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a sequence of items to the trainer</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer2&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 2)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer3&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 3)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightData.IMatrix" base="BrightData.ITensor&lt;BrightData.IMatrix&gt;">
	<summary>
		Matrix interface
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the matrix</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the matrix</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the matrix</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the matrix</summary>
	</property>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Row">
		<summary>Returns a row from the matrix</summary>
				<param type="System.UInt32" name="index" summary="Row index" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Column">
		<summary>Returns a column from the matrix</summary>
				<param type="System.UInt32" name="index" summary="Column index" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetRowSpan">
		<summary>Returns a row as a span</summary>
				<param type="System.UInt32" name="rowY" summary="Row index" />
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="Temporary buffer in which to write the contiguous row values" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetColumnSpan">
		<summary>Returns a column as a span</summary>
				<param type="System.UInt32" name="columnX" summary="Column index" />
			</method>
	<method type="BrightData.IVector" name="GetRowVector">
		<summary>Returns a row as a vector</summary>
				<param type="System.UInt32" name="rowY" summary="Row index" />
			</method>
	<method type="BrightData.IVector" name="GetColumnVector">
		<summary>Returns a column as a vector</summary>
				<param type="System.UInt32" name="columnX" summary="Column index" />
			</method>
	<method type="BrightData.IMatrix" name="Transpose">
		<summary>Returns the transpose of this matrix</summary>
			</method>
	<method type="BrightData.IMatrix" name="Multiply">
		<summary>Multiply this matrix with another matrix (matrix multiplication)</summary>
				<param type="BrightData.IMatrix" name="other" summary="Other matrix" />
			</method>
	<method type="BrightData.IMatrix" name="TransposeAndMultiply">
		<summary>Transpose the other matrix and then multiply with this matrix</summary>
				<param type="BrightData.IMatrix" name="other" summary="Other matrix" />
			</method>
	<method type="BrightData.IMatrix" name="TransposeThisAndMultiply">
		<summary>Transpose this matrix and then multiply with another matrix</summary>
				<param type="BrightData.IMatrix" name="other" summary="Other matrix" />
			</method>
	<method type="BrightData.IVector" name="GetDiagonal">
		<summary>Returns the diagonal of this matrix</summary>
			</method>
	<method type="BrightData.IVector" name="RowSums">
		<summary>Returns the sum of all rows in this matrix</summary>
			</method>
	<method type="BrightData.IVector" name="ColumnSums">
		<summary>Returns the sum of all columns in this matrix</summary>
			</method>
	<method type="BrightData.IVector" name="Multiply">
		<summary>Multiplies this matrix with a vector</summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="(BrightData.IMatrix Left, BrightData.IMatrix Right)" name="SplitAtColumn">
		<summary>Splits this matrix into two matrices from a column index</summary>
				<param type="System.UInt32" name="columnIndex" summary="Column index at which to split" />
			</method>
	<method type="(BrightData.IMatrix Top, BrightData.IMatrix Bottom)" name="SplitAtRow">
		<summary>Splits this matrix into two matrices from a row index</summary>
				<param type="System.UInt32" name="rowIndex" summary="Row index at which to split" />
			</method>
	<method type="BrightData.IMatrix" name="ConcatBelow">
		<summary>Concatenates this matrix with another matrix (column counts must agree)</summary>
				<param type="BrightData.IMatrix" name="bottom" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ConcatRight">
		<summary>Concatenates this matrix with another matrix (row counts must agree)</summary>
				<param type="BrightData.IMatrix" name="right" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="MapIndexed">
		<summary>Applies an indexed mapping function to this matrix</summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="MapIndexedInPlace">
		<summary>Applies an indexed mapping function to this matrix (matrix will be modified in place)</summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="(BrightData.IMatrix U, BrightData.IVector S, BrightData.IMatrix VT)" name="Svd">
		<summary>Computes the singular value decomposition of this matrix
https://en.wikipedia.org/wiki/Singular_value_decomposition</summary>
			</method>
	<method type="BrightData.IMatrix" name="GetNewMatrixFromRows">
		<summary>Creates a new matrix from the specified rows of this matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndices" summary="Row indices" />
			</method>
	<method type="BrightData.IMatrix" name="GetNewMatrixFromColumns">
		<summary>Creates a new matrix from the specified columns of this matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndices" summary="Column indices" />
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds a tensor segment to each row of this matrix (matrix will be modified in place)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn">
		<summary>Adds a tensor segment to each column of this matrix (matrix will be modified in place)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="MultiplyEachRowWith">
		<summary>Multiplies each row of this matrix with a tensor segment (matrix will be modified in place)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="MultiplyEachColumnWith">
		<summary>Multiplies each column of this matrix with a tensor segment (matrix will be modified in place)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="SoftmaxPerRow">
		<summary>Computes the per row software of this matrix</summary>
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="SoftmaxDerivativePerRow">
		<summary>Computes the per row softmax derivative of this matrix</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Clone">
		<summary>Clones the matrix</summary>
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetRowAsReadOnly">
		<summary>Returns a row as a read only vector</summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetColumnAsReadOnly">
		<summary>Returns a column as a read only vector</summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector[]" name="AllRowsAsReadOnly">
		<summary>Returns all rows as read only vectors</summary>
				<param type="System.Boolean" name="makeCopy" summary="True to make a copy of each row" />
			</method>
	<method type="BrightData.IReadOnlyVector[]" name="AllColumnsAsReadOnly">
		<summary>Returns all columns as read only vectors</summary>
				<param type="System.Boolean" name="makeCopy" summary="True to make a copy of each column" />
			</method>
</interface>
<interface name="BrightWire.IMemoryNode" base="">
	<summary>
		Recurrent neural networks memory node
	</summary>
		<property type="System.Single[]" name="Data">
		<summary>The current state of the memory node</summary>
	</property>
</interface>
<interface name="BrightWire.IMiniBatch" base="">
	<summary>
		Information about the current mini batch
	</summary>
		<property type="System.UInt32[]" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence">
		<summary>Gets the next item in the sequence</summary>
			</method>
	<property type="System.UInt32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex">
		<summary>Gets a sequence item</summary>
				<param type="System.UInt32" name="index" summary="The index to retrieve" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the sequence iterator</summary>
			</method>
	<property type="BrightWire.IMiniBatch" name="NextMiniBatch">
		<summary>Subsequent mini bach</summary>
	</property>
	<property type="BrightWire.IMiniBatch" name="PreviousMiniBatch">
		<summary>Previous mini batch</summary>
	</property>
</interface>
<interface name="BrightWire.IMiniBatchSequence" base="">
	<summary>
		A sequence within a mini batch
	</summary>
		<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary>Mini batch</summary>
	</property>
	<property type="System.UInt32" name="SequenceIndex">
		<summary>Index of the sequence</summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary>Sequence type</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Input">
		<summary>Input data</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary>Training target data</summary>
	</property>
	<property type="BrightWire.IGraphContext" name="GraphContext">
		<summary>Graph sequence context that has been executed for this sequence</summary>
	</property>
</interface>
<interface name="BrightData.INonNegativeDiscreteDistribution" base="BrightData.IDistribution&lt;System.UInt32&gt;">
	<summary>
		Positive discrete data distribution
	</summary>
	</interface>
<interface name="BrightData.INormalize" base="">
	<summary>
		Data normalizer
	</summary>
		<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary>Type of data normalization</summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary>Value to divide each value</summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary>Value to subtract from each value</summary>
	</property>
</interface>
<interface name="BrightData.INotifyOperationProgress" base="">
	<summary>
		Notifies of operations and messages
	</summary>
		<method type="System.Void" name="OnStartOperation">
		<summary>Called at the start of an operation</summary>
				<param type="System.Guid" name="operationId" summary="Unique id for this operation" />
				<param type="System.String" name="msg" summary="Optional message associated with the operation" />
			</method>
	<method type="System.Void" name="OnOperationProgress">
		<summary>Called when the operation has progressed</summary>
				<param type="System.Guid" name="operationId" summary="Unique id for this operation" />
				<param type="System.Single" name="progressPercent" summary="Progress percentage (between 0 and 1)" />
			</method>
	<method type="System.Void" name="OnCompleteOperation">
		<summary>Called when the operation has completed</summary>
				<param type="System.Guid" name="operationId" summary="Unique id for this operation" />
				<param type="System.Boolean" name="wasCancelled" summary="True if the operation was cancelled" />
			</method>
	<method type="System.Void" name="OnMessage">
		<summary>Called to notify about a message</summary>
				<param type="System.String" name="msg" summary="Message to user" />
			</method>
</interface>
<interface name="BrightData.INumericSegment&lt;T&gt;" base="BrightData.IReadOnlyNumericSegment&lt;T&gt;">
	<summary>
		An editable segment of numeric values
	</summary>
		<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<method type="System.Void" name="CopyFrom">
		<summary>Copies from the span into the segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="Span to copy from" />
				<param type="System.UInt32" name="targetOffset" summary="Index into this segment to replace from" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Sets each value within the segment to zero</summary>
			</method>
	<method type="(T[] Array, System.UInt32 Offset, System.UInt32 Stride)" name="GetUnderlyingArray">
		<summary>Returns the underlying array used by the segment (if available)</summary>
			</method>
</interface>
<interface name="BrightData.IOperation&lt;T&gt;" base="System.IDisposable">
	<summary>
		A generic operation that might require user notification and that can be cancelled
	</summary>
		<method type="T" name="Complete">
		<summary>Tries to complete the operation</summary>
				<param type="BrightData.INotifyOperationProgress" name="notifyUser" summary="Optional interface to notify the user of progress" />
				<param type="System.Threading.CancellationToken" name="cancellationToken" summary="Cancellation token to cancel operation" />
			</method>
</interface>
<interface name="BrightData.IOperation" base="">
	<summary>
		Represents a potentially long-running operation
	</summary>
		<method type="System.Threading.Tasks.Task" name="Execute">
		<summary>Executes the operation</summary>
				<param type="BrightData.INotifyOperationProgress" name="notify" summary="Notify about progress (optional)" />
				<param type="System.String" name="msg" summary="Message to notification when operation starts (optional)" />
				<param type="System.Threading.CancellationToken" name="ct" summary="Cancellation token (optional)" />
			</method>
</interface>
<interface name="BrightWire.IPropertySet" base="BrightData.IHaveLinearAlgebraProvider">
	<summary>
		The current set of graph initialisation parameters
	</summary>
		<property type="BrightWire.IWeightInitialisation" name="WeightInitialisation">
		<summary>The weight initialiser to use</summary>
	</property>
	<property type="BrightWire.IGradientDescentOptimisation" name="GradientDescent">
		<summary>The gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="TemplateGradientDescentDescriptor">
		<summary>The template based gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="GradientDescentDescriptor">
		<summary>The descriptor to create new gradient descent optimisations</summary>
	</property>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified template based gradient descent optimisation</summary>
				<param type="BrightWire.ICreateTemplateBasedGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.ICreateGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="optimisation" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified weight initialiser</summary>
				<param type="BrightWire.IWeightInitialisation" name="weightInit" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Clone">
		<summary>Clones the current property set</summary>
			</method>
	<method type="T" name="Get">
		<summary>Gets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
	<method type="BrightWire.IPropertySet" name="Set">
		<summary>Sets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="obj" summary="The property value" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Clears the named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
</interface>
<interface name="BrightData.IProvideDataBlocks" base="System.IDisposable">
	<summary>
		Provides data blocks
	</summary>
		<method type="BrightData.IByteBlockSource" name="Get">
		<summary>Returns a data block associated with the id</summary>
				<param type="System.Guid" name="id" summary="" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Clears all data blocks</summary>
			</method>
</interface>
<interface name="BrightWire.IRandomProjection" base="System.IDisposable">
	<summary>
		Random projection
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>The size to reduce to</summary>
	</property>
	<property type="BrightData.IMatrix" name="Matrix">
		<summary>The transformation matrix</summary>
	</property>
	<method type="BrightData.IVector" name="Compute">
		<summary>Reduces a vector</summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Compute">
		<summary>Reduces a matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
</interface>
<interface name="BrightData.IReadOnlyBuffer" base="BrightData.IHaveSize">
	<summary>
		Read only buffer - composed of multiple blocks of a fixed size
	</summary>
		<property type="System.UInt32" name="BlockSize">
		<summary>Size of each block in the buffer</summary>
	</property>
	<property type="System.UInt32" name="BlockCount">
		<summary>Number of blocks in the buffer</summary>
	</property>
	<property type="System.Type" name="DataType">
		<summary>The type of data within the buffer</summary>
	</property>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;System.Object&gt;" name="EnumerateAll">
		<summary>Enumerates all objects within the buffer</summary>
			</method>
</interface>
<interface name="BrightData.IReadOnlyBuffer&lt;T&gt;" base="BrightData.IReadOnlyBuffer">
	<summary>
		Typed read only buffer
	</summary>
		<method type="System.Threading.Tasks.Task" name="ForEachBlock">
		<summary>Executes a callback on each block within the buffer</summary>
				<param type="BrightData.BlockCallback&lt;T&gt;" name="callback" summary="" />
				<param type="BrightData.INotifyOperationProgress" name="notify" summary="" />
				<param type="System.String" name="message" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.ReadOnlyMemory&lt;T&gt;&gt;" name="GetTypedBlock">
		<summary>Returns a block from the buffer</summary>
				<param type="System.UInt32" name="blockIndex" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;T&gt;" name="EnumerateAllTyped">
		<summary>Enumerates all values in the buffer</summary>
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerator&lt;T&gt;" name="GetAsyncEnumerator">
		<summary>Enumerates all values in the buffer</summary>
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
</interface>
<interface name="BrightData.IReadOnlyBufferWithMetaData" base="BrightData.IReadOnlyBuffer">
	<summary>
		A read only buffer with metadata
	</summary>
	</interface>
<interface name="BrightData.IReadOnlyBufferWithMetaData&lt;T&gt;" base="BrightData.IReadOnlyBuffer&lt;T&gt;">
	<summary>
		A typed read only buffer with metadata
	</summary>
	</interface>
<interface name="BrightData.IReadOnlyMatrix" base="BrightData.IReadOnlyTensor">
	<summary>
		Matrix that cannot be modified
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the matrix</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the matrix</summary>
	</property>
	<method type="BrightData.IReadOnlyVector" name="GetRow">
		<summary>Returns a row from the matrix</summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetColumn">
		<summary>Returns a column from the matrix</summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Create">
		<summary>Creates a new mutable matrix that is a copy of this matrix</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</interface>
<interface name="BrightData.IReadOnlyNumericSegment&lt;T&gt;" base="BrightData.ICountReferences">
	<summary>
		A read only segment of numeric values - might be contiguous or a wrapper around a contiguous block
	</summary>
		<property type="System.String" name="SegmentType">
		<summary>Segment type</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="T" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<method type="T[]" name="ToNewArray">
		<summary>Creates a new array from the segment</summary>
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Values">
		<summary>Iterates all values in the segment</summary>
	</property>
	<method type="System.Void" name="CopyTo">
		<summary>Copies this segment to another segment</summary>
				<param type="BrightData.INumericSegment&lt;T&gt;" name="segment" summary="Segment to copy to" />
				<param type="System.UInt32" name="sourceOffset" summary="Index within this segment to copy from" />
				<param type="System.UInt32" name="targetOffset" summary="Index within other segment to replace from" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary>Copies this segment to a span</summary>
				<param type="System.Span&lt;T&gt;" name="destination" summary="Destination span" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary>Copies to a pointer</summary>
				<param type="T*" name="destination" summary="Pointer to memory to copy to" />
				<param type="System.Int32" name="sourceOffset" summary="Index within this segment to copy from" />
				<param type="System.Int32" name="stride" summary="Increment after each copy" />
				<param type="System.Int32" name="count" summary="Number of elements to copy" />
			</method>
	<property type="BrightData.IHaveReadOnlyContiguousSpan&lt;System.Single&gt;" name="Contiguous">
		<summary>Tries to return a contiguous span from the current segment if possible</summary>
	</property>
	<property type="System.Boolean" name="IsWrapper">
		<summary>True if the segment wraps another segment</summary>
	</property>
</interface>
<interface name="BrightData.IReadOnlyTensor" base="BrightData.IHaveSpanOf&lt;System.Single&gt;">
	<summary>
		Generic read only tensor
	</summary>
	</interface>
<interface name="BrightData.IReadOnlyTensor3D" base="BrightData.IReadOnlyTensor">
	<summary>
		3D tensor that cannot be modified
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the 3D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the 3D tensor</summary>
	</property>
	<method type="BrightData.IReadOnlyMatrix" name="GetMatrix">
		<summary>Returns a matrix from the 3D tensor</summary>
				<param type="System.UInt32" name="index" summary="Matrix index" />
			</method>
	<method type="BrightData.ITensor3D" name="Create">
		<summary>Creates a new mutable tensor that is a copy of this tensor</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</interface>
<interface name="BrightData.IReadOnlyTensor4D" base="BrightData.IReadOnlyTensor">
	<summary>
		4D tensor that cannot be modified
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the 4D tensor</summary>
	</property>
	<method type="BrightData.IReadOnlyTensor3D" name="GetTensor">
		<summary>Returns a 3D tensor from the 4D tensor</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="Create">
		<summary>Creates a new mutable tensor that is a copy of this tensor</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</interface>
<interface name="BrightData.IReadOnlyVector" base="BrightData.IReadOnlyTensor">
	<summary>
		Vector that cannot be modified
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value at the index</summary>
	</property>
	<method type="BrightData.IVector" name="Create">
		<summary>Creates a new mutable vector that is a copy of this vector</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</interface>
<interface name="BrightWire.IRowClassifier" base="">
	<summary>
		Classifies convertible rows
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary>Classifies a convertible row</summary>
				<param type="BrightData.DataTable.TableRow" name="row" summary="Row to classify" />
			</method>
</interface>
<interface name="BrightData.ISetLinearAlgebraProvider" base="">
	<summary>
		Indicates that the type can set a linear algebra provider
	</summary>
		<property type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Property to set the linear algebra provider</summary>
	</property>
	<property type="System.Func&lt;BrightData.LinearAlgebra.LinearAlgebraProvider&gt;" name="LinearAlgebraProviderFactory">
		<summary>Linear algebra provider factory</summary>
	</property>
</interface>
<interface name="BrightWire.ITableClassifier" base="">
	<summary>
		Classifies a data table
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, (System.String Classification, System.Single Weight)[] Predictions)&gt;" name="Classify">
		<summary>Classifies each row of a data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="Table to classify" />
			</method>
</interface>
<interface name="BrightData.ITensor" base="BrightData.IReadOnlyTensor">
	<summary>
		Untyped tensor interface - vector, matrix, 3D tensor etc
	</summary>
		<property type="BrightData.BrightDataContext" name="Context">
		<summary>Underlying bright data context</summary>
	</property>
	<method type="BrightData.IVector" name="Reshape">
		<summary>Reshapes to a vector</summary>
			</method>
	<method type="BrightData.IMatrix" name="Reshape">
		<summary>Reshapes to a matrix</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Row count of each matrix (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Column count of each matrix (one parameter is optional null)" />
			</method>
	<method type="BrightData.ITensor3D" name="Reshape">
		<summary>Reshapes to a 3D tensor</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="Number of matrices (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows in each matrix (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns in each matrix (one parameter is optional null)" />
			</method>
	<method type="BrightData.ITensor4D" name="Reshape">
		<summary>Reshapes to a 4D tensor</summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="count" summary="Number of 3D tensors (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="Number of matrices in each 3D tensor (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows in each matrix (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns in each matrix (one parameter is optional null)" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Sets all values to zero</summary>
			</method>
	<method type="BrightData.ITensor" name="Clone">
		<summary>Creates a copy of this tensor</summary>
			</method>
	<property type="System.UInt32" name="TotalSize">
		<summary>Total count of all values</summary>
	</property>
	<property type="System.UInt32[]" name="Shape">
		<summary>Tensor shape - for a vector the array will have a single element, for a matrix it will be [columns, rows], a 3D tensor will be [columns, rows, depth] etc</summary>
	</property>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a tensor to this tensor (the result will be stored in this tensor)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a tensor to this tensor (the result will be stored in this tensor)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
				<param type="System.Single" name="coefficient1" summary="Value to multiply each element of this tensor" />
				<param type="System.Single" name="coefficient2" summary="Value to multiply each element of the other tensor" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a value to this tensor (the result will be stored in this tensor)</summary>
				<param type="System.Single" name="scalar" summary="Value to add" />
			</method>
	<method type="System.Void" name="MultiplyInPlace">
		<summary>Multiplies a value to this tensor (the result will be stored in this tensor)</summary>
				<param type="System.Single" name="scalar" summary="Value to multiply" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts a tensor from this tensor (the result will be stored in this tensor)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts a tensor from this tensor (the result will be stored in this tensor)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
				<param type="System.Single" name="coefficient1" summary="Value to multiply each element of this tensor" />
				<param type="System.Single" name="coefficient2" summary="Value to multiply each element of the other tensor" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace">
		<summary>Multiplies each value in this tensor with the corresponding value in the other tensor (the result will be stored in this tensor)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace">
		<summary>Divides each value in this tensor with the corresponding value in the other tensor (the result will be stored in this tensor)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Single" name="DotProduct">
		<summary>Computes the dot product of this tensor with another tensor (of same length)</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="System.Void" name="ConstrainInPlace">
		<summary>Modifies this tensor so that no value is less than or greater than supplied parameters</summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="minValue" summary="Minimum value to allow (optional)" />
				<param type="System.Nullable&lt;System.Single&gt;" name="maxValue" summary="Maximum value to allow (optional)" />
			</method>
	<method type="System.Single" name="Average">
		<summary>Finds the average value of this tensor</summary>
			</method>
	<method type="System.Single" name="L1Norm">
		<summary>Returns the L1 norm of this tensor (manhattan distance)</summary>
			</method>
	<method type="System.Single" name="L2Norm">
		<summary>Returns the L2 norm of this tensor (euclidean norm)</summary>
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary>Checks if the tensor is entirely finite (does not contain NAN or Infinity)</summary>
			</method>
	<method type="System.Single" name="CosineDistance">
		<summary>Calculates the cosine distance between this and another tensor</summary>
				<param type="BrightData.ITensor" name="other" summary="Other tensor" />
			</method>
	<method type="System.Single" name="EuclideanDistance">
		<summary>Calculates the euclidean distance between this and another tensor</summary>
				<param type="BrightData.ITensor" name="other" summary="Other tensor" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance">
		<summary>Calculates the mean squared distance between this and another tensor</summary>
				<param type="BrightData.ITensor" name="other" summary="" />
			</method>
	<method type="System.Single" name="SquaredEuclideanDistance">
		<summary>Calculates the squared euclidean distance between this and another tensor</summary>
				<param type="BrightData.ITensor" name="other" summary="Other tensor" />
			</method>
	<method type="System.Single" name="ManhattanDistance">
		<summary>Calculates the manhattan distance between this and another tensor</summary>
				<param type="BrightData.ITensor" name="other" summary="Other tensor" />
			</method>
	<method type="System.Single" name="StdDev">
		<summary>Calculates the standard deviation of this tensor</summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="Existing mean of tensor if available (otherwise it will be calculated)" />
			</method>
	<method type="System.Void" name="RoundInPlace">
		<summary>Rounds each value in this tensor to either the lower or upper parameter (the result will be stored in this tensor)</summary>
				<param type="System.Single" name="lower" summary="" />
				<param type="System.Single" name="upper" summary="" />
			</method>
	<method type="System.Void" name="MapInPlace">
		<summary>Applies a mapping function to each value of this tensor (the result will be stored in this tensor)</summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="L1RegularisationInPlace">
		<summary>Applies L1 regularization to this tensor (the result will be stored in this tensor)</summary>
				<param type="System.Single" name="coefficient" summary="" />
			</method>
	<method type="System.Single" name="Sum">
		<summary>Sums all values of this tensor</summary>
			</method>
</interface>
<interface name="BrightData.ITensor&lt;T&gt;" base="BrightData.ITensor">
	<summary>
		Typed tensor interface - vector, matrix, 3D tensor etc
	</summary>
		<method type="T" name="Clone">
		<summary>Creates a clone of this tensor</summary>
			</method>
	<method type="T" name="Add">
		<summary>Adds a tensor to this tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="Add">
		<summary>Adds a tensor to this tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
				<param type="System.Single" name="coefficient1" summary="Coefficient to multiply each value in this tensor" />
				<param type="System.Single" name="coefficient2" summary="Coefficient to multiply each value in the other tensor" />
			</method>
	<method type="T" name="Add">
		<summary>Adds a value to each element in this tensor</summary>
				<param type="System.Single" name="scalar" summary="Value to add" />
			</method>
	<method type="T" name="Multiply">
		<summary>Multiplies a value to each element in this tensor</summary>
				<param type="System.Single" name="scalar" summary="Value to multiply" />
			</method>
	<method type="T" name="Subtract">
		<summary>Subtracts another tensor from this tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="Subtract">
		<summary>Subtracts another tensor from this tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
				<param type="System.Single" name="coefficient1" summary="Coefficient to multiply each value in this tensor" />
				<param type="System.Single" name="coefficient2" summary="Coefficient to multiply each value in the other tensor" />
			</method>
	<method type="T" name="PointwiseMultiply">
		<summary>Multiplies each value in this tensor with the corresponding value in another tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="PointwiseDivide">
		<summary>Divides each value in this tensor with the corresponding value in another tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="Other tensor" />
			</method>
	<method type="T" name="Sqrt">
		<summary>Returns the square root of each value in this tensor</summary>
			</method>
	<method type="T" name="Reverse">
		<summary>Reverses the order of the elements in this tensor</summary>
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Split">
		<summary>Splits this tensor into multiple contiguous tensors</summary>
				<param type="System.UInt32" name="blockCount" summary="Number of blocks" />
			</method>
	<method type="T" name="Abs">
		<summary>Computes the absolute value of each value in this tensor</summary>
			</method>
	<method type="T" name="Log">
		<summary>Computes the natural logarithm of each value in this tensor</summary>
			</method>
	<method type="T" name="Exp">
		<summary>Computes the exponent of each value in this tensor</summary>
			</method>
	<method type="T" name="Squared">
		<summary>Computes the square of each value in this tensor</summary>
			</method>
	<method type="T" name="Sigmoid">
		<summary>Computes the sigmoid function of each value in this tensor</summary>
			</method>
	<method type="T" name="SigmoidDerivative">
		<summary>Computes the sigmoid derivative for each value in this tensor</summary>
			</method>
	<method type="T" name="Tanh">
		<summary>Computes the hyperbolic tangent of each value in this tensor</summary>
			</method>
	<method type="T" name="TanhDerivative">
		<summary>Computes the derivative of the hyperbolic tangent for each value in this tensor</summary>
			</method>
	<method type="T" name="Relu">
		<summary>Computes the RELU activation for each value in this tensor
https://en.wikipedia.org/wiki/Rectifier_(neural_networks)</summary>
			</method>
	<method type="T" name="ReluDerivative">
		<summary>Computes the RELU derivative of each value in this tensor
https://en.wikipedia.org/wiki/Rectifier_(neural_networks)</summary>
			</method>
	<method type="T" name="LeakyRelu">
		<summary>Computes the Leaky RELU action for each value in this tensor
https://en.wikipedia.org/wiki/Rectifier_(neural_networks)</summary>
			</method>
	<method type="T" name="LeakyReluDerivative">
		<summary>Computes the Leaky RELU derivative for each value in this tensor
https://en.wikipedia.org/wiki/Rectifier_(neural_networks)</summary>
			</method>
	<method type="T" name="Softmax">
		<summary>Computes the softmax of each value in this tensor</summary>
			</method>
	<method type="BrightData.IMatrix" name="SoftmaxDerivative">
		<summary>Computes the softmax derivative of each value in this tensor</summary>
			</method>
	<method type="T" name="Pow">
		<summary>Raises each element in this tensor by power</summary>
				<param type="System.Single" name="power" summary="" />
			</method>
	<method type="T" name="CherryPick">
		<summary>Returns a new tensor with the values specified in indices</summary>
				<param type="System.UInt32[]" name="indices" summary="Indices to return in new tensor" />
			</method>
	<method type="T" name="Map">
		<summary>Applies a mapping function to this tensor</summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="Mapping function" />
			</method>
</interface>
<interface name="BrightData.ITensor3D" base="BrightData.ITensor&lt;BrightData.ITensor3D&gt;">
	<summary>
		3D tensor - a block of matrices
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from this 3D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from this 3D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from this 3D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from this 3D tensor</summary>
	</property>
	<method type="BrightData.IMatrix" name="GetMatrix">
		<summary>Returns a matrix from the tensor</summary>
				<param type="System.UInt32" name="index" summary="Matrix index" />
			</method>
	<method type="BrightData.ITensor3D" name="AddPadding">
		<summary>Creates a new 3D tensor with a "padding" of zeroes around the edge of each matrix</summary>
				<param type="System.UInt32" name="padding" summary="Size of padding" />
			</method>
	<method type="BrightData.ITensor3D" name="RemovePadding">
		<summary>Removes previously added "padding" from the edge of each matrix</summary>
				<param type="System.UInt32" name="padding" summary="Size of padding" />
			</method>
	<method type="BrightData.IMatrix" name="Im2Col">
		<summary>Image to column (convolution operator)</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Horizontal stride" />
				<param type="System.UInt32" name="yStride" summary="Vertical stride" />
			</method>
	<method type="BrightData.ITensor3D" name="ReverseIm2Col">
		<summary>Reverses a previous image to column operation (convolution)</summary>
				<param type="BrightData.IMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="(BrightData.ITensor3D Result, BrightData.ITensor3D Indices)" name="MaxPool">
		<summary>Computes a max pooling operation</summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="ReverseMaxPool">
		<summary>Reverses a max pooling operation</summary>
				<param type="BrightData.ITensor3D" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="AddAllMatrices">
		<summary>Adds all matrices into one new matrix</summary>
			</method>
	<method type="BrightData.ITensor3D" name="MultiplyEachMatrixBy">
		<summary>Multiply each matrix individually by another matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="Other matrix" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeAndMultiplyEachMatrixBy">
		<summary>Transpose another matrix and multiply each matrix individually by the result</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="Other matrix" />
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds a vector to each row of each matrix (tensor will be modified in place)</summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn">
		<summary>Adds a vector to each column of each matrix (tensor will be modified in place)</summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Multiply">
		<summary>Multiplies this matrix with a 4D tensor</summary>
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeAndMultiply">
		<summary>Transposes the 4D matrix and multiplies this tensor with the result</summary>
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeThisAndMultiply">
		<summary>Transposes this tensor and multiply the result with another 4D tensor</summary>
				<param type="BrightData.ITensor4D" name="other" summary="Other tensor" />
			</method>
	<method type="BrightData.ITensor3D" name="Clone">
		<summary>Clones the tensor</summary>
			</method>
</interface>
<interface name="BrightData.ITensor4D" base="BrightData.ITensor&lt;BrightData.ITensor4D&gt;">
	<summary>
		4D tensor - a block of 3D tensors
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from this 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from this 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from this 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from this 4D tensor</summary>
	</property>
	<method type="BrightData.ITensor3D" name="GetTensor">
		<summary>Returns a 3D tensor</summary>
				<param type="System.UInt32" name="index" summary="3D tensor index" />
			</method>
	<method type="BrightData.ITensor4D" name="AddPadding">
		<summary>Adds padding to each 3D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Size of padding" />
			</method>
	<method type="BrightData.ITensor4D" name="RemovePadding">
		<summary>Removes padding from each 3D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Size of padding" />
			</method>
	<method type="(BrightData.ITensor4D Result, BrightData.ITensor4D Indices)" name="MaxPool">
		<summary>Max pooling operation</summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="ReverseMaxPool">
		<summary>Reverse max pooling operation</summary>
				<param type="BrightData.ITensor4D" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Im2Col">
		<summary>Image to column (convolution operator)</summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="ReverseIm2Col">
		<summary>Reverse of image to column (convolution operator)</summary>
				<param type="BrightData.IMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IVector" name="ColumnSums">
		<summary>Computes the sum of all columns</summary>
			</method>
	<method type="BrightData.IVector" name="RowSums">
		<summary>Computes the sum of all rows</summary>
			</method>
	<method type="BrightData.ITensor4D" name="Clone">
		<summary>Clones the tensor</summary>
			</method>
</interface>
<interface name="BrightData.ITensorDataProvider" base="">
	<summary>
		Provides tensor data
	</summary>
		<method type="System.ReadOnlyMemory&lt;System.Single&gt;" name="GetTensorData">
		<summary>Returns the entire block of tensor data</summary>
			</method>
</interface>
<interface name="BrightData.IVector" base="BrightData.ITensor&lt;BrightData.IVector&gt;">
	<summary>
		Vector interface
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value at the specified index</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value at the specified index</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value at the specified index</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value at the specified index</summary>
	</property>
	<method type="BrightData.IVector" name="MapIndexed">
		<summary>Applies a mapping function that also accepts the vector index</summary>
				<param type="System.Func&lt;System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="MapIndexedInPlace">
		<summary>Applies a mapping function that also accepts the vector index (vector will be modified in place)</summary>
				<param type="System.Func&lt;System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Single[]" name="ToArray">
		<summary>Returns all values in an array</summary>
			</method>
	<method type="BrightData.IVector" name="Clone">
		<summary>Clones the vector</summary>
			</method>
</interface>
<interface name="BrightWire.IVolumeDataSource" base="">
	<summary>
		Volume (3D tensor) based data sources
	</summary>
		<property type="System.UInt32" name="Width">
		<summary>Width of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Height">
		<summary>Height of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>Depth of each input volume</summary>
	</property>
</interface>
<interface name="BrightWire.IWeightedIndexListEncoder" base="">
	<summary>
		Encodes weighted index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the weighted index list to a dense vector</summary>
				<param type="BrightData.Types.WeightedIndexList" name="indexList" summary="" />
			</method>
</interface>
<interface name="BrightWire.IWeightInitialisation" base="">
	<summary>
		Neural network weight initialiser
	</summary>
		<method type="BrightData.IVector" name="CreateBias">
		<summary>Creates the bias vector</summary>
				<param type="System.UInt32" name="size" summary="The size of the vector" />
			</method>
	<method type="BrightData.IMatrix" name="CreateWeight">
		<summary>Creates the weight matrix</summary>
				<param type="System.UInt32" name="rows" summary="Row count" />
				<param type="System.UInt32" name="columns" summary="Column count" />
			</method>
</interface>
<interface name="BrightData.IWriteDataTables" base="">
	<summary>
		Writes tables to a stream
	</summary>
		<method type="System.Threading.Tasks.Task" name="Write">
		<summary>Writes to a stream</summary>
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="buffers" summary="" />
				<param type="System.IO.Stream" name="output" summary="" />
			</method>
</interface>
<interface name="BrightData.IWriteToMetaData" base="">
	<summary>
		Indicates that the type can write values to metadata
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes values to meta data</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="Meta data store" />
			</method>
</interface>

<class name="BrightWire.Models.ConfusionMatrix.ActualClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.And" base="" is-static="true" is-abstract="false">
	<summary>
		Simple AND training data
	</summary>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Get" is-static="true">
		<summary>Generates a data table containing AND training data</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment" base="" is-static="false" is-abstract="false">
	<summary>
		A tensor segment based on a float array
	</summary>
	<method type="System.Void" name="ArrayBasedTensorSegment" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Single[]" name="data" summary="Array of values" />
			</method>
	<method type="System.Int32" name="AddRef" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="Release" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.String" name="SegmentType">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="ToNewArray" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="sourceOffset" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="System.Span&lt;System.Single&gt;" name="destination" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="System.Single*" name="destination" summary="" />
				<param type="System.Int32" name="offset" summary="" />
				<param type="System.Int32" name="stride" summary="" />
				<param type="System.Int32" name="count" summary="" />
			</method>
	<property type="BrightData.IHaveReadOnlyContiguousSpan&lt;System.Single&gt;" name="Contiguous">
		<summary></summary>
	</property>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary></summary>
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="span" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<property type="System.Boolean" name="IsWrapper">
		<summary></summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="System.Void" name="Clear" is-static="false">
		<summary></summary>
			</method>
	<method type="(System.Single[] Array, System.UInt32 Offset, System.UInt32 Stride)" name="GetUnderlyingArray" is-static="false">
		<summary></summary>
			</method>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
</class>
<class name="BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment" base="BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment" is-static="false" is-abstract="false">
	<summary>
		A tensor segment that temporarily owns a buffer from an array pool
	</summary>
	<method type="System.Void" name="ArrayPoolTensorSegment" is-static="false">
		<summary>Constructor</summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;System.Single&gt;" name="data" summary="Rented buffer from pool" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="AddRef" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="Release" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
	<property type="System.String" name="SegmentType">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="ToNewArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary></summary>
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="span" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="sourceOffset" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for node backpropagation
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Dispose</summary>
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphData Signal, BrightWire.IGraphContext Context, BrightWire.ExecutionGraph.Node.NodeBase ToNode)&gt;" name="Backward" is-static="false">
		<summary>Backpropagates the error</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="" />
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A bernoulli naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class[]" name="ClassData">
		<summary>Classification data</summary>
	</property>
	<property type="System.UInt32[]" name="Vocabulary">
		<summary>The list of string indexes that were in the training set</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.BigEndianBinaryReader" base="System.IO.BinaryReader" is-static="false" is-abstract="false">
	<summary>
		Binary reader for big endian streams
	</summary>
	<method type="System.Void" name="BigEndianBinaryReader" is-static="false">
		<summary>Creates a new big endian binary reader</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Int32" name="ReadInt32" is-static="false">
		<summary>Reads an int</summary>
			</method>
	<method type="System.Int16" name="ReadInt16" is-static="false">
		<summary>Reads a short</summary>
			</method>
	<method type="System.Int64" name="ReadInt64" is-static="false">
		<summary>Reads a long</summary>
			</method>
	<method type="System.UInt32" name="ReadUInt32" is-static="false">
		<summary>Reads a ulong</summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept two input signals and output one signal
	</summary>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.BinaryIntegers" base="" is-static="false" is-abstract="false">
	<summary>
		Creates random integers and returns feature vectors against binary mathematical logic
	</summary>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Addition" is-static="true">
		<summary>Creates random integers added together as feature vectors
The input feature contains two features, one for each bit at that position
The output feature contains a single feature: 1 or 0 if that bit is set in the result</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="sampleCount" summary="How many samples to generate" />
			</method>
</class>
<class name="BrightData.BrightDataContext" base="" is-static="false" is-abstract="false">
	<summary>
		Bright data context
	</summary>
	<method type="System.Void" name="BrightDataContext" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider to use (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="Initial value of random seed (or null to randomly initialize)" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Random" name="Random">
		<summary>Default random number generator</summary>
	</property>
	<property type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="System.Func&lt;BrightData.LinearAlgebra.LinearAlgebraProvider&gt;" name="LinearAlgebraProviderFactory">
		<summary>Linear algebra provider factory</summary>
	</property>
	<method type="BrightData.IProvideDataBlocks" name="CreateTempDataBlockProvider" is-static="false">
		<summary>Creates a new temp stream provider</summary>
			</method>
	<method type="T" name="Get" is-static="false">
		<summary>Returns a typed property from the context</summary>
				<param type="System.String" name="name" summary="Property name" />
				<param type="T" name="defaultValue" summary="Value to return if the property was not set" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary>Returns a typed property from the context</summary>
				<param type="System.String" name="name" summary="Property name" />
				<param type="System.Func&lt;T&gt;" name="defaultValueCreator" summary="Callback to return a value if the property was not set" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary>Returns a typed property from the context (or null if the property was not set)</summary>
				<param type="System.String" name="name" summary="Property name" />
			</method>
	<method type="System.Boolean" name="TryGet" is-static="false">
		<summary>Tries to get a typed property from the context</summary>
				<param type="System.String" name="name" summary="Property name" />
				<param type="T" name="ret" summary="The property value (if set)" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary>Sets a typed property in this context</summary>
				<param type="System.String" name="name" summary="Property name" />
				<param type="T" name="value" summary="Property value" />
			</method>
	<method type="System.Void" name="Clear" is-static="false">
		<summary>Removes a typed property from the context</summary>
				<param type="System.String" name="name" summary="Property name" />
			</method>
	<property type="System.Boolean" name="IsStochastic">
		<summary>True if the context does not use a predefined random seed</summary>
	</property>
	<method type="System.Void" name="ResetRandom" is-static="false">
		<summary>Resets the random seed</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="seed" summary="" />
			</method>
	<property type="BrightData.INotifyOperationProgress" name="UserNotifications">
		<summary>Optional interface to provide user notification of long-running operations</summary>
	</property>
</class>
<class name="BrightData.LinearAlgebra.BrightMatrix&lt;LAP&gt;" base="BrightData.LinearAlgebra.BrightTensorBase&lt;BrightData.IMatrix, LAP&gt;" is-static="false" is-abstract="false">
	<summary>
		Row major matrix type
	</summary>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TotalSize">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Row" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Column" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetRowSpan" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetColumnSpan" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetRowAsReadOnly" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetColumnAsReadOnly" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector[]" name="AllRowsAsReadOnly" is-static="false">
		<summary></summary>
				<param type="System.Boolean" name="makeCopy" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector[]" name="AllColumnsAsReadOnly" is-static="false">
		<summary></summary>
				<param type="System.Boolean" name="makeCopy" summary="" />
			</method>
	<method type="BrightData.IVector" name="GetRowVector" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IVector" name="GetColumnVector" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Transpose" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IMatrix" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="other" summary="" />
			</method>
	<method type="BrightData.IVector" name="GetDiagonal" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IVector" name="RowSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IVector" name="ColumnSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IVector" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="TransposeAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="other" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="TransposeThisAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="other" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="MapIndexed" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="MapIndexedInPlace" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="(BrightData.IMatrix Left, BrightData.IMatrix Right)" name="SplitAtColumn" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="(BrightData.IMatrix Top, BrightData.IMatrix Bottom)" name="SplitAtRow" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ConcatBelow" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="bottom" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ConcatRight" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="right" summary="" />
			</method>
	<method type="(BrightData.IMatrix U, BrightData.IVector S, BrightData.IMatrix VT)" name="Svd" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IMatrix" name="GetNewMatrixFromRows" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndices" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="GetNewMatrixFromColumns" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRow" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="MultiplyEachRowWith" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="MultiplyEachColumnWith" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="SoftmaxPerRow" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="SoftmaxDerivativePerRow" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="rows" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IMatrix" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.BrightMatrix" base="BrightData.LinearAlgebra.BrightMatrix&lt;BrightData.LinearAlgebra.LinearAlgebraProvider&gt;" is-static="false" is-abstract="false">
	<summary>
		Matrix type
	</summary>
</class>
<class name="BrightData.LinearAlgebra.BrightTensor3D&lt;LAP&gt;" base="BrightData.LinearAlgebra.BrightTensorBase&lt;BrightData.ITensor3D, LAP&gt;" is-static="false" is-abstract="false">
	<summary>
		Row major 3D tensor
	</summary>
	<method type="System.Void" name="BrightTensor3D" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rows" summary="Rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Columns in each matrix" />
				<param type="LAP" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="BrightData.ITensor3D" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.IReadOnlyMatrix" name="GetMatrixAsReadOnly" is-static="false">
		<summary>Returns a read only matrix</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TotalSize">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<method type="BrightData.IMatrix" name="GetMatrix" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="AddPadding" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="RemovePadding" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Im2Col" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="(BrightData.ITensor3D Result, BrightData.ITensor3D Indices)" name="MaxPool" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="ReverseMaxPool" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor3D" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="ReverseIm2Col" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="AddAllMatrices" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.ITensor3D" name="MultiplyEachMatrixBy" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeAndMultiplyEachMatrixBy" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRow" is-static="false">
		<summary></summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn" is-static="false">
		<summary></summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeThisAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.ITensor3D" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.BrightTensor3D" base="BrightData.LinearAlgebra.BrightTensor3D&lt;BrightData.LinearAlgebra.LinearAlgebraProvider&gt;" is-static="false" is-abstract="false">
	<summary>
		3D tensor
	</summary>
	<method type="System.Void" name="BrightTensor3D" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rows" summary="Rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Columns in each matrix" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.BrightTensor4D&lt;LAP&gt;" base="BrightData.LinearAlgebra.BrightTensorBase&lt;BrightData.ITensor4D, LAP&gt;" is-static="false" is-abstract="false">
	<summary>
		Row major 4D tensor
	</summary>
	<method type="System.Void" name="BrightTensor4D" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in each matrix" />
				<param type="LAP" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="BrightData.ITensor4D" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TensorSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TotalSize">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the 4D tensor</summary>
	</property>
	<property type="System.Single" name="this">
		<summary>Returns a value from the 4D tensor</summary>
	</property>
	<method type="BrightData.ITensor3D" name="GetTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="AddPadding" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="RemovePadding" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="(BrightData.ITensor4D Result, BrightData.ITensor4D Indices)" name="MaxPool" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="ReverseMaxPool" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor4D" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Im2Col" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="ReverseIm2Col" is-static="false">
		<summary></summary>
				<param type="BrightData.IMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IVector" name="ColumnSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IVector" name="RowSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IReadOnlyTensor3D" name="GetTensorAsReadOnly" is-static="false">
		<summary>Returns a read only tensor</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.ITensor4D" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.BrightTensor4D" base="BrightData.LinearAlgebra.BrightTensor4D&lt;BrightData.LinearAlgebra.LinearAlgebraProvider&gt;" is-static="false" is-abstract="false">
	<summary>
		4D tensor
	</summary>
	<method type="System.Void" name="BrightTensor4D" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in each matrix" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.BrightTensorBase&lt;T, LAP&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base tensor type
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T" name="Create" is-static="false">
		<summary>Creates a typed tensor from a tensor segment</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="Tensor segment" />
			</method>
	<property type="System.UInt32" name="TotalSize">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="BrightData.INumericSegment&lt;System.Single&gt;" name="Segment">
		<summary>Underlying tensor segment</summary>
	</property>
	<property type="BrightData.BrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<method type="BrightData.IVector" name="Reshape" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IMatrix" name="Reshape" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Reshape" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="Reshape" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="count" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="" />
			</method>
	<method type="T" name="Map" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="MapInPlace" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="T" name="Clone" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Clear" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Add" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="T" name="Add" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="T" name="Add" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="T" name="Multiply" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="T" name="Subtract" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="T" name="Subtract" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="T" name="PointwiseMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="T" name="PointwiseDivide" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="System.Single" name="DotProduct" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="T" name="Sqrt" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="ConstrainInPlace" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;System.Single&gt;" name="maxValue" summary="" />
			</method>
	<method type="System.Single" name="Average" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="L1Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="L2Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Reverse" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Split" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="System.Single" name="CosineDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="other" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="other" summary="" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="other" summary="" />
			</method>
	<method type="System.Single" name="SquaredEuclideanDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="other" summary="" />
			</method>
	<method type="System.Single" name="ManhattanDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor" name="other" summary="" />
			</method>
	<method type="T" name="Abs" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Log" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Exp" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Squared" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="StdDev" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="" />
			</method>
	<method type="T" name="Sigmoid" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="SigmoidDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Tanh" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="TanhDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Relu" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="ReluDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="LeakyRelu" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="LeakyReluDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Softmax" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IMatrix" name="SoftmaxDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="Pow" is-static="false">
		<summary></summary>
				<param type="System.Single" name="power" summary="" />
			</method>
	<method type="System.Void" name="RoundInPlace" is-static="false">
		<summary></summary>
				<param type="System.Single" name="lower" summary="" />
				<param type="System.Single" name="upper" summary="" />
			</method>
	<method type="T" name="CherryPick" is-static="false">
		<summary></summary>
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
	<method type="System.Void" name="L1RegularisationInPlace" is-static="false">
		<summary></summary>
				<param type="System.Single" name="coefficient" summary="" />
			</method>
	<method type="System.Single" name="Sum" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="ReadOnlySegment">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsReadOnly">
		<summary></summary>
	</property>
</class>
<class name="BrightData.LinearAlgebra.BrightVector&lt;LAP&gt;" base="BrightData.LinearAlgebra.BrightTensorBase&lt;BrightData.IVector, LAP&gt;" is-static="false" is-abstract="false">
	<summary>
		Vector
	</summary>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TotalSize">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="ToArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IVector" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.IVector" name="MapIndexed" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="MapIndexedInPlace" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="BrightData.IVector" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.BrightVector" base="BrightData.LinearAlgebra.BrightVector&lt;BrightData.LinearAlgebra.LinearAlgebraProvider&gt;" is-static="false" is-abstract="false">
	<summary>
		Vector
	</summary>
	<method type="System.Void" name="BrightVector" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability" base="" is-static="false" is-abstract="false">
	<summary>
		A category and its associated log probability
	</summary>
	<property type="System.String" name="Category">
		<summary>The category label</summary>
	</property>
	<property type="System.Double" name="LogProbability">
		<summary>The natural log of the category's probability</summary>
	</property>
	<property type="System.Double" name="Probability">
		<summary>The category's probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		A classification
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The log of the prior probability for this classification</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The log of the missing probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of probabilities for each string index</summary>
	</property>
	<property type="System.Double" name="InverseMissingProbability">
		<summary>The log of the inverse missing probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		Classification data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification's prior log probability</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The classifications missing log probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of string indexes and their probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary" base="" is-static="false" is-abstract="false">
	<summary>
		A classification and its associated data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="LogPrior">
		<summary>The natural log of the prior</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.Column[]" name="ColumnSummary">
		<summary>The column data associated with this classification</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification prior probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.Column" base="" is-static="false" is-abstract="false">
	<summary>
		A column within the naive bayes model
	</summary>
	<property type="System.UInt32" name="ColumnIndex">
		<summary>Index within the data set</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>Type of column (categorical or continuous)</summary>
	</property>
	<property type="System.Double" name="Variance">
		<summary>The variance of the column values (continuous only)</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>The mean of the column values (continuous only)</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability[]" name="Probability">
		<summary>The list of categories within the column and their probability (categorical only)</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.DataTable.Columns.ColumnTypeClassifier" base="" is-static="true" is-abstract="false">
	<summary>
		Classifies data table column types
	</summary>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary>Checks for a decimal type (floating point)</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary>Checks for a numeric type (floating point or integer)</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary>Checks for a continuous type (non-categorical)</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary>Checks for a categorical type (non-continuous)</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="Column type to check" />
			</method>
	<method type="System.Boolean" name="IsBlittable" is-static="true">
		<summary>Checks if the type has an independent memory layout across managed and unmanaged code</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="Column type to check" />
			</method>
	<method type="BrightData.ColumnClass" name="GetClass" is-static="true">
		<summary>Returns the set of possible column classifications</summary>
				<param type="BrightData.BrightDataType" name="type" summary="Column type to check" />
				<param type="BrightData.Types.MetaData" name="metaData" summary="Column metadata" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" base="" is-static="false" is-abstract="false">
	<summary>
		Decision tree configuration
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="FeatureBagCount">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MinDataPerNode">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MaxDepth">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="MinInformationGain">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxAttributes">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.ConfusionMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.String[]" name="ClassificationLabels">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ExpectedClassification[]" name="Classifications">
		<summary></summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="GetCount" is-static="false">
		<summary>Returns the count of the expected vs actual classifications</summary>
				<param type="System.String" name="expected" summary="Expected classification label" />
				<param type="System.String" name="actual" summary="Actual classification label" />
			</method>
</class>
<class name="BrightData.Helper.ConsoleProgressNotification" base="" is-static="false" is-abstract="false">
	<summary>
		Writes progress notifications to the console
	</summary>
	<method type="System.Void" name="OnStartOperation" is-static="false">
		<summary></summary>
				<param type="System.Guid" name="operationId" summary="" />
				<param type="System.String" name="msg" summary="" />
			</method>
	<method type="System.Void" name="OnOperationProgress" is-static="false">
		<summary></summary>
				<param type="System.Guid" name="operationId" summary="" />
				<param type="System.Single" name="progressPercent" summary="" />
			</method>
	<method type="System.Void" name="OnCompleteOperation" is-static="false">
		<summary></summary>
				<param type="System.Guid" name="operationId" summary="" />
				<param type="System.Boolean" name="wasCancelled" summary="" />
			</method>
	<method type="System.Void" name="OnMessage" is-static="false">
		<summary></summary>
				<param type="System.String" name="msg" summary="" />
			</method>
	<method type="System.Boolean" name="WriteProgress" is-static="true">
		<summary>Writes a progress bar to the console</summary>
				<param type="System.Int32" name="newProgress" summary="New progress" />
				<param type="System.Int32" name="oldProgress" summary="Current progress" />
				<param type="System.Int32" name="max" summary="Max progress amount (default 100)" />
			</method>
	<method type="System.Boolean" name="WriteProgress" is-static="true">
		<summary>Writes a progress bar to the console</summary>
				<param type="System.Single" name="progress" summary="New progress (between 0 and 1)" />
				<param type="System.Int32" name="previousPercentage" summary="Current progress percentage (max 100)" />
				<param type="System.Diagnostics.Stopwatch" name="sw" summary="Stopwatch since start of operation" />
			</method>
</class>
<class name="BrightData.Consts" base="" is-static="false" is-abstract="false">
	<summary>
		Constants
	</summary>
</class>
<class name="BrightData.Helper.ConvolutionHelper" base="" is-static="true" is-abstract="false">
	<summary>
		Helper class to calculate convolutional indices
	</summary>
	<method type="System.Collections.Generic.List&lt;(System.UInt32 X, System.UInt32 Y)&gt;" name="LeftToRight" is-static="true">
		<summary>Generates convolution indices from left to right</summary>
				<param type="System.UInt32" name="width" summary="Input width" />
				<param type="System.UInt32" name="height" summary="Input height" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="X Stride" />
				<param type="System.UInt32" name="yStride" summary="Y Stride" />
			</method>
	<method type="System.Collections.Generic.List&lt;(System.UInt32 X, System.UInt32 Y)&gt;" name="TopToBottom" is-static="true">
		<summary>Generates convolution indices from top to bottom</summary>
				<param type="System.UInt32" name="width" summary="Input width" />
				<param type="System.UInt32" name="height" summary="Input height" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="X Stride" />
				<param type="System.UInt32" name="yStride" summary="Y Stride" />
			</method>
</class>
<class name="BrightData.Helper.CsvParser" base="" is-static="false" is-abstract="false">
	<summary>
		Simple CSV parser
	</summary>
	<method type="System.Void" name="CsvParser" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Boolean" name="firstRowIsHeader" summary="True if the first row is a header" />
				<param type="System.Char" name="delimiter" summary="Column delimiter character" />
				<param type="System.Char" name="quote" summary="Quote character" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="Temp stream provider (optional)" />
				<param type="System.Int32" name="blockSize" summary="Block size in bytes" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="Max number of blocks to keep in memory" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="Max number of distinct items to track" />
			</method>
	<property type="System.Action&lt;System.Single&gt;" name="OnProgress">
		<summary>Progress notification</summary>
	</property>
	<property type="System.Action" name="OnComplete">
		<summary>Completion notification</summary>
	</property>
	<method type="System.Threading.Tasks.Task&lt;System.Collections.Generic.List&lt;BrightData.ICompositeBuffer&lt;System.String&gt;&gt;&gt;" name="Parse" is-static="false">
		<summary>Parses CSV from a stream reader</summary>
				<param type="System.IO.StreamReader" name="reader" summary="Stream reader" />
				<param type="System.UInt32" name="maxLines" summary="Max number of lines to read" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;BrightData.ICompositeBuffer&lt;System.String&gt;&gt;" name="Parse" is-static="false">
		<summary>Parses CSV from a string</summary>
				<param type="System.String" name="str" summary="String to parse" />
				<param type="System.UInt32" name="maxLines" summary="Max number of lines to read" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
</class>
<class name="BrightData.Helper.DataEncoder" base="" is-static="false" is-abstract="false">
	<summary>
		Encodes types from/to bytes
	</summary>
	<method type="T" name="Read" is-static="false">
		<summary>Generic method to read from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Source" />
			</method>
	<method type="T[]" name="ReadArray" is-static="false">
		<summary>Generic method to read an array from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Source" />
			</method>
	<method type="System.Void" name="Write" is-static="true">
		<summary>Generic method to write to binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Destination" />
				<param type="T" name="val" summary="Item to write" />
			</method>
	<method type="System.Void" name="Write" is-static="true">
		<summary>Generic method to write an array to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Destination" />
				<param type="T[]" name="values" summary="Array to write" />
			</method>
</class>
<class name="BrightWire.Models.DataSourceModel" base="" is-static="false" is-abstract="false">
	<summary>
		Serialises an adaptive data source - that is, a data source that takes the output from a preliminary output graph and sends it to the primary graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the data source</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>The size of each input training data item</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>The size of each training item output (classification label)</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>The preliminary graph</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for data table based data adapters
	</summary>
	<property type="System.UInt32" name="InputSize">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get" is-static="false">
		<summary></summary>
				<param type="System.UInt32[]" name="rows" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith" is-static="false">
		<summary></summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<property type="BrightData.DataTable.VectorisationModel" name="InputVectoriser">
		<summary></summary>
	</property>
	<property type="BrightData.DataTable.VectorisationModel" name="OutputVectoriser">
		<summary></summary>
	</property>
	<method type="System.UInt32[][]" name="GetSequentialBatches" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.DataTableBuilder" base="" is-static="true" is-abstract="false">
	<summary>
		Creates standard data table builders
	</summary>
	<method type="BrightData.IBuildDataTables" name="CreateTwoColumnMatrixTableBuilder" is-static="true">
		<summary>Creates a data table builder with one feature matrix column and one target matrix column</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputRows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputColumns" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputRows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputColumns" summary="" />
			</method>
	<method type="BrightData.IBuildDataTables" name="CreateTwoColumnVectorTableBuilder" is-static="true">
		<summary>Creates a data table builder with one feature vector column and one target vector column</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputSize" summary="Size of the input vector" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputSize" summary="Size of the output vector" />
			</method>
	<method type="BrightData.IBuildDataTables" name="Create3DTensorToVectorTableBuilder" is-static="true">
		<summary>Creates a data table builder with one feature tensor 3D columns and one target vector column</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputDepth" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputRows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="inputColumns" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="outputSize" summary="Size of the output vector" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DateAnalysis" base="BrightData.Analysis.Readers.FrequencyAnalysis" is-static="false" is-abstract="false">
	<summary>
		Date analysis results
	</summary>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MinDate">
		<summary>Minimum date (null if none)</summary>
	</property>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MaxDate">
		<summary>Maximum date (null if none)</summary>
	</property>
</class>
<class name="BrightWire.Models.TreeBased.DecisionTree" base="" is-static="false" is-abstract="false">
	<summary>
		A decision tree model
	</summary>
	<property type="System.UInt32" name="ClassColumnIndex">
		<summary>The classification label column index</summary>
	</property>
	<property type="BrightWire.Models.TreeBased.DecisionTree.Node" name="Root">
		<summary>The root of the tree</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Converts the tree to XML</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer" base="" is-static="true" is-abstract="false">
	<summary>
		Decision tree classifier
https://en.wikipedia.org/wiki/Decision_tree_learning
	</summary>
	<method type="BrightWire.Models.TreeBased.DecisionTree" name="Train" is-static="true">
		<summary>Trains a decision tree</summary>
				<param type="BrightData.IDataTable" name="table" summary="Training data" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="Decision tree configuration" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DictionaryValues" base="" is-static="false" is-abstract="false">
	<summary>
		Dictionary that holds category string indices
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetValues" is-static="false">
		<summary>Converts from category indices to string</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" name="categoryIndices" summary="" />
			</method>
	<method type="System.String" name="GetValue" is-static="false">
		<summary>Gets the string associated with a category index</summary>
				<param type="System.Int32" name="categoryIndex" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DimensionAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Dimension analysis results
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="XDimension">
		<summary>Max size of the x dimension</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="YDimension">
		<summary>Max size of the y dimension</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ZDimension">
		<summary>Max size of the z dimension</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct size combinations</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Total size across all dimensions</summary>
	</property>
</class>
<class name="BrightData.Helper.DoubleMath" base="" is-static="true" is-abstract="false">
	<summary>
		Helpers for double based math
	</summary>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary>True if the numbers are approximately equal</summary>
				<param type="System.Double" name="value1" summary="First value to compare" />
				<param type="System.Double" name="value2" summary="Second value to compare" />
				<param type="System.Double" name="tolerance" summary="How close to compare" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary>True if the numbers are approximately equal</summary>
				<param type="System.Nullable&lt;System.Double&gt;" name="value1" summary="First value to compare" />
				<param type="System.Nullable&lt;System.Double&gt;" name="value2" summary="Second value to compare" />
				<param type="System.Double" name="tolerance" summary="How close to compare" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Error metrics
	</summary>
	<property type="BrightWire.IErrorMetric" name="BinaryClassification">
		<summary>Binary classification error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="CrossEntropy">
		<summary>Cross entropy error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="OneHotEncoding">
		<summary>One hot encoding error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="Quadratic">
		<summary>Quadratic error metric</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised execution graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Node" name="InputNode">
		<summary>The primary input node</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Node[]" name="OtherNodes">
		<summary>Other connected nodes</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Wire[]" name="Wires">
		<summary>A list of the wires that connect the nodes in the graph</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="VisitNodes" is-static="false">
		<summary>Visits each node in the graph</summary>
				<param type="T" name="param" summary="" />
				<param type="System.Action&lt;T, BrightWire.Models.ExecutionGraphModel.Node, System.UInt32&gt;" name="onEnter" summary="" />
				<param type="System.Action&lt;T, BrightWire.Models.ExecutionGraphModel.Node&gt;" name="onLeave" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>XML representation of the graph</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.ExecutionHistory" base="" is-static="false" is-abstract="false">
	<summary>
		Record of graph execution
	</summary>
	<method type="System.Void" name="ExecutionHistory" is-static="false">
		<summary>Creates a training action history from a single optional parent</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="The node that executed" />
				<param type="BrightWire.IGraphData" name="data" summary="The output of the node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="parent" summary="The single parent that contributed to the output (optional)" />
			</method>
	<method type="System.Void" name="ExecutionHistory" is-static="false">
		<summary>Creates a training action history from multiple parents</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="The node that executed" />
				<param type="BrightWire.IGraphData" name="data" summary="The output of the node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="The parent nodes that contributed to the output" />
			</method>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="Source">
		<summary>Node that was executed</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Node output signal</summary>
	</property>
	<property type="BrightWire.IBackpropagate" name="Backpropagation">
		<summary>Optional backpropagation</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="Parents">
		<summary>The node's ancestors</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.ExecutionResult" base="" is-static="false" is-abstract="false">
	<summary>
		The output from a mini batch
	</summary>
	<method type="System.Void" name="ExecutionResult" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.IMiniBatchSequence" name="miniBatch" summary="The mini batch sequence" />
				<param type="BrightData.IMatrix" name="output" summary="The mini batch output" />
				<param type="System.Boolean" name="wantInputInExecutionResults" summary="True to save graph inputs in the execution results" />
			</method>
	<property type="BrightData.IReadOnlyVector[]" name="Output">
		<summary>The list of output rows</summary>
	</property>
	<property type="BrightData.IReadOnlyVector[]" name="Target">
		<summary>The list of target rows</summary>
	</property>
	<property type="BrightData.IReadOnlyVector[]" name="Input">
		<summary>The list of input rows</summary>
	</property>
	<property type="BrightData.IReadOnlyVector[]" name="Error">
		<summary>Optional list of errors</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="MiniBatchSequence">
		<summary>The mini batch</summary>
	</property>
	<method type="System.Single" name="CalculateError" is-static="false">
		<summary>Calculates the error of the output against the target</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="The error metric to calculate with" />
			</method>
</class>
<class name="BrightWire.Models.ConfusionMatrix.ExpectedClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ActualClassification[]" name="ActualClassifications">
		<summary></summary>
	</property>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Extension methods to attach analyser creation to the bright data context
	</summary>
	<method type="BrightData.Analysis.Readers.DateAnalysis" name="GetDateAnalysis" is-static="true">
		<summary>Gets the date analysis that was stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.DimensionAnalysis" name="GetDimensionAnalysis" is-static="true">
		<summary>Gets the dimension analysis that was stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.FrequencyAnalysis" name="GetFrequencyAnalysis" is-static="true">
		<summary>Gets the frequency analysis that was stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.IndexAnalysis" name="GetIndexAnalysis" is-static="true">
		<summary>Gets the index analysis that was stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.NumericAnalysis" name="GetNumericAnalysis" is-static="true">
		<summary>Gets the numeric analysis that was stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.StringAnalysis" name="GetStringAnalysis" is-static="true">
		<summary>Gets the string analysis that was stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.Readers.DictionaryValues" name="GetDictionaryValues" is-static="true">
		<summary>Gets the categories that were stored in metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.NormalisationModel" name="GetNormalization" is-static="true">
		<summary>Returns a normalization that was previously stored in the metadata</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Meta data store" />
			</method>
	<method type="BrightData.Analysis.NormalisationModel" name="GetColumnNormalization" is-static="true">
		<summary>Returns the normalization that was applied to the specified data table column</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="Column index to retrieve" />
			</method>
	<method type="BrightData.Analysis.Readers.NumericAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes numbers in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DateAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes dates in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.DateTime&gt;" name="dates" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DimensionAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes tensors in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IReadOnlyTensor&gt;" name="tensors" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.IndexAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes indices in a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IHaveIndices&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.StringAnalysis" name="Analyze" is-static="true">
		<summary>Analyzes a sequence of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.FrequencyAnalysis" name="AnalyzeFrequency" is-static="true">
		<summary>Analyzes the frequency of items</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="GetValues" is-static="true">
		<summary>Enumerates values in the buffer (blocking)</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;T&gt;" name="GetValues" is-static="true">
		<summary>Async enumeration of values in the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;System.String&gt;" name="ToReadOnlyStringBuffer" is-static="true">
		<summary>Casts or converts the buffer to a string buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;TT&gt;" name="Convert" is-static="true">
		<summary>Creates a new buffer in which each value is converted via the conversion function</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;FT&gt;" name="buffer" summary="" />
				<param type="System.Func&lt;FT, TT&gt;" name="converter" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.Collections.Generic.Dictionary&lt;System.String, System.Collections.Generic.List&lt;System.UInt32&gt;&gt;&gt;" name="GetGroups" is-static="true">
		<summary>Finds distinct groups within the buffers based on string comparison of the concatenated values</summary>
				<param type="BrightData.IReadOnlyBuffer[]" name="buffers" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.Buffers.ReadOnlySequence&lt;T&gt;&gt;" name="AsReadOnlySequence" is-static="true">
		<summary>Converts the buffer to a read only sequence</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T&gt;" name="GetItem" is-static="true">
		<summary>Retrieves an item from the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="buffer" summary="" />
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T[]&gt;" name="GetItems" is-static="true">
		<summary>Retrieves items from the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="buffer" summary="" />
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
	<method type="BrightData.ExtensionMethods.ReadOnlyBufferIterator&lt;T&gt;" name="GetEnumerator" is-static="true">
		<summary>Creates an iterator for the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T[]&gt;" name="ToArray" is-static="true">
		<summary>Converts the buffer to an array</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="buffer" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;System.String&gt;" name="CreateCompositeBuffer" is-static="true">
		<summary>Creates a composite buffer for strings</summary>
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;T&gt;" name="CreateCompositeBuffer" is-static="true">
		<summary>Creates a composite buffer for types that can be created from a block of byte data</summary>
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="BrightData.CreateFromReadOnlyByteSpan&lt;T&gt;" name="createItem" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer&lt;T&gt;" name="CreateCompositeBuffer" is-static="true">
		<summary>Creates a composite buffer for unmanaged types</summary>
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer" name="CreateCompositeBuffer" is-static="true">
		<summary>Creates a composite buffer</summary>
				<param type="BrightData.BrightDataType" name="dataType" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Buffers.IBufferWriter&lt;T&gt;" name="AsBufferWriter" is-static="true">
		<summary>Creates a buffer writer from a composite buffer</summary>
				<param type="BrightData.ICompositeBuffer&lt;T&gt;" name="buffer" summary="" />
				<param type="System.Int32" name="bufferSize" summary="" />
			</method>
	<method type="System.Boolean" name="CanEncode" is-static="true">
		<summary>Returns true of the buffer can be encoded (distinct items mapped to indices)</summary>
				<param type="BrightData.ICompositeBuffer&lt;T&gt;" name="buffer" summary="" />
			</method>
	<method type="(T[] Table, BrightData.ICompositeBuffer&lt;System.UInt32&gt; Data)" name="Encode" is-static="true">
		<summary>Encoding a composite buffer maps each item to an index and returns both the mapping table and a new composite buffer of the indices</summary>
				<param type="BrightData.ICompositeBuffer&lt;T&gt;" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
			</method>
	<method type="BrightData.ICompositeBuffer" name="CreateCompositeBuffer" is-static="true">
		<summary>Creates a composite buffer for the type</summary>
				<param type="System.Type" name="type" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser" name="GetAnalyser" is-static="true">
		<summary>Creates a column analyser</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="Buffer to analyse" />
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="System.UInt32" name="maxMetaDataWriteCount" summary="Maximum count to write to meta data" />
			</method>
	<method type="BrightData.IOperation" name="Analyse" is-static="true">
		<summary>Analyses the buffer</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="force" summary="" />
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
			</method>
	<method type="BrightData.IOperation" name="CreateBufferCopyOperation" is-static="true">
		<summary>Creates an operation that copies the blocks in the buffer to a destination</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IAppendBlocks" name="output" summary="" />
				<param type="System.Action" name="action" summary="" />
			</method>
	<method type="BrightData.IOperation" name="Analyse" is-static="true">
		<summary>Analyse the buffer</summary>
				<param type="BrightData.IReadOnlyBufferWithMetaData" name="buffer" summary="" />
				<param type="System.Boolean" name="force" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&gt;" name="ToNumeric" is-static="true">
		<summary>Creates a numeric composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;System.Boolean&gt;&gt;" name="ToBoolean" is-static="true">
		<summary>Creates a boolean composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;System.String&gt;&gt;" name="ToString" is-static="true">
		<summary>Creates a string composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;System.DateTime&gt;&gt;" name="ToDateTime" is-static="true">
		<summary>Creates a date time composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;System.DateOnly&gt;&gt;" name="ToDate" is-static="true">
		<summary>Creates a date composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;System.TimeOnly&gt;&gt;" name="ToTime" is-static="true">
		<summary>Creates a time composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;System.Int32&gt;&gt;" name="ToCategoricalIndex" is-static="true">
		<summary>Creates a categorical index composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;BrightData.Types.IndexList&gt;&gt;" name="ToIndexList" is-static="true">
		<summary>Creates an index list composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector&gt;&gt;" name="ToVector" is-static="true">
		<summary>Creates a vector composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;BrightData.Types.WeightedIndexList&gt;&gt;" name="ToWeightedIndexList" is-static="true">
		<summary>Creates a weighted index list composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;T&gt;&gt;" name="To" is-static="true">
		<summary>Creates a typed composite buffer from an existing buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICompositeBuffer&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector&gt;&gt;" name="Vectorise" is-static="true">
		<summary>Vectorise the buffers</summary>
				<param type="BrightData.IReadOnlyBuffer[]" name="buffers" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T[]&gt;" name="ToArray" is-static="true">
		<summary>Creates an array from the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;System.String&gt;" name="GetReadOnlyStringCompositeBuffer" is-static="true">
		<summary>Creates a read only string composite buffer from a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="GetReadOnlyCompositeBuffer" is-static="true">
		<summary>Creates a read only composite buffer for unmanaged types from a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="GetReadOnlyCompositeBuffer" is-static="true">
		<summary>Creates a read only composite buffer for types that can be initialised from a byte block from a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="BrightData.CreateFromReadOnlyByteSpan&lt;T&gt;" name="createItem" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;TT&gt;" name="Cast" is-static="true">
		<summary>Casts a buffer to another type</summary>
				<param type="BrightData.IReadOnlyBuffer&lt;FT&gt;" name="buffer" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="ToType" is-static="true">
		<summary>Converts a type code to a type</summary>
				<param type="System.TypeCode" name="code" summary="Type code" />
			</method>
	<method type="System.Boolean" name="SetIfNotNull" is-static="true">
		<summary>Sets a value only if the value is not null</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="SetIfNotNull" is-static="true">
		<summary>Sets a value only if the value is not null</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="HasConversionOperator" is-static="true">
		<summary>Checks if one type can be implicitly cast to another</summary>
				<param type="System.Type" name="from" summary="" />
				<param type="System.Type" name="to" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Shuffle" is-static="true">
		<summary>Randomly shuffles the items in the sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="seq" summary="" />
				<param type="System.Random" name="rnd" summary="Random number generator to use" />
			</method>
	<method type="(T[] Training, T[] Test)" name="Split" is-static="true">
		<summary>Randomly splits the sequence into two arrays (either "training" or "test")</summary>
				<param type="T[]" name="seq" summary="" />
				<param type="System.Double" name="trainPercentage" summary="Percentage of items to add to the training array" />
			</method>
	<method type="T[]" name="Bag" is-static="true">
		<summary>Sample with replacement</summary>
				<param type="T[]" name="list" summary="" />
				<param type="System.UInt32" name="count" summary="Number of samples" />
				<param type="System.Random" name="rnd" summary="Random number generator to use" />
			</method>
	<method type="System.String" name="GetName" is-static="true">
		<summary>Item name</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
				<param type="System.String" name="defaultName" summary="Name to use if no name was set" />
			</method>
	<method type="System.UInt32" name="GetColumnIndex" is-static="true">
		<summary>Item index</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary>True if the item is numeric</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsTarget" is-static="true">
		<summary>True if the item is a target</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary>True if the item is categorical</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsSequential" is-static="true">
		<summary>True if the item is sequential</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="BrightData.Types.MetaData" name="GetMetaData" is-static="true">
		<summary>Writes available meta data to a new meta data store</summary>
				<param type="BrightData.IWriteToMetaData" name="writer" summary="" />
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Single&gt;" name="GetFloatConverter" is-static="true">
		<summary>Lazy create a float converter per context</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.UInt32" name="count" summary="Upper bound" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.Int32" name="count" summary="Upper bound" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.UInt32" name="start" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary>Generates a range of positive integers</summary>
				<param type="System.Int32" name="count" summary="" />
				<param type="System.Int32" name="start" summary="" />
			</method>
	<method type="System.Single" name="Aggregate" is-static="true">
		<summary>Aggregates a list of floats</summary>
				<param type="BrightData.AggregationType" name="operation" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="data" summary="Data to aggregate" />
			</method>
	<method type="BrightData.Types.MetaData" name="SetTarget" is-static="true">
		<summary>Sets this as a target</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="isTarget" summary="" />
			</method>
	<method type="BrightData.Types.MetaData" name="SetIsCategorical" is-static="true">
		<summary>Sets this as categorical</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="isCategorical" summary="" />
			</method>
	<method type="BrightData.Types.MetaData" name="SetName" is-static="true">
		<summary>Sets the name</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="System.String" name="name" summary="Name" />
			</method>
	<method type="System.String" name="GetFilePath" is-static="true">
		<summary>Returns the file path associated with the metadata (if any)</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(T Item, System.UInt32 Count)&gt;" name="GroupAndCount" is-static="true">
		<summary>Groups items and counts each group</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
	<method type="System.String" name="Format" is-static="true">
		<summary>Formats groups of items</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(T Item, System.UInt32 Count)&gt;" name="items" summary="" />
				<param type="System.Char" name="separator" summary="Group separator" />
			</method>
	<method type="System.Void" name="UseLegacySerializationInput" is-static="true">
		<summary>Enables or disables legacy (version 2) binary serialization - only when reading</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Boolean" name="use" summary="True to enable" />
			</method>
	<method type="BrightData.Helper.DataEncoder" name="GetDataEncoder" is-static="true">
		<summary>Creates a data encoder</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Byte[]" name="GetData" is-static="true">
		<summary>Converts the object to a serialized buffer</summary>
				<param type="BrightData.ICanWriteToBinaryWriter" name="writable" summary="" />
			</method>
	<method type="System.Void" name="NotifyProgress" is-static="true">
		<summary>Notifies about the progress of a multipart operation</summary>
				<param type="BrightData.INotifyOperationProgress" name="notify" summary="" />
				<param type="System.Guid" name="operationId" summary="Unique operation id" />
				<param type="System.UInt32" name="index" summary="Index of current part" />
				<param type="System.UInt32" name="total" summary="Total number of parts" />
				<param type="System.Single" name="progress" summary="Process within the part" />
			</method>
	<method type="System.Boolean" name="WriteProgressPercentage" is-static="true">
		<summary>Writes a progress bar to the console</summary>
				<param type="System.Single" name="progress" summary="New progress (between 0 and 1)" />
				<param type="System.Int32" name="previousPercentage" summary="Current progress percentage (max 100)" />
				<param type="System.Diagnostics.Stopwatch" name="sw" summary="Stopwatch since start of operation" />
			</method>
	<method type="System.String" name="AsCommaSeparated" is-static="true">
		<summary>Writes the enumerable to a comma separated string</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="Items to write" />
			</method>
	<method type="T[]" name="ReadArray" is-static="true">
		<summary>Reads an array of T from the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="System.UInt32" name="size" summary="Number of items to read" />
			</method>
	<method type="T[]" name="ReadArray" is-static="true">
		<summary>Reads an array of T from the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="System.Int32" name="size" summary="Number of items to read" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Collections.Immutable.ImmutableList&lt;T&gt;&gt;" name="FindPermutations" is-static="true">
		<summary>Finds all possible permutations of sub items from the array, including the array itself</summary>
				<param type="T[]" name="items" summary="Array to permute" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(T First, T Second)&gt;" name="FindAllPairs" is-static="true">
		<summary>Enumerates all unique pairs of items within the array
[1, 2, 3] => [1,2], [1,3], [2,3]</summary>
				<param type="T[]" name="items" summary="" />
			</method>
	<method type="System.Collections.Generic.Dictionary&lt;System.String, System.Reflection.MethodInfo&gt;" name="GetGenericMethods" is-static="true">
		<summary>Builds a table of the generic methods from a type</summary>
				<param type="System.Type" name="type" summary="Type to inspect" />
				<param type="System.Reflection.BindingFlags" name="bindingFlags" summary="Method flags" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Enumerate" is-static="true">
		<summary>Enumerates a stream as a series of structs. This is best for small structs such as int32 etc. as the values are not passed by reference.</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.UInt32" name="count" summary="Total count to return" />
				<param type="System.Int32" name="tempBufferSize" summary="Size of temp buffer to use" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes unmanaged items to a stream as a byte array</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="Unmanaged items to write" />
				<param type="System.IO.Stream" name="stream" summary="Destination stream" />
				<param type="System.Int32" name="tempBufferSize" summary="Size of buffer" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 First, System.UInt32 Last)&gt;" name="FindDistinctContiguousRanges" is-static="true">
		<summary>Finds the unique ranges of indices within a sequence</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="" />
			</method>
	<method type="BrightData.IBuildDataTables" name="CreateTableBuilder" is-static="true">
		<summary>Creates a new table builder</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Void" name="DisposeAll" is-static="true">
		<summary>Disposes a collection of disposables</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.IDisposable&gt;" name="disposables" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="ToEnumerable" is-static="true">
		<summary>Converts a single object into an enumerator that will enumerate that object once</summary>
				<param type="T" name="obj" summary="Item to enumerate (once)" />
			</method>
	<method type="System.Single[]" name="ToArray" is-static="true">
		<summary>Extracts an array of floats</summary>
				<param type="BrightData.IHaveSpanOf&lt;System.Single&gt;" name="spanOwner" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="true">
		<summary>Copies tensor values to another tensor</summary>
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="source" summary="Copy from" />
				<param type="BrightData.IHaveTensorSegment&lt;System.Single&gt;" name="target" summary="Copy to" />
			</method>
	<method type="System.DateTime" name="ToDateTime" is-static="true">
		<summary>Attempts to parse a string into a date</summary>
				<param type="System.String" name="str" summary="String that contains a valid date" />
			</method>
	<method type="System.ReadOnlyMemory&lt;System.Object&gt;" name="AsObjects" is-static="true">
		<summary>Re references each item in the memory as an object</summary>
				<param type="System.ReadOnlyMemory&lt;T&gt;" name="block" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="ExecuteAllAsOne" is-static="true">
		<summary>Executes multiple operations as one</summary>
				<param type="BrightData.IOperation[]" name="operations" summary="" />
				<param type="BrightData.INotifyOperationProgress" name="notify" summary="" />
				<param type="System.String" name="msg" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="T[]" name="CompleteInParallel" is-static="true">
		<summary>Returns the results from a collection of operations that might be run in parallel</summary>
				<param type="BrightData.IOperation&lt;T&gt;[]" name="operations" summary="" />
			</method>
	<method type="T[]" name="CompleteInParallel" is-static="true">
		<summary>Returns the results from a collection of operations that might be run in parallel</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IOperation&lt;T&gt;&gt;" name="operations" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.ReadOnlyMemory&lt;T&gt;&gt;" name="ToMemory" is-static="true">
		<summary>Writes the async enumerable to a memory block</summary>
				<param type="System.Collections.Generic.IAsyncEnumerable&lt;T&gt;" name="enumerable" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T[]&gt;" name="ToArray" is-static="true">
		<summary>Writes items from an async enumerable to an array</summary>
				<param type="System.Collections.Generic.IAsyncEnumerable&lt;T&gt;" name="enumerable" summary="" />
				<param type="System.UInt32" name="size" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.Collections.Generic.List&lt;System.Single[]&gt;&gt;" name="ToFloatVectors" is-static="true">
		<summary>Converts an async enumerable of multidimensional arrays to a list of float arrays</summary>
				<param type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="vectorData" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IReadOnlyBufferWithMetaData&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector&gt;&gt;" name="ToVectors" is-static="true">
		<summary>Converts an async enumerable of multidimensional arrays to a buffer of vectors</summary>
				<param type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="vectorData" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IReadOnlyBufferWithMetaData&lt;BrightData.Types.IndexList&gt;&gt;" name="ToIndexLists" is-static="true">
		<summary>Converts an async enumerable of multidimensional arrays to a buffer of index lists</summary>
				<param type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="vectorData" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IReadOnlyBufferWithMetaData&lt;BrightData.Types.WeightedIndexList&gt;&gt;" name="ToWeightedIndexLists" is-static="true">
		<summary>Converts an async enumerable of multidimensional arrays to a buffer of weighted index lists</summary>
				<param type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="vectorData" summary="" />
			</method>
	<method type="BrightData.IByteBlockSource" name="AsDataBlock" is-static="true">
		<summary>Creates a byte block source from a stream</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="System.Nullable&lt;System.Guid&gt;" name="id" summary="" />
			</method>
	<method type="BrightData.IClusteringStrategy" name="NewHierachicalClustering" is-static="true">
		<summary>Creates a hierarchical clustering strategy</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
			</method>
	<method type="BrightData.IClusteringStrategy" name="NewKMeansClustering" is-static="true">
		<summary>Creates a k means clustering strategy</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="maxIterations" summary="" />
			</method>
	<method type="System.UInt32[][]" name="HierarchicalCluster" is-static="true">
		<summary>Hierarchical clustering successively finds the closest distance between pairs of centroids until k is reached</summary>
				<param type="BrightData.IReadOnlyVector[]" name="data" summary="The list of vectors to cluster" />
				<param type="System.UInt32" name="k" summary="The number of clusters to find" />
				<param type="BrightData.DistanceMetric" name="metric" summary="" />
			</method>
	<method type="System.UInt32[][]" name="KMeansCluster" is-static="true">
		<summary>K Means uses coordinate descent and a distance metric between randomly selected centroids to cluster the data</summary>
				<param type="BrightData.IReadOnlyVector[]" name="data" summary="The list of vectors to cluster" />
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
				<param type="System.UInt32" name="k" summary="The number of clusters to find" />
				<param type="System.UInt32" name="maxIterations" summary="The maximum number of iterations" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric to use to compare centroids" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="GetDataType" is-static="true">
		<summary>Converts from a column type to a Type</summary>
				<param type="BrightData.BrightDataType" name="type" summary="Column type" />
			</method>
	<method type="BrightData.BrightDataType" name="GetBrightDataType" is-static="true">
		<summary>Converts from a Type to a ColumnType</summary>
				<param type="System.Type" name="dataType" summary="" />
			</method>
	<method type="System.Boolean" name="IsBlittable" is-static="true">
		<summary>Checks if the column type is blittable</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary>Checks if the column type is numeric</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary>Checks if the column type is decimal</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary>Checks if the column type is continuous</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsInteger" is-static="true">
		<summary>Checks if the column type is an integer</summary>
				<param type="BrightData.BrightDataType" name="type" summary="" />
			</method>
	<method type="System.Boolean" name="IsIndexedList" is-static="true">
		<summary>Checks if the column type is an indexed list (or weighted index list)</summary>
				<param type="BrightData.BrightDataType" name="type" summary="" />
			</method>
	<method type="System.Boolean" name="IsTensor" is-static="true">
		<summary>Checks if the column type is a tensor</summary>
				<param type="BrightData.BrightDataType" name="type" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="RowIndices" is-static="true">
		<summary>Returns all row indices as an enumerable</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="ColumnIndices" is-static="true">
		<summary>Returns all column indices as an enumerable</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser" name="GetAnalyser" is-static="true">
		<summary>Creates a column analyser</summary>
				<param type="BrightData.BrightDataType" name="type" summary="Column type" />
				<param type="BrightData.Types.MetaData" name="metaData" summary="Column meta data" />
				<param type="System.UInt32" name="writeCount" summary="Maximum size of sequences to write in final metadata" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="ParseCsv" is-static="true">
		<summary>Parse CSV in memory without writing to disk (for small data sets)</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.StreamReader" name="reader" summary="Stream reader that contains CSV data" />
				<param type="System.Boolean" name="hasHeader" summary="True if the data contains a header" />
				<param type="System.Char" name="delimiter" summary="CSV delimiter character" />
				<param type="System.String" name="fileOutputPath" summary="Path to write data table on disk (optional)" />
				<param type="System.UInt32" name="maxRows" summary="Maximum number of rows to read" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.TableRow[]&gt;" name="Head" is-static="true">
		<summary>Returns the head (first few rows) of the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="size" summary="Number of rows to return" />
			</method>
	<method type="BrightData.IDataTable" name="LoadTable" is-static="true">
		<summary>Loads a data table from disk</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.String" name="filePath" summary="File path on disk" />
			</method>
	<method type="System.Void" name="SetTargetColumn" is-static="true">
		<summary>Sets the target column across an array of metadata</summary>
				<param type="BrightData.Types.MetaData[]" name="metaData" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="Column index to make target (or null to set no target)" />
			</method>
	<method type="System.Void" name="SetTargetColumn" is-static="true">
		<summary>Sets the target column of the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="Column index to make target (or null to set no target)" />
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="GetTargetColumn" is-static="true">
		<summary>Returns the target column of the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
			</method>
	<method type="System.UInt32" name="GetTargetColumnOrThrow" is-static="true">
		<summary>Returns the target column or throws an exception if none set</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="ColumnIndicesOfFeatures" is-static="true">
		<summary>Returns the feature (non target) columns of the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
			</method>
	<method type="BrightData.Types.MetaData" name="SetType" is-static="true">
		<summary>Sets the column type in a metadata store</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="BrightData.BrightDataType" name="type" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;(BrightData.IReadOnlyNumericSegment&lt;System.Single&gt; Numeric, System.String Label)&gt;" name="GetVectorisedFeatures" is-static="true">
		<summary>Converts the data table to a sequence of labeled vectors (feature columns are vectorised, target column is converted to a string)</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="oneHotEncode" summary="" />
			</method>
	<method type="BrightData.BrightDataType" name="GetColumnType" is-static="true">
		<summary>Gets the column type</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="System.UInt32" name="GetNumDistinct" is-static="true">
		<summary>Gets the number of distinct items</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;(BrightData.IDataTable Training, BrightData.IDataTable Test)&gt;" name="Split" is-static="true">
		<summary>Splits a data table into training and test tables (rows are randomly selected for either)</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.Double" name="trainingFraction" summary="Fraction (0..1) of rows to add to the training table" />
				<param type="System.String" name="trainingFilePath" summary="Path to write training table to disk (optional)" />
				<param type="System.String" name="testFilePath" summary="Path to write test table to disk (optional)" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;(BrightData.IDataTable Training, BrightData.IDataTable Validation)&gt;" name="Fold" is-static="true">
		<summary>Folds the data table into k buckets (for k fold cross validation)</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.Int32" name="k" summary="Number of buckets to create" />
				<param type="System.Boolean" name="shuffle" summary="True to shuffle the table before folding" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;(BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix Features, BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix Target)&gt;" name="AsMatrices" is-static="true">
		<summary>Converts the data table to feature and target matrices</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix&gt;" name="AsMatrix" is-static="true">
		<summary>Converts data table columns to a matrix</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to include in the matrix" />
			</method>
	<method type="System.Void" name="CopyToReadOnly" is-static="true">
		<summary>Copies from a span to a read only span</summary>
				<param type="System.Span&lt;T&gt;" name="from" summary="" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="to" summary="" />
			</method>
	<method type="System.Void" name="CopyToReadOnly" is-static="true">
		<summary>Copies from a span to a read only span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="from" summary="" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="to" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Vectorise" is-static="true">
		<summary>Creates a new data table that has two vector columns, one for the features and the other for the target</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="oneHotEncodeToMultipleColumns" summary="" />
				<param type="System.String" name="filePath" summary="Optional path to save data table to disk" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Vectorise" is-static="true">
		<summary>Creates a new data table that has two vector columns, one for the features and the other for the target</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="oneHotEncodeToMultipleColumns" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndices" summary="Columns to use" />
				<param type="System.String" name="filePath" summary="Optional path to save data table to disk" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="ConvertToTable" is-static="true">
		<summary>Converts indexed classifications to a data table</summary>
				<param type="System.Span&lt;BrightData.IndexListWithLabel&lt;System.String&gt;&gt;" name="data" summary="" />
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="ConvertToTable" is-static="true">
		<summary>Converts weighted index classifications to a data table</summary>
				<param type="System.Span&lt;BrightData.WeightedIndexListWithLabel&lt;System.String&gt;&gt;" name="data" summary="" />
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="ConvertToTable" is-static="true">
		<summary>Converts the vector classifications into a data table</summary>
				<param type="System.Span&lt;(System.String Label, BrightData.IVector Data)&gt;" name="data" summary="" />
				<param type="System.Boolean" name="preserveVectors" summary="True to create a data table with a vector column type, false to convert to columns of floats" />
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="(System.String Classification, BrightData.IReadOnlyVector Data, System.UInt32 Index)[]" name="Vectorise" is-static="true">
		<summary>Converts the weighted index classification list to a list of dense vectors</summary>
				<param type="System.Span&lt;BrightData.WeightedIndexListWithLabel&lt;System.String&gt;&gt;" name="data" summary="" />
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Object" name="GetDefaultValue" is-static="true">
		<summary>Returns a default value for a column type</summary>
				<param type="BrightData.BrightDataType" name="columnType" summary="" />
			</method>
	<method type="System.Object[]" name="ToArray" is-static="true">
		<summary>Converts the segment to an array</summary>
				<param type="BrightData.ICanRandomlyAccessData" name="row" summary="" />
			</method>
	<method type="T" name="Get" is-static="true">
		<summary>Casts the value at column index to type T</summary>
				<param type="BrightData.ICanRandomlyAccessData" name="segment" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.TableRow[]&gt;" name="Sample" is-static="true">
		<summary>Samples rows from the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.UInt32" name="sampleSize" summary="Number of rows to sample" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="ConcatenateColumns" is-static="true">
		<summary>Horizontally concatenates other data tables with this data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.String" name="filePath" summary="File path to save new table (optional)" />
				<param type="BrightData.IDataTable[]" name="others" summary="Other data tables" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="ConcatenateRows" is-static="true">
		<summary>Vertically concatenates other data tables with this data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.String" name="filePath" summary="File path to save new table (optional)" />
				<param type="BrightData.IDataTable[]" name="others" summary="Other data tables" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="CopyRowsToNewTable" is-static="true">
		<summary>Copy specified rows from this to a new data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
				<param type="System.UInt32[]" name="rowIndices" summary="Row indices to copy" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="CopyColumnsToNewTable" is-static="true">
		<summary>Copies all or specified columns to a new data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.String" name="filePath" summary="File path to save new table (optional)" />
				<param type="System.UInt32[]" name="columnIndices" summary="Specified column indices (or all columns if none specified)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 Index, BrightData.BrightDataType Type, BrightData.Types.MetaData MetaData)&gt;" name="GetColumnInfo" is-static="true">
		<summary>Returns column information</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Normalize" is-static="true">
		<summary>Normalizes the data in specified columns of the table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="BrightData.NormalizationType" name="type" summary="Normalization type" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Normalize" is-static="true">
		<summary>Normalizes the data in specified columns of the table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="File path to store new table on disk (optional)" />
				<param type="BrightData.NormalizationType[]" name="columnNormalizationTypes" summary="Normalization types per column" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IReadOnlyBufferWithMetaData&gt;" name="Convert" is-static="true">
		<summary>Converts the buffer with a column conversion</summary>
				<param type="BrightData.IReadOnlyBufferWithMetaData" name="buffer" summary="" />
				<param type="BrightData.ColumnConversion" name="conversion" summary="" />
				<param type="BrightData.IProvideDataBlocks" name="tempStreams" summary="" />
				<param type="System.Int32" name="blockSize" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxInMemoryBlocks" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxDistinctItems" summary="" />
			</method>
	<method type="BrightData.DataTable.Columns.ColumnConversionInfo" name="ConvertColumn" is-static="true">
		<summary>Creates a column conversion</summary>
				<param type="BrightData.ColumnConversion" name="conversion" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.DataTable.Columns.ColumnConversionInfo" name="ConvertColumn" is-static="true">
		<summary>Creates a custom column conversion</summary>
				<param type="BrightData.ColumnConversion" name="conversion" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.Func&lt;FT, TT&gt;" name="converter" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Convert" is-static="true">
		<summary>Applies column conversions to the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightData.ColumnConversion[]" name="conversions" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Convert" is-static="true">
		<summary>Applies column conversions to the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightData.DataTable.Columns.ColumnConversionInfo[]" name="conversions" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Bag" is-static="true">
		<summary>Bags (random sample with duplication) table data to a new table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="File path to save new table (optional)" />
				<param type="System.UInt32" name="sampleCount" summary="Number of rows to sample" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Shuffle" is-static="true">
		<summary>Shuffles all table rows into a new table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="File path to save new table (optional)" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Clone" is-static="true">
		<summary>Clones the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="File path to save new table (optional)" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;(System.String Label, BrightData.IDataTable Table)[]&gt;" name="GroupBy" is-static="true">
		<summary>Groups table data into multiple new tables based on the value(s) from columns</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="groupByColumnIndices" summary="Column indices that form the group" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;(System.String Label, BrightData.IDataTable Table)[]&gt;" name="GroupBy" is-static="true">
		<summary>Groups table data into multiple new tables based on the value(s) from columns</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Func&lt;System.String, System.String&gt;" name="filePathProvider" summary="Provides file paths to save new table" />
				<param type="System.UInt32[]" name="groupByColumnIndices" summary="Column indices that form the group" />
			</method>
	<method type="System.String" name="GetTableSignature" is-static="true">
		<summary>Gets the table signature based on column types</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="WriteDataTable" is-static="true">
		<summary>Writes a data table to a stream</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="Table meta data" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="columns" summary="Data table columns" />
				<param type="System.IO.Stream" name="stream" summary="Output stream" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="BuildDataTable" is-static="true">
		<summary>Builds a data table from an array of typed segments</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="Table level meta data" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="columns" summary="Typed segments (table columns)" />
				<param type="System.IO.Stream" name="stream" summary="Output stream" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="BuildDataTableInMemory" is-static="true">
		<summary>Builds a data table in memory</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="Table level meta data" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="columns" summary="Typed segments (table columns)" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="BuildDataTable" is-static="true">
		<summary>Builds a data table (and writes table data to a file)</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="Table level meta data" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="columns" summary="Typed segments (table columns)" />
				<param type="System.String" name="filePath" summary="File path" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;T[]&gt;" name="MapRows" is-static="true">
		<summary>Maps table rows to another type</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Func&lt;BrightData.DataTable.TableRow, T&gt;" name="mapper" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.TableRow[]&gt;" name="GetAllRows" is-static="true">
		<summary>Returns all rows in the table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="CreateTableInMemory" is-static="true">
		<summary>Creates a data table in memory</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="buffers" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="CreateTable" is-static="true">
		<summary>Creates a data table saved to disk</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="" />
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="buffers" summary="" />
			</method>
	<method type="BrightData.IDataTable" name="LoadTableFromStream" is-static="true">
		<summary>Loads a data table from the stream</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="(System.Type Type, System.UInt32 Size)" name="GetColumnType" is-static="true">
		<summary>Returns the .net type and its size to represent a bright data type within a column</summary>
				<param type="BrightData.BrightDataType" name="dataType" summary="Bright data type" />
			</method>
	<method type="BrightData.IReadOnlyBuffer&lt;T&gt;" name="ConvertTo" is-static="true">
		<summary>Converts the buffer to a typed buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.Analysis.NormalisationModel&gt;" name="GetNormalization" is-static="true">
		<summary>Creates or loads an existing normalisation model from the buffer</summary>
				<param type="BrightData.IReadOnlyBufferWithMetaData" name="buffer" summary="" />
				<param type="BrightData.NormalizationType" name="type" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.ICanVectorise&gt;" name="GetVectoriser" is-static="true">
		<summary>Creates a vectoriser for the buffer</summary>
				<param type="BrightData.IReadOnlyBuffer" name="buffer" summary="" />
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="oneHotEncodeCategoricalData" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.VectorisationModel&gt;" name="GetVectoriser" is-static="true">
		<summary>Creates a vectoriser for the specified columns in a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="oneHotEncodeCategoricalData" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.VectorisationModel&gt;" name="GetVectoriser" is-static="true">
		<summary>Creates a vectoriser from multiple buffers</summary>
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="buffers" summary="" />
				<param type="System.Boolean" name="oneHotEncodeCategoricalData" summary="" />
			</method>
	<method type="BrightData.DataTable.VectorisationModel" name="GetVectoriser" is-static="true">
		<summary>Creates a vectoriser from saved metadata</summary>
				<param type="BrightData.Types.MetaData[]" name="metaData" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AllOrSpecifiedColumnIndices" is-static="true">
		<summary>Returns all or the specified column indices for the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="distinct" summary="" />
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AllOrSpecifiedRowIndices" is-static="true">
		<summary>Enumerates specified row indices (or all if none specified)</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="distinct" summary="" />
				<param type="System.UInt32[]" name="indices" summary="Row indices (optional)" />
			</method>
	<method type="BrightData.IReadOnlyBuffer[]" name="GetColumnsAsBuffers" is-static="true">
		<summary>Returns the specified columns from the data table (or all if none specified) as buffers</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Type" name="GetColumnType" is-static="true">
		<summary>Returns the type of column from a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IOperation[]" name="CopyTo" is-static="true">
		<summary>Creates operations to copy all columns in the table to a destination</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="BrightData.IAppendBlocks[]" name="buffers" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="WriteTo" is-static="true">
		<summary>Writes the data table to a stream</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task" name="WriteTo" is-static="true">
		<summary>Writes the data table to disk</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="path" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.DataTable.TableRow[]&gt;" name="GetSlice" is-static="true">
		<summary>Returns a slice of rows from the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="start" summary="" />
				<param type="System.UInt32" name="count" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IBuildDataTables&gt;" name="Project" is-static="true">
		<summary>Creates a new data table from the existing and a projection function that will be applied to each row</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Func&lt;BrightData.DataTable.TableRow, System.Object[]&gt;" name="projection" summary="" />
				<param type="System.Threading.CancellationToken" name="ct" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="CreateTable" is-static="true">
		<summary>Creates a data table from an array of buffers</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="BrightData.IReadOnlyBufferWithMetaData&lt;T&gt;[]" name="buffers" summary="" />
				<param type="BrightData.Types.MetaData" name="tableMetaData" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Build" is-static="true">
		<summary>Builds the data table, either writing it to disk if a file path was specified otherwise in memory</summary>
				<param type="BrightData.IBuildDataTables" name="builder" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="BuildInMemory" is-static="true">
		<summary>Builds a data table in memory</summary>
				<param type="BrightData.IBuildDataTables" name="builder" summary="" />
			</method>
	<method type="BrightData.IReadOnlyBufferWithMetaData[]" name="GetColumns" is-static="true">
		<summary>Returns an array of columns (all if none specified)</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Single" name="NextRandomFloat" is-static="true">
		<summary>Returns a randomly initialized float greater than or equal to 0f, and less than 1f</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="System.UInt32" name="RandomIndex" is-static="true">
		<summary>Returns a randomly initialized positive number</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="length" summary="Exclusive upper bound" />
			</method>
	<method type="System.UInt32" name="RandomIndex" is-static="true">
		<summary>Returns a randomly initialized positive number</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="length" summary="Exclusive upper bound" />
			</method>
	<method type="BrightData.INonNegativeDiscreteDistribution" name="CreateBernoulliDistribution" is-static="true">
		<summary>Create a bernoulli distribution</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
			</method>
	<method type="BrightData.INonNegativeDiscreteDistribution" name="CreateBinomialDistribution" is-static="true">
		<summary>Create a binomial distribution</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
				<param type="System.UInt32" name="numTrials" summary="" />
			</method>
	<method type="BrightData.INonNegativeDiscreteDistribution" name="CreateCategoricalDistribution" is-static="true">
		<summary>Create a categorical distribution</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="categoricalValues" summary="" />
			</method>
	<method type="BrightData.IContinuousDistribution" name="CreateContinuousDistribution" is-static="true">
		<summary>Create a continuous distribution</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Single" name="inclusiveLowerBound" summary="" />
				<param type="System.Single" name="exclusiveUpperBound" summary="" />
			</method>
	<method type="BrightData.IDiscreteDistribution" name="CreateDiscreteUniformDistribution" is-static="true">
		<summary>Create a discrete uniform distribution</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="inclusiveLowerBound" summary="" />
				<param type="System.Int32" name="exclusiveUpperBound" summary="" />
			</method>
	<method type="BrightData.IContinuousDistribution" name="CreateNormalDistribution" is-static="true">
		<summary>Create a normal distribution</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Single" name="mean" summary="" />
				<param type="System.Single" name="stdDev" summary="Standard deviation" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Single" name="CosineDistance" is-static="true">
		<summary>Vectorized cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite)</summary>
				<param type="System.Single[]" name="v1" summary="First vector" />
				<param type="System.Single[]" name="v2" summary="Second vector" />
			</method>
	<method type="(System.Single Value, System.UInt32 Index)" name="Minimum" is-static="true">
		<summary>Find the minimum value and index in a vector</summary>
				<param type="System.Single[]" name="vector" summary="Vector to analyze" />
			</method>
	<method type="System.UInt32" name="MinimumIndex" is-static="true">
		<summary>Returns the index of the minimum value within a vector</summary>
				<param type="System.Single[]" name="vector" summary="Vector to analyse" />
			</method>
	<method type="System.Single" name="MinimumValue" is-static="true">
		<summary>Returns the minimum value</summary>
				<param type="System.Single[]" name="vector" summary="Vector to analyse" />
			</method>
	<method type="(System.Single Value, System.UInt32 Index)" name="Maximum" is-static="true">
		<summary>Returns the maximum value and index within a vector</summary>
				<param type="System.Single[]" name="vector" summary="Vector to analyse" />
			</method>
	<method type="System.UInt32" name="MaximumIndex" is-static="true">
		<summary>Returns the maximum value within a vector</summary>
				<param type="System.Single[]" name="vector" summary="Vector to analyse" />
			</method>
	<method type="System.Single" name="MaximumValue" is-static="true">
		<summary>Returns the index of the maximum value within a vector</summary>
				<param type="System.Single[]" name="vector" summary="Vector to analyse" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;System.Single&gt;" name="Softmax" is-static="true">
		<summary>Calculates the softmax of a vector
https://en.wikipedia.org/wiki/Softmax_function</summary>
				<param type="System.Single[]" name="vector" summary="" />
			</method>
	<method type="System.Single[]" name="GetAverage" is-static="true">
		<summary>Finds the average of each value from a collection of vectors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single[]&gt;" name="vectors" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="ToReadOnlyVector" is-static="true">
		<summary>Converts the float array to a read only vector</summary>
				<param type="System.Single[]" name="segment" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.IReadOnlyVector" name="Reshape" is-static="true">
		<summary>Reshapes to a vector</summary>
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="vector" summary="" />
			</method>
	<method type="BrightData.IReadOnlyMatrix" name="Reshape" is-static="true">
		<summary>Reshapes to a matrix</summary>
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="vector" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Row count of each matrix (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Column count of each matrix (one parameter is optional null)" />
			</method>
	<method type="BrightData.IReadOnlyTensor3D" name="Reshape" is-static="true">
		<summary>Reshapes to a 3D tensor</summary>
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="vector" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="Number of matrices (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows in each matrix (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns in each matrix (one parameter is optional null)" />
			</method>
	<method type="BrightData.IReadOnlyTensor4D" name="Reshape" is-static="true">
		<summary>Reshapes to a 4D tensor</summary>
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="vector" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="count" summary="Number of 3D tensors (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="Number of matrices in each 3D tensor (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="Number of rows in each matrix (one parameter is optional null)" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="Number of columns in each matrix (one parameter is optional null)" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.Types.IndexList" name="CreateIndexList" is-static="true">
		<summary>Creates an index list from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<method type="BrightData.Types.WeightedIndexList" name="CreateWeightedIndexList" is-static="true">
		<summary>Creates a weighted index list from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<method type="BrightData.Types.WeightedIndexList" name="ToWeightedIndexList" is-static="true">
		<summary>Creates a weighted index list from indexed counts</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 Index, System.UInt32 Count)&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Types.IndexList" name="ToIndexList" is-static="true">
		<summary>Converts the indices to an index list</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="Indices to convert" />
			</method>
	<method type="BrightData.Types.WeightedIndexList" name="ToWeightedIndexList" is-static="true">
		<summary>Converts the indices to a weighted index list</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="Indices to convert" />
				<param type="System.Single" name="weight" summary="Weight to give each index" />
			</method>
	<method type="BrightData.WeightedIndexListWithLabel&lt;T&gt;[]" name="ConvertToWeightedIndexList" is-static="true">
		<summary>Converts the indexed classifications to weighted indexed classifications</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
				<param type="System.Boolean" name="groupByClassification" summary="True to group by classification (i.e. convert the bag to a set)" />
			</method>
	<method type="System.Single" name="GetMaxWeight" is-static="true">
		<summary>Finds the greatest weight within the weighted index classification list</summary>
				<param type="System.Span&lt;BrightData.WeightedIndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the weighted index classification list</summary>
				<param type="System.Span&lt;BrightData.WeightedIndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the index classification list</summary>
				<param type="System.Span&lt;BrightData.IndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.WeightedIndexListWithLabel&lt;T&gt;[]" name="Normalize" is-static="true">
		<summary>Normalizes the weighted index classification list to fit between 0 and 1</summary>
				<param type="System.Span&lt;BrightData.WeightedIndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.WeightedIndexListWithLabel&lt;T&gt;[]" name="Tfidf" is-static="true">
		<summary>Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
https://en.wikipedia.org/wiki/Tf%E2%80%93idf</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.WeightedIndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.WeightedIndexListWithLabel&lt;T&gt;[]" name="Bm25Plus" is-static="true">
		<summary>Okapi B525+ modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
https://en.wikipedia.org/wiki/Okapi_BM25</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.WeightedIndexListWithLabel&lt;T&gt;&gt;" name="data" summary="" />
				<param type="System.Single" name="k" summary="" />
				<param type="System.Single" name="b" summary="" />
				<param type="System.Single" name="d" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a read only vector</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="size" summary="Size of vector" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="initializer" summary="Callback to initialize each value (optional)" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a read only vector</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="size" summary="Size of vector" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="initializer" summary="Callback to initialize each value (optional)" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a read only vector</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="size" summary="Size of vector" />
				<param type="System.Single" name="initialValue" summary="Initial value of each element" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a vector</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="size" summary="Size of vector" />
				<param type="System.Single" name="initialValue" summary="Initial value of each element" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a read only vector</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.Single[]" name="initialData" summary="Initial data" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a read only vector</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.Span&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a read only vector</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="CreateReadOnlyVector" is-static="true">
		<summary>Creates a vector from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrix" is-static="true">
		<summary>Creates a matrix</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single&gt;" name="initializer" summary="Callback to initialize each value (optional)" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrix" is-static="true">
		<summary>Creates a matrix</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.Single" name="initialValue" summary="Initial value of each element" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrix" is-static="true">
		<summary>Creates a matrix from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrixFromRows" is-static="true">
		<summary>Creates a matrix from vectors (each will become a row)</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="BrightData.IReadOnlyVector[]" name="rows" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrixFromRows" is-static="true">
		<summary>Creates a matrix from vectors (each will become a row)</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector[]" name="rows" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrixFromRows" is-static="true">
		<summary>Creates a matrix from rows (each will become a row)</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.Single[][]" name="rows" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from vectors (each will become a column)</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="BrightData.IReadOnlyVector[]" name="columns" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="CreateReadOnlyMatrixFromColumns" is-static="true">
		<summary>Creates a matrix from vectors (each will become a column)</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="System.Single[][]" name="columns" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D" name="CreateReadOnlyTensor3D" is-static="true">
		<summary>Creates a 3D tensor from matrices</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="BrightData.IReadOnlyMatrix[]" name="matrices" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D" name="CreateReadOnlyTensor3D" is-static="true">
		<summary>Create a 3D tensor from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D" name="CreateReadOnlyTensor4D" is-static="true">
		<summary>Creates a 4D tensor from matrices</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="BrightData.IReadOnlyTensor3D[]" name="tensors" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D" name="CreateReadOnlyTensor4D" is-static="true">
		<summary>Creates a 4D tensor from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateIdentityMatrix" is-static="true">
		<summary>Creates an identity matrix (each diagonal element is 1, each other element is 0)</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="size" summary="Width and height of the new matrix" />
			</method>
	<method type="BrightData.IMatrix" name="CreateDiagonalMatrix" is-static="true">
		<summary>Creates a diagonal matrix</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Single[]" name="values" summary="Diagonal values" />
			</method>
	<method type="System.Void" name="InitializeRandomly" is-static="true">
		<summary>Randomly initialize a tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="true">
		<summary>Initialize a tensor to a single value</summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
				<param type="System.Single" name="value" summary="Value to initialize each element of the tensor" />
			</method>
	<method type="System.Void" name="Initialize" is-static="true">
		<summary>Initialize a tensor using a callback</summary>
				<param type="BrightData.ITensor" name="tensor" summary="" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="initializer" summary="Callback for each element" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="LoadReadOnlyVectorFrom" is-static="true">
		<summary>Reads a vector from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Single[]" name="LoadReadOnlyVectorAndThenGetArrayFrom" is-static="true">
		<summary>Reacts a float array from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="ReadMatrixFrom" is-static="true">
		<summary>Reads a matrix from a binary reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ReduceDimensionsWithSvd" is-static="true">
		<summary>Reduce dimensions of the matrix with a singular value decomposition</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="System.UInt32" name="dimensions" summary="Number of dimensions to reduce to" />
			</method>
	<method type="T" name="Average" is-static="true">
		<summary>Calculates an average from a collection of tensors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="tensors" summary="Tensors to average" />
				<param type="System.Boolean" name="dispose" summary="True to dispose each of the input vectors" />
			</method>
	<method type="System.Single" name="FindDistance" is-static="true">
		<summary>Applies a distance metric to two vectors and returns the distance between them</summary>
				<param type="BrightData.IVector" name="vector" summary="First vector" />
				<param type="BrightData.IVector" name="other" summary="Second vector" />
				<param type="BrightData.DistanceMetric" name="distance" summary="Distance metric" />
			</method>
	<method type="BrightData.IVector" name="FindDistances" is-static="true">
		<summary>Applies a distance metric to this and a list of other vectors</summary>
				<param type="BrightData.IVector" name="compareTo" summary="This vector" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IVector&gt;" name="vectors" summary="List of other vectors" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric" />
			</method>
	<method type="BrightData.Types.WeightedIndexList" name="ToSparse" is-static="true">
		<summary>Converts the vector a weighted index list (sparse vector)</summary>
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="true">
		<summary>Copies all values from this tensor to another tensor</summary>
				<param type="BrightData.ITensor" name="tensor" summary="This tensor" />
				<param type="BrightData.ITensor" name="other" summary="Other tensor" />
			</method>
	<method type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="UseDefaultLinearAlgebraProvider" is-static="true">
		<summary>Sets the context to use the default linear algebra provider</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.Types.WeightedIndexList" name="ToSparse" is-static="true">
		<summary>Converts the vector to a sparse format (only non-zero entries are preserved)</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="(System.Single Min, System.Single Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues" is-static="true">
		<summary>Returns the index with the minimum value from this tensor segment</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.UInt32" name="GetMinimumIndex" is-static="true">
		<summary>Returns the index with the minimum value from this tensor segment</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaximumIndex" is-static="true">
		<summary>Returns the index with the maximum value from this tensor segment</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="Sum" is-static="true">
		<summary>Sums all values</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="CosineDistance" is-static="true">
		<summary>Finds cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite) between this and another vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance" is-static="true">
		<summary>Finds the euclidean distance between this and another vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Single" name="ManhattanDistance" is-static="true">
		<summary>Finds the manhattan distance between this and another vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance" is-static="true">
		<summary>Finds the mean squared distance between this and another vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Single" name="SquaredEuclideanDistance" is-static="true">
		<summary>Finds the squared euclidean distance between this and another vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Single" name="FindDistance" is-static="true">
		<summary>Finds the distance between this and another vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
				<param type="BrightData.DistanceMetric" name="distance" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Add" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Add" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Add" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Multiply" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Subtract" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Subtract" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="PointwiseMultiply" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="PointwiseDivide" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Single" name="DotProduct" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.IReadOnlyVector" name="other" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Sqrt" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.Single" name="adjustment" summary="" />
			</method>
	<method type="System.Single" name="Average" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="L1Norm" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="L2Norm" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Reverse" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Abs" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Log" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Exp" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Pow" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.Single" name="power" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Squared" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="StdDev" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Sigmoid" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="SigmoidDerivative" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Tanh" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="TanhDerivative" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Relu" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="ReluDerivative" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="LeakyRelu" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="LeakyReluDerivative" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Softmax" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="SoftmaxDerivative" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.Int32" name="rowCount" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="CherryPickIndices" is-static="true">
		<summary></summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		Extensions that work with a span of numbers
	</summary>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="ZipParallel" is-static="true">
		<summary>Creates a new span of numbers from applying an operation to each pair of elements from this and another span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="System.Func&lt;T, T, T&gt;" name="func" summary="Function that computes a new value from a pair of values" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="ZipVectorized" is-static="true">
		<summary>Applies a function across each pair of elements from this and another span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="BrightData.ExtensionMethods.ComputeVectorisedTwo&lt;T&gt;" name="func1" summary="Vector callback" />
				<param type="System.Func&lt;T, T, T&gt;" name="func2" summary="Element callback" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="MapParallel" is-static="true">
		<summary>Applies a callback to each item in the span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="Vector" />
				<param type="System.Func&lt;T, T&gt;" name="transformer" summary="Callback" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="MapParallel" is-static="true">
		<summary>Applies a callback to each item in the span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="Vector" />
				<param type="System.Func&lt;System.UInt32, T, T&gt;" name="transformer" summary="Callback" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="TransformVectorized" is-static="true">
		<summary>Creates a new span from an existing span via a vectorization function</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="Input buffer" />
				<param type="BrightData.ExtensionMethods.ComputeVectorisedOne&lt;T&gt;" name="transformer1" summary="Vectorized transformer" />
				<param type="System.Func&lt;T, T&gt;" name="transformer2" summary="Sequential transformer" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="TransformParallelIndexed" is-static="true">
		<summary>Creates a new span from an existing span via a function (possibly executed in parallel) that receives an index and returns a new value</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="Input span" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="transformer" summary="Transformation function (possibly executed in parallel)" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="TransformParallelIndexed" is-static="true">
		<summary>Creates a new span from an existing span via a function (possibly executed in parallel) that receives an index and returns a new value</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="Input span" />
				<param type="System.Func&lt;System.UInt32, T, T&gt;" name="transformer" summary="Transformation function (possibly executed in parallel)" />
			</method>
	<method type="System.Void" name="Mutate" is-static="true">
		<summary>Updates a buffer by applying an update function that receives pairs of values from this and another span</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="System.Func&lt;T, T, T&gt;" name="func" summary="Update function" />
			</method>
	<method type="System.Void" name="MutateVectorized" is-static="true">
		<summary>Updates a buffer by applying a vectorized transformation function to each pair of elements in this and another span</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="BrightData.ExtensionMethods.ComputeVectorisedTwo&lt;T&gt;" name="transformer1" summary="Vectorized transformer" />
				<param type="System.Func&lt;T, T, T&gt;" name="transformer2" summary="Sequential transformer" />
			</method>
	<method type="System.Void" name="MutateInPlace" is-static="true">
		<summary>Updates a span in place by applying a mutation function (potentially called in parallel) to each element</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="" />
				<param type="System.Func&lt;T, T&gt;" name="mutator" summary="" />
			</method>
	<method type="System.Void" name="MutateInPlaceVectorized" is-static="true">
		<summary>Updates a span in place by applying a vectorization function to each value</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="" />
				<param type="BrightData.ExtensionMethods.ComputeVectorisedOne&lt;T&gt;" name="mutator1" summary="" />
				<param type="System.Func&lt;T, T&gt;" name="mutator2" summary="" />
			</method>
	<method type="System.Void" name="Analyse" is-static="true">
		<summary>Applies a callback (that might be executed in parallel) against each element in this span and its index</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
				<param type="System.Action&lt;T, System.UInt32&gt;" name="analyser" summary="Callback that receives each value and its index" />
			</method>
	<method type="System.ReadOnlySpan&lt;T&gt;" name="AsReadOnly" is-static="true">
		<summary>Calculates the sum of all values in this span</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="" />
			</method>
	<method type="T" name="Sum" is-static="true">
		<summary>Calculates the sum of all values in this span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Add" is-static="true">
		<summary>Returns a new buffer that contains this span added to another span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Add" is-static="true">
		<summary>Returns a new buffer that contains this span added to another span where each value is multiplied by coefficients</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="T" name="coefficient1" summary="Coefficient to apply to each value in this span" />
				<param type="T" name="coefficient2" summary="Coefficient to apply to each value in the other span" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Add" is-static="true">
		<summary>Returns a new buffer that contains each value added to a scalar</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="true">
		<summary>Adds another span to this span in place</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="true">
		<summary>Adds another span to this span and applies coefficients to each value</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="T" name="coefficient1" summary="Coefficient to apply to each value in this span" />
				<param type="T" name="coefficient2" summary="Coefficient to apply to each value in the other span" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="true">
		<summary>Adds a scalar to each value</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace" is-static="true">
		<summary>Multiplies each value by a scalar</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Multiply" is-static="true">
		<summary>Creates a new buffer that contains each value multiplied by a scalar</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Subtract" is-static="true">
		<summary>Creates a new buffer in which each value in another span is subtracted from the values in this span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Subtract" is-static="true">
		<summary>Creates a new buffer in which each value in another span is multiplied by the second coefficient and then subtracted from the values in this span multiplied by the first coefficient</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="T" name="coefficient1" summary="Coefficient to apply to each value in this span" />
				<param type="T" name="coefficient2" summary="Coefficient to apply to each value in the other span" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="true">
		<summary>Subtracts another span from this span</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="true">
		<summary>Modifies this span so that each value in another span is multiplied by the second coefficient and then subtracted from the values in this span multiplied by the first coefficient</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
				<param type="T" name="coefficient1" summary="Coefficient to apply to each value in this span" />
				<param type="T" name="coefficient2" summary="Coefficient to apply to each value in the other span" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="PointwiseMultiply" is-static="true">
		<summary>Creates a new buffer in which each value in this span is multiplied by the pairwise value from another span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace" is-static="true">
		<summary>Modifies this span so that each value is multiplied by the pairwise value from another span</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="PointwiseDivide" is-static="true">
		<summary>Creates a new buffer in which each value in this span is divided by the pairwise value from another span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace" is-static="true">
		<summary>Modifies this span so that each value in this span is divided by the pairwise value from another span</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="T" name="DotProduct" is-static="true">
		<summary>Calculates the dot product between this span and another span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This span" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other span" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Sqrt" is-static="true">
		<summary>Creates a new vector that contains the square root of each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="This tensor" />
				<param type="T" name="adjustment" summary="A small value to add to each value in case of zeros" />
			</method>
	<method type="System.Void" name="ConstrainInPlace" is-static="true">
		<summary>Modifies this span so that each value falls between the min and max values</summary>
				<param type="System.Span&lt;T&gt;" name="span" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="maxValue" summary="" />
			</method>
	<method type="T" name="Average" is-static="true">
		<summary>Finds the average value in this vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="This tensor" />
			</method>
	<method type="T" name="L1Norm" is-static="true">
		<summary>Calculates the L1 norm of this vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="This tensor" />
			</method>
	<method type="T" name="L2Norm" is-static="true">
		<summary>Calculates the L2 norm of this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="This tensor" />
			</method>
	<method type="(T Min, T Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues" is-static="true">
		<summary>Finds the min and max values (and their indices) of this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="This tensor" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite" is-static="true">
		<summary>Checks if each value in this span is finite (not NaN or Infinity)</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Reverse" is-static="true">
		<summary>Reverses the span</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
			</method>
	<method type="T" name="MeanSquaredDistance" is-static="true">
		<summary>Calculates the mean squared distance between this and another tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other tensor" />
			</method>
	<method type="T" name="SquaredEuclideanDistance" is-static="true">
		<summary>Calculates the squared euclidean distance between this and another tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other tensor" />
			</method>
	<method type="T" name="ManhattanDistance" is-static="true">
		<summary>Calculates the manhattan distance between this and another tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other tensor" />
			</method>
	<method type="T" name="EuclideanDistance" is-static="true">
		<summary>Calculates the euclidean distance between this and another tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Other tensor" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Abs" is-static="true">
		<summary>Creates a new tensor segment that contains the absolute value of each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Log" is-static="true">
		<summary>Creates a new tensor segment that contains the natural logarithm of each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Exp" is-static="true">
		<summary>Creates a new tensor segment that contains the exponent of each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="tensor" summary="This tensor" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Pow" is-static="true">
		<summary>Creates a new tensor segment that contains each value raised by the specified power in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="This tensor" />
				<param type="T" name="power" summary="Specified power" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Squared" is-static="true">
		<summary>Creates a new buffer in which each value in this span is squared</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
			</method>
	<method type="T" name="StdDev" is-static="true">
		<summary>Calculates the standard deviation of this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="This tensor segment" />
				<param type="System.Nullable&lt;T&gt;" name="mean" summary="Mean of the tensor segment (optional)" />
			</method>
	<method type="T" name="Sigmoid" is-static="true">
		<summary>Calculates sigmoid</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="T" name="SigmoidDerivative" is-static="true">
		<summary>Calculates sigmoid derivative</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="T" name="TanhDerivative" is-static="true">
		<summary>Calculates tanh derivative</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="T" name="Relu" is-static="true">
		<summary>Calculates RELU</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="T" name="ReluDerivative" is-static="true">
		<summary>Calculates RELU derivative</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="T" name="LeakyRelu" is-static="true">
		<summary>Calculates leaky RELU</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="T" name="LeakyReluDerivative" is-static="true">
		<summary>Calculates leaky RELU derivative</summary>
				<param type="T" name="val" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Sigmoid" is-static="true">
		<summary>Creates a new tensor segment with sigmoid function applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="SigmoidDerivative" is-static="true">
		<summary>Creates a new tensor segment with sigmoid derivative applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Tanh" is-static="true">
		<summary>Creates a new tensor segment with tanh function applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="TanhDerivative" is-static="true">
		<summary>Creates a new tensor segment with tanh derivative applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Relu" is-static="true">
		<summary>Creates a new tensor segment with RELU function applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="ReluDerivative" is-static="true">
		<summary>Creates a new tensor segment with RELU derivative applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="LeakyRelu" is-static="true">
		<summary>Creates a new tensor segment with Leaky RELU function applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="LeakyReluDerivative" is-static="true">
		<summary>Creates a new tensor segment with Leaky RELU derivative applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="Softmax" is-static="true">
		<summary>Creates a new tensor segment with softmax function applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="SoftmaxDerivative" is-static="true">
		<summary>Creates a new tensor segment with softmax derivative applied to each value in this tensor segment</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="" />
				<param type="System.Int32" name="rowCount" summary="" />
			</method>
	<method type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt;" name="CherryPickIndices" is-static="true">
		<summary>Creates a new buffer from the specified indices</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="span" summary="" />
				<param type="System.UInt32[]" name="arrayIndices" summary="" />
			</method>
	<method type="System.Void" name="RoundInPlace" is-static="true">
		<summary>Rounds each value in this tensor segment to be either the lower or upper supplied parameters</summary>
				<param type="System.Span&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="lower" summary="" />
				<param type="T" name="upper" summary="" />
			</method>
	<method type="System.Void" name="L1Regularization" is-static="true">
		<summary>In place L1 regularization of the tensor segment</summary>
				<param type="System.Span&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="coefficient" summary="Coefficient to apply to each adjusted value" />
			</method>
	<method type="T" name="FindDistance" is-static="true">
		<summary>Applies a distance metric to two vectors and returns the distance between them</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="First vector" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="other" summary="Second vector" />
				<param type="BrightData.DistanceMetric" name="distance" summary="Distance metric" />
			</method>
	<method type="T" name="CosineDistance" is-static="true">
		<summary>Vectorized cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite)</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="v1" summary="First vector" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="v2" summary="Second vector" />
			</method>
	<method type="T" name="AngularDistance" is-static="true">
		<summary>Angular distance between two vectors</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="v1" summary="" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="v2" summary="" />
			</method>
	<method type="T" name="InnerProductSpaceDistance" is-static="true">
		<summary>Inner space distance between two vectors</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="v1" summary="" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="v2" summary="" />
			</method>
	<method type="(T Value, System.UInt32 Index)" name="Minimum" is-static="true">
		<summary>Find the minimum value and index in a vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="Vector to analyze" />
			</method>
	<method type="System.UInt32" name="MinimumIndex" is-static="true">
		<summary>Returns the index of the minimum value within a vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="Vector to analyse" />
			</method>
	<method type="T" name="MinimumValue" is-static="true">
		<summary>Returns the minimum value</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="Vector to analyse" />
			</method>
	<method type="(T Value, System.UInt32 Index)" name="Maximum" is-static="true">
		<summary>Returns the maximum value and index within a vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="Vector to analyse" />
			</method>
	<method type="System.UInt32" name="MaximumIndex" is-static="true">
		<summary>Returns the maximum value within a vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="Vector to analyse" />
			</method>
	<method type="T" name="MaximumValue" is-static="true">
		<summary>Returns the index of the maximum value within a vector</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="vector" summary="Vector to analyse" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="PearsonCorrelationCoefficient" is-static="true">
		<summary>Calculates the pearson correlation coefficient metric between two tensor segments
https://en.wikipedia.org/wiki/Pearson_correlation_coefficient</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="x" summary="" />
				<param type="System.ReadOnlySpan&lt;T&gt;" name="y" summary="" />
			</method>
	<method type="BrightData.Helper.GenericIndexedEnumerator&lt;T&gt;" name="Search" is-static="true">
		<summary>Searches the span for the index of the first value that matches the specified value within a level of tolerance</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="segment" summary="This tensor" />
				<param type="T" name="value" summary="Value to find" />
				<param type="System.Nullable&lt;T&gt;" name="tolerance" summary="Degree of tolerance" />
			</method>
	<method type="(CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;T&gt; Data, System.UInt32 RowCount, System.UInt32 ColumnCount)" name="Transpose" is-static="true">
		<summary>Calculate the matrix transpose</summary>
				<param type="System.ReadOnlySpan&lt;T&gt;" name="matrix" summary="" />
				<param type="System.UInt32" name="rowCount" summary="" />
				<param type="System.UInt32" name="columnCount" summary="" />
			</method>
	<method type="System.Void" name="TransposeInPlace" is-static="true">
		<summary>Transpose a matrix in place</summary>
				<param type="System.Span&lt;T&gt;" name="matrix" summary="" />
				<param type="System.UInt32" name="rowCount" summary="" />
				<param type="System.UInt32" name="columnCount" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="ToReadOnlyVector" is-static="true">
		<summary>Creates a read only vector from the span</summary>
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="span" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="ToReadOnlyVector" is-static="true">
		<summary>Creates a read only vector from the span</summary>
				<param type="System.Span&lt;System.Single&gt;" name="span" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.Types.WeightedIndexList" name="ToSparse" is-static="true">
		<summary>Converts the tensor segment to a sparse format (only non-zero entries are preserved)</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;&gt;" name="Split" is-static="true">
		<summary>Splits this tensor segment into multiple contiguous tensor segments</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="This tensor" />
				<param type="System.UInt32" name="blockCount" summary="Number of blocks" />
			</method>
	<method type="System.Void" name="Set" is-static="true">
		<summary>Sets all values of the tensor segment via a callback that receives each value</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="setValue" summary="" />
			</method>
	<method type="System.Void" name="Set" is-static="true">
		<summary>Sets all values of the tensor segment via a callback that receives the index of each value</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="setValue" summary="" />
			</method>
	<method type="System.Void" name="Set" is-static="true">
		<summary>Sets all values of the tensor segment to a single value</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Single" name="value" summary="Value to set" />
			</method>
	<method type="System.Void" name="SetToRandom" is-static="true">
		<summary>Sets all values of this tensor segment to a random floating point number</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Random" name="random" summary="Random number generator" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="ToReadOnlyVector" is-static="true">
		<summary>Converts the tensor segment to a read only vector</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.IVector" name="ToVector" is-static="true">
		<summary>Creates a vector from a tensor segment</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="BrightData.IMatrix" name="ToMatrix" is-static="true">
		<summary>Creates a matrix from a tensor segment</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="rows" summary="Number of rows in matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
			</method>
	<method type="BrightData.ITensor3D" name="ToTensor3D" is-static="true">
		<summary>Creates a 3D tensor from a tensor segment</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in each matrix" />
			</method>
	<method type="BrightData.ITensor4D" name="ToTensor4D" is-static="true">
		<summary>Creates a 4D tensor from a tensor segment</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in each matrix" />
			</method>
	<method type="RT" name="GetReadOnlySpan" is-static="true">
		<summary>Passes the segment as a readonly span to the callback</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="BrightData.ExtensionMethods.OnReadOnlySpan&lt;System.Single, RT&gt;" name="callback" summary="" />
			</method>
	<method type="RT" name="GetReadOnlySpan" is-static="true">
		<summary>Passes the segment as a readonly span to the callback</summary>
				<param type="T" name="segment" summary="" />
				<param type="BrightData.ExtensionMethods.OnReadOnlySpan&lt;System.Single, RT&gt;" name="callback" summary="" />
			</method>
	<method type="RT" name="GetReadOnlySpans" is-static="true">
		<summary>Passes the readonly spans from the supplied segments into a callback function</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment1" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment2" summary="" />
				<param type="BrightData.ExtensionMethods.OnReadOnlySpans&lt;System.Single, RT&gt;" name="callback" summary="" />
			</method>
	<method type="RT" name="GetReadOnlySpans" is-static="true">
		<summary>Passes the readonly spans from the supplied segments into a callback function</summary>
				<param type="T" name="segment1" summary="" />
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment2" summary="" />
				<param type="BrightData.ExtensionMethods.OnReadOnlySpans&lt;System.Single, RT&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="GetSpans" is-static="true">
		<summary>Passes the first as a mutable span and the second as a readonly span from the supplied segments into a callback function</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment1" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment2" summary="" />
				<param type="BrightData.ExtensionMethods.OnSpans&lt;System.Single&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="GetSpan" is-static="true">
		<summary>Passes the segment as a mutable span into a callback function</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="BrightData.ExtensionMethods.OnSpan&lt;System.Single&gt;" name="callback" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.IDataTypeSpecification" name="AsDataFieldSpecification" is-static="true">
		<summary>Creates a data field specification for a data type</summary>
				<param type="BrightData.BrightDataType" name="dataType" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="System.Boolean" name="canRepeat" summary="" />
			</method>
	<method type="BrightData.IDataTypeSpecification" name="GetTypeSpecification" is-static="true">
		<summary>Creates a type specification for a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;System.Collections.Generic.HashSet&lt;System.UInt32&gt;&gt;" name="FindNonConformingRows" is-static="true">
		<summary>Finds the row indices of any row that does not conform to the type specification</summary>
				<param type="BrightData.IDataTypeSpecification" name="typeInfo" summary="" />
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Static extension methods
	</summary>
	<method type="BrightWire.IMarkovModelTrainer2&lt;T&gt;" name="CreateMarkovTrainer2" is-static="true">
		<summary>Create a markov model trainer of window size 2</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="T" name="empty" summary="Null value for T" />
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="BrightWire.IMarkovModelTrainer3&lt;T&gt;" name="CreateMarkovTrainer3" is-static="true">
		<summary>Create a markov model trainer of window size 3</summary>
				<param type="BrightData.BrightDataContext" name="_" summary="" />
				<param type="T" name="empty" summary="Null value for T" />
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.DataTable.TableRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row in the data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IReadOnlyNumericSegment&lt;System.Single&gt; Vector, System.UInt32 RowIndex, System.String Label)&gt;" name="GetRowsAsLabeledFeatures" is-static="true">
		<summary>Enumerates rows in the table as vectorized rows</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.Boolean" name="oneHotEncode" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="HierarchicalCluster" is-static="true">
		<summary>Clusters the rows in the data table using hierarchical clustering</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="Number of clusters" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="KMeans" is-static="true">
		<summary>Clusters the rows in the data table using k-means clustering</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="Number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="Maximum number of iterations" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric to use" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="NonNegativeMatrixFactorisation" is-static="true">
		<summary>Clusters the rows in the data table using non-negative matrix factorisation clustering</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="Number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="Maximum number of iterations" />
			</method>
	<method type="System.UInt32" name="GetOutputSizeOrThrow" is-static="true">
		<summary>Returns the output size (throw exception if not set)</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.GraphFactory" name="CreateGraphFactory" is-static="true">
		<summary>Creates a graph factory</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider (optional)" />
			</method>
	<method type="BrightWire.ExecutionGraph.GraphFactory" name="CreateGraphFactory" is-static="true">
		<summary>Creates a graph factory</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="CreateSequentialWindow" is-static="true">
		<summary>Creates a matrix to vector training table in which the matrix contains a window of sequentially ordered rows</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="windowSize" summary="The number of rows in each matrix" />
				<param type="System.UInt32[]" name="columnIndices" summary="Column indices to select" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightWire.Models.ConfusionMatrix&gt;" name="CreateConfusionMatrix" is-static="true">
		<summary>Creates a confusion matrix from two columns of a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="Data table" />
				<param type="System.UInt32" name="actualClassificationColumnIndex" summary="The column index of the actual classifications" />
				<param type="System.UInt32" name="expectedClassificationColumnIndex" summary="The column index of the expected classifications" />
			</method>
	<method type="(System.String Label, System.String Classification, System.Single Score)[]" name="Classify" is-static="true">
		<summary>Classifies each row of the index classification list</summary>
				<param type="BrightData.IndexListWithLabel&lt;System.String&gt;[]" name="data" summary="" />
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="The classifier to classify each item in the list" />
			</method>
	<method type="BrightWire.IRowClassifier" name="AsRowClassifier" is-static="true">
		<summary>Converts the index list classifier to a row classifier</summary>
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="Index list classifier" />
				<param type="System.UInt32" name="columnIndex" summary="Column index to classify" />
				<param type="BrightData.IIndexStrings" name="indexer" summary="String indexer (optional)" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.Models.GraphModel" name="Train" is-static="true">
		<summary>Trains a graph for a fixed number of iterations</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="The graph training engine" />
				<param type="System.UInt32" name="numIterations" summary="The number of iterations to train for" />
				<param type="BrightWire.IDataSource" name="testData" summary="The test data source to use" />
				<param type="System.Action&lt;BrightWire.Models.GraphModel&gt;" name="onImprovement" summary="Optional callback for when the test data score has improved against the error metric" />
				<param type="System.Int32" name="testCadence" summary="Determines how many epochs elapse before the test data is evaluated" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.DataTable.TableRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row of the data table</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel" name="GetGraph" is-static="true">
		<summary>Serialises the node and any other connected nodes to an execution graph</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input" summary="" />
				<param type="System.String" name="name" summary="Name of the graph (optional)" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateFrom" is-static="true">
		<summary>Creates a node and any other connected nodes from a serialised execution graph</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Serialised graph" />
			</method>
	<method type="BrightData.IReadOnlyVector[][]" name="OrderSequentialOutput" is-static="true">
		<summary>Aligns the output of sequential graph execution into an ordered list of results</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="results" summary="Output from sequential graph execution" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the matrix to a generic IGraphData</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="Matrix to convert" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the 3D tensor to a generic IGraphData</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="Tensor to convert" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the 4D tensor to a generic IGraphData</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="Tensor to convert" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphContext&gt;" name="GetGraphContexts" is-static="true">
		<summary>Finds the graph sequence contexts that have been executed in this mini batch</summary>
				<param type="BrightWire.IMiniBatch" name="miniBatch" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="GetLinearAlgebraProvider" is-static="true">
		<summary>Returns the linear algebra provider associated from this graph context</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.IRandomProjection" name="CreateRandomProjection" is-static="true">
		<summary>Random projections allow you to reduce the dimensions of a matrix while still preserving significant information</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="fixedSize" summary="The vector size to reduce from" />
				<param type="System.UInt32" name="reducedSize" summary="The vector size to reduce to" />
				<param type="System.Int32" name="s" summary="" />
			</method>
	<method type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a pair of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
			</method>
	<method type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a tuple of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
				<param type="T" name="item3" summary="The third observation" />
			</method>
	<method type="System.UInt32[][]" name="Nnmf" is-static="true">
		<summary>Non-negative matrix factorisation - clustering based on matrix factorisation. Only applicable for training data that is non-negative.</summary>
				<param type="BrightData.IReadOnlyVector[]" name="data" summary="The training data" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="k" summary="The number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="The maximum number of iterations" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightWire.Models.InstanceBased.KNearestNeighbours&gt;" name="TrainKNearestNeighbours" is-static="true">
		<summary>K Nearest Neighbours is an instance based classification method that uses examples from training data to predict classifications</summary>
				<param type="BrightData.IDataTable" name="data" summary="The training data" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightWire.Models.TreeBased.RandomForest&gt;" name="TrainRandomForest" is-static="true">
		<summary>Random forests are built on a bagged collection of features to try to capture the most salient points of the training data without overfitting</summary>
				<param type="BrightData.IDataTable" name="data" summary="The training data" />
				<param type="System.UInt32" name="b" summary="The number of trees in the forest" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="baggedRowCount" summary="" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
	<method type="BrightWire.Models.TreeBased.DecisionTree" name="TrainDecisionTree" is-static="true">
		<summary>Decision trees build a logical tree to classify data. Various measures can be specified to prevent overfitting.</summary>
				<param type="BrightData.IDataTable" name="data" summary="The training data" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
	<method type="BrightWire.Models.Bayesian.MultinomialNaiveBayes" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IndexListWithLabel&lt;System.String&gt;&gt;" name="data" summary="The training data" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightWire.Models.Bayesian.MultinomialNaiveBayes&gt;" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="BrightData.IDataTable" name="table" summary="The training data table that must have an index-list based column to classify against" />
			</method>
	<method type="BrightWire.Models.Bayesian.BernoulliNaiveBayes" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IndexListWithLabel&lt;System.String&gt;&gt;" name="data" summary="The training data" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightWire.Models.Bayesian.BernoulliNaiveBayes&gt;" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="BrightData.IDataTable" name="table" summary="The training data table that must have an index-list based column" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightWire.Models.Bayesian.NaiveBayes&gt;" name="TrainNaiveBayes" is-static="true">
		<summary>Naive bayes is a classifier that assumes conditional independence between all features</summary>
				<param type="BrightData.IDataTable" name="table" summary="The training data provider" />
			</method>
	<method type="System.String" name="GetBestClassification" is-static="true">
		<summary>Finds the classification with the highest weight</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Label, System.Single Weight)&gt;" name="classifications" summary="List of weighted classifications" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel" name="TrainSimpleNeuralNetwork" is-static="true">
		<summary>Trains a neural network with a single hidden layer</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="graph" summary="" />
				<param type="BrightData.IDataTable" name="trainingTable" summary="" />
				<param type="BrightData.IDataTable" name="testTable" summary="" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="" />
				<param type="System.Single" name="learningRate" summary="" />
				<param type="System.UInt32" name="batchSize" summary="" />
				<param type="System.UInt32" name="hiddenLayerSize" summary="" />
				<param type="System.UInt32" name="numIterations" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory, BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="activation" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider, BrightWire.ICreateTemplateBasedGradientDescent&gt;" name="gradientDescent" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider, BrightWire.IWeightInitialisation&gt;" name="weightInitialisation" summary="" />
			</method>
</class>
<class name="BrightData.Helper.FloatMath" base="" is-static="true" is-abstract="false">
	<summary>
		Constrained float math helpers - if the value is too small or too big it will be capped. Also, NaN values are replaced with zero.
	</summary>
	<method type="System.Single" name="Log" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Exp" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Sqrt" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
				<param type="System.Single" name="adjustment" summary="" />
			</method>
	<method type="System.Single" name="Pow" is-static="true">
		<summary></summary>
				<param type="System.Single" name="x" summary="" />
				<param type="System.Single" name="y" summary="" />
			</method>
	<method type="System.Boolean" name="IsZero" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsNotZero" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="AreEqual" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value1" summary="" />
				<param type="System.Single" name="value2" summary="" />
				<param type="System.Single" name="tolerance" summary="" />
			</method>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Next" is-static="true">
		<summary></summary>
				<param type="System.Random" name="rand" summary="" />
			</method>
	<method type="System.Collections.Generic.IEqualityComparer&lt;System.Single&gt;" name="GetEqualityComparer" is-static="true">
		<summary></summary>
				<param type="System.Single" name="tolerance" summary="" />
			</method>
	<method type="System.Int32" name="FloatToInt32Bits" is-static="true">
		<summary></summary>
				<param type="System.Single" name="f" summary="" />
			</method>
	<method type="System.Boolean" name="AlmostEqual2SComplement" is-static="true">
		<summary></summary>
				<param type="System.Single" name="a" summary="" />
				<param type="System.Single" name="b" summary="" />
				<param type="System.Int32" name="maxDeltaBits" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="System.Single" name="v1" summary="" />
				<param type="System.Single" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="T" name="t1" summary="" />
				<param type="T" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="System.Single[]" name="t1" summary="" />
				<param type="System.Single[]" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="t1" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="t1" summary="" />
				<param type="BrightData.IHaveReadOnlyTensorSegment&lt;System.Single&gt;" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.FrequencyAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Frequency analysis results
	</summary>
	<property type="System.UInt64" name="Total">
		<summary>Total number of items observed</summary>
	</property>
	<property type="System.String" name="MostFrequent">
		<summary>Most frequent item</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct items</summary>
	</property>
	<property type="(System.String Label, System.Double Value)[]" name="Frequency">
		<summary>Ranked histogram</summary>
	</property>
</class>
<class name="BrightData.Helper.GenericActivator" base="" is-static="true" is-abstract="false">
	<summary>
		Generic object creator
	</summary>
	<method type="T" name="Create" is-static="true">
		<summary>Creates a new object</summary>
				<param type="System.Type" name="type" summary="Type of object to create" />
				<param type="System.Object[]" name="args" summary="Arguments to pass to constructor" />
			</method>
	<method type="T" name="Create" is-static="true">
		<summary>Creates a new object (via default constructor)</summary>
			</method>
	<method type="T" name="CreateUninitialized" is-static="true">
		<summary>Creates a new uninitialized object (constructor is not invoked)</summary>
			</method>
	<method type="T" name="CreateUninitialized" is-static="true">
		<summary>Creates a new uninitialized object (constructor is not invoked)</summary>
				<param type="System.Type" name="type" summary="Type to create" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt gradient descent optimisers
	</summary>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad">
		<summary>Adagrad gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam">
		<summary>Adam gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum">
		<summary>Momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum">
		<summary>Nesterov momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp">
		<summary>Rms prop gradient descent</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Provides standard graph actions
	</summary>
	<method type="BrightWire.IAction" name="Constrain" is-static="false">
		<summary>Constrains the signal through the graph (either forward or backward)</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Helper.GraphData" base="" is-static="true" is-abstract="false">
	<summary>
		Graph data constants
	</summary>
</class>
<class name="BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext" base="" is-static="false" is-abstract="false">
	<summary>
		Graph engine execution context
	</summary>
	<method type="System.Void" name="GraphExecutionContext" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.IGraphEngine" name="graphEngine" summary="Graph engine" />
				<param type="System.Boolean" name="wantInputInExecutionResults" summary="True to save the graph input in the execution results" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary>Adds graph operations to the queue</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphOperation&gt;" name="operations" summary="" />
			</method>
	<method type="System.Void" name="RegisterContinuation" is-static="false">
		<summary>Registers a continuation that will be executed after the current sequence has been processed in full</summary>
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="" />
				<param type="System.Action&lt;BrightWire.IGraphContext&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="RegisterAdditionalMiniBatch" is-static="false">
		<summary>Registers an additional mini batch to execute after the current mini batch has completed</summary>
				<param type="BrightWire.IMiniBatch" name="miniBatch" summary="Mini batch to execute" />
				<param type="BrightWire.IGraphData" name="data" summary="Initial data" />
				<param type="System.Action&lt;BrightWire.IGraphContext, BrightWire.IGraphData&gt;" name="start" summary="Callback when starting the batch" />
				<param type="System.Action&lt;BrightWire.IGraphContext[]&gt;" name="end" summary="Callback when ending the batch" />
			</method>
	<property type="System.Int32" name="RemainingOperationCount">
		<summary>Count of remaining operations in queue</summary>
	</property>
	<property type="System.Boolean" name="HasContinuations">
		<summary>True if there are registered continuations or additional mini batches that still need to execute</summary>
	</property>
	<property type="System.Boolean" name="WantInputInExecutionResults">
		<summary>True if the input to the graph will be stored in the execution results</summary>
	</property>
	<method type="System.Void" name="Continue" is-static="false">
		<summary>Checks if execution should continue from a remaining continuation</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphContext Context, System.Action&lt;BrightWire.IGraphContext[]&gt; Callback)&gt;" name="ExecuteAdditionalMiniBatch" is-static="false">
		<summary>Executes any additional mini batches</summary>
				<param type="BrightWire.ILearningContext" name="learningContext" summary="" />
			</method>
	<method type="System.Boolean" name="HasMemory" is-static="false">
		<summary>Checks if a named memory slot is in use</summary>
				<param type="System.String" name="index" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="GetMemory" is-static="false">
		<summary>Returns a named memory slot</summary>
				<param type="System.String" name="index" summary="" />
			</method>
	<method type="BrightWire.IGraphOperation" name="GetNextOperation" is-static="false">
		<summary>Pops the next pending graph operation (if any)</summary>
			</method>
	<method type="System.Void" name="SetMemory" is-static="false">
		<summary>Sets a named memory slot</summary>
				<param type="System.String" name="index" summary="" />
				<param type="BrightData.IMatrix" name="memory" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory" base="" is-static="false" is-abstract="false">
	<summary>
		Creates graph nodes
	</summary>
	<method type="System.Void" name="GraphFactory" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="The linear algebra provider to use" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="A property set with initialisation data (optional)" />
			</method>
	<property type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="BrightData.BrightDataContext" name="Context">
		<summary>Bright data context</summary>
	</property>
	<property type="BrightWire.IPropertySet" name="CurrentPropertySet">
		<summary>The current property set</summary>
	</property>
	<method type="System.Void" name="PushPropertySet" is-static="false">
		<summary>Clones the current property set with an optional mutator and then pushes it onto the stack</summary>
				<param type="System.Action&lt;BrightWire.IPropertySet&gt;" name="mutator" summary="Callback that can modify the cloned property set" />
			</method>
	<method type="System.Void" name="PopPropertyStack" is-static="false">
		<summary>Pops the last property set from the stack</summary>
			</method>
	<method type="BrightWire.IGradientDescentOptimisation" name="CreateWeightUpdater" is-static="false">
		<summary>Creates a gradient descent optimiser for the given matrix</summary>
				<param type="BrightData.IMatrix" name="weight" summary="" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="GetWeightInitialisation" is-static="false">
		<summary>Returns an object that can initialize weights in the graph</summary>
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source with training data" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to train with" />
				<param type="System.Single" name="learningRate" summary="Initial learning rate" />
				<param type="System.UInt32" name="batchSize" summary="Mini batch size" />
			</method>
	<method type="BrightWire.IGraphExecutionEngine" name="CreateExecutionEngine" is-static="false">
		<summary>Creates a graph execution engine</summary>
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="The serialised graph to execute" />
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="Linear algebra provider (optional)" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of vectors</summary>
				<param type="BrightData.IVector[]" name="vectorList" summary="The list of vectors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of matrices (sequential vectors)</summary>
				<param type="BrightData.IMatrix[]" name="sequenceList" summary="The list of matrices that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of tensors</summary>
				<param type="BrightData.ITensor3D[]" name="tensorList" summary="The list of tensors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a data table</summary>
				<param type="BrightData.IDataTable" name="dataTable" summary="The data table to convert" />
				<param type="System.UInt32[]" name="featureColumns" summary="Column indices to use as features (or none to use all non target columns)" />
			</method>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase RowClassifier, System.UInt32 OutputSize)" name="CreateClassifier" is-static="false">
		<summary>Create a row classifier node</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="The classifier for each row" />
				<param type="BrightData.IDataTable" name="dataTable" summary="The data table that contains the rows to classify (linked by mini batch index)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateFeedForward" is-static="false">
		<summary>Creates a feed forward layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateDropConnect" is-static="false">
		<summary>Creates a new drop connect layer (a feed forward layer with drop out applied to the weights)</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage of connections to drop (0..1)" />
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateTiedFeedForward" is-static="false">
		<summary>Creates a layer whose weights are shared with another layer (but transposed)</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer that shares weights" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateConvolutional" is-static="false">
		<summary>Creates a convolutional layer</summary>
				<param type="System.UInt32" name="inputDepth" summary="Input depth" />
				<param type="System.UInt32" name="filterCount" summary="Number of convolutional filters" />
				<param type="System.UInt32" name="padding" summary="Padding to apply before convolutions" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate the backpropagation error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateMaxPool" is-static="false">
		<summary>Creates a max pooling convolutional layer</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateRecurrentBridge" is-static="false">
		<summary>Creates a bridge between two recurrent nodes that will copy the hidden state from one to another and copy the error signal backwards between the two</summary>
				<param type="System.String" name="fromName" summary="Name of the first recurrent node" />
				<param type="System.String" name="toName" summary="Name of the second recurrent node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateSimpleRecurrent" is-static="false">
		<summary>Creates a simple recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="Activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateElman" is-static="false">
		<summary>Creates an Elman recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateJordan" is-static="false">
		<summary>Creates a Jordan recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateOneMinusInput" is-static="false">
		<summary>Creates a node that subtracts each input from 1 (1-x)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateSequenceReverser" is-static="false">
		<summary>Creates a node that outputs the reversed index of the current sequence (for bidirectional recurrent networks)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateBatchNormalisation" is-static="false">
		<summary>Creates a node that performs batch normalization</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateGru" is-static="false">
		<summary>Creates a GRU recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateRan" is-static="false">
		<summary>Creates a Recurrent Additive Layer (recurrent)</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateLstm" is-static="false">
		<summary>Creates a LSTM recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="memorySize" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateDropOut" is-static="false">
		<summary>Creates a layer that drops random connections</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage to drop (0..1)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateOutputNode" is-static="false">
		<summary>Creates a node that writes the current forward signal as an output of the graph</summary>
				<param type="System.Int32" name="channel" summary="Output channel" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the engine's input node</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine to build with" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the selected node</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of outgoing connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to build from" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="Wire to subtract from" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Wire to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input1" summary="The node to subtract from" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input2" summary="The node to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two nodes together into a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input1" summary="First node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two nodes together into a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input1" summary="First node" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Concatenates two wires together into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Joins multiple wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder[]" name="wires" summary="Wires to join" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Joins multiple wires into a new wire</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
				<param type="BrightWire.ExecutionGraph.WireBuilder[]" name="wires" summary="Wires to join" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="BidirectionalJoin" is-static="false">
		<summary>Concatenates two wires together into a new wire, but reverses the sequence index of the second input to join</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="forwardInput" summary="Forward wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="backwardInput" summary="Backward wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="CreateWrapper" is-static="false">
		<summary>Wraps an existing node, enabling that node to be used at multiple locations in the same graph</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="nodeToWrap" summary="Node to wrap" />
				<param type="System.String" name="name" summary="Optional name to give the wrapping node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="Create" is-static="false">
		<summary>Creates a node from it's serialised model</summary>
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="node" summary="The node model" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="LeakyReluActivation" is-static="false">
		<summary>Creates a new leaky relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="ReluActivation" is-static="false">
		<summary>Creates a new relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="SigmoidActivation" is-static="false">
		<summary>Creates a new sigmoid activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="TanhActivation" is-static="false">
		<summary>Creates a new tanh activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="SoftMaxActivation" is-static="false">
		<summary>Creates a new softmax activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="ConstantWeightInitialisation" is-static="false">
		<summary>Creates a constant weight initialiser</summary>
				<param type="System.Single" name="biasValue" summary="Single bias value" />
				<param type="System.Single" name="weightValue" summary="Single weight value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="GaussianWeightInitialisation" is-static="false">
		<summary>Creates a gaussian weight initialiser</summary>
				<param type="System.Boolean" name="zeroBias" summary="True to set bias values to zero, otherwise bias initialisation is treated the same as weight initialisation" />
				<param type="System.Single" name="stdDev" summary="Standard deviation of gaussian distribution" />
				<param type="BrightWire.GaussianVarianceCalibration" name="varianceCalibration" summary="How to calibrate the variance" />
				<param type="BrightWire.GaussianVarianceCount" name="varianceCount" summary="How to count connections while calibrating connections" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="IdentityWeightInitialisation" is-static="false">
		<summary>Creates an identity weight initialiser</summary>
				<param type="System.Single" name="identityValue" summary="The value to give to each diagonal value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="XavierWeightInitialisation" is-static="false">
		<summary>Creates a xavier weight initialiser</summary>
				<param type="System.Single" name="parameter" summary="Xavier parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad" is-static="false">
		<summary>Creates an AdaGrad gradient descent optimiser</summary>
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam" is-static="false">
		<summary>Creates an Adam gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Decay parameter" />
				<param type="System.Single" name="decay2" summary="Second decay parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L1" is-static="false">
		<summary>Creates a L1 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L1 parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L2" is-static="false">
		<summary>Creates a L2 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L2 parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum" is-static="false">
		<summary>Creates a momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum" is-static="false">
		<summary>Creates a nesterov momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Nesterov momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp" is-static="false">
		<summary>Creates a rms prop gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Rms decay" />
			</method>
	<property type="BrightWire.IGradientDescentOptimisation" name="SimpleGradientDescent">
		<summary>Uses vanilla stochastic gradient descent</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" name="Regularisation">
		<summary>Prebuilt regularisation</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" name="GradientDescent">
		<summary>Prebuilt gradient descent optimisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" name="ErrorMetric">
		<summary>Error metrics</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" name="WeightInitialisation">
		<summary>Prebuilt weight initialisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider" name="GraphOperation">
		<summary>Standard graph operations</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider" name="GraphAction">
		<summary>Standard graph actions</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.GraphHelperMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Graph extension methods
	</summary>
	<method type="BrightData.IMatrix" name="ReshapeAsMatrix" is-static="true">
		<summary>Reshapes the 3D tensor as a matrix</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ReshapeAsMatrix" is-static="true">
		<summary>Reshapes the 4D tensor as a matrix</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
			</method>
</class>
<class name="BrightWire.Models.GraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>The primary execution graph</summary>
	</property>
	<property type="BrightWire.Models.DataSourceModel" name="DataSource">
		<summary>Optional data source associated with the model</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Provides standard graph operations
	</summary>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="OneDividedBy" is-static="false">
		<summary>Calculates inverse (1/x) of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="InputSquared" is-static="false">
		<summary>Calculates square (x^2) of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="SquareRootOf" is-static="false">
		<summary>Calculates square root of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="OneMinusInput" is-static="false">
		<summary>Calculates one minus graph input (1-x)</summary>
				<param type="System.String" name="name" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.IndexAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Index analysis results
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MinIndex">
		<summary>Lowest observed index</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxIndex">
		<summary>Highest observed index</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct items</summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary>Ranked histogram</summary>
	</property>
</class>
<class name="BrightWire.Models.InstanceBased.KNearestNeighbours" base="" is-static="false" is-abstract="false">
	<summary>
		K Nearest Neighbour Model
	</summary>
	<property type="System.Single[][]" name="Instance">
		<summary>The list of vectors to match against</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The corresponding list of classifications</summary>
	</property>
	<property type="System.UInt32[]" name="DataColumns">
		<summary>The vector indexes to use to encode a data table row as a vector</summary>
	</property>
	<property type="System.UInt32" name="TargetColumn">
		<summary>The vector indexes to use to encode the other column(s) as a classification target</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
				<param type="System.UInt32" name="k" summary="The number of instances to consider" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="The distance metric to compare each row with each instance" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.LinearAlgebraProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Linear algebra provider
	</summary>
	<method type="System.Void" name="LinearAlgebraProvider" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="Bright data context" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.BrightDataContext" name="Context">
		<summary>Bright data context</summary>
	</property>
	<property type="System.String" name="ProviderName">
		<summary>Provider name</summary>
	</property>
	<property type="System.Type" name="VectorType">
		<summary>Type of vectors that will be created</summary>
	</property>
	<property type="System.Type" name="MatrixType">
		<summary>Type of matrices that will be created</summary>
	</property>
	<property type="System.Type" name="Tensor3DType">
		<summary>Type of 3D tensors that will be created</summary>
	</property>
	<property type="System.Type" name="Tensor4DType">
		<summary>Type of 4D tensors that will be created</summary>
	</property>
	<method type="System.Void" name="PushScope" is-static="false">
		<summary>Adds a new scope</summary>
			</method>
	<method type="System.Void" name="PopScope" is-static="false">
		<summary>Pops that last scope and disposes all objects within that scope</summary>
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="CreateSegment" is-static="false">
		<summary>Creates a tensor segment from an array</summary>
				<param type="System.Single[]" name="data" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="CreateSegment" is-static="false">
		<summary>Creates a tensor segment</summary>
				<param type="System.UInt32" name="size" summary="Segment size" />
				<param type="System.Boolean" name="initialiseToZero" summary="True to initialize the all values in the segment to zero" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="CreateSegment" is-static="false">
		<summary>Creates a tensor segment</summary>
				<param type="System.UInt32" name="size" summary="Segment size" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="initializer" summary="Function to initialize each value in the segment" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Clone" is-static="false">
		<summary>Creates a clone of the tensor segment</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="Segment to clone" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector from a tensor segment</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector from a read only tensor segment</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector</summary>
				<param type="System.UInt32" name="size" summary="Size of the vector" />
				<param type="System.Boolean" name="initialiseToZero" summary="True to initialize each value to zero" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector from an array of floats</summary>
				<param type="System.Single[]" name="data" summary="Float array" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector</summary>
				<param type="System.UInt32" name="size" summary="Size of the vector" />
				<param type="System.Single" name="value" summary="Initial value of each item in the vector" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector from a span of floats</summary>
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="span" summary="" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector</summary>
				<param type="System.UInt32" name="size" summary="Size of the vector" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="initializer" summary="Function to initialize each value in the vector" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a new vector from an existing vector</summary>
				<param type="BrightData.IVector" name="vector" summary="Vector to clone" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector from a read only vector</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="Read only vector" />
			</method>
	<method type="BrightData.IVector" name="CreateVector" is-static="false">
		<summary>Creates a vector from an enumerable of floats</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="values" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrix" is-static="false">
		<summary>Creates a matrix from a segment</summary>
				<param type="System.UInt32" name="rowCount" summary="Number of rows" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrix" is-static="false">
		<summary>Creates a matrix from a segment</summary>
				<param type="System.UInt32" name="rowCount" summary="Number of rows" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns" />
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrix" is-static="false">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rowCount" summary="Number of rows" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns" />
				<param type="System.Boolean" name="initialiseToZero" summary="True to initialize each value to zero" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrix" is-static="false">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rowCount" summary="Number of rows" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single&gt;" name="initializer" summary="Function to initialize each value in the matrix that will receive (row index, column index)" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrix" is-static="false">
		<summary>Creates a new matrix from an existing matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="Matrix to clone" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrix" is-static="false">
		<summary>Creates a matrix from a read only matrix</summary>
				<param type="BrightData.IReadOnlyMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from the rows supplied as vectors</summary>
				<param type="BrightData.IVector[]" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from the rows supplied as read only vectors</summary>
				<param type="BrightData.IReadOnlyVector[]" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from the rows supplied</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single[]&gt;" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from the rows supplied</summary>
				<param type="System.Single[][]" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRowsAndThenDisposeInput" is-static="false">
		<summary>Creates a matrix from the rows supplied as vectors and then disposes each input vector</summary>
				<param type="BrightData.IVector[]" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from the rows supplied as tensor segments</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;[]" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from the rows supplied as tensor segments</summary>
				<param type="System.ReadOnlySpan&lt;BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;&gt;" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromRows" is-static="false">
		<summary>Creates a matrix from rows supplied</summary>
				<param type="System.ReadOnlySpan&lt;System.Single[]&gt;" name="rows" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied as vectors</summary>
				<param type="BrightData.IVector[]" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied as read only vectors</summary>
				<param type="BrightData.IReadOnlyVector[]" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single[]&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied</summary>
				<param type="System.Single[][]" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumnsAndThenDisposeInput" is-static="false">
		<summary>Creates a matrix from the columns supplied as vectors and then disposes each input vector</summary>
				<param type="BrightData.IVector[]" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied as tensor segments</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;[]" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied as tensor segments</summary>
				<param type="System.ReadOnlySpan&lt;BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="CreateMatrixFromColumns" is-static="false">
		<summary>Creates a matrix from the columns supplied</summary>
				<param type="System.ReadOnlySpan&lt;System.Single[]&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor</summary>
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rowCount" summary="Rows in each matrix" />
				<param type="System.UInt32" name="columnCount" summary="Columns in each matrix" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor</summary>
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rowCount" summary="Rows in each matrix" />
				<param type="System.UInt32" name="columnCount" summary="Columns in each matrix" />
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor</summary>
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="rowCount" summary="Rows in each matrix" />
				<param type="System.UInt32" name="columnCount" summary="Columns in each matrix" />
				<param type="System.Boolean" name="initialiseToZero" summary="True to initialize each value to zero" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor from existing matrices</summary>
				<param type="BrightData.IMatrix[]" name="matrices" summary="Matrices that will form the 3D tensor" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor from existing matrices</summary>
				<param type="BrightData.IReadOnlyMatrix[]" name="matrices" summary="Matrices that will form the 3D tensor" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor from another 3D tensor (clone)</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor from a read only 3D tensor</summary>
				<param type="BrightData.IReadOnlyTensor3D" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3DAndThenDisposeInput" is-static="false">
		<summary>Creates a 3D tensor from existing matrices and then disposes each matrix</summary>
				<param type="BrightData.IMatrix[]" name="matrices" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3DAndThenDisposeInput" is-static="false">
		<summary>Creates a 3D tensor from existing matrices and then disposes each matrix</summary>
				<param type="System.Span&lt;BrightData.IMatrix&gt;" name="matrices" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="CreateTensor3D" is-static="false">
		<summary>Creates a 3D tensor from existing matrices</summary>
				<param type="System.Span&lt;T&gt;" name="matrices" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor</summary>
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rowCount" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns in each matrix" />
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor</summary>
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rowCount" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns in each matrix" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="data" summary="Tensor segment" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor</summary>
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.UInt32" name="depth" summary="Number of matrices in each 3D tensor" />
				<param type="System.UInt32" name="rowCount" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columnCount" summary="Number of columns in each matrix" />
				<param type="System.Boolean" name="initialiseToZero" summary="True to initialize each value to zero" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor from existing 3D tensors</summary>
				<param type="BrightData.ITensor3D[]" name="tensors" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor from existing 3D tensors</summary>
				<param type="BrightData.IReadOnlyTensor3D[]" name="tensors" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Clones this 4D tensor</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor from an existing 4D tensor</summary>
				<param type="BrightData.IReadOnlyTensor4D" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4DAndThenDisposeInput" is-static="false">
		<summary>Creates a 4D tensor from existing 3D tensors and then disposes each 3D tensor</summary>
				<param type="BrightData.ITensor3D[]" name="tensors" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4DAndThenDisposeInput" is-static="false">
		<summary>Creates a 4D tensor from existing 3D tensors and then disposes each 3D tensor</summary>
				<param type="System.Span&lt;BrightData.ITensor3D&gt;" name="tensors" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="CreateTensor4D" is-static="false">
		<summary>Creates a 4D tensor from existing 3D tensors</summary>
				<param type="System.Span&lt;T&gt;" name="tensors" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="MapParallel" is-static="false">
		<summary>Applies a mapping function to each value in the segment to create a new segment (potentially in parallel)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mapper" summary="Mapping function that receives each value from the segment" />
			</method>
	<method type="System.Void" name="MapParallelInPlace" is-static="false">
		<summary>Applies a mapping function to each value in the segment in place (potentially in parallel)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mapper" summary="Mapping function that receives each value from the segment" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="MapParallel" is-static="false">
		<summary>Applies a mapping function to each value in the segment to create a new segment (potentially in parallel)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Func&lt;System.UInt32, System.Single, System.Single&gt;" name="mapper" summary="Mapping function that receives the index and each value from the segment" />
			</method>
	<method type="System.Void" name="MapParallelInPlace" is-static="false">
		<summary>Applies a mapping function to each value in the segment in place (potentially in parallel)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Func&lt;System.UInt32, System.Single, System.Single&gt;" name="mapper" summary="Mapping function that receives the index and each value from the segment" />
			</method>
	<method type="BrightData.ITensor" name="CreateTensor" is-static="false">
		<summary>Creates a tensor from a tensor shape</summary>
				<param type="System.UInt32[]" name="shape" summary="Array containing the size of each dimension in the tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="Tensor segment" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Add" is-static="false">
		<summary>Adds two tensors into a new tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Add" is-static="false">
		<summary>Adds two tensors into a new tensor and applies coefficients to each element in the two tensors</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Add" is-static="false">
		<summary>Creates a new tensor from adding a scalar to each element in the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary>Adds another tensor to the first tensor which will be modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="target" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="other" summary="Other tensor" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary>Adds another tensor to the first tensor and applies coefficients to each element in each tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="target" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="other" summary="Other tensor" />
				<param type="System.Single" name="coefficient1" summary="Coefficient applied to each element of the first tensor" />
				<param type="System.Single" name="coefficient2" summary="Coefficient applied to each element of the other tensor" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary>Adds a scalar to each element of this tensor - modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="target" summary="" />
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace" is-static="false">
		<summary>Multiplies each element of the tensor by a scalar - modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="target" summary="" />
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Multiply" is-static="false">
		<summary>Creates a new tensor by multiplying each element of the tensor with a scalar</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="target" summary="" />
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Subtract" is-static="false">
		<summary>Subtracts the second tensor from the first tensor into a new tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Subtract" is-static="false">
		<summary>Subtracts the second tensor from the first tensor into a new tensor and applies coefficients to each value in each tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
				<param type="System.Single" name="coefficient1" summary="Coefficient to apply to each element in the first tensor" />
				<param type="System.Single" name="coefficient2" summary="Coefficient to apply to each element in the second tensor" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary>Subtracts the second tensor from the first tensor - first tensor modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary>Subtracts the second tensor from the first tensor and applies coefficient to each value in the tensors - first tensor modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
				<param type="System.Single" name="coefficient1" summary="Coefficient to apply to each element in the first tensor" />
				<param type="System.Single" name="coefficient2" summary="Coefficient to apply to each element in the second tensor" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="PointwiseMultiply" is-static="false">
		<summary>Creates a new tensor by multiplying each element in the first tensor with the corresponding value in the second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace" is-static="false">
		<summary>Multiplies each element in the first tensor with the corresponding value in the second tensor - first tensor modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="PointwiseDivide" is-static="false">
		<summary>Creates a new tensor by dividing each element in the first tensor with the corresponding value in the second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace" is-static="false">
		<summary>Dividing each element in the first tensor with the corresponding value in the second tensor - first tensor is modified in place</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Single" name="DotProduct" is-static="false">
		<summary>Calculates the dot product of the first with the second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Sqrt" is-static="false">
		<summary>Creates a new tensor that contains the square root of each value in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.Single" name="adjustment" summary="A small value to add to each value in case of zeros" />
			</method>
	<method type="System.Void" name="ConstrainInPlace" is-static="false">
		<summary>Constrains each value in this tensor to lie between the min and max values (if supplied)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.Nullable&lt;System.Single&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;System.Single&gt;" name="maxValue" summary="" />
			</method>
	<method type="System.Single" name="Average" is-static="false">
		<summary>Finds the average of the values in the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Single" name="L1Norm" is-static="false">
		<summary>Finds the L1 norm (manhattan distance) of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Single" name="L2Norm" is-static="false">
		<summary>Finds the L2 norm (euclidean distance) of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="(System.Single Min, System.Single Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues" is-static="false">
		<summary>Finds the minimum and maximum values of the tensor (and their corresponding indices)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetMinIndex" is-static="false">
		<summary>Finds the index of the minimum value of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="false">
		<summary>Finds the index of the maximum value of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Single" name="GetMin" is-static="false">
		<summary>Finds the minimum value of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Single" name="GetMax" is-static="false">
		<summary>Finds the maximum value of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite" is-static="false">
		<summary>Checks if the tensor is entirely finite (not NaN or Infinity)</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Reverse" is-static="false">
		<summary>Reverse the order of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;&gt;" name="Split" is-static="false">
		<summary>Splits the tensor into separate (contiguous) sub tensors</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.UInt32" name="blockCount" summary="Number of blocks to split into" />
			</method>
	<method type="System.Single" name="CosineDistance" is-static="false">
		<summary>Finds the cosine distance between the first and second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Single" name="EuclideanDistance" is-static="false">
		<summary>Finds the euclidean distance between the first and second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance" is-static="false">
		<summary>Finds the mean squared distance between the first and second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Single" name="SquaredEuclideanDistance" is-static="false">
		<summary>Finds the squared euclidean distance between the first and second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="System.Single" name="ManhattanDistance" is-static="false">
		<summary>Finds the manhattan distance between the first and second tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor1" summary="First tensor" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor2" summary="Second tensor" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Abs" is-static="false">
		<summary>Creates a new tensor that contains the absolute value of each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Log" is-static="false">
		<summary>Creates a new tensor that contains the natural logarithm of each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Exp" is-static="false">
		<summary>Creates a new tensor that contains the exponent of each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Squared" is-static="false">
		<summary>Creates a new tensor that contains the square of each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Single" name="StdDev" is-static="false">
		<summary>Finds the standard deviation of each element in the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="Pre-calculated mean of the tensor or null to calculate" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Sigmoid" is-static="false">
		<summary>Creates a new tensor that contains the sigmoid function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="SigmoidDerivative" is-static="false">
		<summary>Creates a new tensor that contains the derivative of the sigmoid function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Tanh" is-static="false">
		<summary>Creates a new tensor that contains the tanh function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="TanhDerivative" is-static="false">
		<summary>Creates a new tensor that contains the derivative of the tanh function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Relu" is-static="false">
		<summary>Creates a new tensor that contains the relu function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="ReluDerivative" is-static="false">
		<summary>Creates a new tensor that contains the derivative of the relu function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="LeakyRelu" is-static="false">
		<summary>Creates a new tensor that contains the leaky relu function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="LeakyReluDerivative" is-static="false">
		<summary>Creates a new tensor that contains the derivative of the leaky relu function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Softmax" is-static="false">
		<summary>Creates a new tensor that contains the softmax function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="SoftmaxDerivative" is-static="false">
		<summary>Creates a new tensor that contains the derivative of the softmax function applied to each element in this tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="Pow" is-static="false">
		<summary>Creates a new tensor that each element of the tensor raised to the specified power</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.Single" name="power" summary="" />
			</method>
	<method type="System.Void" name="RoundInPlace" is-static="false">
		<summary>Rounds each element in the tensor to be either the lower or the upper parameter depending on its distance</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.Single" name="lower" summary="" />
				<param type="System.Single" name="upper" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;" name="CherryPickIndices" is-static="false">
		<summary>Returns a new tensor with only the supplied indices</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Transpose" is-static="false">
		<summary>Calculate the matrix transpose</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IVector" name="Multiply" is-static="false">
		<summary>Multiplies the matrix with a vector</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Multiply" is-static="false">
		<summary>Matrix multiplication</summary>
				<param type="BrightData.IMatrix" name="matrix1" summary="" />
				<param type="BrightData.IMatrix" name="matrix2" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="TransposeSecondAndMultiply" is-static="false">
		<summary>Transposes the second matrix and then multiplies the first with the second matrix</summary>
				<param type="BrightData.IMatrix" name="matrix1" summary="" />
				<param type="BrightData.IMatrix" name="matrix2" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="TransposeFirstAndMultiply" is-static="false">
		<summary>Transposes the first matrix and then multiplies with the second matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.IMatrix" name="other" summary="" />
			</method>
	<method type="BrightData.IVector" name="GetDiagonal" is-static="false">
		<summary>Returns the matrix diagonal</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IVector" name="RowSums" is-static="false">
		<summary>Returns the sum of each row</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IVector" name="ColumnSums" is-static="false">
		<summary>Returns the sum of each column</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IVector" name="ColumnSums" is-static="false">
		<summary>Returns the sum of each matrix column</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
			</method>
	<method type="BrightData.IVector" name="RowSums" is-static="false">
		<summary>Returns the sum of each matrix row</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
			</method>
	<method type="(BrightData.IMatrix U, BrightData.IVector S, BrightData.IMatrix VT)" name="Svd" is-static="false">
		<summary>Calculates the singular value decomposition of the matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
			</method>
	<method type="System.Void" name="L1Regularisation" is-static="false">
		<summary>In place L1 regularization of the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.Single" name="coefficient" summary="" />
			</method>
	<method type="(BrightData.IMatrix Left, BrightData.IMatrix Right)" name="SplitAtColumn" is-static="false">
		<summary>Splits the matrix at the specified column index into two sub matrices</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="(BrightData.IMatrix Top, BrightData.IMatrix Bottom)" name="SplitAtRow" is-static="false">
		<summary>Splits the matrix at the specified row index into two sub matrices</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ConcatColumns" is-static="false">
		<summary>Concatenates the two matrices (column count must agree)</summary>
				<param type="BrightData.IMatrix" name="top" summary="" />
				<param type="BrightData.IMatrix" name="bottom" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="ConcatRows" is-static="false">
		<summary>Concatenates the two matrices (row count must agree)</summary>
				<param type="BrightData.IMatrix" name="left" summary="" />
				<param type="BrightData.IMatrix" name="right" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="AddPadding" is-static="false">
		<summary>Applies zero padding to each matrix in the tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="RemovePadding" is-static="false">
		<summary>Removes padding from each matrix in a tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="Im2Col" is-static="false">
		<summary>Applies the convolutional operator the 3D tensor to obtain a matrix</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="ReverseIm2Col" is-static="false">
		<summary>Reverses a previous Im2Col operation</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.IMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="(BrightData.ITensor3D Result, BrightData.ITensor3D Indices)" name="MaxPool" is-static="false">
		<summary>Calculates the max pooling operator of the 3D tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="ReverseMaxPool" is-static="false">
		<summary>Calculates a reverse max pool operation</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.ITensor3D" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="AddMatrices" is-static="false">
		<summary>Creates the pointwise sum of each matrix within the 3D tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Multiply" is-static="false">
		<summary>Multiplies each sub matrix within the 3D tensor with another matrix</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.IMatrix" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeFirstAndMultiply" is-static="false">
		<summary>Transposes each sub matrix within the 3D tensor and then multiplies them with another matrix</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.IMatrix" name="other" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRow" is-static="false">
		<summary>Adds a vector to each row of each matrix within the tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn" is-static="false">
		<summary>Adds a vector to each column of each matrix within the tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.IVector" name="vector" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Multiply" is-static="false">
		<summary>Multiplies each sub matrix within the 3D tensor with a reshaped matrix from each sub 3D tensor within the 4D tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeFirstAndMultiply" is-static="false">
		<summary>Multiplies each transposed sub matrix within the 3D tensor with a reshaped matrix from each sub 3D tensor within the 4D tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="TransposeSecondAndMultiply" is-static="false">
		<summary>Multiplies each sub matrix within the 3D tensor with the transposed reshaped matrix from each sub 3D tensor within the 4D tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="BrightData.ITensor4D" name="other" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="AddPadding" is-static="false">
		<summary>Adds padding to each sub matrix</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="RemovePadding" is-static="false">
		<summary>Removes padding from each sub matrix</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="(BrightData.ITensor4D Result, BrightData.ITensor4D Indices)" name="MaxPool" is-static="false">
		<summary>Applies a max pooling operation to the 4D tensor</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="ReverseMaxPool" is-static="false">
		<summary>Reverses a max pooling operation</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="BrightData.ITensor4D" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="Im2Col" is-static="false">
		<summary>Convolutional operation applied to each sub tensor</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.ITensor4D" name="ReverseIm2Col" is-static="false">
		<summary>Reverses the convolutional operator on each sub tensor</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="BrightData.IMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="GetMatrix" is-static="false">
		<summary>Returns a sub matrix from the 3D tensor</summary>
				<param type="BrightData.ITensor3D" name="tensor" summary="" />
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.ITensor3D" name="GetTensor" is-static="false">
		<summary>Returns a sub tensor from the 4D tensor</summary>
				<param type="BrightData.ITensor4D" name="tensor" summary="" />
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="GetNewMatrixFromRows" is-static="false">
		<summary>Returns a new matrix from the specified row indices</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndices" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="GetNewMatrixFromColumns" is-static="false">
		<summary>Returns a new matrix from the specified column indices</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRow" is-static="false">
		<summary>Adds a tensor to each row of the matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn" is-static="false">
		<summary>Adds a tensor to each column of the matrix</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="MultiplyEachRowWith" is-static="false">
		<summary>Multiplies each row of the matrix with the tensor</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="MultiplyEachColumnWith" is-static="false">
		<summary>Multiplies each column of the matrix with the tensor</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.IMatrix" name="FindDistances" is-static="false">
		<summary>Finds the distance between each pair of vectors</summary>
				<param type="BrightData.IVector[]" name="vectors" summary="First set of vectors" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IVector&gt;" name="compareTo" summary="Second set of vectors" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric" />
			</method>
	<method type="System.Void" name="BindThread" is-static="false">
		<summary>Binds a new thread to this provider</summary>
			</method>
	<method type="System.Single" name="Sum" is-static="false">
		<summary>Returns the sum of values in the tensor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="MultiSoftmax" is-static="false">
		<summary>Calculates the softmax of a set of tensors</summary>
				<param type="System.ArraySegment&lt;BrightData.INumericSegment&lt;System.Single&gt;&gt;" name="segments" summary="" />
			</method>
	<method type="BrightData.IMatrix[]" name="MultiSoftmaxDerivative" is-static="false">
		<summary>Calculates the softmax derivative of a set of tensors</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="segments" summary="" />
			</method>
	<method type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="SoftmaxDerivativePerRow" is-static="false">
		<summary>Computes the per row softmax derivative</summary>
				<param type="BrightData.IMatrix" name="matrix" summary="" />
				<param type="BrightData.INumericSegment&lt;System.Single&gt;[]" name="rows" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing two items at a time
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;[]" name="Observations">
		<summary>The list of observations</summary>
	</property>
	<method type="System.Void" name="MarkovModel2" is-static="false">
		<summary>Constructor</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;&gt;" name="observations" summary="" />
			</method>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing the last three observations
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;[]" name="Observations">
		<summary>The list of observations</summary>
	</property>
	<method type="System.Void" name="MarkovModel3" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;&gt;" name="observations" summary="" />
			</method>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding two items
	</summary>
	<property type="T" name="Item1">
		<summary>The second last preceding item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The last preceding item</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="Transition">
		<summary>The list of possible transitions from this state</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals override</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hash code override</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding three instances
	</summary>
	<property type="T" name="Item1">
		<summary>The third last item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The second last item</summary>
	</property>
	<property type="T" name="Item3">
		<summary>The third last item</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="Transitions">
		<summary>The list of associated transitions</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals override</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hashcode override</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model state transition
	</summary>
	<property type="T" name="NextState">
		<summary>The next state</summary>
	</property>
	<property type="System.Single" name="Probability">
		<summary>The probability of this next state</summary>
	</property>
	<method type="System.Void" name="MarkovModelStateTransition" is-static="false">
		<summary>Constructor</summary>
				<param type="T" name="nextState" summary="" />
				<param type="System.Single" name="probability" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment" base="BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment" is-static="false" is-abstract="false">
	<summary>
		A tensor segment that temporarily owns a buffer from an array pool
	</summary>
	<method type="System.Void" name="MemoryOwnerTensorSegment" is-static="false">
		<summary>Constructor</summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.MemoryOwner&lt;System.Single&gt;" name="data" summary="Rented buffer from pool" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="AddRef" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="Release" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
	<property type="System.String" name="SegmentType">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="ToNewArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary></summary>
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="span" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="sourceOffset" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Types.MetaData" base="" is-static="false" is-abstract="false">
	<summary>
		Unstructured meta data store
	</summary>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="Existing meta data to copy from" />
				<param type="System.String[]" name="keys" summary="Keys to copy (or all if none specified)" />
			</method>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metaData" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary>Creates metadata from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="Reader" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary>Copies this to another metadata store</summary>
				<param type="BrightData.Types.MetaData" name="metadata" summary="Other meta data store" />
				<param type="System.String[]" name="keys" summary="Keys to copy (optional)" />
			</method>
	<method type="System.Object" name="Get" is-static="false">
		<summary>Returns a value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
			</method>
	<method type="T" name="GetNullable" is-static="false">
		<summary>Returns a typed nullable value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary>Returns a typed value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
				<param type="T" name="valueIfMissing" summary="Value to return if the value has not been set" />
			</method>
	<method type="T" name="GetOrThrow" is-static="false">
		<summary>Returns an existing value (throws if not found)</summary>
				<param type="System.String" name="name" summary="Name of the value" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary>Sets a named value</summary>
				<param type="System.String" name="name" summary="Name of the value" />
				<param type="T" name="value" summary="Value" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>XML representation of the metadata</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes meta data</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary>Reads values from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetStringsWithPrefix" is-static="false">
		<summary>Returns all value names with the specified prefix</summary>
				<param type="System.String" name="prefix" summary="Prefix to query" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.String Name, System.IConvertible Value, System.String StringValue)&gt;" name="GetNonEmpty" is-static="false">
		<summary>Returns non empty metadata</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Has" is-static="false">
		<summary>Checks if a value has been set</summary>
				<param type="System.String" name="key" summary="Name of the value" />
			</method>
	<method type="System.Void" name="Remove" is-static="false">
		<summary>Removes a value</summary>
				<param type="System.String" name="key" summary="Name of the value" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="AllKeys">
		<summary>Returns all keys that have been set</summary>
	</property>
	<method type="BrightData.Types.MetaData" name="Clone" is-static="false">
		<summary>Creates a clone of the current metadata</summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Helper.MiniBatch" base="" is-static="false" is-abstract="false">
	<summary>
		Information about the current mini batch
	</summary>
	<method type="System.Void" name="MiniBatch" is-static="false">
		<summary>Creates a non sequential mini batch</summary>
				<param type="System.UInt32[]" name="rows" summary="The indices of the rows in this mini batch" />
				<param type="BrightWire.IDataSource" name="dataSource" summary="Associated data source" />
				<param type="BrightWire.IGraphData" name="input" summary="Mini batch input data" />
				<param type="BrightWire.IGraphData" name="output" summary="Expected output data (when training, otherwise null)" />
			</method>
	<method type="System.Void" name="MiniBatch" is-static="false">
		<summary>Creates a sequential mini batch</summary>
				<param type="System.UInt32[]" name="rows" summary="The indices of the rows in this mini batch" />
				<param type="BrightWire.IDataSource" name="dataSource" summary="Associated data source" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary>Adds another item to the sequential mini batch</summary>
				<param type="BrightWire.MiniBatchSequenceType" name="type" summary="Type of the sequential item" />
				<param type="BrightWire.IGraphData" name="input" summary="Mini batch input data" />
				<param type="BrightWire.IGraphData" name="output" summary="Expected output data (when training, otherwise null)" />
			</method>
	<property type="System.UInt32[]" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Data source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<property type="System.UInt32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="System.Void" name="Reset" is-static="false">
		<summary>Resets the sequence iterator</summary>
			</method>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence" is-static="false">
		<summary>Gets the next item in the sequence (or null if none)</summary>
			</method>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex" is-static="false">
		<summary>Gets a sequence item</summary>
				<param type="System.UInt32" name="index" summary="The index to retrieve" />
			</method>
	<property type="BrightWire.IMiniBatch" name="NextMiniBatch">
		<summary>Subsequent mini batch</summary>
	</property>
	<property type="BrightWire.IMiniBatch" name="PreviousMiniBatch">
		<summary>Previous mini batch</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.MultiGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept input on an arbitrary number of channels and output a single signal
	</summary>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class[]" name="ClassData">
		<summary>The list of possible classifications</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary[]" name="Class">
		<summary>A list of possible classifications and their data</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.DecisionTree.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node in the decision tree
	</summary>
	<property type="BrightWire.Models.TreeBased.DecisionTree.Node[]" name="Children">
		<summary>The nodes children</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary>The column index that is being split on</summary>
	</property>
	<property type="System.String" name="MatchLabel">
		<summary>The value to match this node</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Split">
		<summary>The value to split on</summary>
	</property>
	<property type="System.String" name="Classification">
		<summary>This node's classification label</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the node as XML</summary>
				<param type="System.Xml.XmlWriter" name="writer" summary="The XML writer" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.ExecutionGraphModel.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node within the graph
	</summary>
	<method type="System.Void" name="Node" is-static="false">
		<summary>Default constructor</summary>
			</method>
	<method type="System.Void" name="Node" is-static="false">
		<summary>Initialize from binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.String" name="TypeName">
		<summary>The .NET type name of the node type</summary>
	</property>
	<property type="System.String" name="Id">
		<summary>The unique id within the graph</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Node friendly name</summary>
	</property>
	<property type="System.String" name="Description">
		<summary>A short description of the node</summary>
	</property>
	<property type="System.Byte[]" name="Data">
		<summary>The node's parameters</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.NodeBase" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for graph nodes
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Disposal</summary>
			</method>
	<property type="System.String" name="Id">
		<summary>The node's unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The node's name in the graph</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.ExecutionGraph.Helper.WireToNode&gt;" name="Output">
		<summary>The list of outgoing wires along which the output signal will be sent</summary>
	</property>
	<method type="System.Void" name="Forward" is-static="false">
		<summary>Executes the graph</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="Initial data" />
				<param type="BrightWire.IGraphContext" name="context" summary="Context" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="prev" summary="" />
			</method>
	<method type="(BrightWire.ExecutionGraph.Node.NodeBase FromNode, BrightWire.IGraphData Output, System.Func&lt;BrightWire.IBackpropagate&gt; BackProp)" name="ForwardSingleStep" is-static="false">
		<summary>Executes a single forward step</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="source" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel.Node" name="SerialiseTo" is-static="false">
		<summary>Serialise this node and any connected nodes</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraphModel.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraphModel.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise" is-static="false">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="graph" summary="The complete graph" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Serialise the node</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Binary writer" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary>Deserialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader" />
			</method>
	<method type="System.Void" name="Initialise" is-static="false">
		<summary>Initialise the node from serialised data</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Unique id" />
				<param type="System.String" name="name" summary="Node name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="FindByName" is-static="false">
		<summary>Finds a connected node by friendly name</summary>
				<param type="System.String" name="name" summary="The node's name to search for" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="FindById" is-static="false">
		<summary>Finds a connected node by id</summary>
				<param type="System.String" name="id" summary="Unique id to find" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.ExecutionGraph.Node.NodeBase&gt;" name="SubNodes">
		<summary>The list of sub-nodes</summary>
	</property>
	<method type="System.Void" name="LoadParameters" is-static="false">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="FindSubNodeByNameOrThrow" is-static="false">
		<summary>Finds a sub node by name, or throws an exception if not found</summary>
				<param type="System.String" name="name" summary="Sub node name" />
			</method>
	<method type="System.Void" name="RemoveDirectDescendant" is-static="false">
		<summary>Removes the wire that connects this from a direct descendant</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="directDescendant" summary="" />
			</method>
	<method type="System.Void" name="ApplyError" is-static="false">
		<summary>Applies an error to this node</summary>
				<param type="BrightWire.NodeErrorType" name="type" summary="Error type" />
				<param type="BrightData.ITensor" name="delta" summary="" />
				<param type="BrightWire.ILearningContext" name="context" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.NormalisationModel" base="" is-static="false" is-abstract="false">
	<summary>
		Normalization parameters
	</summary>
	<method type="System.Void" name="NormalisationModel" is-static="false">
		<summary>Creates a new set of parameters based on supplied the numeric analysis</summary>
				<param type="BrightData.NormalizationType" name="type" summary="Type of normalization" />
				<param type="BrightData.Types.MetaData" name="analysedMetaData" summary="Numeric analysis" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the normalization parameters to a meta data store</summary>
				<param type="BrightData.Types.MetaData" name="metaData" summary="" />
			</method>
	<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary>Type of normalization</summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary>Value that will be divided (after subtraction)</summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary>Value that will be subtracted</summary>
	</property>
	<method type="System.Double" name="Normalize" is-static="false">
		<summary>Normalizes a value with the parameters</summary>
				<param type="System.Double" name="val" summary="Value to normalize" />
			</method>
	<method type="System.Double" name="ReverseNormalize" is-static="false">
		<summary>Reverse a normalized value</summary>
				<param type="System.Double" name="val" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.NumericAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		Numeric analysis results
	</summary>
	<property type="System.Double" name="L1Norm">
		<summary>L1 Norm</summary>
	</property>
	<property type="System.Double" name="L2Norm">
		<summary>L2 Norm</summary>
	</property>
	<property type="System.Double" name="Min">
		<summary>Minimum observed value</summary>
	</property>
	<property type="System.Double" name="Max">
		<summary>Maximum observed value</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>Mean of values</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="SampleVariance">
		<summary>Sample variance of values</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="SampleStdDev">
		<summary>Sample standard deviation</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="PopulationVariance">
		<summary>Population variance of values</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="PopulationStdDev">
		<summary>Population standard deviation</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Median">
		<summary>Median value</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Mode">
		<summary>Mode (most frequent value)</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary>Number of distinct values</summary>
	</property>
	<property type="System.UInt64" name="Total">
		<summary>Total count of items</summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary>Ranked histogram</summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="FrequencyRange">
		<summary>Bucketed histogram</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.MiniBatchProvider.Operation" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.IMiniBatch" name="GetMiniBatch" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.Or" base="" is-static="true" is-abstract="false">
	<summary>
		Simple OR training data
	</summary>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Get" is-static="true">
		<summary>Generates a data table containing OR training data</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.RandomForest" base="" is-static="false" is-abstract="false">
	<summary>
		A random forest model
	</summary>
	<property type="BrightWire.Models.TreeBased.DecisionTree[]" name="Forest">
		<summary>The list of trees in the forest</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		Read only matrix
	</summary>
	<method type="System.Void" name="ReadOnlyMatrix" is-static="false">
		<summary>Creates a matrix from bytes</summary>
				<param type="System.ReadOnlySpan&lt;System.Byte&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyMatrix" is-static="false">
		<summary>Creates a matrix from float memory</summary>
				<param type="System.ReadOnlyMemory&lt;System.Single&gt;" name="data" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyMatrix" is-static="false">
		<summary>Creates an empty matrix</summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyMatrix" is-static="false">
		<summary>Creates a matrix from the initializer</summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single&gt;" name="initializer" summary="" />
			</method>
	<property type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="ReadOnlySegment">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.IMatrix" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper" name="Row" is-static="false">
		<summary>Returns a row segment</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper" name="Column" is-static="false">
		<summary>Returns a column segment</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetRow" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="GetColumn" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector[]" name="AllRows" is-static="false">
		<summary>Returns all rows as vectors</summary>
			</method>
	<method type="BrightData.IReadOnlyVector[]" name="AllColumns" is-static="false">
		<summary>Returns all columns as vectors</summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix" name="other" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Enumerates all values in the matrix</summary>
	</property>
	<property type="System.ReadOnlySpan&lt;System.Byte&gt;" name="DataAsBytes">
		<summary></summary>
	</property>
</class>
<class name="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D" base="" is-static="false" is-abstract="false">
	<summary>
		Read only tensor
	</summary>
	<method type="System.Void" name="ReadOnlyTensor3D" is-static="false">
		<summary>Creates a tensor from matrices</summary>
				<param type="BrightData.IReadOnlyMatrix[]" name="matrices" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyTensor3D" is-static="false">
		<summary>Creates a tensor from byte data</summary>
				<param type="System.ReadOnlySpan&lt;System.Byte&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyTensor3D" is-static="false">
		<summary>Creates a tensor from float memory</summary>
				<param type="System.ReadOnlyMemory&lt;System.Single&gt;" name="data" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<property type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="ReadOnlySegment">
		<summary></summary>
	</property>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.ITensor3D" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
	<method type="BrightData.IReadOnlyMatrix" name="GetMatrix" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D" name="other" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="System.ReadOnlySpan&lt;System.Byte&gt;" name="DataAsBytes">
		<summary></summary>
	</property>
</class>
<class name="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D" base="" is-static="false" is-abstract="false">
	<summary>
		Read only 4D tensor
	</summary>
	<method type="System.Void" name="ReadOnlyTensor4D" is-static="false">
		<summary>Creates a 4D tensor from 3D tensors</summary>
				<param type="BrightData.IReadOnlyTensor3D[]" name="tensors" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyTensor4D" is-static="false">
		<summary>Creates a tensor from bytes</summary>
				<param type="System.ReadOnlySpan&lt;System.Byte&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyTensor4D" is-static="false">
		<summary>Creates a tensor from float memory</summary>
				<param type="System.ReadOnlyMemory&lt;System.Single&gt;" name="data" summary="" />
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TensorSize">
		<summary></summary>
	</property>
	<property type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="ReadOnlySegment">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.ITensor4D" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
	<method type="BrightData.IReadOnlyTensor3D" name="GetTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D" name="other" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="System.ReadOnlySpan&lt;System.Byte&gt;" name="DataAsBytes">
		<summary></summary>
	</property>
</class>
<class name="BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper" base="" is-static="false" is-abstract="false">
	<summary>
		Read only tensor segment wrapper
	</summary>
	<method type="System.Void" name="ReadOnlyTensorSegmentWrapper" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="segment" summary="Tensor segment to wrap" />
				<param type="System.UInt32" name="offset" summary="First index within the wrapped tensor segment" />
				<param type="System.UInt32" name="stride" summary="Stride within the wrapped tensor segment" />
				<param type="System.UInt32" name="length" summary="Number of values in this tensor segment" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="AddRef" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Int32" name="Release" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.String" name="SegmentType">
		<summary></summary>
	</property>
	<property type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="UnderlyingSegment">
		<summary>The segment that was wrapped by this tensor segment</summary>
	</property>
	<property type="System.UInt32" name="Offset">
		<summary>First index within the wrapped tensor segment</summary>
	</property>
	<property type="System.UInt32" name="Stride">
		<summary>Stride within the wrapped tensor segment</summary>
	</property>
	<property type="System.Boolean" name="IsWrapper">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="ToNewArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="sourceOffset" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="System.Span&lt;System.Single&gt;" name="destination" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="System.Single*" name="destination" summary="" />
				<param type="System.Int32" name="offset" summary="" />
				<param type="System.Int32" name="stride" summary="" />
				<param type="System.Int32" name="count" summary="" />
			</method>
	<property type="BrightData.IHaveReadOnlyContiguousSpan&lt;System.Single&gt;" name="Contiguous">
		<summary></summary>
	</property>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" base="" is-static="false" is-abstract="false">
	<summary>
		Read only vector
	</summary>
	<method type="System.Void" name="ReadOnlyVector" is-static="false">
		<summary>Creates a vector from float memory</summary>
				<param type="System.ReadOnlyMemory&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyVector" is-static="false">
		<summary>Creates a vector from bytes</summary>
				<param type="System.ReadOnlySpan&lt;System.Byte&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyVector" is-static="false">
		<summary>Creates an empty vector</summary>
				<param type="System.UInt32" name="size" summary="" />
			</method>
	<method type="System.Void" name="ReadOnlyVector" is-static="false">
		<summary>Creates a vector from the initializer</summary>
				<param type="System.UInt32" name="size" summary="" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="initializer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.ReadOnlySpan&lt;System.Single&gt;" name="GetSpan" is-static="false">
		<summary></summary>
				<param type="CommunityToolkit.HighPerformance.Buffers.SpanOwner&lt;System.Single&gt;" name="temp" summary="" />
				<param type="System.Boolean" name="wasTempUsed" summary="" />
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.IVector" name="Create" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.LinearAlgebraProvider" name="lap" summary="" />
			</method>
	<property type="BrightData.IReadOnlyNumericSegment&lt;System.Single&gt;" name="ReadOnlySegment">
		<summary></summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector" name="other" summary="" />
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="System.ReadOnlySpan&lt;System.Byte&gt;" name="DataAsBytes">
		<summary></summary>
	</property>
	<property type="System.ReadOnlySpan&lt;System.Single&gt;" name="ReadOnlySpan">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Enumerates all values in the vector</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.ReberGrammar" base="" is-static="false" is-abstract="false">
	<summary>
		Generates Reber grammar sequences: https://www.willamette.edu/~gorr/classes/cs449/reber.html
	</summary>
	<method type="System.Char" name="GetChar" is-static="true">
		<summary>Gets the character at the specified index</summary>
				<param type="System.Int32" name="index" summary="Index to query" />
			</method>
	<method type="System.Int32" name="GetIndex" is-static="true">
		<summary>Gets the index for the specified character</summary>
				<param type="System.Char" name="ch" summary="The character to query" />
			</method>
	<method type="BrightData.IReadOnlyMatrix" name="Encode" is-static="true">
		<summary>Encodes a reber sequence as a sequence of one hot encoded vectors</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.String" name="sequence" summary="The reber sequence to encode" />
			</method>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="GetOneHot" is-static="true">
		<summary>One hot encodes the REBER strings</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="strList" summary="A list of REBER sequences" />
			</method>
	<property type="System.Int32" name="Size">
		<summary>The number of REBER characters</summary>
	</property>
	<method type="System.Void" name="ReberGrammar" is-static="false">
		<summary>Creates a reber grammar builder</summary>
				<param type="System.Random" name="random" summary="Random number provider" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Get" is-static="false">
		<summary>Generates an unlimited number of reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="minlength" summary="Minimum length of the sequences (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxLength" summary="Minimum length of the sequences (optional)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetExtended" is-static="false">
		<summary>Generates an unlimited number of extended reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="minlength" summary="Minimum length of the sequences (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxLength" summary="Minimum length of the sequences (optional)" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt regularisation
	</summary>
	<property type="BrightWire.ICreateGradientDescent" name="L1">
		<summary>L1 regularisation</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="L2">
		<summary>L2 regularisation</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.DataTableAdapter.RowBasedDataTableAdapterBase" base="BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase&lt;BrightData.ICanRandomlyAccessData&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for data tables that work with data table rows
	</summary>
</class>
<class name="BrightWire.TrainingData.Artificial.SequenceGenerator" base="" is-static="false" is-abstract="false">
	<summary>
		Generates random alphabetical sequences
	</summary>
	<method type="System.Void" name="SequenceGenerator" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="dictionarySize" summary="The number of letters to use" />
				<param type="System.UInt32" name="minSize" summary="The minimum size of each sequence" />
				<param type="System.UInt32" name="maxSize" summary="The maximum size of each sequence" />
				<param type="System.Boolean" name="noRepeat" summary="True to avoid repeating any previous character within each sequence" />
			</method>
	<property type="System.UInt32" name="DictionarySize">
		<summary>The number of letters to use</summary>
	</property>
	<method type="System.String" name="NextSequence" is-static="false">
		<summary>Generates a new sequence</summary>
			</method>
	<method type="BrightData.IReadOnlyVector" name="Encode" is-static="false">
		<summary>Converts the character to a one hot encoded vector</summary>
				<param type="System.Char" name="ch" summary="" />
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="Encode" is-static="false">
		<summary>Encodes the characters as a dense vector</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.Char, System.Single)&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.IReadOnlyMatrix" name="Encode" is-static="false">
		<summary>Encodes the string as a list of dense vectors within a matrix (each character becomes a row in the matrix)</summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GenerateSequences" is-static="false">
		<summary>Generator function to generate new sequences</summary>
			</method>
	<method type="System.String" name="Decode" is-static="false">
		<summary>Converts character indices to a string</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="characters" summary="Character indices" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SequenceWindowBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Creates a new training feature vector using a window of surrounding features at each point in the input sequence
	</summary>
	<method type="System.Void" name="SequenceWindowBuilder" is-static="false">
		<summary>Creates a new sequence window builder</summary>
				<param type="System.Int32" name="before" summary="The number of previous items to include before each item" />
				<param type="System.Int32" name="after" summary="The number of following items to include after each item" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Single[]&gt;" name="Get" is-static="false">
		<summary>Augments a single sequence</summary>
				<param type="System.Single[][]" name="data" summary="The sequence to analyse" />
			</method>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of the generated training data</summary>
	</property>
</class>
<class name="BrightData.Helper.SerialisationHelper" base="" is-static="true" is-abstract="false">
	<summary>
		Serialisation helpers
	</summary>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the string</summary>
				<param type="System.String" name="str" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the integer</summary>
				<param type="System.Int32" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the uint</summary>
				<param type="System.UInt32" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the double</summary>
				<param type="System.Double" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the float</summary>
				<param type="System.Single" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Conditionally writes a nullable value</summary>
				<param type="System.Nullable&lt;T&gt;" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
				<param type="System.Action&lt;T&gt;" name="onWrite" summary="" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="ReadNullable" is-static="true">
		<summary>Conditionally reads a nullable value</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.Func&lt;T&gt;" name="onRead" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the collection of items</summary>
				<param type="System.Collections.Generic.IReadOnlyCollection&lt;BrightData.ICanWriteToBinaryWriter&gt;" name="list" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the array</summary>
				<param type="T[]" name="array" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes an array of arrays to a binary writer</summary>
				<param type="T[][]" name="arrayOfArrays" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="T[][]" name="ReadArrayOfArrays" is-static="true">
		<summary>Reads an array of arrays from a binary reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary>Writes the array of strings</summary>
				<param type="System.String[]" name="array" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="T" name="Create" is-static="true">
		<summary>Creates a new object after reading its serialized data from the reader</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadObjectArray" is-static="true">
		<summary>Reads an array of objects from the reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
	<method type="T[]" name="ReadStructArray" is-static="true">
		<summary>Reads an array of structs from the reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.String[]" name="ReadStringArray" is-static="true">
		<summary>Reads an array of strings from the reader</summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SimpleTokeniser" base="" is-static="true" is-abstract="false">
	<summary>
		Finds strings of words and numbers in a larger string
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Tokenise" is-static="true">
		<summary>Splits the text into smaller word and number strings. Punctuation characters become single character strings.</summary>
				<param type="System.String" name="text" summary="The text to tokenise" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="JoinNegations" is-static="true">
		<summary>Simple token modification following "not".
Double not or punctuation stops the not mode</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="tokenList" summary="The list of tokens" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String[]&gt;" name="FindSentences" is-static="true">
		<summary>Finds sentences from a list of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="stringList" summary="The list of strings" />
			</method>
	<method type="System.Boolean" name="IsEndOfSentence" is-static="true">
		<summary>Checks if the string is an end of sentence token</summary>
				<param type="System.String" name="str" summary="The string to check" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.SingleBackpropagationBase&lt;T&gt;" base="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that back propagate to a single parent
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightWire.IGraphData Signal, BrightWire.IGraphContext Context, BrightWire.ExecutionGraph.Node.NodeBase ToNode)&gt;" name="Backward" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="" />
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase[]" name="parents" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.StaticAnalysers" base="" is-static="true" is-abstract="false">
	<summary>
		Static methods to create analyzers
	</summary>
	<method type="BrightData.IDataAnalyser&lt;System.DateTime&gt;" name="CreateDateAnalyser" is-static="true">
		<summary>Creates a date analyzer</summary>
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="CreateNumericAnalyser" is-static="true">
		<summary>Creates a numeric analyzer</summary>
				<param type="System.UInt32" name="writeCount" summary="Number of items to write in histogram" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="CreateConvertToStringAnalyser" is-static="true">
		<summary>Creates an analyzer that will convert each item to a string</summary>
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;BrightData.IReadOnlyTensor&gt;" name="CreateDimensionAnalyser" is-static="true">
		<summary>Creates a dimension analyzer (to analyze the shape of tensors)</summary>
			</method>
	<method type="BrightData.IDataAnalyser&lt;T&gt;" name="CreateFrequencyAnalyser" is-static="true">
		<summary>Creates an analyzer that tracks observed frequency of items</summary>
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;BrightData.IHaveIndices&gt;" name="CreateIndexAnalyser" is-static="true">
		<summary>Creates an analyzer that tracks observed indices (for index lists and weighted index lists)</summary>
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;System.Double&gt;" name="CreateNumericAnalyser" is-static="true">
		<summary>Creates a numeric analyzer</summary>
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser&lt;System.String&gt;" name="CreateStringAnalyser" is-static="true">
		<summary>Creates a string analyzer</summary>
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser" name="CreateFrequencyAnalyser" is-static="true">
		<summary>Creates a frequency analyzer (each item will be converted to a string)</summary>
				<param type="System.Type" name="type" summary="" />
				<param type="System.UInt32" name="writeCount" summary="" />
			</method>
</class>
<class name="BrightData.Converter.StaticConverters" base="" is-static="false" is-abstract="false">
	<summary>
		Static methods to create converters
	</summary>
	<method type="BrightData.ICanConvert&lt;T, System.Decimal&gt;" name="GetConverterToDecimal" is-static="true">
		<summary>Creates a converter to decimals</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Double&gt;" name="GetConverterToDouble" is-static="true">
		<summary>Creates a converter to doubles</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Single&gt;" name="GetConverterToFloat" is-static="true">
		<summary>Creates a converter to floats</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Int32&gt;" name="GetConverterToInt" is-static="true">
		<summary>Creates a converter to integers</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Int64&gt;" name="GetConverterToLong" is-static="true">
		<summary>Creates a converter to longs (Int64)</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.Int16&gt;" name="GetConverterToShort" is-static="true">
		<summary>Creates a converter to shorts (Int16)</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;T, System.SByte&gt;" name="GetConverterToSignedByte" is-static="true">
		<summary>Creates a convert to signed bytes</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;TF, TT&gt;" name="GetNumericConverter" is-static="true">
		<summary>Creates a numeric converter from TF to TT</summary>
			</method>
	<method type="BrightData.ICanConvert&lt;TF, TT&gt;" name="GetConverter" is-static="true">
		<summary>Creates a converter from TF to TT</summary>
			</method>
</class>
<class name="BrightData.Analysis.Readers.StringAnalysis" base="BrightData.Analysis.Readers.FrequencyAnalysis" is-static="false" is-abstract="false">
	<summary>
		String analysis results
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MinLength">
		<summary>Length of smallest observed string</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxLength">
		<summary>Length of largest observed string</summary>
	</property>
</class>
<class name="BrightData.Helper.StringIndexer" base="" is-static="false" is-abstract="false">
	<summary>
		Builds a string table
	</summary>
	<method type="System.Void" name="StringIndexer" is-static="false">
		<summary>Creates a string indexer</summary>
				<param type="System.String[]" name="strings" summary="Initial strings in table" />
			</method>
	<method type="BrightData.Helper.StringIndexer" name="Create" is-static="true">
		<summary>Creates a string indexer</summary>
				<param type="System.String[]" name="strings" summary="Initial strings in table" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Returns the index of a string (creates it if not already in table)</summary>
				<param type="System.String" name="str" summary="String to search" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of the string table</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="OrderedStrings">
		<summary>Returns all strings by indexed order</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The probabilities associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The log of the conditional probability</summary>
	</property>
	<property type="System.Double" name="InverseProbability">
		<summary>The log of the inverse conditional probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The conditional probability associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The conditional probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.StringTable" base="" is-static="false" is-abstract="false">
	<summary>
		An array of indexed strings
	</summary>
	<property type="System.String[]" name="Data">
		<summary>The array of indexed strings</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Helper.StringTableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Assigns string indices to strings
	</summary>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates an empty string table builder</summary>
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre-populated with an existing string table</summary>
				<param type="BrightWire.Models.StringTable" name="stringTable" summary="The string table to pre-populate" />
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre-populated with an existing string table</summary>
				<param type="System.String[]" name="stringTable" summary="The string table to pre-populate" />
			</method>
	<method type="System.Boolean" name="TryGetIndex" is-static="false">
		<summary>Returns true if the string has already been added</summary>
				<param type="System.String" name="str" summary="The string to check" />
				<param type="System.UInt32" name="ret" summary="The string index" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Gets a string index for a string (creates a new index if not found)</summary>
				<param type="System.String" name="str" summary="The string to look up" />
			</method>
	<property type="BrightWire.Models.StringTable" name="StringTable">
		<summary>Serialises the string table</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Returns the size of the string table</summary>
	</property>
	<method type="System.String" name="GetString" is-static="false">
		<summary>Returns the string at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The string index" />
			</method>
</class>
<class name="BrightData.LinearAlgebra.Segments.TensorSegmentWrapper" base="BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper" is-static="false" is-abstract="false">
	<summary>
		A tensor segment that wraps another tensor segment
	</summary>
	<method type="System.Void" name="TensorSegmentWrapper" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.INumericSegment&lt;System.Single&gt;" name="segment" summary="Tensor segment to wrap" />
				<param type="System.UInt32" name="offset" summary="First index within the wrapped tensor segment" />
				<param type="System.UInt32" name="stride" summary="Stride within the wrapped tensor segment" />
				<param type="System.UInt32" name="length" summary="Number of values in this tensor segment" />
			</method>
	<property type="BrightData.INumericSegment&lt;System.Single&gt;" name="UnderlyingSegment">
		<summary>The segment that was wrapped by this tensor segment</summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary></summary>
				<param type="System.ReadOnlySpan&lt;System.Single&gt;" name="span" summary="" />
				<param type="System.UInt32" name="targetOffset" summary="" />
			</method>
	<method type="System.Void" name="Clear" is-static="false">
		<summary></summary>
			</method>
	<method type="(System.Single[] Array, System.UInt32 Offset, System.UInt32 Stride)" name="GetUnderlyingArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.Helper.ThreadSafeHashSet&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A hash set that can be accessed by more than one thread at the same time
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Add" is-static="false">
		<summary>Adds a new item</summary>
				<param type="T" name="item" summary="Item to add" />
			</method>
	<method type="System.Void" name="Clear" is-static="false">
		<summary>Clears all items</summary>
			</method>
	<method type="System.Boolean" name="Contains" is-static="false">
		<summary>Checks if the set contains the specified item</summary>
				<param type="T" name="item" summary="Item to find" />
			</method>
	<method type="System.Boolean" name="Remove" is-static="false">
		<summary>Removes an item</summary>
				<param type="T" name="item" summary="Item to remove" />
			</method>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the set</summary>
	</property>
	<method type="System.Void" name="ForEach" is-static="false">
		<summary>Applies a callback to each item in the set</summary>
				<param type="System.Action&lt;T&gt;" name="callback" summary="" />
			</method>
	<method type="System.Boolean" name="TryPop" is-static="false">
		<summary>Tries to pop an item from the set</summary>
				<param type="T" name="ret" summary="Item that was removed" />
			</method>
</class>
<class name="BrightWire.Helper.VectorDistanceHelper" base="" is-static="false" is-abstract="false">
	<summary>
		Calculates the distance between a list of vectors and a list of vectors to compare against
	</summary>
	<method type="System.Void" name="VectorDistanceHelper" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IVector[]" name="data" summary="List of vectors to compare" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric for comparison" />
			</method>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IVector&gt;" name="CompareTo">
		<summary>The list of vectors to compare against</summary>
	</property>
	<property type="BrightData.DistanceMetric" name="Metric">
		<summary>Distance metric</summary>
	</property>
	<method type="System.Int32" name="AddComparison" is-static="false">
		<summary>Adds a comparison vector (will be owned and disposed by the helper class)</summary>
				<param type="BrightData.IVector" name="comparison" summary="Vector to compare against" />
			</method>
	<method type="System.Void" name="UpdateComparisonVector" is-static="false">
		<summary>Updates the comparison vector at this index (disposes the old vector)</summary>
				<param type="System.Int32" name="index" summary="Index to update" />
				<param type="BrightData.IVector" name="newVector" summary="Vector to replace with" />
			</method>
	<method type="System.Void" name="SetComparisonVectors" is-static="false">
		<summary>Updates the entire list of comparison vectors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IVector&gt;" name="comparisonVectors" summary="List of vectors to compare against" />
			</method>
	<method type="System.UInt32[]" name="GetClosest" is-static="false">
		<summary>Returns the index of the closest comparison vector for each vector</summary>
			</method>
	<method type="BrightData.IVector" name="GetAverageFromData" is-static="false">
		<summary>Returns a vector averaged from the data vectors</summary>
				<param type="System.UInt32[]" name="indices" summary="Indices of the data vectors to use in the averaged vector" />
			</method>
</class>
<class name="BrightData.DataTable.VectorisationModel" base="" is-static="false" is-abstract="false">
	<summary>
		A collection of vectorisers (such as from the columns of a data table)
	</summary>
	<method type="System.Void" name="VectorisationModel" is-static="false">
		<summary>Initialise the model from a collection of vectorisers</summary>
				<param type="BrightData.ICanVectorise[]" name="vectorisers" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary>The combined output size of all vectorisers</summary>
	</property>
	<property type="BrightData.ICanVectorise[]" name="Vectorisers">
		<summary>The source vectorisers</summary>
	</property>
	<property type="System.UInt32[]" name="SourceColumnIndices">
		<summary>The source column indices from the data table (if available)</summary>
	</property>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="Vectorise" is-static="false">
		<summary>Vectorise the buffers as an enumerable</summary>
				<param type="BrightData.IReadOnlyBuffer[]" name="buffers" summary="Buffers to vectoriser" />
				<param type="BrightData.Types.MetaData[]" name="metaData" summary="Metadata in which to store the vectorisation parameters" />
			</method>
	<method type="System.Threading.Tasks.Task" name="ForEachVector" is-static="false">
		<summary>Vectorise the buffers and pass each vector to a callback</summary>
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="buffers" summary="" />
				<param type="BrightData.DataTable.VectorisationModel.VectorCallback" name="callback" summary="" />
			</method>
	<method type="System.Single[]" name="Vectorise" is-static="false">
		<summary>Single vectorisation</summary>
				<param type="BrightData.ICanRandomlyAccessData" name="data" summary="" />
			</method>
	<method type="System.Single[]" name="Vectorise" is-static="false">
		<summary>Single vectorisation</summary>
				<param type="System.Object[]" name="values" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="Vectorise" is-static="false">
		<summary>Vectorise the buffers as an enumerable</summary>
				<param type="BrightData.IReadOnlyBufferWithMetaData[]" name="buffers" summary="" />
			</method>
	<method type="System.Collections.Generic.IAsyncEnumerable&lt;System.Single[,]&gt;" name="Vectorise" is-static="false">
		<summary>Vectorise the data table</summary>
				<param type="BrightData.IDataTable" name="table" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="List of column indices to vectorise (optional)" />
			</method>
</class>
<class name="BrightData.Types.VectorSet" base="" is-static="false" is-abstract="false">
	<summary>
		Represents a set of vectors
	</summary>
	<method type="System.Void" name="VectorSet" is-static="false">
		<summary>Creates a vector set</summary>
				<param type="System.UInt32" name="vectorSize" summary="" />
				<param type="BrightData.Types.VectorSet.StorageType" name="type" summary="" />
			</method>
	<property type="System.UInt32" name="VectorSize">
		<summary>Size of each vector</summary>
	</property>
	<method type="System.UInt32" name="Add" is-static="false">
		<summary>Adds a vector to the set</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
			</method>
	<method type="System.UInt32[]" name="Add" is-static="false">
		<summary>Adds a collection of vectors to the set</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IReadOnlyVector&gt;" name="vectors" summary="" />
			</method>
	<method type="System.Void" name="Remove" is-static="false">
		<summary>Removes a vector</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IReadOnlyVector" name="Get" is-static="false">
		<summary>Returns a specified vector</summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="Rank" is-static="false">
		<summary>Returns the ranking (based on distance) between a vector and every vector in this set</summary>
				<param type="BrightData.IReadOnlyVector" name="vector" summary="" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="" />
			</method>
	<method type="System.UInt32[]" name="Closest" is-static="false">
		<summary>Returns the index of the closest vector in the set to each of the supplied vectors</summary>
				<param type="BrightData.IReadOnlyVector[]" name="vector" summary="" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="" />
			</method>
	<method type="System.Single[]" name="GetAverage" is-static="false">
		<summary>Creates an average vector from the specified vectors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="keys" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt weight initialisers
	</summary>
	<property type="BrightWire.IWeightInitialisation" name="Ones">
		<summary>All weights are initialised to 1</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Zeroes">
		<summary>All weights are initialised to 0</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Gaussian">
		<summary>Weights are randomly initialised using a gaussian distribution</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Xavier">
		<summary>Weights are randomly initialised using the xavier algorithm</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity">
		<summary>Weights are initialised to the identity matrix</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity01">
		<summary>Weights are initialised to the identity matrix / 10</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraphModel.Wire" base="" is-static="false" is-abstract="false">
	<summary>
		Wires connect nodes (aka edges)
	</summary>
	<property type="System.String" name="FromId">
		<summary>The source node id</summary>
	</property>
	<property type="System.String" name="ToId">
		<summary>The target node id</summary>
	</property>
	<property type="System.UInt32" name="InputChannel">
		<summary>The channel on the target node to send the source node's output</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.WireBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Wires nodes together to build strands of a graph
	</summary>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.UInt32" name="size" summary="Initial wire size" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.UInt32" name="width" summary="Initial input width" />
				<param type="System.UInt32" name="height" summary="Initial input height" />
				<param type="System.UInt32" name="depth" summary="Initial input depth" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes to the engine output node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine" />
			</method>
	<property type="System.UInt32" name="CurrentSize">
		<summary>The current wire size</summary>
	</property>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="SetNewSize" is-static="false">
		<summary>Changes the current size of the builder</summary>
				<param type="System.UInt32" name="newSize" summary="New size" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="SetNewSize" is-static="false">
		<summary>Changes the current size of the builder</summary>
				<param type="System.UInt32" name="width" summary="New width" />
				<param type="System.UInt32" name="height" summary="New height" />
				<param type="System.UInt32" name="depth" summary="New depth" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddClassifier" is-static="false">
		<summary>Connects a row classifier</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightData.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddFeedForward" is-static="false">
		<summary>Adds a feed forward layer</summary>
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddTiedFeedForward" is-static="false">
		<summary>Adds a feed forward layer whose weights are tied to a previous layer</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer whose weights are tied" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropOut" is-static="false">
		<summary>Adds a drop out layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropConnect" is-static="false">
		<summary>Adds a drop connect layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddOutput" is-static="false">
		<summary>Creates a node that writes the current forward signal as an output of the graph</summary>
				<param type="System.Int32" name="channel" summary="Output channel" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds a node</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddForwardAction" is-static="false">
		<summary>Adds an action that will be executed in the forward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackwardAction" is-static="false">
		<summary>Adds an action that will be executed in the backward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBatchNormalisation" is-static="false">
		<summary>Adds a batch normalisation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRecurrentBridge" is-static="false">
		<summary>Creates a bridge between two recurrent nodes that will copy the hidden state from one to another and copy the error signal backwards between the two</summary>
				<param type="System.String" name="fromName" summary="Name of the first recurrent node" />
				<param type="System.String" name="toName" summary="Name of the second recurrent node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSimpleRecurrent" is-static="false">
		<summary>Adds a simple recurrent neural network layer</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="Activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddElman" is-static="false">
		<summary>Adds an Elman recurrent neural network layer</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddJordan" is-static="false">
		<summary>Adds a Jordan recurrent neural network layer</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation" summary="First activation layer" />
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="activation2" summary="Second activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddGru" is-static="false">
		<summary>Adds a gated recurrent unit recurrent neural network layer</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRan" is-static="false">
		<summary>Adds a recurrent additive layer (recurrent)</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddLstm" is-static="false">
		<summary>Adds a long short term memory recurrent neural network layer</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ReverseSequence" is-static="false">
		<summary>Adds a node that will reverse the sequence (for bidirectional recurrent neural networks)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddMaxPooling" is-static="false">
		<summary>Adds a max pooling convolutional layer</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of max pooling filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of max pooling filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddConvolutional" is-static="false">
		<summary>Adds a convolutional layer</summary>
				<param type="System.UInt32" name="filterCount" summary="Number of filters in the layer" />
				<param type="System.UInt32" name="padding" summary="Padding to add before applying the convolutions" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate a backpropagation signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="TransposeFrom4DTensorToMatrix" is-static="false">
		<summary>Transposes the graph signal to move between convolutional and non-convolutional layers</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="TransposeAndCombine" is-static="false">
		<summary>Transposes the graph signal and merges each depth slice</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagation" is-static="false">
		<summary>Adds backpropagation - when executed an error signal will be calculated and flow backwards to previous nodes</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagationThroughTime" is-static="false">
		<summary>Adds backpropagation through time</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSequenceToSequencePivot" is-static="false">
		<summary>Pivots between the encoder and decoder sequences (seq2seq)</summary>
				<param type="System.String" name="encoderName" summary="Encoder node name" />
				<param type="System.String" name="decoderName" summary="Decoder node name" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainForwardSignal" is-static="false">
		<summary>Constrains the error signal in the forward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainBackwardSignal" is-static="false">
		<summary>Constrains the error signal in the backward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="WriteNodeMemoryToSlot" is-static="false">
		<summary>Writes node memory to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="System.String" name="nodeName" summary="The node name to read" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSelfAttention" is-static="false">
		<summary>Adds a self attention node</summary>
				<param type="System.String" name="encoderName" summary="Name of encoder node (must be same size as decoder)" />
				<param type="System.String" name="decoderName" summary="Name of decoder node (must be same size as encoder)" />
				<param type="System.UInt32" name="encoderSize" summary="Size of the encoder" />
				<param type="System.UInt32" name="decoderSize" summary="Size of the decoder" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="JoinInputWithMemory" is-static="false">
		<summary>Concatenates the named memory slot with the input signal</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.Node.NodeBase" name="Find" is-static="false">
		<summary>Tries to find the specified node</summary>
				<param type="System.String" name="name" summary="The friendly name of the node" />
			</method>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="LastNode">
		<summary>The last added node</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.WireToNode" base="" is-static="false" is-abstract="false">
	<summary>
		Wires connect nodes in the graph
	</summary>
	<method type="System.Void" name="WireToNode" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.ExecutionGraph.Node.NodeBase" name="node" summary="The destination node" />
				<param type="System.UInt32" name="channel" summary="The input channel on the node" />
			</method>
	<property type="BrightWire.ExecutionGraph.Node.NodeBase" name="SendTo">
		<summary>The node to send a signal to</summary>
	</property>
	<property type="System.UInt32" name="Channel">
		<summary>The channel to send the signal on</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.Xor" base="" is-static="true" is-abstract="false">
	<summary>
		Simple XOR training data
	</summary>
	<method type="System.Threading.Tasks.Task&lt;BrightData.IDataTable&gt;" name="Get" is-static="true">
		<summary>Generates a data table containing XOR training data</summary>
				<param type="BrightData.BrightDataContext" name="context" summary="" />
			</method>
</class>
</assembly>
