<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BrightWire</name>
    </assembly>
    <members>
        <member name="T:BrightWire.Bayesian.BernoulliNaiveBayesClassifier">
            <summary>
            Bernoulli naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.BernoulliNaiveBayesClassifier.#ctor(BrightWire.Models.Bayesian.BernoulliNaiveBayes)">
            <summary>
            Bernoulli naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.BernoulliNaiveBayesClassifier.Classify(BrightData.Types.IndexList)">
            <summary>
             Naive bayes values should only be used for ranking against each other
            </summary>
        </member>
        <member name="T:BrightWire.Bayesian.MultinomialNaiveBayesClassifier">
            <summary>
            Multinomial naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.MultinomialNaiveBayesClassifier.#ctor(BrightWire.Models.Bayesian.MultinomialNaiveBayes)">
            <summary>
            Multinomial naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.MultinomialNaiveBayesClassifier.Classify(BrightData.Types.IndexList)">
            <summary>
             Naive bayes values should only be used for ranking against each other
            </summary>
        </member>
        <member name="T:BrightWire.Bayesian.NaiveBayesClassifier">
            <summary>
            Naive bayes classifier
            </summary>
        </member>
        <member name="M:BrightWire.Bayesian.NaiveBayesClassifier.Classify(BrightData.DataTable.Rows.GenericTableRow)">
            <summary>
            Naive bayes classifications should only be used for ranking against each other and not for deriving an actual weighted probability
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Bayesian.Training.MarkovModelTrainer2`1">
            <summary>
            Builds markov models with a window size of 2
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.Bayesian.Training.MarkovModelTrainer2`1.#ctor(`0,System.Int32)">
            <summary>
            Builds markov models with a window size of 2
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightWire.Bayesian.Training.NaiveBayesTrainer">
            <summary>
            Simple naive bayes trainer
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.AdaGradDescriptor">
            <summary>
            Creates an AdaGrad gradient descent optimisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.AdamDescriptor">
            <summary>
            Creates an adam gradient descent optimisation
            </summary>
        </member>
        <member name="M:BrightWire.Descriptor.AdamDescriptor.#ctor(System.Single,System.Single)">
            <summary>
            Creates an adam gradient descent optimisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.L1RegularisationDescriptor">
            <summary>
            Creates L1 regularisation
            </summary>
        </member>
        <member name="M:BrightWire.Descriptor.L1RegularisationDescriptor.#ctor(System.Single)">
            <summary>
            Creates L1 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.L2RegularisationDescriptor">
            <summary>
            Creates L2 regularisation
            </summary>
        </member>
        <member name="M:BrightWire.Descriptor.L2RegularisationDescriptor.#ctor(System.Single)">
            <summary>
            Creates L2 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.MomentumDescriptor">
            <summary>
            Creates a momentum gradient descent optimiser
            </summary>
        </member>
        <member name="M:BrightWire.Descriptor.MomentumDescriptor.#ctor(System.Single)">
            <summary>
            Creates a momentum gradient descent optimiser
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.NesterovMomentumDescriptor">
            <summary>
            Creates a nesterov momentum gradient descent optimiser
            </summary>
        </member>
        <member name="M:BrightWire.Descriptor.NesterovMomentumDescriptor.#ctor(System.Single)">
            <summary>
            Creates a nesterov momentum gradient descent optimiser
            </summary>
        </member>
        <member name="T:BrightWire.Descriptor.RmsPropDescriptor">
            <summary>
            Creates a rms prop gradient descent optimiser
            </summary>
        </member>
        <member name="M:BrightWire.Descriptor.RmsPropDescriptor.#ctor(System.Single)">
            <summary>
            Creates a rms prop gradient descent optimiser
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.Backpropagate">
            <summary>
            Backpropagates the graph against the error metric
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.BackpropagateThroughTime">
            <summary>
            Backpropagates through time (for recurrent neural networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.ConstrainSignal">
            <summary>
            Constrains the signal through the graph to lie between two values
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Action.ConstrainSignal.#ctor(System.Single,System.Single)">
            <summary>
            Constrains the signal through the graph to lie between two values
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.CopyNamedMemory">
            <summary>
            Copies named memory from one slot to another
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Action.CopyNamedMemory.#ctor(System.String,BrightWire.IHaveMemoryNode)">
            <summary>
            Copies named memory from one slot to another
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Action.SetMemory">
            <summary>
            Saves the current graph signal into named memory
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Action.SetMemory.#ctor(System.String,System.String)">
            <summary>
            Saves the current graph signal into named memory
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.LeakyRelu">
            <summary>
            Leaky RELU activation
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Activation.LeakyRelu.#ctor(System.String)">
            <summary>
            Leaky RELU activation
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.Relu">
            <summary>
            RELu activation
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Activation.Relu.#ctor(System.String)">
            <summary>
            RELu activation
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.Sigmoid">
            <summary>
            Sigmoid activation function
            https://en.wikipedia.org/wiki/Sigmoid_function
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Activation.Sigmoid.#ctor(System.String)">
            <summary>
            Sigmoid activation function
            https://en.wikipedia.org/wiki/Sigmoid_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.SoftMax">
            <summary>
            Softmax activation function
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Activation.SoftMax.#ctor(System.String)">
            <summary>
            Softmax activation function
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Activation.Tanh">
            <summary>
            Tanh activation function
            https://en.wikipedia.org/wiki/Activation_function
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Activation.Tanh.#ctor(System.String)">
            <summary>
            Tanh activation function
            https://en.wikipedia.org/wiki/Activation_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataSource.SequentialDataSource">
            <summary>
            Feeds sequential data to the graph
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataSource.VectorDataSource">
            <summary>
            Feeds data to the execution graph
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1">
            <summary>
            Base class for data table based data adapters
            </summary>
            <typeparam name="T">The type of the cached data</typeparam>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1._featureColumnIndices">
            <summary>
            The data table column indices with features
            </summary>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1._targetColumnIndex">
            <summary>
            Target column index
            </summary>
        </member>
        <member name="F:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1._dataTable">
            <summary>
            Data table
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.#ctor(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Constructor
            </summary>
            <param name="dataTable"></param>
            <param name="featureColumns"></param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.InputSize">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.OutputSize">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.RowCount">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.Get(System.UInt32[])">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.CloneWith(BrightData.IDataTable)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.InputVectoriser">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.OutputVectoriser">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.GetSequentialBatches">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.GetRows(System.UInt32[])">
            <summary>
            Returns data for the specified row indices
            </summary>
            <param name="rows">List of row indices</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.DataTableAdapterBase`1.GetMiniBatch(System.UInt32[],System.ValueTuple{System.Single[],System.Single[]}[])">
            <summary>
            Creates a mini batch
            </summary>
            <param name="rows">Row indices</param>
            <param name="data">Array of input/output pairs</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.DefaultDataTableAdapter">
            <summary>
            Vectorise each row of the data table on demand
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.IndexListDataTableAdapter">
            <summary>
            Adapts data tables with an index list based feature columns (corresponding to an unweighted sparse vector)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.ManyToOneDataTableAdapter">
            <summary>
            Adapts data tables that classify a sequence into a single classification
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.OneToManyDataTableAdapter">
            <summary>
            Adapts data tables that generate sequences from a single vector
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.GenericRowBasedDataTableAdapterBase">
            <summary>
            Base class for data tables that work with generic data table rows
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.GenericRowBasedDataTableAdapterBase.#ctor(BrightData.IDataTable,System.UInt32[])">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.GenericRowBasedDataTableAdapterBase.GetSegment(System.UInt32,BrightData.ICanRandomlyAccessData)">
            <summary>
            Returns a tensor segment from a segment provider
            </summary>
            <param name="columnIndex"></param>
            <param name="segmentProvider"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.GenericRowBasedDataTableAdapterBase.GetRows(System.UInt32[])">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.SequentialDataTableAdapter">
            <summary>
            Adapts data tables that classify each step of a sequence
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.Tensor3DBasedDataTableAdapter">
            <summary>
            Adapts data tables that classify tensors (volumes)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.TypedRowBasedDataTableAdapterBase`2.GetRows(System.UInt32[])">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.VectorBasedDataTableAdapter">
            <summary>
            Segment table adapter for tables with vector data
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.DataTableAdapter.VectorBasedDataTableAdapter.#ctor(BrightData.IDataTable,System.UInt32[],System.UInt32,System.Nullable{System.UInt32})">
            <summary>
            Segment table adapter for tables with vector data
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.DataTableAdapter.WeightedIndexListDataTableAdapter">
            <summary>
            Adapts data tables with weighted index list based columns (corresponding to a sparse vector)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.ExecutionEngine">
            <summary>
            Executes (without training) graphs
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.ExecutionEngine.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},BrightWire.Models.ExecutionGraphModel,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Executes (without training) graphs
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.ExecutionGraphSequenceContext">
            <summary>
            Execution engine context
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext">
            <summary>
            Graph engine execution context
            </summary>
            <remarks>
            Constructor
            </remarks>
            <param name="graphEngine">Graph engine</param>
            <param name="wantInputInExecutionResults">True to save the graph input in the execution results</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.#ctor(BrightWire.IGraphEngine,System.Boolean)">
            <summary>
            Graph engine execution context
            </summary>
            <remarks>
            Constructor
            </remarks>
            <param name="graphEngine">Graph engine</param>
            <param name="wantInputInExecutionResults">True to save the graph input in the execution results</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.LinearAlgebraProvider">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.Add(System.Collections.Generic.IEnumerable{BrightWire.IGraphOperation})">
            <summary>
            Adds graph operations to the queue
            </summary>
            <param name="operations"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.RegisterContinuation(BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence,System.Action{BrightWire.IGraphContext})">
            <summary>
            Registers a continuation that will be executed after the current sequence has been processed in full
            </summary>
            <param name="sequence"></param>
            <param name="callback"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.RegisterAdditionalMiniBatch(BrightWire.ExecutionGraph.Helper.MiniBatch,BrightWire.IGraphData,System.Action{BrightWire.IGraphContext,BrightWire.IGraphData},System.Action{BrightWire.IGraphContext[]})">
            <summary>
            Registers an additional mini batch to execute after the current mini batch has completed
            </summary>
            <param name="miniBatch">Mini batch to execute</param>
            <param name="data">Initial data</param>
            <param name="start">Callback when starting the batch</param>
            <param name="end">Callback when ending the batch</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.RemainingOperationCount">
            <summary>
            Count of remaining operations in queue
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.HasContinuations">
            <summary>
            True if there are registered continuations or additional mini batches that still need to execute
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.WantInputInExecutionResults">
            <summary>
            True if the input to the graph will be stored in the execution results
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.Continue(BrightWire.IGraphContext)">
            <summary>
            Checks if execution should continue from a remaining continuation
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.ExecuteAdditionalMiniBatch(BrightWire.ILearningContext)">
            <summary>
            Executes any additional mini batches
            </summary>
            <param name="learningContext"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.HasMemory(System.String)">
            <summary>
            Checks if a named memory slot is in use
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.GetMemory(System.String)">
            <summary>
            Returns a named memory slot
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.GetNextOperation">
            <summary>
            Pops the next pending graph operation (if any)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext.SetMemory(System.String,BrightData.IMatrix{System.Single})">
            <summary>
            Sets a named memory slot
            </summary>
            <param name="index"></param>
            <param name="memory"></param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.LearningContext">
            <summary>
            Graph engine learning context
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.SequentialRowDataSource">
            <summary>
            Helper class when executing a single sequence
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.SequentialRowDataSource.#ctor(System.Single[][],BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single})">
            <summary>
            Helper class when executing a single sequence
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Engine.Helper.SingleRowDataSource">
            <summary>
            Helper class when executing a single row instead of the normal batch mode
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Engine.Helper.SingleRowDataSource.#ctor(System.Single[],BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.Boolean,BrightWire.MiniBatchSequenceType,System.UInt32)">
            <summary>
            Helper class when executing a single row instead of the normal batch mode
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.BinaryClassification">
            <summary>
            Binary classification rounds outputs to 1 or 0 and compares them against the target
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.CrossEntropy">
            <summary>
            Cross entropy error
            https://en.wikipedia.org/wiki/Cross_entropy#Cross-entropy_error_function_and_logistic_regression
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.OneHotEncoding">
            <summary>
            Finds the single index of the highest activation and compares it to the target index
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.ErrorMetric.Quadratic">
            <summary>
            Quadratic error
            https://en.wikipedia.org/wiki/Mean_squared_error#Loss_function
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.AdaGrad">
            <summary>
            AdaGrad gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.AdaGrad.#ctor(BrightData.IMatrix{System.Single},BrightWire.IGradientDescentOptimisation)">
            <summary>
            AdaGrad gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.Adam">
            <summary>
            Adam gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.Adam.#ctor(System.Single,System.Single,BrightData.IMatrix{System.Single},BrightData.IMatrix{System.Single},BrightWire.IGradientDescentOptimisation)">
            <summary>
            Adam gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.L1Regularisation">
            <summary>
            L1 regularisation
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.L1Regularisation.#ctor(System.Single)">
            <summary>
            L1 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.L2Regularisation">
            <summary>
            L2 regularisation
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.L2Regularisation.#ctor(System.Single)">
            <summary>
            L2 regularisation
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.Momentum">
            <summary>
            Gradient descent with momentum
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.Momentum.#ctor(System.Single,BrightData.IMatrix{System.Single},BrightWire.IGradientDescentOptimisation)">
            <summary>
            Gradient descent with momentum
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#Momentum
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.NesterovMomentum">
            <summary>
            Gradient descent with nesterov momentum
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.NesterovMomentum.#ctor(System.Single,BrightData.IMatrix{System.Single},BrightWire.IGradientDescentOptimisation)">
            <summary>
            Gradient descent with nesterov momentum
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.RmsProp">
            <summary>
            Rms prop gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#RMSProp
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GradientDescent.RmsProp.#ctor(System.Single,BrightData.IMatrix{System.Single},BrightWire.IGradientDescentOptimisation)">
            <summary>
            Rms prop gradient descent
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent#RMSProp
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GradientDescent.StochasticGradientDescent">
            <summary>
            Simple SGD
            https://en.wikipedia.org/wiki/Stochastic_gradient_descent
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory">
            <summary>
            Creates graph nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},BrightWire.IPropertySet)">
            <summary>
            Constructor
            </summary>
            <param name="lap">The linear algebra provider to use</param>
            <param name="propertySet">A property set with initialisation data (optional)</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.LinearAlgebraProvider">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.CurrentPropertySet">
            <summary>
            The current property set
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.PushPropertySet(System.Action{BrightWire.IPropertySet})">
            <summary>
            Clones the current property set with an optional mutator and then pushes it onto the stack
            </summary>
            <param name="mutator">Callback that can modify the cloned property set</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.PopPropertyStack">
            <summary>
            Pops the last property set from the stack
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateWeightUpdater(BrightData.IMatrix{System.Single})">
            <summary>
            Creates a gradient descent optimiser for the given matrix
            </summary>
            <param name="weight"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GetWeightInitialisation">
            <summary>
            Returns an object that can initialize weights in the graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateTrainingEngine(BrightWire.IDataSource,BrightWire.IErrorMetric,System.Single,System.UInt32)">
            <summary>
            Creates a graph training engine
            </summary>
            <param name="dataSource">Segment source with training data</param>
            <param name="errorMetric">Error metric to train with</param>
            <param name="learningRate">Initial learning rate</param>
            <param name="batchSize">Mini batch size</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateExecutionEngine(BrightWire.Models.ExecutionGraphModel,BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single})">
            <summary>
            Creates a graph execution engine
            </summary>
            <param name="graph">The serialised graph to execute</param>
            <param name="lap">Linear algebra provider (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightData.IVector{System.Single}[])">
            <summary>
            Creates a data source from a list of vectors
            </summary>
            <param name="vectorList">The list of vectors that will be the rows in the data source</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightData.IMatrix{System.Single}[])">
            <summary>
            Creates a data source from a list of matrices (sequential vectors)
            </summary>
            <param name="sequenceList">The list of matrices that will be the rows in the data source</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightData.ITensor3D{System.Single}[])">
            <summary>
            Creates a data source from a list of tensors
            </summary>
            <param name="tensorList">The list of tensors that will be the rows in the data source</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDataSource(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Creates a data source from a data table
            </summary>
            <param name="dataTable">The data table to convert</param>
            <param name="featureColumns">Column indices to use as features (or none to use all non target columns)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateClassifier(BrightWire.IRowClassifier,BrightData.IDataTable,System.String)">
            <summary>
            Create a row classifier node
            </summary>
            <param name="classifier">The classifier for each row</param>
            <param name="dataTable">The data table that contains the rows to classify (linked by mini batch index)</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateFeedForward(System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a feed forward layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDropConnect(System.Single,System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a new drop connect layer (a feed forward layer with drop out applied to the weights)
            </summary>
            <param name="dropoutPercentage">Percentage of connections to drop (0..1)</param>
            <param name="inputSize">Number of incoming connections</param>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateTiedFeedForward(BrightWire.IFeedForward,System.String)">
            <summary>
            Creates a layer whose weights are shared with another layer (but transposed)
            </summary>
            <param name="layer">The layer that shares weights</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateConvolutional(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.String)">
            <summary>
            Creates a convolutional layer
            </summary>
            <param name="inputDepth">Input depth</param>
            <param name="filterCount">Number of convolutional filters</param>
            <param name="padding">Padding to apply before convolutions</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="xStride">X stride</param>
            <param name="yStride">Y stride</param>
            <param name="shouldBackpropagate">True to calculate the backpropagation error signal</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateMaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a max pooling convolutional layer
            </summary>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="xStride">X stride</param>
            <param name="yStride">Y stride</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateRecurrentBridge(System.String,System.String,System.String)">
            <summary>
            Creates a bridge between two recurrent nodes that will copy the hidden state from one to another and copy the error signal backwards between the two
            </summary>
            <param name="fromName">Name of the first recurrent node</param>
            <param name="toName">Name of the second recurrent node</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateSimpleRecurrent(System.UInt32,System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Creates a simple recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memorySize">Size of the layer memory</param>
            <param name="activation">Activation layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateElman(System.UInt32,System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Creates an Elman recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memorySize">Size of the layer memory</param>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateJordan(System.UInt32,System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Creates a Jordan recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memorySize">Size of the layer memory</param>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateOneMinusInput(System.String)">
            <summary>
            Creates a node that subtracts each input from 1 (1-x)
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateSequenceReverser(System.String)">
            <summary>
            Creates a node that outputs the reversed index of the current sequence (for bidirectional recurrent networks)
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateBatchNormalisation(System.UInt32,System.String)">
            <summary>
            Creates a node that performs batch normalization
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateGru(System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a GRU recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memorySize">Size of the layer memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateRan(System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a Recurrent Additive Layer (recurrent)
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memorySize">Size of the layer memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateLstm(System.UInt32,System.UInt32,System.String)">
            <summary>
            Creates a LSTM recurrent layer
            </summary>
            <param name="inputSize">Number of incoming connections</param>
            <param name="memorySize">Size of the layer memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateDropOut(System.Single,System.String)">
            <summary>
            Creates a layer that drops random connections
            </summary>
            <param name="dropoutPercentage">Percentage to drop (0..1)</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateOutputNode(System.Int32,System.String)">
            <summary>
            Creates a node that writes the current forward signal as an output of the graph
            </summary>
            <param name="channel">Output channel</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Connect(BrightWire.IGraphTrainingEngine)">
            <summary>
            Builds a new wire from the engine's input node
            </summary>
            <param name="engine">Graph engine to build with</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Connect(System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Builds a new wire from the selected node
            </summary>
            <param name="inputSize">Number of outgoing connections</param>
            <param name="node">The node to build from</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Add(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Adds the output of two wires into a new wire
            </summary>
            <param name="input1">First wire</param>
            <param name="input2">Second wire</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Subtract(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Subtracts the second input from the first input and sends the result to a new wire
            </summary>
            <param name="input1">Wire to subtract from</param>
            <param name="input2">Wire to subtract</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Subtract(System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Subtracts the second input from the first input and sends the result to a new wire
            </summary>
            <param name="inputSize">The number of connections</param>
            <param name="input1">The node to subtract from</param>
            <param name="input2">The node to subtract</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Add(System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Adds the output of two nodes together into a new wire
            </summary>
            <param name="inputSize">The number of connections</param>
            <param name="input1">First node</param>
            <param name="input2">Second node</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Multiply(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Multiplies the output of two wires into a new wire
            </summary>
            <param name="input1"></param>
            <param name="input2"></param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Multiply(System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Multiplies the output of two nodes together into a new wire
            </summary>
            <param name="inputSize">The number of connections</param>
            <param name="input1">First node</param>
            <param name="input2">Second node</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Join(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Concatenates two wires together into a new wire
            </summary>
            <param name="input1">First wire to join</param>
            <param name="input2">Second wire to join</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Join(BrightWire.ExecutionGraph.WireBuilder[])">
            <summary>
            Joins multiple wires into a new wire
            </summary>
            <param name="wires">Wires to join</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Join(System.String,BrightWire.ExecutionGraph.WireBuilder[])">
            <summary>
            Joins multiple wires into a new wire
            </summary>
            <param name="name">Optional name to give the node</param>
            <param name="wires">Wires to join</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.BidirectionalJoin(BrightWire.ExecutionGraph.WireBuilder,BrightWire.ExecutionGraph.WireBuilder,System.String)">
            <summary>
            Concatenates two wires together into a new wire, but reverses the sequence index of the second input to join
            </summary>
            <param name="forwardInput">Forward wire to join</param>
            <param name="backwardInput">Backward wire to join</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.CreateWrapper(BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Wraps an existing node, enabling that node to be used at multiple locations in the same graph
            </summary>
            <param name="nodeToWrap">Node to wrap</param>
            <param name="name">Optional name to give the wrapping node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Create(BrightWire.Models.ExecutionGraphModel.Node)">
            <summary>
            Creates a node from it's serialised model
            </summary>
            <param name="node">The node model</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.LeakyReluActivation(System.String)">
            <summary>
            Creates a new leaky relu activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.ReluActivation(System.String)">
            <summary>
            Creates a new relu activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.SigmoidActivation(System.String)">
            <summary>
            Creates a new sigmoid activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.TanhActivation(System.String)">
            <summary>
            Creates a new tanh activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.SoftMaxActivation(System.String)">
            <summary>
            Creates a new softmax activation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.ConstantWeightInitialisation(System.Single,System.Single)">
            <summary>
            Creates a constant weight initialiser
            </summary>
            <param name="biasValue">Single bias value</param>
            <param name="weightValue">Single weight value</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GaussianWeightInitialisation(System.Boolean,System.Single,BrightWire.GaussianVarianceCalibration,BrightWire.GaussianVarianceCount)">
            <summary>
            Creates a gaussian weight initialiser
            </summary>
            <param name="zeroBias">True to set bias values to zero, otherwise bias initialisation is treated the same as weight initialisation</param>
            <param name="stdDev">Standard deviation of gaussian distribution</param>
            <param name="varianceCalibration">How to calibrate the variance</param>
            <param name="varianceCount">How to count connections while calibrating connections</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.IdentityWeightInitialisation(System.Single)">
            <summary>
            Creates an identity weight initialiser
            </summary>
            <param name="identityValue">The value to give to each diagonal value</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.XavierWeightInitialisation(System.Single)">
            <summary>
            Creates a xavier weight initialiser
            </summary>
            <param name="parameter">Xavier parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.AdaGrad">
            <summary>
            Creates an AdaGrad gradient descent optimiser
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Adam(System.Single,System.Single)">
            <summary>
            Creates an Adam gradient descent optimiser
            </summary>
            <param name="decay">Decay parameter</param>
            <param name="decay2">Second decay parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.L1(System.Single)">
            <summary>
            Creates a L1 regularisation gradient descent optimiser
            </summary>
            <param name="lambda">L1 parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.L2(System.Single)">
            <summary>
            Creates a L2 regularisation gradient descent optimiser
            </summary>
            <param name="lambda">L2 parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.Momentum(System.Single)">
            <summary>
            Creates a momentum gradient descent optimiser
            </summary>
            <param name="momentum">Momentum parameter</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.NesterovMomentum(System.Single)">
            <summary>
            Creates a nesterov momentum gradient descent optimiser
            </summary>
            <param name="momentum">Nesterov momentum parameter</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.RmsProp(System.Single)">
            <summary>
            Creates a rms prop gradient descent optimiser
            </summary>
            <param name="decay">Rms decay</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.SimpleGradientDescent">
            <summary>
            Uses vanilla stochastic gradient descent
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider">
            <summary>
            Prebuilt regularisation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider.L1">
            <summary>
            L1 regularisation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider.L2">
            <summary>
            L2 regularisation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.Regularisation">
            <summary>
            Prebuilt regularisation
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider">
            <summary>
            Prebuilt gradient descent optimisers
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.AdaGrad">
            <summary>
            Adagrad gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.Adam">
            <summary>
            Adam gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.Momentum">
            <summary>
            Momentum gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.NesterovMomentum">
            <summary>
            Nesterov momentum gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider.RmsProp">
            <summary>
            Rms prop gradient descent
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GradientDescent">
            <summary>
            Prebuilt gradient descent optimisers
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider">
            <summary>
            Error metrics
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.BinaryClassification">
            <summary>
            Binary classification error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.CrossEntropy">
            <summary>
            Cross entropy error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.OneHotEncoding">
            <summary>
            One hot encoding error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider.Quadratic">
            <summary>
            Quadratic error metric
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.ErrorMetric">
            <summary>
            Error metrics
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider">
            <summary>
            Prebuilt weight initialisers
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Ones">
            <summary>
            All weights are initialised to 1
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Zeroes">
            <summary>
            All weights are initialised to 0
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Gaussian">
            <summary>
            Weights are randomly initialised using a gaussian distribution
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Xavier">
            <summary>
            Weights are randomly initialised using the xavier algorithm
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Identity">
            <summary>
            Weights are initialised to the identity matrix
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider.Identity01">
            <summary>
            Weights are initialised to the identity matrix / 10
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.WeightInitialisation">
            <summary>
            Prebuilt weight initialisers
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider">
            <summary>
            Provides standard graph operations
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.OneDividedBy(System.String)">
            <summary>
            Calculates inverse (1/x) of graph input
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.InputSquared(System.String)">
            <summary>
            Calculates square (x^2) of graph input
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.SquareRootOf(System.String)">
            <summary>
            Calculates square root of graph input
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider.OneMinusInput(System.String)">
            <summary>
            Calculates one minus graph input (1-x)
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GraphOperation">
            <summary>
            Standard graph operations
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider">
            <summary>
            Provides standard graph actions
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider.Constrain(System.Single,System.Single)">
            <summary>
            Constrains the signal through the graph (either forward or backward)
            </summary>
            <param name="min">Minimum allowed value</param>
            <param name="max">Maximum allowed value</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.GraphFactory.GraphAction">
            <summary>
            Standard graph actions
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.ExecutionHistory">
            <summary>
            Record of graph execution
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.ExecutionHistory.#ctor(BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.IGraphData,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Creates a training action history from a single optional parent
            </summary>
            <param name="source">The node that executed</param>
            <param name="data">The output of the node</param>
            <param name="parent">The single parent that contributed to the output (optional)</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.ExecutionHistory.#ctor(BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.IGraphData,BrightWire.ExecutionGraph.Node.NodeBase[])">
            <summary>
            Creates a training action history from multiple parents
            </summary>
            <param name="source">The node that executed</param>
            <param name="data">The output of the node</param>
            <param name="parents">The parent nodes that contributed to the output</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.ExecutionHistory.Source">
            <summary>
            Node that was executed
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.ExecutionHistory.Data">
            <summary>
            Node output signal
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.ExecutionHistory.Backpropagation">
            <summary>
            Optional backpropagation
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.ExecutionHistory.Parents">
            <summary>
            The node's ancestors
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.ExecutionHistory.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.GraphData">
            <summary>
            Graph data constants
            </summary>
        </member>
        <member name="F:BrightWire.ExecutionGraph.Helper.GraphData.Null">
            <summary>
            Null graph data
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MatrixGraphData">
            <summary>
            Graph data adaptor for matrices
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MatrixGraphData.#ctor(BrightData.IMatrix{System.Single})">
            <summary>
            Graph data adaptor for matrices
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.Tensor3DGraphData">
            <summary>
            Graph data adaptor for 3D tensors
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.Tensor3DGraphData.#ctor(BrightData.IMatrix{System.Single},System.UInt32,System.UInt32)">
            <summary>
            Graph data adaptor for 3D tensors
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.Tensor4DGraphData">
            <summary>
            Graph data adapter for 4D tensors
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.Tensor4DGraphData.#ctor(BrightData.IMatrix{System.Single},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Graph data adapter for 4D tensors
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.GraphHelperMethods">
            <summary>
            Graph extension methods
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.GraphHelperMethods.ReshapeAsMatrix(BrightData.ITensor3D{System.Single})">
            <summary>
            Reshapes the 3D tensor as a matrix
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.GraphHelperMethods.ReshapeAsMatrix(BrightData.ITensor4D{System.Single})">
            <summary>
            Reshapes the 4D tensor as a matrix
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MiniBatch">
            <summary>
            Information about the current mini batch
            </summary>
            <remarks>
            Creates a sequential mini batch
            </remarks>
            <param name="rows">The indices of the rows in this mini batch</param>
            <param name="dataSource">Associated data source</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.#ctor(System.UInt32[],BrightWire.IDataSource)">
            <summary>
            Information about the current mini batch
            </summary>
            <remarks>
            Creates a sequential mini batch
            </remarks>
            <param name="rows">The indices of the rows in this mini batch</param>
            <param name="dataSource">Associated data source</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence">
            <summary>
            A sequence within a mini batch
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.#ctor(BrightWire.IGraphData,BrightWire.IGraphData,BrightWire.ExecutionGraph.Helper.MiniBatch,System.UInt32,BrightWire.MiniBatchSequenceType)">
            <summary>
            A sequence within a mini batch
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.MiniBatch">
            <summary>
            Mini batch
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.SequenceIndex">
            <summary>
            Index of the sequence
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.Type">
            <summary>
            Sequence type
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.Input">
            <summary>
            Input data
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.Target">
            <summary>
            Training target data
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.GraphContext">
            <summary>
            Graph sequence context that has been executed for this sequence
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.#ctor(System.UInt32[],BrightWire.IDataSource,BrightWire.IGraphData,BrightWire.IGraphData,System.Boolean,BrightWire.MiniBatchSequenceType,System.UInt32)">
            <summary>
            Creates a non sequential mini batch
            </summary>
            <param name="rows">The indices of the rows in this mini batch</param>
            <param name="dataSource">Associated data source</param>
            <param name="input">Mini batch input data</param>
            <param name="output">Expected output data (when training, otherwise null)</param>
            <param name="isSequential"></param>
            <param name="type"></param>
            <param name="sequenceIndex"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.Add(BrightWire.MiniBatchSequenceType,BrightWire.IGraphData,BrightWire.IGraphData)">
            <summary>
            Adds another item to the sequential mini batch
            </summary>
            <param name="type">Type of the sequential item</param>
            <param name="input">Mini batch input data</param>
            <param name="output">Expected output data (when training, otherwise null)</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.Rows">
            <summary>
            Row indexes of the current batch
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.DataSource">
            <summary>
            Data source
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.IsSequential">
            <summary>
            True if the data is sequential
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.BatchSize">
            <summary>
            Number of items in the batch
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.CurrentSequence">
            <summary>
            Current sequence (non sequential batches have a single sequence)
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.HasNextSequence">
            <summary>
            True if there is another item in the sequence after the current item
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.SequenceCount">
            <summary>
            Gets the length of the sequence
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.Reset">
            <summary>
            Resets the sequence iterator
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.GetNextSequence">
            <summary>
            Gets the next item in the sequence (or null if none)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatch.GetSequenceAtIndex(System.UInt32)">
            <summary>
            Gets a sequence item
            </summary>
            <param name="index">The index to retrieve</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.NextMiniBatch">
            <summary>
            Subsequent mini batch
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.MiniBatch.PreviousMiniBatch">
            <summary>
            Previous mini batch
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.MiniBatchProvider">
            <summary>
            Divides epochs into a list of mini batches
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.MiniBatchProvider.#ctor(BrightWire.IDataSource,System.Random)">
            <summary>
            Divides epochs into a list of mini batches
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Helper.WireToNode">
            <summary>
            Wires connect nodes in the graph
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Helper.WireToNode.#ctor(BrightWire.ExecutionGraph.Node.NodeBase,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="node">The destination node</param>
            <param name="channel">The input channel on the node</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.WireToNode.SendTo">
            <summary>
            The node to send a signal to
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Helper.WireToNode.Channel">
            <summary>
            The channel to send the signal on
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Attention.TensorFeedForward">
            <summary>
            Applies a feed forward node to each matrix within a tensor
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Attention.TensorFeedForward.#ctor(BrightWire.IFeedForward,System.String,System.String)">
            <summary>
            Applies a feed forward node to each matrix within a tensor
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.BackpropagationBase`1">
            <summary>
            Base class for node backpropagation
            </summary>
            <typeparam name="T">The node type</typeparam>
        </member>
        <member name="F:BrightWire.ExecutionGraph.Node.BackpropagationBase`1._source">
            <summary>
            The node that generated the forward signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="source">The node that generated the forward signal</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.DisposeMemory(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="isDisposing"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.ErrorTo(BrightWire.IGraphData,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase[])">
            <summary>
            Sends the error to each of the parents
            </summary>
            <param name="errorSignal"></param>
            <param name="context"></param>
            <param name="parents"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.BackpropagationBase`1.Backward(BrightWire.IGraphData,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase[])">
            <summary>
            Backpropagates the error
            </summary>
            <param name="errorSignal"></param>
            <param name="context"></param>
            <param name="parents"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Filter.DropConnect">
            <summary>
            Drop connect (inverted) regularisation
            http://cs.nyu.edu/~wanli/dropc/
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Filter.DropOut">
            <summary>
            Drop out (inverted) regularisation
            https://en.wikipedia.org/wiki/Dropout_(neural_networks)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.AddGate">
            <summary>
            Outputs the two input signals added together
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.AddGate.#ctor(System.String)">
            <summary>
            Outputs the two input signals added together
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase">
            <summary>
            Base class for nodes that accept two input signals and output one signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase.ForwardSingleStep(BrightWire.IGraphData,System.UInt32,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase.Activate(BrightWire.IGraphContext,BrightWire.IGraphData,BrightWire.IGraphData,BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            When both the primary and secondary inputs have arrived
            </summary>
            <param name="context">Graph context</param>
            <param name="primary">Primary signal</param>
            <param name="secondary">Secondary signal</param>
            <param name="primarySource">Primary source node</param>
            <param name="secondarySource">Secondary source node</param>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase">
            <summary>
            Base class for nodes that accept input on an arbitrary number of channels and output a single signal
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel">
            <summary>
            Information about an incoming signal
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Channel">
            <summary>
            The channel on which the signal was received
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Data">
            <summary>
            The signal
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Source">
            <summary>
            The node the signal came from
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Size">
            <summary>
            The size of the input signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="size">The size of the input signal</param>
            <param name="channel">The channel</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.SetData(BrightData.IMatrix{System.Single},BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Sets data
            </summary>
            <param name="data">The node signal</param>
            <param name="source">The source node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.Clear">
            <summary>
            Clears the data
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel.IsValid">
            <summary>
            True if a signal has been received
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.#ctor(System.String,BrightWire.ExecutionGraph.WireBuilder[])">
            <summary>
            Constructor
            </summary>
            <param name="name">The name of the node (optional)</param>
            <param name="incoming">The list of incoming wires</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.ForwardSingleStep(BrightWire.IGraphData,System.UInt32,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.Activate(BrightWire.IGraphContext,System.Collections.Generic.List{BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.IncomingChannel})">
            <summary>
            Called when all registered inputs have arrived
            </summary>
            <param name="context">The graph context</param>
            <param name="data">The list of incoming signals</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.GetInfo">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.ReadFrom(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiGateBase.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.MultiplyGate">
            <summary>
            Outputs the two input signals multiplied together
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.MultiplyGate.#ctor(System.String)">
            <summary>
            Outputs the two input signals multiplied together
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Gate.SubtractGate">
            <summary>
            Subtracts the second input from the first input
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Gate.SubtractGate.#ctor(System.String)">
            <summary>
            Subtracts the second input from the first input
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.ExecuteBackwardAction">
            <summary>
            Executes an action when back-propagating
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.ExecuteBackwardAction.#ctor(BrightWire.IAction,System.String)">
            <summary>
            Executes an action when back-propagating
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.ExecuteForwardAction">
            <summary>
            Executes an action when executing forward
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.ExecuteForwardAction.#ctor(BrightWire.IAction,System.String)">
            <summary>
            Executes an action when executing forward
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.HookErrorSignal">
            <summary>
            Provides a hook into the backpropagation signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.HookErrorSignal.#ctor(System.Action{BrightWire.IGraphContext},System.String)">
            <summary>
            Provides a hook into the backpropagation signal
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.RecurrentBridge">
            <summary>
            Connects the hidden states across two recurrent neural network nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.RecurrentBridge.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Connects the hidden states across two recurrent neural network nodes
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.RowClassifier">
            <summary>
            Executes a row based classifier
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.RowClassifier.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},BrightWire.IRowClassifier,BrightData.IDataTable,System.String)">
            <summary>
            Executes a row based classifier
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.TransposeAndCombineSignal">
            <summary>
            Transpose the input and combine each depth slice - used when translating between tensor and matrix based signals
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.TransposeAndCombineSignal.#ctor(System.String)">
            <summary>
            Transpose the input and combine each depth slice - used when translating between tensor and matrix based signals
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Helper.TransposeFrom4DTensorToMatrix">
            <summary>
            Transpose the input - used when translating between tensor and matrix based signals
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Helper.TransposeFrom4DTensorToMatrix.#ctor(System.String)">
            <summary>
            Transpose the input - used when translating between tensor and matrix based signals
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.FlowThrough">
            <summary>
            Simple pass through of the input signal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Input.FlowThrough.#ctor(System.String)">
            <summary>
            Simple pass through of the input signal
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.JoinSignalWithMemory">
            <summary>
            Joins the graph signal with a saved signal stored in named memory
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Input.JoinSignalWithMemory.#ctor(System.String,System.String)">
            <summary>
            Joins the graph signal with a saved signal stored in named memory
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.MemoryFeeder">
            <summary>
            Feeds memory into the graph from a named memory slot
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.OneToMany">
            <summary>
            Waits for all children to finish back-propagating before sending the error further backward
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Input.ReverseSequence">
            <summary>
            Inputs the opposite sequential item from the input index (for bidirectional recurrent neural networks)
            https://en.wikipedia.org/wiki/Bidirectional_recurrent_neural_networks
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.BatchNorm">
            <summary>
            Batch normalisation layer
            https://arxiv.org/abs/1502.03167
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.Convolutional">
            <summary>
            Convolutional neural network layer
            https://en.wikipedia.org/wiki/Convolutional_neural_network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.ElmanJordan">
            <summary>
            Elman or Jordan style recurrent neural network
            https://en.wikipedia.org/wiki/Recurrent_neural_network#Elman_networks_and_Jordan_networks
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.FeedForward">
            <summary>
            Feed forward neural network
            https://en.wikipedia.org/wiki/Feedforward_neural_network
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Layer.FeedForward.#ctor(System.UInt32,System.UInt32,BrightData.IVector{System.Single},BrightData.IMatrix{System.Single},BrightWire.IGradientDescentOptimisation,System.String)">
            <summary>
            Feed forward neural network
            https://en.wikipedia.org/wiki/Feedforward_neural_network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.GatedRecurrentUnit">
            <summary>
            GRU recurrent neural network
            https://en.wikipedia.org/wiki/Gated_recurrent_unit
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.LongShortTermMemory">
            <summary>
            LSTM recurrent neural network
            https://en.wikipedia.org/wiki/Long_short-term_memory
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.MaxPool">
            <summary>
            Max pooling convolutional neural network
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Layer.MaxPool.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Max pooling convolutional neural network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer">
            <summary>
            Implementation of Recurrent Additive Network
            http://www.kentonl.com/pub/llz.2017.pdf
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer.Output">
            <summary>
            Expose the output node so that we can append nodes to it
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.Layer.RecurrentAdditiveLayer.SubNodes">
            <summary>
            The list of sub nodes
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.SelfAttention">
            <summary>
            Implementation of self attention from: https://arxiv.org/abs/1409.0473
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Layer.SelfAttention.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.String,System.String,BrightWire.ExecutionGraph.Node.Layer.FeedForward,System.String,System.String)">
            <summary>
            Implementation of self attention from: https://arxiv.org/abs/1409.0473
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.SimpleRecurrent">
            <summary>
            Simple recurrent neural network
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Layer.TiedFeedForward">
            <summary>
            A feed forward layer with tied weights (from a previous feed forward layer)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Layer.TiedFeedForward.#ctor(BrightWire.IFeedForward,BrightWire.IWeightInitialisation,System.String)">
            <summary>
            A feed forward layer with tied weights (from a previous feed forward layer)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.NodeBase">
            <summary>
            Base class for graph nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">The name of the node (optional)</param>
            <param name="id">The node's unique id (optional)</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Initialise(BrightWire.ExecutionGraph.GraphFactory,System.String,System.Byte[])">
            <summary>
            Called when de-serialising the node
            </summary>
            <param name="graph">Graph factory</param>
            <param name="description">Node description</param>
            <param name="data">Node serialisation data</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Dispose">
            <summary>
            Disposal
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.DisposeInternal(System.Boolean)">
            <summary>
            Disposal
            </summary>
            <param name="isDisposing"></param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.Id">
            <summary>
            The node's unique id
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.Name">
            <summary>
            The node's name in the graph
            </summary>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.Output">
            <summary>
            The list of outgoing wires along which the output signal will be sent
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Forward(BrightWire.IGraphData,BrightWire.IGraphContext,System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Executes the graph
            </summary>
            <param name="signal">Initial data</param>
            <param name="context">Context</param>
            <param name="channel"></param>
            <param name="prev"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ForwardSingleStep(BrightWire.IGraphData,System.UInt32,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Executes a single forward step
            </summary>
            <param name="signal"></param>
            <param name="channel"></param>
            <param name="context"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.SerialiseTo(System.Collections.Generic.HashSet{BrightWire.ExecutionGraph.Node.NodeBase},System.Collections.Generic.List{BrightWire.Models.ExecutionGraphModel.Node},System.Collections.Generic.HashSet{BrightWire.Models.ExecutionGraphModel.Wire})">
            <summary>
            Serialise this node and any connected nodes
            </summary>
            <param name="existing">Set of nodes that have already been serialised in the current context</param>
            <param name="connectedTo">List of nodes this node is connected to</param>
            <param name="wireList">List of wires between all connected nodes</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.GetInfo">
            <summary>
            Returns serialisation information
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.OnDeserialise(System.Collections.Generic.IReadOnlyDictionary{System.String,BrightWire.ExecutionGraph.Node.NodeBase})">
            <summary>
            Called after the graph has been completely deserialised
            </summary>
            <param name="graph">The complete graph</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Serialise the node
            </summary>
            <param name="writer">Binary writer</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ReadFrom(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Deserialise the node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="reader">Binary reader</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Initialise(BrightWire.ExecutionGraph.GraphFactory,System.String,System.String,System.String,System.Byte[])">
            <summary>
            Initialise the node from serialised data
            </summary>
            <param name="factory">Graph factory</param>
            <param name="id">Unique id</param>
            <param name="name">Node name</param>
            <param name="description">Node description</param>
            <param name="data">Serialisation data</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.FindByName(System.String)">
            <summary>
            Finds a connected node by friendly name
            </summary>
            <param name="name">The node's name to search for</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.FindById(System.String)">
            <summary>
            Finds a connected node by id
            </summary>
            <param name="id">Unique id to find</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.Node.NodeBase.SubNodes">
            <summary>
            The list of sub-nodes
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Serialise(BrightWire.ExecutionGraph.Node.NodeBase,System.IO.BinaryWriter)">
            <summary>
            Serialise the node to the writer
            </summary>
            <param name="node">The node to serialise</param>
            <param name="writer">The binary writer</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.WriteData(System.Action{System.IO.BinaryWriter})">
            <summary>
            Helper function to write data to a binary writer
            </summary>
            <param name="callback">Callback to receive the writer</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ReadFrom(System.Byte[],System.Action{System.IO.BinaryReader})">
            <summary>
            Helper function to read from a binary reader
            </summary>
            <param name="data">The data to read</param>
            <param name="callback">Callback to receive the writer</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.Hydrate(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Reads serialisation information and creates a node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.LoadParameters(BrightWire.ExecutionGraph.GraphFactory,BrightWire.Models.ExecutionGraphModel.Node)">
            <summary>
            Loads parameters into an existing node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="nodeData">Serialised node parameters</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.FindSubNodeByNameOrThrow(System.String)">
            <summary>
            Finds a sub node by name, or throws an exception if not found
            </summary>
            <param name="name">Sub node name</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.WriteSubNode(System.String,System.IO.BinaryWriter)">
            <summary>
            Writes a sub node to the binary writer
            </summary>
            <param name="name">Sub node name</param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ReadSubNode(System.String,BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Initializes a sub node from a binary reader
            </summary>
            <param name="name">Sub node name</param>
            <param name="factory"></param>
            <param name="reader"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.RemoveDirectDescendant(BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Removes the wire that connects this from a direct descendant
            </summary>
            <param name="directDescendant"></param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.NodeBase.ApplyError(BrightWire.NodeErrorType,BrightData.ITensor{System.Single},BrightWire.ILearningContext)">
            <summary>
            Applies an error to this node
            </summary>
            <param name="type">Error type</param>
            <param name="delta"></param>
            <param name="context"></param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.BatchMean">
            <summary>
            Calculates the mean across the batch 
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Operation.BatchMean.#ctor(System.String)">
            <summary>
            Calculates the mean across the batch 
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.OneDividedByInput">
            <summary>
            Calculates 1/x
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Operation.OneDividedByInput.#ctor(System.String)">
            <summary>
            Calculates 1/x
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.OneMinusInput">
            <summary>
            Subtracts the input from one (1-x)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Operation.OneMinusInput.#ctor(System.String)">
            <summary>
            Subtracts the input from one (1-x)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput">
            <summary>
            Calculates the square root of the input
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput.#ctor(System.String)">
            <summary>
            Calculates the square root of the input
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput.Backpropagation">
            <summary>
            Derivative of sqrt(x) is 0.5/sqrt(x)
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput.Backpropagation.#ctor(BrightWire.ExecutionGraph.Node.Operation.SquareRootOfInput,BrightData.IMatrix{System.Single})">
            <summary>
            Derivative of sqrt(x) is 0.5/sqrt(x)
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.Node.SingleBackpropagationBase`1">
            <summary>
            Base class for nodes that back propagate to a single parent
            </summary>
            <typeparam name="T">The node type</typeparam>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.SingleBackpropagationBase`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="source">The node that generated the forward signal</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.SingleBackpropagationBase`1.Backpropagate(BrightWire.IGraphData,BrightWire.IGraphContext)">
            <summary>
            Backpropagates the error
            </summary>
            <param name="errorSignal"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.Node.SingleBackpropagationBase`1.Backward(BrightWire.IGraphData,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase[])">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Constant">
            <summary>
            Initializes all weights to a constant
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WeightInitialisation.Constant.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.Single,System.Single)">
            <summary>
            Initializes all weights to a constant
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Gaussian">
            <summary>
            Initialises weights randomly based on a gaussian distribution
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Identity">
            <summary>
            Identity matrix: https://arxiv.org/abs/1504.00941
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WeightInitialisation.Identity.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.Single)">
            <summary>
            Identity matrix: https://arxiv.org/abs/1504.00941
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WeightInitialisation.Xavier">
            <summary>
            Xavier weight initialisation
            http://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WeightInitialisation.Xavier.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.Single)">
            <summary>
            Xavier weight initialisation
            http://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization
            </summary>
        </member>
        <member name="T:BrightWire.ExecutionGraph.WireBuilder">
            <summary>
            Wires nodes together to build strands of a graph
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.#ctor(BrightWire.ExecutionGraph.GraphFactory,System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Connects new nodes starting from the specified node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="size">Initial wire size</param>
            <param name="node">The node to build from</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.#ctor(BrightWire.ExecutionGraph.GraphFactory,System.UInt32,System.UInt32,System.UInt32,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Connects new nodes starting from the specified node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="width">Initial input width</param>
            <param name="height">Initial input height</param>
            <param name="depth">Initial input depth</param>
            <param name="node">The node to build from</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.#ctor(BrightWire.ExecutionGraph.GraphFactory,BrightWire.IGraphTrainingEngine)">
            <summary>
            Connects new nodes to the engine output node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="engine">Graph engine</param>
        </member>
        <member name="P:BrightWire.ExecutionGraph.WireBuilder.CurrentSize">
            <summary>
            The current wire size
            </summary>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.SetNewSize(System.UInt32)">
            <summary>
            Changes the current size of the builder
            </summary>
            <param name="newSize">New size</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.SetNewSize(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Changes the current size of the builder
            </summary>
            <param name="width">New width</param>
            <param name="height">New height</param>
            <param name="depth">New depth</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddClassifier(BrightWire.IRowClassifier,BrightData.IDataTable,System.String)">
            <summary>
            Connects a row classifier
            </summary>
            <param name="classifier"></param>
            <param name="dataTable"></param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddFeedForward(System.UInt32,System.String)">
            <summary>
            Adds a feed forward layer
            </summary>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddTiedFeedForward(BrightWire.IFeedForward,System.String)">
            <summary>
            Adds a feed forward layer whose weights are tied to a previous layer
            </summary>
            <param name="layer">The layer whose weights are tied</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddDropOut(System.Single,System.String)">
            <summary>
            Adds a drop out layer
            </summary>
            <param name="dropOutPercentage">Percentage of connections to drop</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddDropConnect(System.Single,System.UInt32,System.String)">
            <summary>
            Adds a drop connect layer
            </summary>
            <param name="dropOutPercentage">Percentage of connections to drop</param>
            <param name="outputSize">Number of outgoing connections</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddOutput(System.Int32,System.String)">
            <summary>
            Creates a node that writes the current forward signal as an output of the graph
            </summary>
            <param name="channel">Output channel</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.Add(BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Adds a node
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddForwardAction(BrightWire.IAction,System.String)">
            <summary>
            Adds an action that will be executed in the forward pass
            </summary>
            <param name="action">Action to execute</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBackwardAction(BrightWire.IAction,System.String)">
            <summary>
            Adds an action that will be executed in the backward pass
            </summary>
            <param name="action">Action to execute</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBatchNormalisation(System.String)">
            <summary>
            Adds a batch normalisation layer
            </summary>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddRecurrentBridge(System.String,System.String,System.String)">
            <summary>
            Creates a bridge between two recurrent nodes that will copy the hidden state from one to another and copy the error signal backwards between the two
            </summary>
            <param name="fromName">Name of the first recurrent node</param>
            <param name="toName">Name of the second recurrent node</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddSimpleRecurrent(BrightWire.ExecutionGraph.Node.NodeBase,System.UInt32,System.String)">
            <summary>
            Adds a simple recurrent neural network layer
            </summary>
            <param name="activation">Activation layer</param>
            <param name="memorySize">Size of the memory layer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddElman(BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.UInt32,System.String)">
            <summary>
            Adds an Elman recurrent neural network layer
            </summary>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddJordan(BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.ExecutionGraph.Node.NodeBase,System.UInt32,System.String)">
            <summary>
            Adds a Jordan recurrent neural network layer
            </summary>
            <param name="activation">First activation layer</param>
            <param name="activation2">Second activation layer</param>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddGru(System.UInt32,System.String)">
            <summary>
            Adds a gated recurrent unit recurrent neural network layer
            </summary>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddRan(System.UInt32,System.String)">
            <summary>
            Adds a recurrent additive layer (recurrent)
            </summary>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddLstm(System.UInt32,System.String)">
            <summary>
            Adds a long short term memory recurrent neural network layer
            </summary>
            <param name="memorySize">Size of the memory buffer</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.ReverseSequence(System.String)">
            <summary>
            Adds a node that will reverse the sequence (for bidirectional recurrent neural networks)
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddMaxPooling(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a max pooling convolutional layer
            </summary>
            <param name="filterWidth">Width of max pooling filter</param>
            <param name="filterHeight">Height of max pooling filter</param>
            <param name="xStride">X stride</param>
            <param name="yStride">Y stride</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddConvolutional(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean,System.String)">
            <summary>
            Adds a convolutional layer
            </summary>
            <param name="filterCount">Number of filters in the layer</param>
            <param name="padding">Padding to add before applying the convolutions</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <param name="shouldBackpropagate">True to calculate a backpropagation signal</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.TransposeFrom4DTensorToMatrix(System.String)">
            <summary>
            Transposes the graph signal to move between convolutional and non-convolutional layers
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.TransposeAndCombine(System.String)">
            <summary>
            Transposes the graph signal and merges each depth slice
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBackpropagation(System.String)">
            <summary>
            Adds backpropagation - when executed an error signal will be calculated and flow backwards to previous nodes
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddBackpropagationThroughTime(System.String)">
            <summary>
            Adds backpropagation through time
            </summary>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddSequenceToSequencePivot(System.String,System.String,System.String)">
            <summary>
            Pivots between the encoder and decoder sequences (seq2seq)
            </summary>
            <param name="encoderName">Encoder node name</param>
            <param name="decoderName">Decoder node name</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.ConstrainForwardSignal(System.Single,System.Single,System.String)">
            <summary>
            Constrains the error signal in the forward direction
            </summary>
            <param name="min">Minimum allowed value</param>
            <param name="max">Maximum allowed value</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.ConstrainBackwardSignal(System.Single,System.Single,System.String)">
            <summary>
            Constrains the error signal in the backward direction
            </summary>
            <param name="min">Minimum allowed value</param>
            <param name="max">Maximum allowed value</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.WriteNodeMemoryToSlot(System.String,System.String,System.String)">
            <summary>
            Writes node memory to a named memory slot
            </summary>
            <param name="slotName">Memory slot name</param>
            <param name="nodeName">The node name to read</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.AddSelfAttention(System.String,System.String,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a self attention node
            </summary>
            <param name="encoderName">Name of encoder node (must be same size as decoder)</param>
            <param name="decoderName">Name of decoder node (must be same size as encoder)</param>
            <param name="encoderSize">Size of the encoder</param>
            <param name="decoderSize">Size of the decoder</param>
            <param name="name">Optional name to give the node</param>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.JoinInputWithMemory(System.String,System.UInt32,System.String)">
            <summary>
            Concatenates the named memory slot with the input signal
            </summary>
            <param name="slotName">Memory slot name</param>
            <param name="memorySize">Size of the memory</param>
            <param name="name">Optional name to give the node</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExecutionGraph.WireBuilder.Find(System.String)">
            <summary>
            Tries to find the specified node
            </summary>
            <param name="name">The friendly name of the node</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.ExecutionGraph.WireBuilder.LastNode">
            <summary>
            The last added node
            </summary>
        </member>
        <member name="T:BrightWire.ExtensionMethods">
            <summary>
            Static extension methods
            </summary>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMarkovTrainer2``1(BrightData.BrightDataContext,``0,System.Int32)">
            <summary>
            Create a markov model trainer of window size 2
            </summary>
            <typeparam name="T">The markov chain data type</typeparam>
            <param name="_"></param>
            <param name="empty">Null value for T</param>
            <param name="minObservations">Minimum number of data points to record an observation</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateMarkovTrainer3``1(BrightData.BrightDataContext,``0,System.Int32)">
            <summary>
            Create a markov model trainer of window size 3
            </summary>
            <typeparam name="T">The markov chain data type</typeparam>
            <param name="_"></param>
            <param name="empty">Null value for T</param>
            <param name="minObservations">Minimum number of data points to record an observation</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Classify(BrightData.IDataTable,BrightWire.IRowClassifier)">
            <summary>
            Classifies each row in the data table
            </summary>
            <param name="dataTable"></param>
            <param name="classifier"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetRowsAsLabeledFeatures(BrightData.IDataTable,System.Boolean)">
            <summary>
            Enumerates rows in the table as vectorized rows
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncode"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.HierarchicalCluster(BrightData.IDataTable,System.UInt32)">
            <summary>
            Clusters the rows in the data table using hierarchical clustering
            </summary>
            <param name="dataTable"></param>
            <param name="k">Number of clusters</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.KMeans(BrightData.IDataTable,System.UInt32,System.UInt32,BrightData.DistanceMetric)">
            <summary>
            Clusters the rows in the data table using k-means clustering
            </summary>
            <param name="dataTable"></param>
            <param name="k">Number of clusters</param>
            <param name="maxIterations">Maximum number of iterations</param>
            <param name="distanceMetric">Distance metric to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.NonNegativeMatrixFactorisation(BrightData.IDataTable,System.UInt32,System.UInt32)">
            <summary>
            Clusters the rows in the data table using non-negative matrix factorisation clustering
            </summary>
            <param name="dataTable"></param>
            <param name="k">Number of clusters</param>
            <param name="maxIterations">Maximum number of iterations</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetOutputSizeOrThrow(BrightWire.IDataSource)">
            <summary>
            Returns the output size (throw exception if not set)
            </summary>
            <param name="dataSource"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateGraphFactory(BrightData.BrightDataContext,BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single})">
            <summary>
            Creates a graph factory
            </summary>
            <param name="context"></param>
            <param name="lap">Linear algebra provider (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateGraphFactory(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single})">
            <summary>
            Creates a graph factory
            </summary>
            <param name="lap"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateSequentialWindow(BrightData.IDataTable,System.UInt32,System.UInt32[])">
            <summary>
            Creates a matrix to vector training table in which the matrix contains a window of sequentially ordered rows
            </summary>
            <param name="dataTable"></param>
            <param name="windowSize">The number of rows in each matrix</param>
            <param name="columnIndices">Column indices to select</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateConfusionMatrix(BrightData.IDataTable,System.UInt32,System.UInt32)">
            <summary>
            Creates a confusion matrix from two columns of a data table
            </summary>
            <param name="dataTable">Data table</param>
            <param name="actualClassificationColumnIndex">The column index of the actual classifications</param>
            <param name="expectedClassificationColumnIndex">The column index of the expected classifications</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Classify(BrightData.IndexListWithLabel{System.String}[],BrightWire.IIndexListClassifier)">
            <summary>
            Classifies each row of the index classification list
            </summary>
            <param name="data"></param>
            <param name="classifier">The classifier to classify each item in the list</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsRowClassifier(BrightWire.IIndexListClassifier,System.UInt32,BrightData.IIndexStrings)">
            <summary>
            Converts the index list classifier to a row classifier
            </summary>
            <param name="classifier">Index list classifier</param>
            <param name="columnIndex">Column index to classify</param>
            <param name="indexer">String indexer (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Train(BrightWire.IGraphTrainingEngine,System.UInt32,BrightWire.IDataSource,System.Action{BrightWire.Models.GraphModel},System.Int32)">
            <summary>
            Trains a graph for a fixed number of iterations
            </summary>
            <param name="engine">The graph training engine</param>
            <param name="numIterations">The number of iterations to train for</param>
            <param name="testData">The test data source to use</param>
            <param name="onImprovement">Optional callback for when the test data score has improved against the error metric</param>
            <param name="testCadence">Determines how many epochs elapse before the test data is evaluated</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Classify(BrightWire.IRowClassifier,BrightData.IDataTable)">
            <summary>
            Classifies each row of the data table
            </summary>
            <param name="classifier"></param>
            <param name="dataTable"></param>
            <returns>A list of rows with their corresponding classifications</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetGraph(BrightWire.ExecutionGraph.Node.NodeBase,System.String)">
            <summary>
            Serialises the node and any other connected nodes to an execution graph
            </summary>
            <param name="input"></param>
            <param name="name">Name of the graph (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateFrom(BrightWire.ExecutionGraph.GraphFactory,BrightWire.Models.ExecutionGraphModel)">
            <summary>
            Creates a node and any other connected nodes from a serialised execution graph
            </summary>
            <param name="factory"></param>
            <param name="graph">Serialised graph</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.OrderSequentialOutput(System.Collections.Generic.IAsyncEnumerable{BrightWire.Models.ExecutionResult})">
            <summary>
            Aligns the output of sequential graph execution into an ordered list of results
            </summary>
            <param name="results">Output from sequential graph execution</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.OrderSequentialOutput(System.Collections.Generic.IEnumerable{BrightWire.Models.ExecutionResult})">
            <summary>
            Aligns the output of sequential graph execution into an ordered list of results
            </summary>
            <param name="results">Output from sequential graph execution</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsGraphData(BrightData.IMatrix{System.Single})">
            <summary>
            Converts the matrix to a generic IGraphData
            </summary>
            <param name="matrix">Matrix to convert</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsGraphData(BrightData.ITensor3D{System.Single})">
            <summary>
            Converts the 3D tensor to a generic IGraphData
            </summary>
            <param name="tensor">Tensor to convert</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.AsGraphData(BrightData.ITensor4D{System.Single})">
            <summary>
            Converts the 4D tensor to a generic IGraphData
            </summary>
            <param name="tensor">Tensor to convert</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetGraphContexts(BrightWire.ExecutionGraph.Helper.MiniBatch)">
            <summary>
            Finds the graph sequence contexts that have been executed in this mini batch
            </summary>
            <param name="miniBatch"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetLinearAlgebraProvider(BrightWire.IGraphContext)">
            <summary>
            Returns the linear algebra provider associated from this graph context
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.CreateRandomProjection(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Random projections allow you to reduce the dimensions of a matrix while still preserving significant information
            </summary>
            <param name="lap">Linear algebra provider</param>
            <param name="fixedSize">The vector size to reduce from</param>
            <param name="reducedSize">The vector size to reduce to</param>
            <param name="s"></param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetTransitions``1(System.Collections.Generic.Dictionary{BrightWire.Models.Bayesian.MarkovModelObservation2{``0},BrightWire.Models.Bayesian.MarkovModelStateTransition{``0}[]},``0,``0)">
            <summary>
            Find the next set of state transitions from a pair of observations
            </summary>
            <typeparam name="T">The type of the model</typeparam>
            <param name="model">A markov model saved to a dictionary</param>
            <param name="item1">The first observation</param>
            <param name="item2">The second observation</param>
            <returns>The list of state transitions or null if nothing was found</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetTransitions``1(System.Collections.Generic.Dictionary{BrightWire.Models.Bayesian.MarkovModelObservation3{``0},BrightWire.Models.Bayesian.MarkovModelStateTransition{``0}[]},``0,``0,``0)">
            <summary>
            Find the next set of state transitions from a tuple of observations
            </summary>
            <typeparam name="T">The type of the model</typeparam>
            <param name="model">A markov model saved to a dictionary</param>
            <param name="item1">The first observation</param>
            <param name="item2">The second observation</param>
            <param name="item3">The third observation</param>
            <returns>The list of state transitions or null if nothing was found</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.Nnmf(BrightData.IReadOnlyVector{System.Single}[],BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.UInt32,System.UInt32)">
            <summary>
            Non-negative matrix factorisation - clustering based on matrix factorisation. Only applicable for training data that is non-negative.
            </summary>
            <param name="data">The training data</param>
            <param name="lap">Linear algebra provider</param>
            <param name="k">The number of clusters</param>
            <param name="maxIterations">The maximum number of iterations</param>
            <returns>A list of k clusters</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainKNearestNeighbours(BrightData.IDataTable)">
            <summary>
            K Nearest Neighbours is an instance based classification method that uses examples from training data to predict classifications
            </summary>
            <param name="data">The training data</param>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainRandomForest(BrightData.IDataTable,System.UInt32,System.Nullable{System.UInt32},BrightWire.TreeBased.Training.DecisionTreeTrainer.Config)">
            <summary>
            Random forests are built on a bagged collection of features to try to capture the most salient points of the training data without overfitting
            </summary>
            <param name="data">The training data</param>
            <param name="b">The number of trees in the forest</param>
            <param name="baggedRowCount"></param>
            <param name="config"></param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainDecisionTree(BrightData.IDataTable,BrightWire.TreeBased.Training.DecisionTreeTrainer.Config)">
            <summary>
            Decision trees build a logical tree to classify data. Various measures can be specified to prevent overfitting.
            </summary>
            <param name="data">The training data</param>
            <param name="config"></param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainMultinomialNaiveBayes(System.Collections.Generic.IEnumerable{BrightData.IndexListWithLabel{System.String}})">
            <summary>
            Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.
            </summary>
            <param name="data">The training data</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainMultinomialNaiveBayes(BrightData.IDataTable)">
            <summary>
            Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.
            </summary>
            <param name="table">The training data table that must have an index-list based column to classify against</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainBernoulliNaiveBayes(System.Collections.Generic.IEnumerable{BrightData.IndexListWithLabel{System.String}})">
            <summary>
            Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.
            </summary>
            <param name="data">The training data</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainBernoulliNaiveBayes(BrightData.IDataTable)">
            <summary>
            Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.
            </summary>
            <param name="table">The training data table that must have an index-list based column</param>
            <returns>A model that can be used for classification</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainNaiveBayes(BrightData.IDataTable)">
            <summary>
            Naive bayes is a classifier that assumes conditional independence between all features
            </summary>
            <param name="table">The training data provider</param>
            <returns>A naive bayes model</returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.GetBestClassification(System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,System.Single}})">
            <summary>
            Finds the classification with the highest weight
            </summary>
            <param name="classifications">List of weighted classifications</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.ExtensionMethods.TrainSimpleNeuralNetwork(BrightWire.ExecutionGraph.GraphFactory,BrightData.IDataTable,BrightData.IDataTable,BrightWire.IErrorMetric,System.Single,System.UInt32,System.UInt32,System.UInt32,System.Func{BrightWire.ExecutionGraph.GraphFactory,BrightWire.ExecutionGraph.Node.NodeBase},System.Func{BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider,BrightWire.ICreateTemplateBasedGradientDescent},System.Func{BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider,BrightWire.IWeightInitialisation})">
            <summary>
            Trains a neural network with a single hidden layer
            </summary>
            <param name="graph"></param>
            <param name="trainingTable"></param>
            <param name="testTable"></param>
            <param name="errorMetric"></param>
            <param name="learningRate"></param>
            <param name="batchSize"></param>
            <param name="hiddenLayerSize"></param>
            <param name="numIterations"></param>
            <param name="activation"></param>
            <param name="gradientDescent"></param>
            <param name="weightInitialisation"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Helper.PropertySet">
            <summary>
            Property set implementation
            </summary>
        </member>
        <member name="M:BrightWire.Helper.PropertySet.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single})">
            <summary>
            Property set implementation
            </summary>
        </member>
        <member name="P:BrightWire.Helper.PropertySet.LinearAlgebraProvider">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Helper.RandomProjection">
            <summary>
            Implements random projection
            </summary>
        </member>
        <member name="T:BrightWire.Helper.TypeLoader">
            <summary>
            Loads types in an assembly agnostic fashion
            </summary>
        </member>
        <member name="T:BrightWire.Helper.VectorBasedStatistics">
            <summary>
            Calculate vector based statistics
            </summary>
        </member>
        <member name="M:BrightWire.Helper.VectorBasedStatistics.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.UInt32,System.Single[],System.Single[],System.UInt32)">
            <summary>
            Calculate vector based statistics
            </summary>
        </member>
        <member name="T:BrightWire.Helper.VectorDistanceHelper">
            <summary>
            Calculates the distance between a list of vectors and a list of vectors to compare against
            </summary>
        </member>
        <member name="M:BrightWire.Helper.VectorDistanceHelper.#ctor(BrightData.IVector{System.Single}[],BrightData.DistanceMetric)">
            <summary>
            Constructor
            </summary>
            <param name="data">List of vectors to compare</param>
            <param name="distanceMetric">Distance metric for comparison</param>
        </member>
        <member name="P:BrightWire.Helper.VectorDistanceHelper.CompareTo">
            <summary>
            The list of vectors to compare against
            </summary>
        </member>
        <member name="P:BrightWire.Helper.VectorDistanceHelper.Metric">
            <summary>
            Distance metric
            </summary>
        </member>
        <member name="M:BrightWire.Helper.VectorDistanceHelper.AddComparison(BrightData.IVector{System.Single})">
            <summary>
            Adds a comparison vector (will be owned and disposed by the helper class)
            </summary>
            <param name="comparison">Vector to compare against</param>
            <returns>Index of the comparison vector</returns>
        </member>
        <member name="M:BrightWire.Helper.VectorDistanceHelper.UpdateComparisonVector(System.Int32,BrightData.IVector{System.Single})">
            <summary>
            Updates the comparison vector at this index (disposes the old vector)
            </summary>
            <param name="index">Index to update</param>
            <param name="newVector">Vector to replace with</param>
        </member>
        <member name="M:BrightWire.Helper.VectorDistanceHelper.SetComparisonVectors(System.Collections.Generic.IEnumerable{BrightData.IVector{System.Single}})">
            <summary>
            Updates the entire list of comparison vectors
            </summary>
            <param name="comparisonVectors">List of vectors to compare against</param>
        </member>
        <member name="M:BrightWire.Helper.VectorDistanceHelper.GetClosest">
            <summary>
            Returns the index of the closest comparison vector for each vector
            </summary>
        </member>
        <member name="M:BrightWire.Helper.VectorDistanceHelper.GetAverageFromData(System.UInt32[])">
            <summary>
            Returns a vector averaged from the data vectors
            </summary>
            <param name="indices">Indices of the data vectors to use in the averaged vector</param>
        </member>
        <member name="T:BrightWire.InstanceBased.KnnClassifier">
            <summary>
            K Nearest Neighbour classifier
            </summary>
        </member>
        <member name="T:BrightWire.InstanceBased.Training.KnnClassificationTrainer">
            <summary>
            K Nearest Neighbour classification trainer
            </summary>
        </member>
        <member name="T:BrightWire.IGraphData">
            <summary>
            Wrapper around the data that is used as a signal between nodes in the graph
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Rows">
            <summary>
            Row count
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Columns">
            <summary>
            Column count
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Depth">
            <summary>
            3D Tensor depth (1 if the signal is a matrix)
            </summary>
        </member>
        <member name="P:BrightWire.IGraphData.Count">
            <summary>
            Count of 3D tensors (1 if the signal is a matrix or 3D tensor)
            </summary>
        </member>
        <member name="M:BrightWire.IGraphData.GetMatrix">
            <summary>
            Gets the signal as a matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphData.Get3DTensor">
            <summary>
            Gets the signal as a 3D tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphData.Get4DTensor">
            <summary>
            Gets the signal as a 4D tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphData.ReplaceWith(BrightData.IMatrix{System.Single})">
            <summary>
            Replaces the data with the specified matrix (but preserves any tensor metadata)
            </summary>
            <param name="matrix">The matrix to use as a replacement</param>
        </member>
        <member name="P:BrightWire.IGraphData.Item(System.UInt32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:BrightWire.IGraphData.HasValue">
            <summary>
            True if this graph data has been set (false for null)
            </summary>
        </member>
        <member name="T:BrightWire.IAction">
            <summary>
            An action to perform when a signal reaches a node
            </summary>
        </member>
        <member name="M:BrightWire.IAction.Execute(BrightWire.IGraphData,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Executes the action
            </summary>
            <param name="input">Current graph signal</param>
            <param name="context">Graph context</param>
            <param name="node"></param>
            <returns>Optional new graph signal to propagate</returns>
        </member>
        <member name="M:BrightWire.IAction.Serialise">
            <summary>
            Serialises the action to a string
            </summary>
        </member>
        <member name="M:BrightWire.IAction.Initialise(System.String)">
            <summary>
            Initialises the action
            </summary>
            <param name="data">Previously serialised data</param>
        </member>
        <member name="T:BrightWire.ICanInitialiseNode">
            <summary>
            Interface that allows the node to be initialised
            </summary>
        </member>
        <member name="M:BrightWire.ICanInitialiseNode.Initialise(BrightWire.ExecutionGraph.GraphFactory,System.String,System.String,System.String,System.Byte[])">
            <summary>
            Initialise the node
            </summary>
            <param name="factory">Graph factory</param>
            <param name="id">Node unique id</param>
            <param name="name">Friendly name</param>
            <param name="description">Node description</param>
            <param name="data">Serialisation data</param>
        </member>
        <member name="T:BrightWire.ICanSerialise">
            <summary>
            Serialisation interface for graph components
            </summary>
        </member>
        <member name="M:BrightWire.ICanSerialise.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the node state to the binary writer
            </summary>
        </member>
        <member name="M:BrightWire.ICanSerialise.ReadFrom(BrightWire.ExecutionGraph.GraphFactory,System.IO.BinaryReader)">
            <summary>
            Reads the node state
            </summary>
            <param name="factory">Graph factory</param>
            <param name="reader">Binary reader that holds the node's state</param>
        </member>
        <member name="T:BrightWire.IGraphContext">
            <summary>
            Represents a single pass through the graph
            </summary>
        </member>
        <member name="P:BrightWire.IGraphContext.Data">
            <summary>
            Current signal
            </summary>
        </member>
        <member name="P:BrightWire.IGraphContext.ExecutionContext">
            <summary>
            Current execution context
            </summary>
        </member>
        <member name="P:BrightWire.IGraphContext.LearningContext">
            <summary>
            Current learning context (optional)
            </summary>
        </member>
        <member name="P:BrightWire.IGraphContext.BatchSequence">
            <summary>
            Current mini batch sequence
            </summary>
        </member>
        <member name="M:BrightWire.IGraphContext.AddForwardHistory(BrightWire.ExecutionGraph.Node.NodeBase,BrightWire.IGraphData,System.Func{BrightWire.IBackpropagate},BrightWire.ExecutionGraph.Node.NodeBase[])">
            <summary>
            Records forward node execution
            </summary>
            <param name="source">Node that was executed</param>
            <param name="data">Output from the node</param>
            <param name="callback">Optional callback to add backpropagation</param>
            <param name="prev">Ancestors that fed input into the node</param>
        </member>
        <member name="M:BrightWire.IGraphContext.Backpropagate(BrightWire.IGraphData)">
            <summary>
            Backpropagates the signal
            </summary>
            <param name="delta">Error signal</param>
        </member>
        <member name="P:BrightWire.IGraphContext.ErrorSignal">
            <summary>
            Final error signal
            </summary>
        </member>
        <member name="M:BrightWire.IGraphContext.SetOutput(BrightWire.IGraphData,System.Int32)">
            <summary>
            Saves the data as an output of the graph
            </summary>
            <param name="data">Segment to save</param>
            <param name="channel">Channel to save against (optional)</param>
        </member>
        <member name="M:BrightWire.IGraphContext.GetOutput(System.Int32)">
            <summary>
            Returns a saved output
            </summary>
            <param name="channel">Output channel (optional)</param>
        </member>
        <member name="P:BrightWire.IGraphContext.Output">
            <summary>
            Returns all stored output
            </summary>
        </member>
        <member name="P:BrightWire.IGraphContext.Results">
            <summary>
            Execution results
            </summary>
        </member>
        <member name="M:BrightWire.IGraphContext.ClearForBackpropagation">
            <summary>
            Resets the context for another run of backpropagation
            </summary>
        </member>
        <member name="M:BrightWire.IGraphContext.SetData(System.String,System.String,BrightWire.IGraphData)">
            <summary>
            Stores sequence specific data
            </summary>
            <param name="name">Source node name</param>
            <param name="type">Data type</param>
            <param name="data"></param>
        </member>
        <member name="M:BrightWire.IGraphContext.GetData(System.String)">
            <summary>
            Retrieves sequence specific data
            </summary>
            <param name="type">Data type</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.ICreateGraphContext">
            <summary>
            A type that can create a graph context
            </summary>
        </member>
        <member name="M:BrightWire.ICreateGraphContext.Create(BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext,BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence,BrightWire.ILearningContext)">
            <summary>
            Creates a graph context
            </summary>
            <param name="executionContext">Graph execution context</param>
            <param name="sequence">Mini batch sequence</param>
            <param name="learningContext">Learning context (null if executing without training)</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IBackpropagate">
            <summary>
            Backpropagation handler
            </summary>
        </member>
        <member name="M:BrightWire.IBackpropagate.Backward(BrightWire.IGraphData,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase[])">
            <summary>
            Backpropagate
            </summary>
            <param name="errorSignal">Error signal</param>
            <param name="context">Graph context</param>
            <param name="parents"></param>
        </member>
        <member name="T:BrightWire.IDataSource">
            <summary>
            Segment sources feed data into a graph
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.InputSize">
            <summary>
            The size of the input data
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.OutputSize">
            <summary>
            The size of the output data
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="M:BrightWire.IDataSource.Get(System.UInt32[])">
            <summary>
            Gets a mini batch with the specified rows
            </summary>
            <param name="rows">List of rows</param>
        </member>
        <member name="M:BrightWire.IDataSource.GetSequentialBatches">
            <summary>
            For sequential data, returns the row indexes grouped by sequence length
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IDataSource.CloneWith(BrightData.IDataTable)">
            <summary>
            Creates a new data source, using the current as a template but replacing the data table
            </summary>
            <param name="dataTable">The new data table</param>
            <returns></returns>
        </member>
        <member name="P:BrightWire.IDataSource.InputVectoriser">
            <summary>
            Table vectoriser to create a feature vector
            </summary>
        </member>
        <member name="P:BrightWire.IDataSource.OutputVectoriser">
            <summary>
            Table vectoriser to create a target vector
            </summary>
        </member>
        <member name="T:BrightWire.IAdaptiveDataSource">
            <summary>
            Adaptive data sources apply the output from a preliminary graph
            </summary>
        </member>
        <member name="P:BrightWire.IAdaptiveDataSource.AdaptiveInput">
            <summary>
            The input node of the preliminary graph
            </summary>
        </member>
        <member name="M:BrightWire.IAdaptiveDataSource.GetModel(System.String)">
            <summary>
            Gets the serialised preliminary graph
            </summary>
            <param name="name">Optional name to give the data source</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.MiniBatchSequenceType">
            <summary>
            Mini batch type
            </summary>
        </member>
        <member name="F:BrightWire.MiniBatchSequenceType.Standard">
            <summary>
            Standard batch type (non-sequential batches have a single standard sequence item)
            </summary>
        </member>
        <member name="F:BrightWire.MiniBatchSequenceType.SequenceStart">
            <summary>
            Start of a sequence
            </summary>
        </member>
        <member name="F:BrightWire.MiniBatchSequenceType.SequenceEnd">
            <summary>
            End of a sequence
            </summary>
        </member>
        <member name="T:BrightWire.IGraphOperation">
            <summary>
            A pending graph operation (mini batch)
            </summary>
        </member>
        <member name="M:BrightWire.IGraphOperation.GetMiniBatch">
            <summary>
            Creates the mini batch
            </summary>
        </member>
        <member name="T:BrightWire.IGraphEngine">
            <summary>
            Graph engines drive execution within a graph
            </summary>
        </member>
        <member name="P:BrightWire.IGraphEngine.Graph">
            <summary>
            Serialised version of the current graph and its parameters
            </summary>
        </member>
        <member name="P:BrightWire.IGraphEngine.DataSource">
            <summary>
            Segment source that feeds into the graph
            </summary>
        </member>
        <member name="P:BrightWire.IGraphEngine.Start">
            <summary>
            The graph's single start node
            </summary>
        </member>
        <member name="T:BrightWire.IGraphExecutionEngine">
            <summary>
            Graph engine that is optimised for inference
            </summary>
        </member>
        <member name="M:BrightWire.IGraphExecutionEngine.Execute(BrightWire.IDataSource,System.UInt32,System.Action{System.Single},System.Boolean)">
            <summary>
            Executes a data source on the current graph
            </summary>
            <param name="dataSource">Segment source to process</param>
            <param name="batchSize">Initial size of each mini batch</param>
            <param name="batchCompleteCallback">Optional callback to be notified after each mini batch has completed</param>
            <param name="wantInputInExecutionResults">True to write the input rows to the execution results</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphExecutionEngine.Execute(System.Single[])">
            <summary>
            Executes a single vector on the current graph
            </summary>
            <param name="input">Vector to execute</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphExecutionEngine.ExecuteSingleSequentialStep(BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext,System.UInt32,System.Single[],BrightWire.MiniBatchSequenceType)">
            <summary>
            Executes a sequential input on the current graph
            </summary>
            <param name="executionContext">Execution context</param>
            <param name="sequenceIndex">Index of the current sequence (starting from 0)</param>
            <param name="input">Input vector</param>
            <param name="sequenceType">The sequence type (start, standard, end)</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphExecutionEngine.ExecuteSequential(System.Single[][])">
            <summary>
            Executes a sequence of inputs on the current graph
            </summary>
            <param name="input">List of vector inputs</param>
            <returns>List of execution results</returns>
        </member>
        <member name="M:BrightWire.IGraphExecutionEngine.CreateExecutionContext">
            <summary>
            Creates a graph execution context
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IGraphTrainingEngine">
            <summary>
            A graph engine that can train the graph from training data
            </summary>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.Train(BrightWire.ExecutionGraph.Engine.Helper.GraphExecutionContext,System.Action{System.Single},System.Threading.CancellationToken)">
            <summary>
            Executes a training epoch on the graph
            </summary>
            <param name="executionContext">Graph execution context</param>
            <param name="batchCompleteCallback">Optional callback to be notified after each mini batch has completed</param>
            <param name="ct"></param>
            <returns>Graph training error</returns>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.Test(BrightWire.IDataSource,System.UInt32,System.Action{System.Single},System.Action{System.Single,System.Boolean,System.Boolean})">
            <summary>
            Executes test data on the current graph
            </summary>
            <param name="testDataSource">Segment source with test data</param>
            <param name="batchSize">Initial size of each mini batch</param>
            <param name="batchCompleteCallback">Optional callback to be notified after each mini batch has completed</param>
            <param name="values">Optional callback to get the (testError, trainingRate, isPercentage, isImprovedScore) data</param>
            <returns>True if the model performance has improved since the last test</returns>
        </member>
        <member name="P:BrightWire.IGraphTrainingEngine.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="P:BrightWire.IGraphTrainingEngine.LearningContext">
            <summary>
            Graph learning context
            </summary>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.LoadParametersFrom(BrightWire.ExecutionGraph.GraphFactory,BrightWire.Models.ExecutionGraphModel)">
            <summary>
            Loads model parameters into the existing graph (based on matching ids or names)
            IMPORTANT: if loading into a different graph the node ids will not be the same and so node names will need to be assigned for any nodes to be copied
            </summary>
            <param name="factory">Graph factory</param>
            <param name="graph">Model to load parameters from</param>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.CreateExecutionEngine(BrightWire.Models.ExecutionGraphModel)">
            <summary>
            Creates an inference only engine from the current graph
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.Reset">
            <summary>
            Resets the learning context epoch and the best test result
            </summary>
        </member>
        <member name="M:BrightWire.IGraphTrainingEngine.SetStartNode(BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Sets the engine's start node (can be used to load a previously saved graph)
            </summary>
            <param name="startNode">Node to use as the engine's start node</param>
        </member>
        <member name="T:BrightWire.IHaveMemoryNode">
            <summary>
            Nodes that have a memory feeder sub-node
            </summary>
        </member>
        <member name="P:BrightWire.IHaveMemoryNode.Memory">
            <summary>
            The memory feed sub node
            </summary>
        </member>
        <member name="T:BrightWire.IMemoryNode">
            <summary>
            Recurrent neural networks memory node
            </summary>
        </member>
        <member name="P:BrightWire.IMemoryNode.Data">
            <summary>
            The current state of the memory node
            </summary>
        </member>
        <member name="T:BrightWire.IFeedForward">
            <summary>
            Feed forward layer
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.Id">
            <summary>
            Node id
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.InputSize">
            <summary>
            Size of incoming connections
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.OutputSize">
            <summary>
            Size of outgoing connections
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.Bias">
            <summary>
            Bias vector
            </summary>
        </member>
        <member name="P:BrightWire.IFeedForward.Weight">
            <summary>
            Weight matrix
            </summary>
        </member>
        <member name="M:BrightWire.IFeedForward.UpdateWeights(BrightData.IMatrix{System.Single},BrightWire.ILearningContext)">
            <summary>
            Updates the weights
            </summary>
            <param name="delta">Weight delta matrix</param>
            <param name="context">Graph learning context</param>
        </member>
        <member name="M:BrightWire.IFeedForward.UpdateBias(BrightData.IMatrix{System.Single},BrightWire.ILearningContext)">
            <summary>
            Updates the bias
            </summary>
            <param name="delta"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightWire.IFeedForward.ForwardSingleStep(BrightWire.IGraphData,System.UInt32,BrightWire.IGraphContext,BrightWire.ExecutionGraph.Node.NodeBase)">
            <summary>
            Executes the feed forward node
            </summary>
            <param name="signal"></param>
            <param name="channel"></param>
            <param name="context"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IHaveFeedForward">
            <summary>
            Nodes that contain a feed forward layer
            </summary>
        </member>
        <member name="P:BrightWire.IHaveFeedForward.FeedForward">
            <summary>
            Feed forward layer
            </summary>
        </member>
        <member name="T:BrightWire.IHaveAction">
            <summary>
            Node that exposes an action
            </summary>
        </member>
        <member name="P:BrightWire.IHaveAction.Action">
            <summary>
            The node's action
            </summary>
        </member>
        <member name="T:BrightWire.IVolumeDataSource">
            <summary>
            Volume (3D tensor) based data sources
            </summary>
        </member>
        <member name="P:BrightWire.IVolumeDataSource.Width">
            <summary>
            Width of each input volume
            </summary>
        </member>
        <member name="P:BrightWire.IVolumeDataSource.Height">
            <summary>
            Height of each input volume
            </summary>
        </member>
        <member name="P:BrightWire.IVolumeDataSource.Depth">
            <summary>
            Depth of each input volume
            </summary>
        </member>
        <member name="T:BrightWire.IErrorMetric">
            <summary>
            Error metrics used to quantify machine learning
            </summary>
        </member>
        <member name="P:BrightWire.IErrorMetric.DisplayAsPercentage">
            <summary>
            True if the result should be formatted as a percentage
            </summary>
        </member>
        <member name="M:BrightWire.IErrorMetric.Compute(BrightData.IReadOnlyVector{System.Single},BrightData.IReadOnlyVector{System.Single})">
            <summary>
            Computes the error between the output vector and target vector
            </summary>
            <param name="output">The vector that was the output of the model</param>
            <param name="targetOutput">The vector that the model was expected to output</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IErrorMetric.Compute(System.Single[],System.Single[])">
            <summary>
            Computes the error between the output vector and target vector
            </summary>
            <param name="output">The vector that was the output of the model</param>
            <param name="targetOutput">The vector that the model was expected to output</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IErrorMetric.CalculateGradient(BrightData.IMatrix{System.Single},BrightData.IMatrix{System.Single})">
            <summary>
            Calculates the gradient of the error function
            </summary>
            <param name="output">The mini batch of output vectors</param>
            <param name="targetOutput">The mini batch of expected target vectors</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IRandomProjection">
            <summary>
            Random projection
            </summary>
        </member>
        <member name="P:BrightWire.IRandomProjection.Size">
            <summary>
            The size to reduce to
            </summary>
        </member>
        <member name="P:BrightWire.IRandomProjection.Matrix">
            <summary>
            The transformation matrix
            </summary>
        </member>
        <member name="M:BrightWire.IRandomProjection.Compute(BrightData.IVector{System.Single})">
            <summary>
            Reduces a vector
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IRandomProjection.Compute(BrightData.IMatrix{System.Single})">
            <summary>
            Reduces a matrix
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IMarkovModelTrainer`1">
            <summary>
            Markov model trainer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.IMarkovModelTrainer`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a sequence of items to the trainer
            </summary>
            <param name="items"></param>
        </member>
        <member name="T:BrightWire.IMarkovModelTrainer2`1">
            <summary>
            Markov model trainer (window size 2)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.IMarkovModelTrainer2`1.Build">
            <summary>
            Gets all current observations
            </summary>
        </member>
        <member name="T:BrightWire.IMarkovModelTrainer3`1">
            <summary>
            Markov model trainer (window size 3)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightWire.IMarkovModelTrainer3`1.Build">
            <summary>
            Gets all current observations
            </summary>
        </member>
        <member name="T:BrightWire.ILearningContext">
            <summary>
            Graph learning context
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.EpochSeconds">
            <summary>
            The duration in seconds of the last epoch
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.EpochMilliseconds">
            <summary>
            The duration in milliseconds of the last epoch
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.CurrentEpoch">
            <summary>
            The index of the current epoch (starting from one)
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.LearningRate">
            <summary>
            The current learning/training rate
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.BatchSize">
            <summary>
            The current mini batch size
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.RowCount">
            <summary>
            The total number of rows per epoch
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.AddError(BrightWire.NodeErrorType,BrightWire.ExecutionGraph.Node.NodeBase,BrightData.ITensor{System.Single})">
            <summary>
            Adds an error to the node
            </summary>
            <param name="errorType">Error type</param>
            <param name="fromNode">The node that created the error</param>
            <param name="error">Error</param>
        </member>
        <member name="M:BrightWire.ILearningContext.ApplyUpdates">
            <summary>
            Apply any deferred updates
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.StartEpoch">
            <summary>
            Start a new epoch
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.EndEpoch">
            <summary>
            End the current epoch
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.SetRowCount(System.UInt32)">
            <summary>
            Sets the number of rows
            </summary>
            <param name="rowCount">The number of rows per epoch</param>
        </member>
        <member name="M:BrightWire.ILearningContext.DeferBackpropagation(BrightWire.IGraphData,System.Func{BrightWire.IGraphData,BrightWire.IGraphData})">
            <summary>
            Register the backpropagation to be deferred
            </summary>
            <param name="errorSignal">The error signal associated with this backpropagation (optional, can be null)</param>
            <param name="update">The callback to execute the backpropagation</param>
        </member>
        <member name="M:BrightWire.ILearningContext.BackpropagateThroughTime(BrightWire.IGraphData,System.Int32)">
            <summary>
            Backpropagates the error signal across all deferred backpropagations
            </summary>
            <param name="signal">The backpropagation signal</param>
            <param name="maxDepth">The maximum depth to backpropagate the signal</param>
        </member>
        <member name="M:BrightWire.ILearningContext.ScheduleLearningRate(System.UInt32,System.Single)">
            <summary>
            Schedules a change in the learning rate the specified epoch
            </summary>
            <param name="atEpoch">The epoch to change the learning rate</param>
            <param name="newLearningRate">The learning rate to use at that epoch</param>
        </member>
        <member name="M:BrightWire.ILearningContext.EnableNodeUpdates(BrightWire.ExecutionGraph.Node.NodeBase,System.Boolean)">
            <summary>
            Enable or disable node parameter updates
            </summary>
            <param name="node">The node to modify</param>
            <param name="enableUpdates">True if the node can make updates via backpropagation</param>
        </member>
        <member name="E:BrightWire.ILearningContext.BeforeEpochStarts">
            <summary>
            Fired before each epoch starts
            </summary>
        </member>
        <member name="E:BrightWire.ILearningContext.AfterEpochEnds">
            <summary>
            Fired after each epoch ends
            /// </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.ErrorMetric">
            <summary>
            Error metric to use when evaluating training progress
            </summary>
        </member>
        <member name="P:BrightWire.ILearningContext.GraphFactory">
            <summary>
            Graph factory
            </summary>
        </member>
        <member name="M:BrightWire.ILearningContext.ResetEpoch">
            <summary>
            Resets the epoch
            </summary>
        </member>
        <member name="T:BrightWire.IGradientDescentOptimisation">
            <summary>
            Gradient descent optimisation
            </summary>
        </member>
        <member name="M:BrightWire.IGradientDescentOptimisation.Update(BrightData.IMatrix{System.Single},BrightData.IMatrix{System.Single},BrightWire.ILearningContext)">
            <summary>
            Updates the matrix with the delta
            </summary>
            <param name="source">The matrix to update</param>
            <param name="delta">The delta matrix</param>
            <param name="context">The graph learning context</param>
        </member>
        <member name="T:BrightWire.ICreateGradientDescent">
            <summary>
            Creates a gradient descent optimisation
            </summary>
        </member>
        <member name="M:BrightWire.ICreateGradientDescent.Create(BrightWire.IPropertySet)">
            <summary>
            Creates the gradient descent optimisation
            </summary>
            <param name="propertySet">The property set that contains initialisation parameters</param>
        </member>
        <member name="T:BrightWire.ICreateTemplateBasedGradientDescent">
            <summary>
            Creates gradient descent optimisations based on a matrix
            </summary>
        </member>
        <member name="M:BrightWire.ICreateTemplateBasedGradientDescent.Create(BrightWire.IGradientDescentOptimisation,BrightData.IMatrix{System.Single},BrightWire.IPropertySet)">
            <summary>
            Creates the gradient descent optimisation for a particular target matrix
            </summary>
            <param name="prev">Any other previously created gradient descent optimisation in this context</param>
            <param name="template">The instance of the matrix that will be updated</param>
            <param name="propertySet">The property set that contains initialisation parameters</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IPropertySet">
            <summary>
            The current set of graph initialisation parameters
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.WeightInitialisation">
            <summary>
            The weight initialiser to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.GradientDescent">
            <summary>
            The gradient descent optimisation to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.TemplateGradientDescentDescriptor">
            <summary>
            The template based gradient descent optimisation to use
            </summary>
        </member>
        <member name="P:BrightWire.IPropertySet.GradientDescentDescriptor">
            <summary>
            The descriptor to create new gradient descent optimisations
            </summary>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.ICreateTemplateBasedGradientDescent)">
            <summary>
            Use the specified template based gradient descent optimisation
            </summary>
            <param name="descriptor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.ICreateGradientDescent)">
            <summary>
            Use the specified gradient descent optimisation
            </summary>
            <param name="descriptor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.IGradientDescentOptimisation)">
            <summary>
            Use the specified gradient descent optimisation
            </summary>
            <param name="optimisation"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Use(BrightWire.IWeightInitialisation)">
            <summary>
            Use the specified weight initialiser
            </summary>
            <param name="weightInit"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Clone">
            <summary>
            Clones the current property set
            </summary>
            <returns>Shallow copy of the current properties</returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Get``1(System.String)">
            <summary>
            Gets a named property
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="name">The property name</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Set``1(System.String,``0)">
            <summary>
            Sets a named property
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="name">The property name</param>
            <param name="obj">The property value</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.IPropertySet.Clear(System.String)">
            <summary>
            Clears the named property
            </summary>
            <param name="name">The property name</param>
        </member>
        <member name="T:BrightWire.GaussianVarianceCalibration">
            <summary>
            Gaussian weight initialisation type
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCalibration.SquareRootN">
            <summary>
            Variances are calibrated by dividing by the square root of the connection count
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCalibration.SquareRoot2N">
            <summary>
            Variances are calibrated by multiplying by twice the square root of the connection count
            </summary>
        </member>
        <member name="T:BrightWire.GaussianVarianceCount">
            <summary>
            Gaussian variance count
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.None">
            <summary>
            No variance calibration is applied
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.FanIn">
            <summary>
            The count of incoming connections is used
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.FanOut">
            <summary>
            The count of outgoing connections is used
            </summary>
        </member>
        <member name="F:BrightWire.GaussianVarianceCount.FanInFanOut">
            <summary>
            The count incoming and outgoing connections is used
            </summary>
        </member>
        <member name="T:BrightWire.IWeightInitialisation">
            <summary>
            Neural network weight initialiser
            </summary>
        </member>
        <member name="M:BrightWire.IWeightInitialisation.CreateBias(System.UInt32)">
            <summary>
            Creates the bias vector
            </summary>
            <param name="size">The size of the vector</param>
        </member>
        <member name="M:BrightWire.IWeightInitialisation.CreateWeight(System.UInt32,System.UInt32)">
            <summary>
            Creates the weight matrix
            </summary>
            <param name="rows">Row count</param>
            <param name="columns">Column count</param>
        </member>
        <member name="T:BrightWire.ILogisticRegressionClassifier">
            <summary>
            Logistic regression classifier
            </summary>
        </member>
        <member name="M:BrightWire.ILogisticRegressionClassifier.Predict(BrightData.IMatrix{System.Single})">
            <summary>
            Outputs a list of values from 0 to 1 for each input data
            </summary>
            <param name="input">Input data</param>
        </member>
        <member name="T:BrightWire.ILinearRegressionPredictor">
            <summary>
            Linear regression predictor
            </summary>
        </member>
        <member name="M:BrightWire.ILinearRegressionPredictor.Predict(System.Single[])">
            <summary>
            Predicts a value from input data
            </summary>
            <param name="input">The input data</param>
        </member>
        <member name="M:BrightWire.ILinearRegressionPredictor.Predict(System.Single[][])">
            <summary>
            Bulk value prediction
            </summary>
            <param name="input">List of data to predict</param>
            <returns>List of predictions</returns>
        </member>
        <member name="T:BrightWire.IIndexListEncoder">
            <summary>
            Encodes index lists to dense vectors
            </summary>
        </member>
        <member name="M:BrightWire.IIndexListEncoder.Encode(BrightData.Types.IndexList)">
            <summary>
            Encodes the index lists to a dense vector
            </summary>
            <param name="indexList">The index list to encode</param>
        </member>
        <member name="T:BrightWire.IWeightedIndexListEncoder">
            <summary>
            Encodes weighted index lists to dense vectors
            </summary>
        </member>
        <member name="M:BrightWire.IWeightedIndexListEncoder.Encode(BrightData.Types.WeightedIndexList)">
            <summary>
            Encodes the weighted index list to a dense vector
            </summary>
            <param name="indexList"></param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.IIndexListClassifier">
            <summary>
            A classifier that classifies index lists
            </summary>
        </member>
        <member name="M:BrightWire.IIndexListClassifier.Classify(BrightData.Types.IndexList)">
            <summary>
            Classifies the input data and returns the classifications with their weights
            </summary>
            <param name="indexList">The index list to classify</param>
        </member>
        <member name="T:BrightWire.IRowClassifier">
            <summary>
            Classifies convertible rows
            </summary>
        </member>
        <member name="M:BrightWire.IRowClassifier.Classify(BrightData.DataTable.Rows.GenericTableRow)">
            <summary>
            Classifies a convertible row
            </summary>
            <param name="row">Row to classify</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.ITableClassifier">
            <summary>
            Classifies a data table
            </summary>
        </member>
        <member name="M:BrightWire.ITableClassifier.Classify(BrightData.IDataTable)">
            <summary>
            Classifies each row of a data table
            </summary>
            <param name="table">Table to classify</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.NodeErrorType">
            <summary>
            Node error type
            </summary>
        </member>
        <member name="F:BrightWire.NodeErrorType.Default">
            <summary>
            Default error
            </summary>
        </member>
        <member name="F:BrightWire.NodeErrorType.Bias">
            <summary>
            Error in node bias
            </summary>
        </member>
        <member name="F:BrightWire.NodeErrorType.Weight">
            <summary>
            Error in node weights
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.BernoulliNaiveBayes">
            <summary>
            A bernoulli naive bayes model
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability">
            <summary>
            The probabilities associated with a string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.StringIndex">
            <summary>
            The string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.ConditionalProbability">
            <summary>
            The log of the conditional probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.InverseProbability">
            <summary>
            The log of the inverse conditional probability
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class">
            <summary>
            A classification
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Label">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Prior">
            <summary>
            The log of the prior probability for this classification
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.MissingProbability">
            <summary>
            The log of the missing probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Index">
            <summary>
            The list of probabilities for each string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.InverseMissingProbability">
            <summary>
            The log of the inverse missing probability
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.ClassData">
            <summary>
            Classification data
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Vocabulary">
            <summary>
            The list of string indexes that were in the training set
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.CreateClassifier">
            <summary>
            Creates a classifier from this model
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.BernoulliNaiveBayes.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModelStateTransition`1">
            <summary>
            A markov model state transition
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelStateTransition`1.NextState">
            <summary>
            The next state
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelStateTransition`1.Probability">
            <summary>
            The probability of this next state
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelStateTransition`1.#ctor(`0,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="nextState"></param>
            <param name="probability"></param>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelStateTransition`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModelObservation2`1">
            <summary>
            A markov model observation based on the preceding two items
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Item1">
            <summary>
            The second last preceding item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Item2">
            <summary>
            The last preceding item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Transition">
            <summary>
            The list of possible transitions from this state
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation2`1.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation2`1.GetHashCode">
            <summary>
            Hash code override
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation2`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModel2`1">
            <summary>
            A markov model based on observing two items at a time
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel2`1.Observations">
            <summary>
            The list of observations
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModel2`1.#ctor(System.Collections.Generic.IEnumerable{BrightWire.Models.Bayesian.MarkovModelObservation2{`0}})">
            <summary>
            Constructor
            </summary>
            <param name="observations"></param>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel2`1.AsDictionary">
            <summary>
            Converts the model to a dictionary
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModelObservation3`1">
            <summary>
            A markov model observation based on the preceding three instances
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Item1">
            <summary>
            The third last item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Item2">
            <summary>
            The second last item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Item3">
            <summary>
            The third last item
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Transitions">
            <summary>
            The list of associated transitions
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation3`1.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation3`1.GetHashCode">
            <summary>
            Hashcode override
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModelObservation3`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.MarkovModel3`1">
            <summary>
            A markov model based on observing the last three observations
            </summary>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel3`1.Observations">
            <summary>
            The list of observations
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MarkovModel3`1.#ctor(System.Collections.Generic.IEnumerable{BrightWire.Models.Bayesian.MarkovModelObservation3{`0}})">
            <summary>
            
            </summary>
            <param name="observations"></param>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MarkovModel3`1.AsDictionary">
            <summary>
            Converts the model to a dictionary
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MultinomialNaiveBayes">
            <summary>
            Multinomial naive bayes model
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability">
            <summary>
            The conditional probability associated with a string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability.StringIndex">
            <summary>
            The string index
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability.ConditionalProbability">
            <summary>
            The conditional probability
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class">
            <summary>
            Classification data
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Label">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Prior">
            <summary>
            The classification's prior log probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.MissingProbability">
            <summary>
            The classifications missing log probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Index">
            <summary>
            The list of string indexes and their probability
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.Models.Bayesian.MultinomialNaiveBayes.ClassData">
            <summary>
            The list of possible classifications
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.CreateClassifier">
            <summary>
            Creates a classifier from the model
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.MultinomialNaiveBayes.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes">
            <summary>
            A naive bayes model
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
            <summary>
            The type of data within the column
            </summary>
        </member>
        <member name="F:BrightWire.Models.Bayesian.NaiveBayes.ColumnType.ContinuousGaussian">
            <summary>
            Continuous values
            </summary>
        </member>
        <member name="F:BrightWire.Models.Bayesian.NaiveBayes.ColumnType.Categorical">
            <summary>
            Categorical values
            </summary>
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.Column">
            <summary>
            A column within the naive bayes model
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.ColumnIndex">
            <summary>
            Index within the data set
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Type">
            <summary>
            Type of column (categorical or continuous)
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Variance">
            <summary>
            The variance of the column values (continuous only)
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Mean">
            <summary>
            The mean of the column values (continuous only)
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Column.Probability">
            <summary>
            The list of categories within the column and their probability (categorical only)
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.Column.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.Column.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability">
            <summary>
            A category and its associated log probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability.Category">
            <summary>
            The category label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability.LogProbability">
            <summary>
            The natural log of the category's probability
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability.Probability">
            <summary>
            The category's probability
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.CategoricalProbability.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary">
            <summary>
            A classification and its associated data
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.Label">
            <summary>
            The classification label
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.LogPrior">
            <summary>
            The natural log of the prior
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.ColumnSummary">
            <summary>
            The column data associated with this classification
            </summary>
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.Prior">
            <summary>
            The classification prior probability
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.ClassSummary.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.Models.Bayesian.NaiveBayes.Class">
            <summary>
            A list of possible classifications and their data
            </summary>
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.CreateClassifier">
            <summary>
            Creates a classifier from this model
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.Bayesian.NaiveBayes.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.ConfusionMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="T:BrightWire.Models.ConfusionMatrix.ActualClassification">
            <summary>
            
            </summary>
        </member>
        <member name="T:BrightWire.Models.ConfusionMatrix.ExpectedClassification">
            <summary>
            
            </summary>
        </member>
        <member name="M:BrightWire.Models.ConfusionMatrix.GetCount(System.String,System.String)">
            <summary>
            Returns the count of the expected vs actual classifications
            </summary>
            <param name="expected">Expected classification label</param>
            <param name="actual">Actual classification label</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.DataSourceModel">
            <summary>
            Serialises an adaptive data source - that is, a data source that takes the output from a preliminary output graph and sends it to the primary graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.Version">
            <summary>
            Segment contract version number
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.Name">
            <summary>
            The name of the data source
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.InputSize">
            <summary>
            The size of each input training data item
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.OutputSize">
            <summary>
            The size of each training item output (classification label)
            </summary>
        </member>
        <member name="P:BrightWire.Models.DataSourceModel.Graph">
            <summary>
            The preliminary graph
            </summary>
        </member>
        <member name="M:BrightWire.Models.DataSourceModel.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.DataSourceModel.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.ExecutionGraphModel">
            <summary>
            A serialised execution graph
            </summary>
        </member>
        <member name="T:BrightWire.Models.ExecutionGraphModel.Node">
            <summary>
            A node within the graph
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Node.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Node.#ctor(System.IO.BinaryReader)">
            <summary>
            Initialize from binary reader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Node.TypeName">
            <summary>
            The .NET type name of the node type
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Node.Id">
            <summary>
            The unique id within the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Node.Name">
            <summary>
            Node friendly name
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Node.Description">
            <summary>
            A short description of the node
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Node.Data">
            <summary>
            The node's parameters
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Node.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Node.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.ExecutionGraphModel.Wire">
            <summary>
            Wires connect nodes (aka edges)
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Wire.#ctor(System.String,System.String,System.UInt32)">
            <summary>
            Wires connect nodes (aka edges)
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Wire.FromId">
            <summary>
            The source node id
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Wire.ToId">
            <summary>
            The target node id
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Wire.InputChannel">
            <summary>
            The channel on the target node to send the source node's output
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Wire.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Wire.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Wire.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Wire.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Wire.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Version">
            <summary>
            Segment contract version number
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Name">
            <summary>
            The name of the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.InputNode">
            <summary>
            The primary input node
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.OtherNodes">
            <summary>
            Other connected nodes
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.Wires">
            <summary>
            A list of the wires that connect the nodes in the graph
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.ExecutionGraphModel.VisitNodes``1(``0,System.Action{``0,BrightWire.Models.ExecutionGraphModel.Node,System.UInt32},System.Action{``0,BrightWire.Models.ExecutionGraphModel.Node})">
            <summary>
            Visits each node in the graph
            </summary>
            <param name="param"></param>
            <param name="onEnter"></param>
            <param name="onLeave"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightWire.Models.ExecutionGraphModel.AsXml">
            <summary>
            XML representation of the graph
            </summary>
        </member>
        <member name="T:BrightWire.Models.ExecutionResult">
            <summary>
            The output from a mini batch
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionResult.#ctor(BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence,BrightData.IMatrix{System.Single},System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="miniBatch">The mini batch sequence</param>
            <param name="output">The mini batch output</param>
            <param name="wantInputInExecutionResults">True to save graph inputs in the execution results</param>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Output">
            <summary>
            The list of output rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Target">
            <summary>
            The list of target rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Input">
            <summary>
            The list of input rows
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.Error">
            <summary>
            Optional list of errors
            </summary>
        </member>
        <member name="P:BrightWire.Models.ExecutionResult.MiniBatchSequence">
            <summary>
            The mini batch
            </summary>
        </member>
        <member name="M:BrightWire.Models.ExecutionResult.CalculateError(BrightWire.IErrorMetric)">
            <summary>
            Calculates the error of the output against the target
            </summary>
            <param name="errorMetric">The error metric to calculate with</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.Models.GraphModel">
            <summary>
            A serialised graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.Version">
            <summary>
            Segment contract version number
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.Name">
            <summary>
            The name of the graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.Graph">
            <summary>
            The primary execution graph
            </summary>
        </member>
        <member name="P:BrightWire.Models.GraphModel.DataSource">
            <summary>
            Optional data source associated with the model
            </summary>
        </member>
        <member name="M:BrightWire.Models.GraphModel.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.GraphModel.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.InstanceBased.KNearestNeighbours">
            <summary>
            K Nearest Neighbour Model
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.Instance">
            <summary>
            The list of vectors to match against
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.Classification">
            <summary>
            The corresponding list of classifications
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.DataColumns">
            <summary>
            The vector indexes to use to encode a data table row as a vector
            </summary>
        </member>
        <member name="P:BrightWire.Models.InstanceBased.KNearestNeighbours.TargetColumn">
            <summary>
            The vector indexes to use to encode the other column(s) as a classification target
            </summary>
        </member>
        <member name="M:BrightWire.Models.InstanceBased.KNearestNeighbours.CreateClassifier(BrightData.LinearAlgebra.LinearAlgebraProvider{System.Single},System.UInt32,BrightData.DistanceMetric)">
            <summary>
            Creates a classifier from this model
            </summary>
            <param name="lap">The linear algebra provider</param>
            <param name="k">The number of instances to consider</param>
            <param name="distanceMetric">The distance metric to compare each row with each instance</param>
        </member>
        <member name="M:BrightWire.Models.InstanceBased.KNearestNeighbours.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.InstanceBased.KNearestNeighbours.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.StringTable">
            <summary>
            An array of indexed strings
            </summary>
        </member>
        <member name="P:BrightWire.Models.StringTable.Data">
            <summary>
            The array of indexed strings
            </summary>
        </member>
        <member name="T:BrightWire.Models.TreeBased.DecisionTree">
            <summary>
            A decision tree model
            </summary>
        </member>
        <member name="T:BrightWire.Models.TreeBased.DecisionTree.Node">
            <summary>
            A node in the decision tree
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.Node.Children">
            <summary>
            The nodes children
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.Node.ColumnIndex">
            <summary>
            The column index that is being split on
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.Node.MatchLabel">
            <summary>
            The value to match this node
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.Node.Split">
            <summary>
            The value to split on
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.Node.Classification">
            <summary>
            This node's classification label
            </summary>
        </member>
        <member name="M:BrightWire.Models.TreeBased.DecisionTree.Node.WriteTo(System.Xml.XmlWriter)">
            <summary>
            Writes the node as XML
            </summary>
            <param name="writer">The XML writer</param>
        </member>
        <member name="M:BrightWire.Models.TreeBased.DecisionTree.Node.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.TreeBased.DecisionTree.Node.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.ClassColumnIndex">
            <summary>
            The classification label column index
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.Root">
            <summary>
            The root of the tree
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.DecisionTree.AsXml">
            <summary>
            Converts the tree to XML
            </summary>
        </member>
        <member name="M:BrightWire.Models.TreeBased.DecisionTree.CreateClassifier">
            <summary>
            Creates a classifier from the model
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.TreeBased.DecisionTree.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.TreeBased.DecisionTree.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.Models.TreeBased.RandomForest">
            <summary>
            A random forest model
            </summary>
        </member>
        <member name="P:BrightWire.Models.TreeBased.RandomForest.Forest">
            <summary>
            The list of trees in the forest
            </summary>
        </member>
        <member name="M:BrightWire.Models.TreeBased.RandomForest.CreateClassifier">
            <summary>
            Creates a classifier from the model
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.Models.TreeBased.RandomForest.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightWire.Models.TreeBased.RandomForest.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.And">
            <summary>
            Simple AND training data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.And.Get(BrightData.BrightDataContext)">
            <summary>
            Generates a data table containing AND training data
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.BinaryIntegers">
            <summary>
            Creates random integers and returns feature vectors against binary mathematical logic
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.BinaryIntegers.GetBitArray(System.Int32)">
            <summary>
            Converts a value to an array of floats, with 1 or 0 for each bit position
            </summary>
            <param name="val">The number to convert</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.BinaryIntegers.Addition(BrightData.BrightDataContext,System.Int32)">
            <summary>
            Creates random integers added together as feature vectors
            The input feature contains two features, one for each bit at that position
            The output feature contains a single feature: 1 or 0 if that bit is set in the result
            </summary>
            <param name="context"></param>
            <param name="sampleCount">How many samples to generate</param>
            <returns>A list of sequences</returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.Or">
            <summary>
            Simple OR training data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.Or.Get(BrightData.BrightDataContext)">
            <summary>
            Generates a data table containing OR training data
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.ReberGrammar">
            <summary>
            Generates Reber grammar sequences: https://www.willamette.edu/~gorr/classes/cs449/reber.html
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetChar(System.Int32)">
            <summary>
            Gets the character at the specified index
            </summary>
            <param name="index">Index to query</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetIndex(System.Char)">
            <summary>
            Gets the index for the specified character
            </summary>
            <param name="ch">The character to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.Encode(BrightData.BrightDataContext,System.String)">
            <summary>
            Encodes a reber sequence as a sequence of one hot encoded vectors
            </summary>
            <param name="context"></param>
            <param name="sequence">The reber sequence to encode</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetOneHot(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            One hot encodes the REBER strings
            </summary>
            <param name="context"></param>
            <param name="strList">A list of REBER sequences</param>
            <returns>A data table with matrices to represent the sequences of vectors and their corresponding outputs</returns>
        </member>
        <member name="P:BrightWire.TrainingData.Artificial.ReberGrammar.Size">
            <summary>
            The number of REBER characters
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.#ctor(System.Random)">
            <summary>
            Creates a reber grammar builder
            </summary>
            <param name="random">Random number provider</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.Get(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Generates an unlimited number of reber sequences
            </summary>
            <param name="minlength">Minimum length of the sequences (optional)</param>
            <param name="maxLength">Minimum length of the sequences (optional)</param>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.ReberGrammar.GetExtended(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Generates an unlimited number of extended reber sequences
            </summary>
            <param name="minlength">Minimum length of the sequences (optional)</param>
            <param name="maxLength">Minimum length of the sequences (optional)</param>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.SequenceGenerator">
            <summary>
            Generates random alphabetical sequences
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.#ctor(BrightData.BrightDataContext,System.Int32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="context"></param>
            <param name="dictionarySize">The number of letters to use</param>
            <param name="minSize">The minimum size of each sequence</param>
            <param name="maxSize">The maximum size of each sequence</param>
            <param name="noRepeat">True to avoid repeating any previous character within each sequence</param>
        </member>
        <member name="P:BrightWire.TrainingData.Artificial.SequenceGenerator.DictionarySize">
            <summary>
            The number of letters to use
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.NextSequence">
            <summary>
            Generates a new sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Encode(System.Char,System.Single)">
            <summary>
            Converts the character to a one hot encoded vector
            </summary>
            <param name="ch"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Encode(System.Collections.Generic.IEnumerable{System.ValueTuple{System.Char,System.Single}})">
            <summary>
            Encodes the characters as a dense vector
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Encode(System.String)">
            <summary>
            Encodes the string as a list of dense vectors within a matrix (each character becomes a row in the matrix)
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.GenerateSequences">
            <summary>
            Generator function to generate new sequences
            </summary>
            <returns>Infinite number of sequences</returns>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.SequenceGenerator.Decode(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Converts character indices to a string
            </summary>
            <param name="characters">Character indices</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Artificial.Xor">
            <summary>
            Simple XOR training data
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Artificial.Xor.Get(BrightData.BrightDataContext)">
            <summary>
            Generates a data table containing XOR training data
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.BigEndianBinaryReader">
            <summary>
            Binary reader for big endian streams
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a new big endian binary reader
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadInt32">
            <summary>
            Reads an int
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadInt16">
            <summary>
            Reads a short
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadInt64">
            <summary>
            Reads a long
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.BigEndianBinaryReader.ReadUInt32">
            <summary>
            Reads a ulong
            </summary>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.DataTableBuilder">
            <summary>
            Creates standard data table builders
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.DataTableBuilder.CreateTwoColumnMatrixTableBuilder(BrightData.BrightDataContext,System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Creates a data table builder with one feature matrix column and one target matrix column
            </summary>
            <param name="context"></param>
            <param name="inputRows"></param>
            <param name="inputColumns"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.DataTableBuilder.CreateTwoColumnVectorTableBuilder(BrightData.BrightDataContext,System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Creates a data table builder with one feature vector column and one target vector column
            </summary>
            <param name="context"></param>
            <param name="inputSize">Size of the input vector</param>
            <param name="outputSize">Size of the output vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.DataTableBuilder.Create3DTensorToVectorTableBuilder(BrightData.BrightDataContext,System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Creates a data table builder with one feature tensor 3D columns and one target vector column
            </summary>
            <param name="context"></param>
            <param name="inputDepth"></param>
            <param name="inputRows"></param>
            <param name="inputColumns"></param>
            <param name="outputSize">Size of the output vector</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.SequenceWindowBuilder">
            <summary>
            Creates a new training feature vector using a window of surrounding features at each point in the input sequence
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SequenceWindowBuilder.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new sequence window builder
            </summary>
            <param name="before">The number of previous items to include before each item</param>
            <param name="after">The number of following items to include after each item</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SequenceWindowBuilder.Get(System.Single[][])">
            <summary>
            Augments a single sequence
            </summary>
            <param name="data">The sequence to analyse</param>
            <returns>A new sequence, augmented with contextual information</returns>
        </member>
        <member name="P:BrightWire.TrainingData.Helper.SequenceWindowBuilder.OutputSize">
            <summary>
            The size of the generated training data
            </summary>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.SimpleTokeniser">
            <summary>
            Finds strings of words and numbers in a larger string
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.Tokenise(System.String)">
            <summary>
            Splits the text into smaller word and number strings. Punctuation characters become single character strings.
            </summary>
            <param name="text">The text to tokenise</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.JoinNegations(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Simple token modification following "not".
            Double not or punctuation stops the not mode
            </summary>
            <param name="tokenList">The list of tokens</param>
            <returns>A sequence of modified tokens</returns>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.FindSentences(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds sentences from a list of strings
            </summary>
            <param name="stringList">The list of strings</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.SimpleTokeniser.IsEndOfSentence(System.String)">
            <summary>
            Checks if the string is an end of sentence token
            </summary>
            <param name="str">The string to check</param>
        </member>
        <member name="T:BrightWire.TrainingData.Helper.StringTableBuilder">
            <summary>
            Assigns string indices to strings
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.#ctor">
            <summary>
            Creates an empty string table builder
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.#ctor(BrightWire.Models.StringTable)">
            <summary>
            Creates a string table builder pre-populated with an existing string table
            </summary>
            <param name="stringTable">The string table to pre-populate</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.#ctor(System.String[])">
            <summary>
            Creates a string table builder pre-populated with an existing string table
            </summary>
            <param name="stringTable">The string table to pre-populate</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.TryGetIndex(System.String,System.UInt32@)">
            <summary>
            Returns true if the string has already been added
            </summary>
            <param name="str">The string to check</param>
            <param name="ret">The string index</param>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.GetIndex(System.String)">
            <summary>
            Gets a string index for a string (creates a new index if not found)
            </summary>
            <param name="str">The string to look up</param>
        </member>
        <member name="P:BrightWire.TrainingData.Helper.StringTableBuilder.StringTable">
            <summary>
            Serialises the string table
            </summary>
        </member>
        <member name="P:BrightWire.TrainingData.Helper.StringTableBuilder.Size">
            <summary>
            Returns the size of the string table
            </summary>
        </member>
        <member name="M:BrightWire.TrainingData.Helper.StringTableBuilder.GetString(System.UInt32)">
            <summary>
            Returns the string at the specified index
            </summary>
            <param name="index">The string index</param>
        </member>
        <member name="T:BrightWire.TreeBased.DecisionTreeClassifier">
            <summary>
            Classifies rows based on a previously trained model
            </summary>
        </member>
        <member name="M:BrightWire.TreeBased.DecisionTreeClassifier.#ctor(BrightWire.Models.TreeBased.DecisionTree)">
            <summary>
            Classifies rows based on a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.TreeBased.RandomForestClassifier">
            <summary>
            Classifies rows based on a previously trained model
            </summary>
        </member>
        <member name="T:BrightWire.TreeBased.Training.DecisionTreeTrainer">
            <summary>
            Decision tree classifier
            https://en.wikipedia.org/wiki/Decision_tree_learning
            </summary>
        </member>
        <member name="T:BrightWire.TreeBased.Training.DecisionTreeTrainer.Config">
            <summary>
            Decision tree configuration
            </summary>
        </member>
        <member name="M:BrightWire.TreeBased.Training.DecisionTreeTrainer.Train(BrightData.IDataTable,BrightWire.TreeBased.Training.DecisionTreeTrainer.Config)">
            <summary>
            Trains a decision tree
            </summary>
            <param name="table">Training data</param>
            <param name="config">Decision tree configuration</param>
            <returns></returns>
        </member>
        <member name="T:BrightWire.TreeBased.Training.RandomForestTrainer">
            <summary>
            Random forest classifier
            https://en.wikipedia.org/wiki/Random_forest
            </summary>
        </member>
    </members>
</doc>
