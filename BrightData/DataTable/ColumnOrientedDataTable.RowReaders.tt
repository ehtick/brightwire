<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var COUNT = 11; #>
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
#pragma warning disable CA2012

namespace BrightData
{
<# for(var i = 2; i < COUNT; i++) {
        var range = Enumerable.Range(1, i).ToList();
        var typeString = String.Join(", ", range.Select(x => $"T{x}"));
        var parameters = String.Join(", ", range.Select(x => $"T{x} C{x}"));
        var where = String.Join(" ", range.Select(x => $"where T{x}: notnull"));
#>
    public readonly record struct TableRow<<#= typeString #>>(<#= parameters #>) <#= where #>;
<# } #>

    public partial interface IDataTable
    {
<# for(var i = 2; i < COUNT; i++) {
        var range = Enumerable.Range(1, i).ToList();
        var typeString = String.Join(", ", range.Select(x => $"T{x}"));
        var parameters = String.Join(", ", range.Select(x => $"T{x} C{x}"));
        var where = String.Join(" ", range.Select(x => $"where T{x}: notnull"));
#>
        IAsyncEnumerable<TableRow<<#= typeString #>>> Enumerate<<#= typeString #>>(
<# for(var j = 1; j <= i; j++) { #>
            uint columnIndex<#= j #> = <#= j-1 #>, 
<# } #>
            CancellationToken ct = default
        ) <#= where #>;
<# } #>
    }
}

namespace BrightData.DataTable
{
    internal partial class ColumnOrientedDataTable
    {
<# for(var i = 2; i < COUNT; i++) {
        var range = Enumerable.Range(1, i).ToList();
        var typeString = String.Join(", ", range.Select(x => $"T{x}"));
        var parameters = String.Join(", ", range.Select(x => $"T{x} C{x}"));
        var where = String.Join(" ", range.Select(x => $"where T{x}: notnull"));
        var rowParams = String.Join(", ", range.Select(x => $"e{x}.Current"));
        var getColumns = String.Join(", ", range.Select(x => $"GetColumn<T{x}>(columnIndex{x})"));
        var currentValues = String.Join(", ", range.Select(x => $"e{x}.Current"));
        var bufferInput = String.Join(", ", range.Select(x => $"IReadOnlyBuffer<T{x}> input{x}"));
        var allBs = String.Join(", ", range.Select(x => $"b{x}"));
        var allBlockSpans = String.Join(", ", range.Select(x => $"block{x}.Span"));
        var allReadOnlySpans = String.Join(", ", range.Select(x => $"ReadOnlySpan<T{x}> span{x}"));
        var allSpans = String.Join(", ", range.Select(x => $"span{x}[i]"));
#>      
        public async IAsyncEnumerable<TableRow<<#= typeString #>>> Enumerate<<#= typeString #>>(
<# for(var j = 1; j <= i; j++) { #>
            uint columnIndex<#= j #> = <#= j-1 #>, 
<# } #>
            [EnumeratorCancellation] CancellationToken ct = default) 
            <#= where #>
        {
            const int size = <#= i #>;
<# for(var j = 1; j <= i; j++) { #>
            var e<#= j #> = GetColumn<T<#= j #>>(columnIndex<#= j #>).GetAsyncEnumerator(ct);
<# } #>
            var currentTasks = new ValueTask<bool>[size];
            var isValid = true;

            while (!ct.IsCancellationRequested && isValid) {
<# for(var j = 1; j <= i; j++) { #>
                currentTasks[<#= j-1 #>] = e<#= j #>.MoveNextAsync();
<# } #>
                for (var i = 0; i < size; i++) {
                    if (await currentTasks[i] != true) {
                        isValid = false;
                        break;
                    }
                }
                var row = new TableRow<<#= typeString #>>(<#= rowParams #>);
                yield return row;
            }
        }

        class RowReader<<#= typeString #>> : IReadOnlyBuffer<TableRow<<#= typeString #>>> <#= where #>
        {
<# for(var j = 1; j <= i; j++) { #>
            readonly IReadOnlyBuffer<T<#= j #>> _input<#= j #>;
<# } #>

            public RowReader(<#= bufferInput #>)
            {
<# for(var j = 2; j <= i; j++) { #>
                if (input1.BlockSize != input<#= j #>.BlockSize)
                    throw new ArgumentException($"Expected all buffers to have same block size (input1:{input1.BlockSize} vs input<#= j #>:{input<#= j #>.BlockSize})");
                if(input1.BlockCount != input<#= j #>.BlockCount)
                    throw new ArgumentException($"Expected all buffers to have same block count (input1:{input1.BlockCount} vs input<#= j #>:{input<#= j #>.BlockCount})");
                if(input1.Size != input<#= j #>.Size)
                    throw new ArgumentException($"Expected all buffers to have same size (input1:{input1.Size} vs input<#= j #>:{input<#= j #>.Size})");
<# } #>

                Size = input1.Size;
                BlockSize = input1.BlockSize;
                BlockCount = input1.BlockCount;
                DataType = typeof(TableRow<<#= typeString #>>);
<# for(var j = 1; j <= i; j++) { #>
                _input<#= j #> = input<#= j #>;
<# } #>
            }

            public uint Size { get; }
            public uint BlockSize { get; }
            public uint BlockCount { get; }
            public Type DataType { get; }
            public async IAsyncEnumerable<object> EnumerateAll()
            {
                await foreach(var item in EnumerateAllTyped())
                    yield return item;
            }

            public async Task ForEachBlock(BlockCallback<TableRow<<#= typeString #>>> callback, INotifyUser? notify = null, string? message = null, CancellationToken ct = default)
            {
                for (uint i = 0; i < BlockCount && !ct.IsCancellationRequested; i++) {
                    var block = await GetTypedBlock(i);
                    callback(block.Span);
                }
            }

            public async Task<ReadOnlyMemory<TableRow<<#= typeString #>>>> GetTypedBlock(uint blockIndex)
            {
<# for(var j = 1; j <= i; j++) { #>
                var b<#= j #> = _input<#= j #>.GetTypedBlock(blockIndex);
<# } #>
                await Task.WhenAll(<#= allBs #>);
<# for(var j = 1; j <= i; j++) { #>
                var block<#= j #> = b<#= j #>.Result;
<# } #>
<# for(var j = 2; j <= i; j++) { #>
                if (block1.Length != block<#= j #>.Length)
                    throw new Exception($"Expected all blocks to have same size (block1:{block1.Length} vs block<#= j #>:{block<#= j #>.Length})");
<# } #>
                var ret = new TableRow<<#= typeString #>>[block1.Length];
                Copy(<#= allBlockSpans #>, ret);
                return ret;
            }

            static void Copy(<#= allReadOnlySpans #>, Span<TableRow<<#= typeString #>>> output)
            {
                for (var i = 0; i < span1.Length; i++)
                    output[i] = new TableRow<<#= typeString #>>(<#= allSpans #>);
            }

            public async IAsyncEnumerable<TableRow<<#= typeString #>>> EnumerateAllTyped()
            {
                const int size = <#= i #>;
<# for(var j = 1; j <= i; j++) { #>
                var e<#= j #> = _input<#= j #>.GetAsyncEnumerator();
<# } #>
                var currentTasks = new ValueTask<bool>[size];
                var isValid = true;

                while (isValid) {
<# for(var j = 1; j <= i; j++) { #>
                    currentTasks[<#= j-1 #>] = e<#= j #>.MoveNextAsync();
<# } #>
                    for (var i = 0; i < size; i++) {
                        if (await currentTasks[i] != true) {
                            isValid = false;
                            break;
                        }
                    }
                    var row = new TableRow<<#= typeString #>>(<#= currentValues #>);
                    yield return row;
                }
            }

            public IAsyncEnumerator<TableRow<<#= typeString #>>> GetAsyncEnumerator(CancellationToken ct = default) => EnumerateAllTyped().GetAsyncEnumerator(ct);
        }
        public IReadOnlyBuffer<TableRow<<#= typeString #>>> GetRowReader<<#= typeString #>>(
<# for(var j = 1; j <= i; j++) { #>
            uint columnIndex<#= j #> = <#= j-1 #><#= (j == i) ? "" : "," #>
<# } #>
        ) 
            <#= where #>
        {
            return new RowReader<<#= typeString #>>(<#= getColumns #>);
        }
<# } #>
    }
}