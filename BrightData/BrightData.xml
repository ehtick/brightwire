<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BrightData</name>
    </assembly>
    <members>
        <member name="T:BrightData.Analysis.Readers.DateAnalysis">
            <summary>
            Date analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MinDate">
            <summary>
            Minimum date (null if none)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MaxDate">
            <summary>
            Maximum date (null if none)
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.DictionaryValues">
            <summary>
            Dictionary that holds category string indices
            </summary>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValues(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Converts from category indices to string
            </summary>
            <param name="categoryIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValue(System.Int32)">
            <summary>
            Gets the string associated with a category index
            </summary>
            <param name="categoryIndex"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Analysis.Readers.DimensionAnalysis">
            <summary>
            Dimension analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.XDimension">
            <summary>
            Max size of the x dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.YDimension">
            <summary>
            Max size of the y dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.ZDimension">
            <summary>
            Max size of the z dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.NumDistinct">
            <summary>
            Number of distinct size combinations
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.Size">
            <summary>
            Total size across all dimensions
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.FrequencyAnalysis">
            <summary>
            Frequency analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Total">
            <summary>
            Total number of items observed
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.MostFrequent">
            <summary>
            Most frequent item
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.IndexAnalysis">
            <summary>
            Index analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MinIndex">
            <summary>
            Lowest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MaxIndex">
            <summary>
            Highest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.NumericAnalysis">
            <summary>
            Numeric analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L1Norm">
            <summary>
            L1 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L2Norm">
            <summary>
            L2 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Min">
            <summary>
            Minimum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Max">
            <summary>
            Maximum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mean">
            <summary>
            Mean of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleVariance">
            <summary>
            Sample variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleStdDev">
            <summary>
            Sample standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationVariance">
            <summary>
            Population variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationStdDev">
            <summary>
            Population standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Median">
            <summary>
            Median value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mode">
            <summary>
            Mode (most frequent value)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.NumDistinct">
            <summary>
            Number of distinct values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Total">
            <summary>
            Total count of items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.FrequencyRange">
            <summary>
            Bucketed histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.StringAnalysis">
            <summary>
            String analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MinLength">
            <summary>
            Length of smallest observed string
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MaxLength">
            <summary>
            Length of largest observed string
            </summary>
        </member>
        <member name="T:BrightData.Analysis.StaticAnalysers">
            <summary>
            Static methods to create analyzers
            </summary>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDateAnalyser(System.UInt32)">
            <summary>
            Creates a date analyzer
            </summary>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <param name="writeCount">Number of items to write in histogram</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateConvertToStringAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that will convert each item to a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDimensionAnalyser(System.UInt32)">
            <summary>
            Creates a dimension analyzer (to analyze the shape of tensors)
            </summary>
            <param name="maxCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed frequency of items
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateIndexAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed indices (for index lists and weighted index lists)
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateStringAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser(System.Type,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer (each item will be converted to a string)
            </summary>
            <param name="type"></param>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.BinaryData">
            <summary>
            Blob of binary data
            </summary>
        </member>
        <member name="M:BrightData.BinaryData.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Binary data</param>
        </member>
        <member name="M:BrightData.BinaryData.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="reader">Binary reader to read binary data from</param>
        </member>
        <member name="M:BrightData.BinaryData.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BinaryData.Data">
            <summary>
            Byte array of binary data
            </summary>
        </member>
        <member name="M:BrightData.BinaryData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:BrightData.BrightDataContext">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="randomSeed">Initial value of random seed (or null to randomly initialize)</param>
        </member>
        <member name="M:BrightData.BrightDataContext.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.Random">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.DataReader">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.LinearAlgebraProvider2">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,System.Func{``0})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Set``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Set``1(System.String,System.Func{``0})">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.IsStochastic">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.ResetRandom(System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.UserNotifications">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.EncodedStream.EncodedStreamReader">
            <summary>
            Reads from potentially encoded storage
            </summary>
        </member>
        <member name="T:BrightData.Buffer.EncodedStream.EncodedStreamWriter">
            <summary>
            Writes hybrid buffers to binary writers, potentially encoding along the way
            </summary>
        </member>
        <member name="M:BrightData.Buffer.EncodedStream.EncodedStreamWriter.CopyTo``1(BrightData.IHybridBuffer{``0},System.IO.Stream)">
            <summary>
            Writes the hybrid buffer to a stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="buffer">Buffer to write</param>
            <param name="stream">Stream to write to</param>
        </member>
        <member name="M:BrightData.Buffer.EncodedStream.EncodedStreamWriter.GetWriter``1(BrightData.ICanEnumerateWithSize{``0},System.Boolean)">
            <summary>
            Returns an writer that can write the buffer to a binary writer
            </summary>
            <param name="buffer">Buffer to write</param>
            <param name="shouldEncode">If the values should be encoded</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.Buffer.Hybrid.HybridBufferBase`1">
            <summary>
            Hybrid buffers write to disk after their in memory cache is exhausted
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Buffer.Hybrid.HybridBufferSegment`1">
            <summary>
            A single type data table segment that can grow in size
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Buffer.Hybrid.HybridBufferSegment`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.Hybrid.HybridBufferSegment`1.MetaData">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.Hybrid.HybridBufferSegment`1.SingleType">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.Hybrid.HybridBufferSegment`1.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.Hybrid.HybridBufferSegment`1.CopyTo(System.IO.Stream)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.InMemory.InMemorySegment`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.InMemory.InMemorySegment`1.MetaData">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.InMemory.InMemorySegment`1.SingleType">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.InMemory.InMemorySegment`1.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Consts">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:BrightData.Consts.DataTableVersion">
            <summary>
            Data table version
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxDistinct">
            <summary>
            Default max distinct count
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxWriteCount">
            <summary>
            Default max write count
            </summary>
        </member>
        <member name="F:BrightData.Consts.RowProcessingNotificationCadence">
            <summary>
            Number of rows to process before notifying about progress
            </summary>
        </member>
        <member name="F:BrightData.Consts.MinimumSizeForParallel">
            <summary>
            Minimum size to use parallel processing
            </summary>
        </member>
        <member name="F:BrightData.Consts.MinimumSizeForVectorised">
            <summary>
            Minimum size to use SIMD processing
            </summary>
        </member>
        <member name="F:BrightData.Consts.SimpleMetaData">
            <summary>
            Standard metadata
            </summary>
        </member>
        <member name="F:BrightData.Consts.StandardMetaData">
            <summary>
            Standard metadata
            </summary>
        </member>
        <member name="T:BrightData.Converter.StaticConverters">
            <summary>
            Static methods to create converters
            </summary>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToDecimal``1">
            <summary>
            Creates a converter to decimals
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToDouble``1">
            <summary>
            Creates a converter to doubles
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToFloat``1">
            <summary>
            Creates a converter to floats
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToInt``1">
            <summary>
            Creates a converter to ints
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToLong``1">
            <summary>
            Creates a converter to longs (Int64)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToShort``1">
            <summary>
            Creates a converter to shorts (Int16)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToSignedByte``1">
            <summary>
            Creates a convert to signed bytes
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverter``2">
            <summary>
            Creates a converter from FT to TT
            </summary>
            <typeparam name="TF">Type to convert from</typeparam>
            <typeparam name="TT">Type to convert to</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableRow.Get``1(System.UInt32)">
            <summary>
            Returns a value (dynamic conversion to type T)
            </summary>
            <typeparam name="T">Type to convert to</typeparam>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.RowIndex">
            <summary>
            Row index
            </summary>
        </member>
        <member name="M:BrightData.DataTable.SequentialColumnReader`2.EnumerateTyped">
            <inheritdoc />
        </member>
        <member name="T:BrightData.ExtensionMethods">
            <summary>
            Extension methods to attach analyser creation to the bright data context
            </summary>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalyser(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Creates a date analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalyser``1(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetConvertToStringAnalyser``1(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalyser(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Creates a dimension analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalyser``1(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalyser(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates an index analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalyser(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalyser(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalyser(BrightData.BrightDataContext,System.Type,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <param name="_"></param>
            <param name="type"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the date analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the dimension analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the frequency analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the index analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the numeric analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the string analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDictionaryValues(BrightData.IMetaData)">
            <summary>
            Gets the categories that were stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNormalization(BrightData.IMetaData)">
            <summary>
            
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes numbers in a sequence
            </summary>
            <param name="data"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Analyzes dates in a sequence
            </summary>
            <param name="dates"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.ITensor2})">
            <summary>
            Analyzes tensors in a sequence
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.IHaveIndices})">
            <summary>
            Analyzes indices in a sequence
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Analyzes a sequence of strings
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AnalyzeFrequency``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes the frequency of items
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridStructBuffer``1(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a struct buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridStructBuffer(BrightData.BrightDataContext,System.Type,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a struct buffer
            </summary>
            <param name="_"></param>
            <param name="type">Type of structs</param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridStringBuffer(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a string buffer
            </summary>
            <param name="_"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridObjectBuffer``1(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Creates an object buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridObjectBuffer(BrightData.BrightDataContext,System.Type,BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Creates an object buffer
            </summary>
            <param name="context"></param>
            <param name="type">Type of objects</param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetBufferReader``1(BrightData.BrightDataContext,System.IO.BinaryReader,System.UInt32)">
            <summary>
            Returns a reader that buffers items in memory
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context">Bright data context</param>
            <param name="reader">Binary reader</param>
            <param name="inMemorySize">Number of bytes to use as an in memory buffer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToType(System.TypeCode)">
            <summary>
            Converts a type code to a type
            </summary>
            <param name="code">Type code</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.IMetaData,System.String,System.Nullable{``0})">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <typeparam name="T"></typeparam>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.IMetaData,System.String,``0)">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.HasConversionOperator(System.Type,System.Type)">
            <summary>
            Checks if one type can be implicitly cast to another
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Randomly shuffles the items in the sequence
            </summary>
            <param name="seq"></param>
            <param name="rnd">Random number generator to use</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split``1(``0[],System.Double)">
            <summary>
            Randomly splits the sequence into a two arrays (either "training" or "test")
            </summary>
            <param name="seq"></param>
            <param name="trainPercentage">Percentage of items to add to the training array</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bag``1(``0[],System.UInt32,System.Random)">
            <summary>
            Sample with replacement
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">Number of samples</param>
            <param name="rnd">Random number generator to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetName(BrightData.IMetaData)">
            <summary>
            Item name
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnIndex(BrightData.IMetaData)">
            <summary>
            Item index
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.IMetaData)">
            <summary>
            True if the item is numeric
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTarget(BrightData.IMetaData)">
            <summary>
            True if the item is a target
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsCategorical(BrightData.IMetaData)">
            <summary>
            True if the item is categorical
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsSequential(BrightData.IMetaData)">
            <summary>
            True if the item is sequential
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMetaData(BrightData.IWriteToMetaData)">
            <summary>
            Writes available meta data to a new meta data store
            </summary>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFloatConverter``1(BrightData.BrightDataContext)">
            <summary>
            Lazy create a float converter per context
            </summary>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32,System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32,System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Aggregate(BrightData.AggregationType,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Aggregates a list of floats
            </summary>
            <param name="operation"></param>
            <param name="data">Data to aggregate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTarget(BrightData.IMetaData,System.Boolean)">
            <summary>
            Sets this as a target
            </summary>
            <param name="metaData"></param>
            <param name="isTarget"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIsCategorical(BrightData.IMetaData,System.Boolean)">
            <summary>
            Sets this as categorical
            </summary>
            <param name="metaData"></param>
            <param name="isCategorical"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetName(BrightData.IMetaData,System.String)">
            <summary>
            Sets the name
            </summary>
            <param name="metaData"></param>
            <param name="name">Name</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFilePath(BrightData.IMetaData)">
            <summary>
            Returns the file path associated with the meta data (if any)
            </summary>
            <param name="metaData"></param>
            <returns>File path</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupAndCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Groups items and counts each group
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Format``1(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,System.UInt32}},System.Char)">
            <summary>
            Formats groups of items
            </summary>
            <param name="items"></param>
            <param name="separator">Group separator</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.UseLegacySerializationInput(BrightData.BrightDataContext,System.Boolean)">
            <summary>
            Enables or disables legacy (version 2) binary serialization - only when reading
            </summary>
            <param name="context"></param>
            <param name="use">True to enable</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataEncoder(BrightData.BrightDataContext)">
            <summary>
            Creates a data encoder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetData(BrightData.ICanWriteToBinaryWriter)">
            <summary>
            Converts the object to a serialized buffer
            </summary>
            <param name="writable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.NotifyProgress(BrightData.INotifyUser,System.String,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Notifies about the progress of a multi part operation
            </summary>
            <param name="notify"></param>
            <param name="operationId">Unique operation id</param>
            <param name="index">Index of current part</param>
            <param name="total">Total number of parts</param>
            <param name="progress">Process within the part</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteProgressPercentage(System.Single,System.Int32@,System.Diagnostics.Stopwatch)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="progress">New progress (between 0 and 1)</param>
            <param name="previousPercentage">Current progress percentage (max 100)</param>
            <param name="sw">Stopwatch since start of operation</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsCommaSeparated``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes the enumerable to a comma separated string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items to write</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadArray``1(System.IO.Stream,System.UInt32)">
            <summary>
            Reads an array of T from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="size">Number of items to read</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadArray``1(System.IO.Stream,System.Int32)">
            <summary>
            Reads an array of T from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="size">Number of items to read</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindPermutations``1(``0[])">
            <summary>
            Finds all possible permutations of sub items from the array, including the array itself
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Array to permute</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Enumerate``1(System.IO.Stream,System.UInt32,System.Int32)">
            <summary>
            Enumerates a stream as a series of structs. This is best for small structs such as int32 etc as the values are not passed by reference.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="count">Total count to return</param>
            <param name="tempBufferSize">Size of temp buffer to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType(BrightData.BrightDataType)">
            <summary>
            Converts from a column type to a Type
            </summary>
            <param name="type">Column type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetBrightDataType(System.Type)">
            <summary>
            Converts from a Type to a ColumnType
            </summary>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsBlittable(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is blittable
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is numeric
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsDecimal(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is decimal
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsContinuous(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is continuous
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsInteger(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is an integer
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsIndexedList(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is an indexed list (or weighted index list)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTensor(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is a tensor
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType(BrightData.IDataTableSegment)">
            <summary>
            Returns the underlying Type for a data table segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType``1(BrightData.IDataTableSegment{``0})">
            <summary>
            Returns the underlying Type for a data table segment
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RowIndices(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns all row indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndices(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns all column indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``1(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <param name="dataTable"></param>
            <typeparam name="T0"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``2(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="dataTable"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``3(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="dataTable"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``4(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="dataTable"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnAnalyser(BrightData.BrightDataType,BrightData.IMetaData,System.UInt32,System.UInt32)">
            <summary>
            Creates a column analyser
            </summary>
            <param name="type">Column type</param>
            <param name="metaData">Column meta data</param>
            <param name="writeCount">Maximum size of sequences to write in final meta data</param>
            <param name="maxDistinctCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ParseCsvIntoMemory(BrightData.BrightDataContext,System.IO.StreamReader,System.Boolean,System.Char,System.Int32,System.UInt16,System.Threading.CancellationToken)">
            <summary>
            Parse CSV in memory without writing to disk (for small data sets)
            </summary>
            <param name="context"></param>
            <param name="reader">Stream reader that contains CSV data</param>
            <param name="hasHeader">True if the data contains a header</param>
            <param name="delimiter">CSV delimiter character</param>
            <param name="maxRows">Maximum number of rows to read</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ParseCsv(BrightData.BrightDataContext,System.IO.StreamReader,System.Boolean,System.Char,System.String,System.Int32,System.UInt32,System.UInt16,System.Threading.CancellationToken)">
            <summary>
            Parse CSV into a column oriented data table using hybrid buffers
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">CSV</param>
            <param name="hasHeader">True if the CSV has a text based header</param>
            <param name="delimiter">CSV delimiter</param>
            <param name="fileOutputPath">Optional path to save final table</param>
            <param name="maxRows">Maximum number of rows of CSV to read</param>
            <param name="inMemoryRowCount">Number of rows to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <param name="tempBasePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Head(BrightData.DataTable.BrightDataTable,System.UInt32)">
            <summary>
            Returns the head (first few rows) of the data table
            </summary>
            <param name="dataTable"></param>
            <param name="size">Number of rows to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadTable(BrightData.BrightDataContext,System.String)">
            <summary>
            Loads a data table from disk
            </summary>
            <param name="context"></param>
            <param name="filePath">File path on disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyToFloatSegment``1(BrightData.IDataTableSegment{``0},BrightData.ITensorSegment2)">
            <summary>
            Copies a data table segment to a tensor segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="column">Data table segment</param>
            <param name="vector">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.ISingleTypeTableSegment,BrightData.ITensorSegment2)">
            <summary>
            Copies a data table segment to tensor segment
            </summary>
            <param name="column">Data table segment</param>
            <param name="vector">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTargetColumn(BrightData.DataTable.BrightDataTable,System.Nullable{System.UInt32})">
            <summary>
            Sets the target column of the data table
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to make target (or null to set no target)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumn(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns the target column of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumnOrThrow(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns the target column or throws an exception if none set
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndicesOfFeatures(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns the feature (non target) columns of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetType(BrightData.IMetaData,BrightData.BrightDataType)">
            <summary>
            Sets the column type in a meta data store
            </summary>
            <param name="metaData"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetHybridBufferWithMetaData(BrightData.BrightDataType,BrightData.IMetaData,BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates an appendable buffer for a column type
            </summary>
            <param name="metaData"></param>
            <param name="type">Column type</param>
            <param name="context"></param>
            <param name="tempStream"></param>
            <param name="bufferSize">In memory cache size</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectorisedFeatures(BrightData.DataTable.BrightDataTable)">
            <summary>
            Converts the data table to a sequence of labeled vectors (feature columns are vectorised, target column is converted to a string)
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnType(BrightData.IMetaData)">
            <summary>
            Gets the column type
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumDistinct(BrightData.IMetaData)">
            <summary>
            Gets the number of distinct items
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split(BrightData.DataTable.BrightDataTable,System.Double,System.String,System.String)">
            <summary>
            Splits a data table into training and test tables (rows are randomly selected for either)
            </summary>
            <param name="table"></param>
            <param name="trainingFraction">Fraction (0..1) of rows to add to the training table</param>
            <param name="trainingFilePath">Path to write training table to disk (optional)</param>
            <param name="testFilePath">Path to write test table to disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Fold(BrightData.DataTable.BrightDataTable,System.Int32,System.Boolean)">
            <summary>
            Folds the data table into k buckets (for k fold cross validation)
            </summary>
            <param name="table"></param>
            <param name="k">Number of buckets to create</param>
            <param name="shuffle">True to shuffle the table before folding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.EnumerateTyped``1(BrightData.ISingleTypeTableSegment)">
            <summary>
            Strongly typed enumeration of items in segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray``1(BrightData.ISingleTypeTableSegment)">
            <summary>
            Reads the segment as a strongly typed array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrices(BrightData.DataTable.BrightDataTable)">
            <summary>
            Converts the data table to feature and target matrices
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrix(BrightData.DataTable.BrightDataTable,System.UInt32[])">
            <summary>
            Converts data table columns to a matrix
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices to include in the matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.DataTable.BrightDataTable,System.Boolean,System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.DataTable.BrightDataTable,System.Boolean,System.Collections.Generic.IEnumerable{System.UInt32},System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="columnIndices">Columns to use</param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray``1(BrightData.IDataTableSegment{``0})">
            <summary>
            Converts a data table segment to an array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IndexList}},BrightData.BrightDataContext)">
            <summary>
            Converts indexed classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.BrightDataContext)">
            <summary>
            Converts weighted index classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IVector}},System.Boolean,BrightData.BrightDataContext)">
            <summary>
            Converts the vector classifications into a data table
            </summary>
            <param name="data"></param>
            <param name="preserveVectors">True to create a data table with a vector column type, false to to convert to columns of floats</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.BrightDataContext)">
            <summary>
            Converts the weighted index classification list to a list of dense vectors
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDefaultValue(BrightData.BrightDataType)">
            <summary>
            Returns a default value for a column type
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectoriser(BrightData.DataTable.BrightDataTable,System.Boolean,System.UInt32[])">
            <summary>
            Returns a vectoriser
            </summary>
            <param name="table"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="columnIndices">Column indices to vectorise</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadVectoriser(BrightData.DataTable.BrightDataTable,System.IO.BinaryReader)">
            <summary>
            Loads a previously created data table vectoriser
            </summary>
            <param name="dataTable"></param>
            <param name="reader">Reader to load parameters from</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertColumn(BrightData.ColumnConversionType,System.UInt32)">
            <summary>
            Creates a column conversion parameter
            </summary>
            <param name="type">Type of column conversion</param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertColumn(BrightData.NormalizationType,System.UInt32)">
            <summary>
            Creates a column normalization parameter
            </summary>
            <param name="type"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReinterpretColumns(System.UInt32[],BrightData.BrightDataType,System.String,System.UInt32)">
            <summary>
            Creates a reinterpret columns parameter
            </summary>
            <param name="sourceColumnIndices"></param>
            <param name="newColumnType"></param>
            <param name="newColumnName"></param>
            <param name="outputColumnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray(BrightData.IDataTableSegment)">
            <summary>
            Converts the segment to an array
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Get``1(BrightData.IDataTableSegment,System.UInt32)">
            <summary>
            Casts the value at column index to type T
            </summary>
            <param name="segment"></param>
            <param name="columnIndex"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sample(BrightData.DataTable.BrightDataTable,System.UInt32)">
            <summary>
            Samples rows from the data table
            </summary>
            <param name="table"></param>
            <param name="sampleSize">Number of rows to sample</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCustomColumnMutator``2(BrightData.DataTable.BrightDataTable,System.UInt32,System.Func{``0,``1},System.Action{BrightData.IMetaData})">
            <summary>
            Creates a custom column mutator
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to convert</param>
            <param name="converter">Column converter</param>
            <param name="columnFinaliser">Called after each row </param>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Convert(BrightData.DataTable.BrightDataTable,BrightData.IColumnTransformationParam[])">
            <summary>
            Creates a new table with columns that have been converted
            </summary>
            <param name="dataTable"></param>
            <param name="conversion">Column conversion parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,BrightData.IColumnTransformationParam[])">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="conversion">Column normalization parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateColumns(BrightData.DataTable.BrightDataTable,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="dataTable"></param>
            <param name="others">Other tables to concatenate</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateRows(BrightData.DataTable.BrightDataTable,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="dataTable"></param>
            <param name="others">Other tables to concatenate</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReinterpretColumns(BrightData.DataTable.BrightDataTable,BrightData.IProvideTempStreams,System.String,BrightData.IReinterpretColumns[])">
            <summary>
            Many to one or one to many style column transformations
            </summary>
            <param name="dataTable"></param>
            <param name="columns">Parameters to determine which columns are reinterpreted</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyRows(BrightData.DataTable.BrightDataTable,System.String,System.UInt32[])">
            <summary>
            Copy specified rows from this to a new data table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath"></param>
            <param name="rowIndices">Row indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnTransformers(BrightData.DataTable.BrightDataTable,BrightData.IProvideTempStreams,System.Collections.Generic.IEnumerable{BrightData.IColumnTransformationParam})">
            <summary>
            Gets column transformers
            </summary>
            <param name="dataTable"></param>
            <param name="input">Column transformation parameter objects</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateColumns(BrightData.DataTable.BrightDataTable,System.String,BrightData.IColumnTransformationParam[])">
            <summary>
            
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="conversionParams">Column normalization parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnInfo(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns column information
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,BrightData.NormalizationType)">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="type">Normalization type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,System.String,BrightData.NormalizationType)">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="type">Normalization type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTableSignature(BrightData.DataTable.BrightDataTable)">
            <summary>
            Gets the table signature based on column types
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.NextRandomFloat(BrightData.BrightDataContext)">
            <summary>
            Returns a randomly initialized float greater than or equal to 0f, and less than 1f
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.BrightDataContext,System.Int32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBernoulliDistribution(BrightData.BrightDataContext,System.Single)">
            <summary>
            Create a bernoulli distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBinomialDistribution(BrightData.BrightDataContext,System.Single,System.UInt32)">
            <summary>
            Create a binomial distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <param name="numTrials"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCategoricalDistribution(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Create a categorical distribution
            </summary>
            <param name="context"></param>
            <param name="categoricalValues"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateContinuousDistribution(BrightData.BrightDataContext,System.Single,System.Single)">
            <summary>
            Create a continuous distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiscreteUniformDistribution(BrightData.BrightDataContext,System.Int32,System.Int32)">
            <summary>
            Create a discrete uniform distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateNormalDistribution(BrightData.BrightDataContext,System.Single,System.Single)">
            <summary>
            Create a normal distribution
            </summary>
            <param name="context"></param>
            <param name="mean"></param>
            <param name="stdDev">Standard deviation</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.UInt32[])">
            <summary>
            Creates an index list from indices
            </summary>
            <param name="context"></param>
            <param name="indices">Indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates an index list from indices
            </summary>
            <param name="context"></param>
            <param name="indices">Indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates an index list from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.ValueTuple{System.UInt32,System.Single}[])">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="context"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,System.Single}})">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="context"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{BrightData.WeightedIndexList.Item})">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="context"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a weighted index list from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToWeightedIndexList(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IndexList}},System.Boolean)">
            <summary>
            Converts the indexed classifications to weighted indexed classifications
            </summary>
            <param name="data"></param>
            <param name="groupByClassification">True to group by classification (i.e convert the bag to a set)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxWeight(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Finds the greatest weight within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Find the greatest index within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IndexList}})">
            <summary>
            Find the greatest index within the index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Normalizes the weighted index classification list to fit between 0 and 1
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Tfidf``1(System.Collections.Generic.IReadOnlyList{System.ValueTuple{``0,BrightData.WeightedIndexList}})">
            <summary>
            Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Tf%E2%80%93idf
            </summary>
            <returns>A newly weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bm25Plus``1(System.Collections.Generic.IReadOnlyList{System.ValueTuple{``0,BrightData.WeightedIndexList}},System.Single,System.Single,System.Single)">
            <summary>
            Okapi B525+ modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Okapi_BM25
            </summary>
            <returns>Newly weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVectorInfo(BrightData.BrightDataContext,System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVectorInfo(BrightData.BrightDataContext,System.UInt32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVectorInfo(BrightData.BrightDataContext,System.Single[])">
            <summary>
            Creates a vector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="initialData">Initial data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVectorInfo(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a vector from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfo(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfo(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Creates a matrix
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfo(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a matrix from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfoFromRows(BrightData.BrightDataContext,BrightData.IVectorInfo[])">
            <summary>
            Creates a matrix from vectors (each will become a row)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfoFromRows(BrightData.BrightDataContext,System.Single[][])">
            <summary>
            Creates a matrix from rows (each will become a row)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfoFromColumns(BrightData.BrightDataContext,BrightData.IVectorInfo[])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixInfoFromColumns(BrightData.BrightDataContext,System.Single[][])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor3D(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 3D tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor3D(BrightData.BrightDataContext,BrightData.IMatrixInfo[])">
            <summary>
            Creates a 3D tensor from matrices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="slices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor3D(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Create a 3D tensor from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor4D(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 4D tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor4D(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a 4D tensor from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor4D(BrightData.BrightDataContext,BrightData.ITensor3D[])">
            <summary>
            Creates a 4D tensor from 3D tensors
            </summary>
            <param name="context"></param>
            <param name="tensors">3D tensors that form the 4D tensor</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIdentityMatrix(BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32)">
            <summary>
            Creates an identity matrix (each diagonal element is 1, each other element is 0)
            </summary>
            <param name="lap"></param>
            <param name="size">Width and height of the new matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiagonalMatrix(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Single[])">
            <summary>
            Creates a diagonal matrix
            </summary>
            <param name="lap"></param>
            <param name="values">Diagonal values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.InitializeRandomly``1(BrightData.ITensor2)">
            <summary>
            Randomly initialize a tensor
            </summary>
            <param name="tensor"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize(BrightData.ITensor2,System.Single)">
            <summary>
            Initialize a tensor to a single value
            </summary>
            <param name="tensor"></param>
            <param name="value">Value to initialize each element of the tensor</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize(BrightData.ITensor2,System.Func{System.UInt32,System.Single})">
            <summary>
            Initialize a tensor using a callback
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensor"></param>
            <param name="initializer">Callback for each element</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.ITensorSegment2)">
            <summary>
            Converts the tensor segment to a sparse format (only non zero entries are preserved)
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadVectorFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a vector from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadMatrixFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a matrix from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Minimum(System.Single[])">
            <summary>
            Find the minimum value and index in a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns>Tuple containing the minimum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumIndex(System.Single[])">
            <summary>
            Returns the index of the minimum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumValue(System.Single[])">
            <summary>
            Returns the minimum value
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Maximum(System.Single[])">
            <summary>
            Returns the maximum value and index within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns>Tuple containing the maximum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumIndex(System.Single[])">
            <summary>
            Returns the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumValue(System.Single[])">
            <summary>
            Returns the index of the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Softmax(System.Single[])">
            <summary>
            Calculates the softmax of a vector
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReduceDimensions(BrightData.IMatrix,System.UInt32)">
            <summary>
            Reduce dimensions of the matrix with a singular value decomposition
            </summary>
            <param name="matrix"></param>
            <param name="dimensions">Number of dimensions to reduce to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Average``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Calculates an average from a collection of tensors
            </summary>
            <param name="tensors">Tensors to average</param>
            <param name="dispose">True to dispose each of the input vectors</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsDataFieldSpecification(BrightData.BrightDataType,System.String,System.Boolean)">
            <summary>
            Creates a data field specification for a data type
            </summary>
            <param name="dataType"></param>
            <param name="name"></param>
            <param name="canRepeat"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTypeSpecification(BrightData.DataTable.BrightDataTable)">
            <summary>
            Creates a type specification for a data table
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindNonConformingRows(BrightData.IDataTypeSpecification,BrightData.DataTable.BrightDataTable)">
            <summary>
            Finds the row indices of any row that does not conform to the type specification
            </summary>
            <param name="typeInfo"></param>
            <param name="dataTable"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:BrightData.Helper.ColumnTypeClassifier">
            <summary>
            Classifies data table column types
            </summary>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsDecimal(BrightData.BrightDataType)">
            <summary>
            Checks for a decimal type (floating point)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsNumeric(BrightData.BrightDataType)">
            <summary>
            Checks for a numeric type (floating point or integer)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsContinuous(BrightData.BrightDataType)">
            <summary>
            Checks for a continuous type (non categorical)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsCategorical(BrightData.BrightDataType)">
            <summary>
            Checks for a categorical type (non continuous)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsBlittable(BrightData.BrightDataType)">
            <summary>
            Checks if the type has an independent memory layout across managed and unmanaged code
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.GetClass(BrightData.BrightDataType,BrightData.IMetaData)">
            <summary>
            Returns the set of possible column classifications
            </summary>
            <param name="type">Column type to check</param>
            <param name="metaData">Column metadata</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ConsoleProgressNotification">
            <summary>
            Writes progress notifications to the console
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnStartOperation(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnOperationProgress(System.String,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnCompleteOperation(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.WriteProgress(System.Int32,System.Int32@,System.Int32)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="newProgress">New progress</param>
            <param name="oldProgress">Current progress</param>
            <param name="max">Max progress amount (default 100)</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.WriteProgress(System.Single,System.Int32@,System.Diagnostics.Stopwatch)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="progress">New progress (between 0 and 1)</param>
            <param name="previousPercentage">Current progress percentage (max 100)</param>
            <param name="sw">Stopwatch since start of operation</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper">
            <summary>
            Helper class to calculate convolutional indices
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.LeftToRight(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from left to right
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.TopToBottom(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from top to bottom
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper.ConvolutionalDelegate">
            <inheritdoc />
        </member>
        <member name="F:BrightData.Helper.ConvolutionHelper.Default">
            <summary>
            Default convolutional direction
            </summary>
        </member>
        <member name="T:BrightData.Helper.DataEncoder">
            <summary>
            Encodes types from/to bytes
            </summary>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Read``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read from a binary reader
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read an array from a binary reader
            </summary>
            <typeparam name="T">Type within the array</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0)">
            <summary>
            Generic method to write to binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="val">Item to write</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0[])">
            <summary>
            Generic method to write an array to a binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="values">Array to write</param>
        </member>
        <member name="T:BrightData.Helper.DoubleMath">
            <summary>
            Helpers for double based math
            </summary>
        </member>
        <member name="F:BrightData.Helper.DoubleMath.AlmostZero">
            <summary>
            A number that is close to zero
            </summary>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Double,System.Double,System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Nullable{System.Double},System.Nullable{System.Double},System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.FloatMath">
            <summary>
            Constrained float math helpers - if the value is too small or too big it will be capped. Also NaN values are replaced with zero.
            </summary>
        </member>
        <member name="T:BrightData.Helper.GenericActivator">
            <summary>
            Generic object creator
            </summary>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``2(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T1">Type to cast created object to</typeparam>
            <typeparam name="T2">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1">
            <summary>
            Creates a new object (via default constructor)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1">
            <summary>
            Creates a new unitialized object (constructor is not invoked)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1(System.Type)">
            <summary>
            Creates a new unitialized object (constructor is not invoked)
            </summary>
            <param name="type">Type to create</param>
            <typeparam name="T">Type to return (created object cast to this type)</typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ShapedBase">
            <summary>
            Tensor shape
            </summary>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Shape">
            <summary>
            Array of sizes
            </summary>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.#ctor(System.UInt32[])">
            <summary>
            Constructor
            </summary>
            <param name="shape">Array of sizes</param>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Size">
            <summary>
            Total size of the shape
            </summary>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Rank">
            <summary>
            Number of sizes within the shape
            </summary>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ShapedBase.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads the shape from a binary reader
            </summary>
            <param name="reader">Reader</param>
            <returns>Size of tensor</returns>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.ResolveShape(System.UInt32,System.Nullable{System.UInt32}[])">
            <summary>
            Works out the shape from a possibly incomplete list of sizes
            </summary>
            <param name="total">Total size</param>
            <param name="shape">List of sizes that form the shape (one can be null)</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.StreamCloner">
            <summary>
            Clones streams
            </summary>
        </member>
        <member name="T:BrightData.Helper.StringIndexer">
            <summary>
            Builds a string table
            </summary>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.#ctor(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.Create(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.GetIndex(System.String)">
            <summary>
            Returns the index of a string (creates it if not already in table)
            </summary>
            <param name="str">String to search</param>
            <returns>String index</returns>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OutputSize">
            <summary>
            Size of the string table
            </summary>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OrderedStrings">
            <summary>
            Returns all strings by indexed order
            </summary>
        </member>
        <member name="T:BrightData.Helper.TempStreamManager">
            <summary>
            Manages a collection of temp files
            </summary>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="basePath">Location on disk to write new temp files</param>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.GetNewTempPath">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.Get(System.String)">
            <summary>
            Returns an existing (or creates a new) temp stream
            </summary>
            <param name="uniqueId">Unique identifier</param>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.HasStream(System.String)">
            <summary>
            Checks if the the stream has been created
            </summary>
            <param name="uniqueId">Unique identifier</param>
            <returns>True if the stream has been created</returns>
        </member>
        <member name="T:BrightData.HybridBuffersExtensionMethods">
            <summary>
            Static methods to create hybrid buffers
            </summary>
        </member>
        <member name="M:BrightData.HybridBuffersExtensionMethods.CreateHybridStructBuffer``1(BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store structs
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tempStream"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.HybridBuffersExtensionMethods.CreateHybridStructBuffer(BrightData.IProvideTempStreams,System.Type,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store structs
            </summary>
            <param name="tempStream"></param>
            <param name="type"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.HybridBuffersExtensionMethods.CreateHybridStringBuffer(BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store strings
            </summary>
            <param name="tempStream"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.HybridBuffersExtensionMethods.CreateHybridObjectBuffer``1(BrightData.IProvideTempStreams,BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Creates a buffer to store objects
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tempStream"></param>
            <param name="context"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.HybridBuffersExtensionMethods.CreateHybridObjectBuffer(BrightData.IProvideTempStreams,BrightData.BrightDataContext,System.Type,System.UInt32)">
            <summary>
            Creates a buffer to store objects
            </summary>
            <param name="tempStream"></param>
            <param name="context"></param>
            <param name="type"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IndexList">
            <summary>
            Contains a list of indices
            </summary>
        </member>
        <member name="P:BrightData.IndexList.Indices">
            <summary>
            The list of indices
            </summary>
        </member>
        <member name="P:BrightData.IndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.IndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.IndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.IndexList})">
            <summary>
            Merges a sequence of index lists into a single index list
            </summary>
            <param name="lists">Lists to merge</param>
        </member>
        <member name="M:BrightData.IndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.IndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.IndexList.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.ToXml">
            <summary>
            Converts the index list to XML
            </summary>
        </member>
        <member name="M:BrightData.IndexList.JaccardSimilarity(BrightData.IndexList)">
            <summary>
            Calculates the jaccard similarity between this and another index list
            </summary>
            <param name="other">Index list to compare to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.AsDense(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.UInt32})">
            <summary>
            Converts to a vector
            </summary>
            <param name="maxIndex">Maximum index to include</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.HasIndex(System.UInt32)">
            <summary>
            Checks if the specified index has been set
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveIndices">
            <summary>
            Indicates that the type has a list of indices
            </summary>
        </member>
        <member name="P:BrightData.IHaveIndices.Indices">
            <summary>
            Enumerates the indices
            </summary>
        </member>
        <member name="T:BrightData.ICanWriteToBinaryWriter">
            <summary>
            Indicates that the type can serialize to a binary writer
            </summary>
        </member>
        <member name="M:BrightData.ICanWriteToBinaryWriter.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Serialize to binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:BrightData.ICanInitializeFromBinaryReader">
            <summary>
            Indicates that the type can initialize from a binary reader
            </summary>
        </member>
        <member name="M:BrightData.ICanInitializeFromBinaryReader.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Initialize from a binary reader
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">Reader to read from to initialize</param>
        </member>
        <member name="T:BrightData.ISerializable">
            <summary>
            Supports both writing and reading from binary
            </summary>
        </member>
        <member name="T:BrightData.IMetaData">
            <summary>
            Unstructured meta data store
            </summary>
        </member>
        <member name="M:BrightData.IMetaData.Get(System.String)">
            <summary>
            Returns a value
            </summary>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.GetNullable``1(System.String)">
            <summary>
            Returns a typed nullable value
            </summary>
            <param name="name">Name of the value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Get``1(System.String,``0)">
            <summary>
            Returns a typed value
            </summary>
            <param name="name">Name of the value</param>
            <param name="valueIfMissing">Value to return if the value has not been set</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Get``1(System.String)">
            <summary>
            Returns an existing value (throws if not found)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Set``1(System.String,``0)">
            <summary>
            Sets a named value
            </summary>
            <param name="name">Name of the value</param>
            <param name="value">Value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMetaData.AsXml">
            <summary>
            XML representation of the meta data
            </summary>
        </member>
        <member name="M:BrightData.IMetaData.CopyTo(BrightData.IMetaData)">
            <summary>
            Copies this to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
        </member>
        <member name="M:BrightData.IMetaData.CopyTo(BrightData.IMetaData,System.String[])">
            <summary>
            Copies the specified values to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keys">Values to copy</param>
        </member>
        <member name="M:BrightData.IMetaData.CopyAllExcept(BrightData.IMetaData,System.String[])">
            <summary>
            Copies all except for the specified values to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keys">Values NOT to copy (i.e. skip)</param>
        </member>
        <member name="M:BrightData.IMetaData.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads values from a binary reader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:BrightData.IMetaData.GetStringsWithPrefix(System.String)">
            <summary>
            Returns all value names with the specified prefix
            </summary>
            <param name="prefix">Prefix to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Has(System.String)">
            <summary>
            Checks if a value has been set
            </summary>
            <param name="key">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Remove(System.String)">
            <summary>
            Removes a value
            </summary>
            <param name="key">Name of the value</param>
        </member>
        <member name="P:BrightData.IMetaData.AllKeys">
            <summary>
            Returns all keys that have been set
            </summary>
        </member>
        <member name="M:BrightData.IMetaData.Clone">
            <summary>
            Creates a clone of the current metadata
            </summary>
        </member>
        <member name="T:BrightData.IHaveMetaData">
            <summary>
            Indicates that the type has a meta data store
            </summary>
        </member>
        <member name="P:BrightData.IHaveMetaData.MetaData">
            <summary>
            Meta data store
            </summary>
        </member>
        <member name="T:BrightData.IReferenceCountedMemory">
            <summary>
            Reference counted memory block
            </summary>
        </member>
        <member name="P:BrightData.IReferenceCountedMemory.Size">
            <summary>
            Size of the memory block
            </summary>
        </member>
        <member name="M:BrightData.IReferenceCountedMemory.AddRef">
            <summary>
            Adds a reference
            </summary>
            <returns>Current number of references</returns>
        </member>
        <member name="M:BrightData.IReferenceCountedMemory.Release">
            <summary>
            Removes a reference
            </summary>
            <returns>Current number of references</returns>
        </member>
        <member name="P:BrightData.IReferenceCountedMemory.AllocationIndex">
            <summary>
            Returns this block's allocation index
            </summary>
        </member>
        <member name="P:BrightData.IReferenceCountedMemory.IsValid">
            <summary>
            Checks if the block is valid
            </summary>
        </member>
        <member name="T:BrightData.ITensor">
            <summary>
            Tensor base interface
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Shape">
            <summary>
            The shape of the tensor (array of each dimension)
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Size">
            <summary>
            Total number of elements in tensor
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Rank">
            <summary>
            Size of the Shape array
            </summary>
        </member>
        <member name="P:BrightData.ITensor.IsValid">
            <summary>
            True if the underlying memory has been properly scoped
            </summary>
        </member>
        <member name="T:BrightData.IDataReader">
            <summary>
            Typed data reader
            </summary>
        </member>
        <member name="M:BrightData.IDataReader.Read``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed value from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataReader.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed array from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensorPool">
            <summary>
            A memory pool of tensors
            </summary>
        </member>
        <member name="M:BrightData.ITensorPool.Get``1(System.UInt32)">
            <summary>
            Returns an existing cached array if available or allocates a new array otherwise
            </summary>
            <typeparam name="T"></typeparam>
            <param name="size">Size of the tensor to allocate</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDisposableLayers">
            <summary>
            Collects a list of disposable objects that can all be disposed when the layer is disposed
            </summary>
        </member>
        <member name="M:BrightData.IDisposableLayers.Add(System.IDisposable)">
            <summary>
            Adds a new disposable object
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:BrightData.IDisposableLayers.Push">
            <summary>
            Creates a new layer to add disposable objects to
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDisposableLayers.Pop">
            <summary>
            Disposes all objects in the top layer and removes this layer
            </summary>
        </member>
        <member name="T:BrightData.ISetLinearAlgebraProvider">
            <summary>
            Indicates that the type can set a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.ISetLinearAlgebraProvider.LinearAlgebraProvider2">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.IHaveLinearAlgebraProvider">
            <summary>
            Gives access to a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.IHaveLinearAlgebraProvider.LinearAlgebraProvider2">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.IHaveDataContext">
            <summary>
            Indicates that the type has a data context
            </summary>
        </member>
        <member name="P:BrightData.IHaveDataContext.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="T:BrightData.ITensorSegment`1">
            <summary>
            Typed indexable data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.ITensorSegment`1.IsContiguous">
            <summary>
            True if the data values are contiguous in memory
            </summary>
        </member>
        <member name="P:BrightData.ITensorSegment`1.Item(System.UInt32)">
            <summary>
            Returns a value at an index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment`1.Item(System.Int64)">
            <summary>
            Returns a value at an index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorSegment`1.Clone">
            <summary>
            Clones the data into a new managed block
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment`1.Values">
            <summary>
            All values
            </summary>
        </member>
        <member name="M:BrightData.ITensorSegment`1.InitializeFrom(System.IO.Stream)">
            <summary>
            Initialize the segment from a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.Initialize(System.Func{System.UInt32,`0})">
            <summary>
            Initialize the segment from a callback
            </summary>
            <param name="initializer">Functions that returns values for each indexed value</param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.Initialize(`0)">
            <summary>
            Initialize the segment to a single value
            </summary>
            <param name="initialValue">Initial value</param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.Initialize(System.Span{`0})">
            <summary>
            Initialize from an array
            </summary>
            <param name="initialData"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.WriteTo(System.IO.Stream)">
            <summary>
            Writes to a stream
            </summary>
            <param name="writerBaseStream"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.CopyTo(System.Span{`0},System.UInt32,System.UInt32)">
            <summary>
            Copies values from this segment to an existing array
            </summary>
            <param name="array"></param>
            <param name="sourceIndex">Index to start copying from</param>
            <param name="count">Number of values to copy</param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.CopyTo(BrightData.ITensorSegment{`0})">
            <summary>
            Copies all values to another segment
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.AsNumericsVector(System.Int32)">
            <summary>
            Returns part of the segment as a numerics vector
            </summary>
        </member>
        <member name="M:BrightData.ITensorSegment`1.GetArrayForLocalUseOnly">
            <summary>
            Returns an array that is only valid in local scope
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IWriteToMetaData">
            <summary>
            Indicates that the type can write values to meta data
            </summary>
        </member>
        <member name="M:BrightData.IWriteToMetaData.WriteTo(BrightData.IMetaData)">
            <summary>
            Writes values to meta data
            </summary>
            <param name="metadata">Meta data store</param>
        </member>
        <member name="T:BrightData.IDataAnalyser">
            <summary>
            Base data analyzer type
            </summary>
        </member>
        <member name="M:BrightData.IDataAnalyser.AddObject(System.Object)">
            <summary>
            Adds an object to analyze
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IAcceptSequentialTypedData`1">
            <summary>
            Typed data can be sequentially added
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IAcceptSequentialTypedData`1.Add(`0)">
            <summary>
            Adds a typed object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IDataAnalyser`1">
            <summary>
            Typed data analyser
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.NormalizationType">
            <summary>
            Types of data normalization
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Standard">
            <summary>
            Standard deviation
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Euclidean">
            <summary>
            Euclidean norm
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Manhattan">
            <summary>
            Manhattan
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.FeatureScale">
            <summary>
            Between 0..1
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert">
            <summary>
            Indicates that the type can convert different types
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.From">
            <summary>
            Type that is converted from
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.To">
            <summary>
            Type that is converted to
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert`2">
            <summary>
            Typed converter interface
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.ICanConvert`2.Convert(`0)">
            <summary>
            Converts a type from one to another
            </summary>
            <param name="data">Object to convert</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.INormalize">
            <summary>
            Data normalizer
            </summary>
        </member>
        <member name="P:BrightData.INormalize.NormalizationType">
            <summary>
            Type of data normalization
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Divide">
            <summary>
            Value to divide each value
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Subtract">
            <summary>
            Value to subtract from each value
            </summary>
        </member>
        <member name="T:BrightData.AggregationType">
            <summary>
            Types of aggregations
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Sum">
            <summary>
            Sums values to a final value
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Average">
            <summary>
            Averages values
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Max">
            <summary>
            Finds the maximum value
            </summary>
        </member>
        <member name="T:BrightData.IDistribution`1">
            <summary>
            Data distribution
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDistribution`1.Sample">
            <summary>
            Samples a value from the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDiscreteDistribution">
            <summary>
            Discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.INonNegativeDiscreteDistribution">
            <summary>
            Positive discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.IContinuousDistribution">
            <summary>
            Continuous data distribution
            </summary>
        </member>
        <member name="T:BrightData.IProvideTempStreams">
            <summary>
            Temp stream provider
            </summary>
        </member>
        <member name="M:BrightData.IProvideTempStreams.GetNewTempPath">
            <summary>
            Returns the path to a new temp file
            </summary>
        </member>
        <member name="M:BrightData.IProvideTempStreams.Get(System.String)">
            <summary>
            Returns an existing or creates a new temporary stream
            </summary>
            <param name="uniqueId">Id that uniquely identifies the context</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IProvideTempStreams.HasStream(System.String)">
            <summary>
            Checks if a stream has been created
            </summary>
            <param name="uniqueId">Id that uniquely identifies the context</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHybridBuffer">
            <summary>
            Hybrid buffers write first to memory but then to disk once it's cache is exhausted
            </summary>
        </member>
        <member name="M:BrightData.IHybridBuffer.CopyTo(System.IO.Stream)">
            <summary>
            Copies the buffer to a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:BrightData.IHybridBuffer.NumDistinct">
            <summary>
            Number of distinct items in the buffer (or null if not known)
            </summary>
        </member>
        <member name="M:BrightData.IHybridBuffer.AddObject(System.Object)">
            <summary>
            Adds an object to the buffer
            </summary>
            <param name="obj">Object to add</param>
        </member>
        <member name="P:BrightData.IHybridBuffer.DataType">
            <summary>
            Buffer data type
            </summary>
        </member>
        <member name="T:BrightData.IHybridBuffer`1">
            <summary>
            Typed hybrid buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.HybridBufferType">
            <summary>
            Type of hybrid buffer
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.Unknown">
            <summary>
            Unknown type
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.Struct">
            <summary>
            Buffer of structs
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.String">
            <summary>
            Buffer of strings
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.EncodedStruct">
            <summary>
            Buffer of encoded structs
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.EncodedString">
            <summary>
            Buffer of encoded strings
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.Object">
            <summary>
            Buffer of objects
            </summary>
        </member>
        <member name="T:BrightData.IHaveSize">
            <summary>
            Indicates that the type has a size
            </summary>
        </member>
        <member name="P:BrightData.IHaveSize.Size">
            <summary>
            Number of items
            </summary>
        </member>
        <member name="T:BrightData.ICanEnumerate">
            <summary>
            Indicates that the type can enumerate items
            </summary>
        </member>
        <member name="M:BrightData.ICanEnumerate.Enumerate">
            <summary>
            Enumerates all items
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanEnumerate`1">
            <summary>
            Indicates that the type can enumerate items of this type
            </summary>
            <typeparam name="T">Type to enumerate</typeparam>
        </member>
        <member name="M:BrightData.ICanEnumerate`1.EnumerateTyped">
            <summary>
            Enumerates all items
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IIndexStrings">
            <summary>
            Indicates that the type can convert string to string indices
            </summary>
        </member>
        <member name="M:BrightData.IIndexStrings.GetIndex(System.String)">
            <summary>
            Returns the index for a string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IIndexStrings.OutputSize">
            <summary>
            Gets the total number of possible string indices
            </summary>
        </member>
        <member name="T:BrightData.IHaveIndexer">
            <summary>
            Indicates that the type has string indexer
            </summary>
        </member>
        <member name="P:BrightData.IHaveIndexer.Indexer">
            <summary>
            String indexer
            </summary>
        </member>
        <member name="T:BrightData.ICanComplete">
            <summary>
            Indicates that an operation can be completed
            </summary>
        </member>
        <member name="M:BrightData.ICanComplete.Complete">
            <summary>
            Complete the operation
            </summary>
        </member>
        <member name="T:BrightData.IHaveDictionary">
            <summary>
            Indicates that the type has a dictionary (string table)
            </summary>
        </member>
        <member name="P:BrightData.IHaveDictionary.Dictionary">
            <summary>
            Current dictionary (string table)
            </summary>
        </member>
        <member name="T:BrightData.ICanReadSection">
            <summary>
            Implemented by types that can repeatedly read the same section of a stream
            </summary>
        </member>
        <member name="M:BrightData.ICanReadSection.GetReader">
            <summary>
            Creates a new reader for the readable section of the stream
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICloneStreams">
            <summary>
            Clones streams
            </summary>
        </member>
        <member name="M:BrightData.ICloneStreams.Clone(System.Nullable{System.Int64})">
            <summary>
            Creates a new repeatable section reader
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataSpecificationType">
            <summary>
            Type of data specification
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.Field">
            <summary>
            Represents a field of data
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.Composite">
            <summary>
            Represents an item that holds a set of other items
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.FieldSet">
            <summary>
            Represents a field that takes a value from one of a set of possibilities
            </summary>
        </member>
        <member name="T:BrightData.IDataTypeSpecification">
            <summary>
            Data type specifications can validate a data source
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.Name">
            <summary>
            Name of this item
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.Children">
            <summary>
            Children of this item (optional)
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.UnderlyingType">
            <summary>
            Underlying .net type for this item
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.SpecificationType">
            <summary>
            Item type
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.CanRepeat">
            <summary>
            True if the item can repeat
            </summary>
        </member>
        <member name="T:BrightData.IDataTypeSpecification`1">
            <summary>
            Typed data specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDataTypeSpecification`1.IsValid(`0)">
            <summary>
            Checks if the typed instance is valid against the specification
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTypeSpecification`1.AddPredicate(System.Predicate{`0})">
            <summary>
            Adds an additional predicate that must match to be considered valid
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="T:BrightData.INotifyUser">
            <summary>
            Notifies the user of operations and messages
            </summary>
        </member>
        <member name="M:BrightData.INotifyUser.OnStartOperation(System.String,System.String)">
            <summary>
            Called at the start of an operation
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="msg">Optional message associated with the operation</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnOperationProgress(System.String,System.Single)">
            <summary>
            Called when the operation has progressed
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="progressPercent">Progress percentage (between 0 and 1)</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnCompleteOperation(System.String,System.Boolean)">
            <summary>
            Called when the operation has completed
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="wasCancelled">True if the operation was cancelled</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnMessage(System.String)">
            <summary>
            Called to notify the user
            </summary>
            <param name="msg">Message to user</param>
        </member>
        <member name="T:BrightData.DataTableOrientation">
            <summary>
            Determines if the data table is oriented as either rows or columns
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.Unknown">
            <summary>
            Pathological case
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.RowOriented">
            <summary>
            Data table is a series of rows, optimised for per-row processing
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.ColumnOriented">
            <summary>
            Data table is a series of columns, optimised for column based processing
            </summary>
        </member>
        <member name="T:BrightData.BrightDataType">
            <summary>
            Data types enumeration
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Unknown">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Boolean">
            <summary>
            Boolean values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.SByte">
            <summary>
            Signed byte values (-128 to 128)
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Short">
            <summary>
            Short values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Int">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Long">
            <summary>
            Long values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Float">
            <summary>
            Float values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Double">
            <summary>
            Double values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Decimal">
            <summary>
            Decimal values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.String">
            <summary>
            String values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Date">
            <summary>
            Date values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.IndexList">
            <summary>
            List of indices
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.WeightedIndexList">
            <summary>
            Weighted list of indices
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Vector">
            <summary>
            Vector of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Matrix">
            <summary>
            Matrix of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Tensor3D">
            <summary>
            3D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Tensor4D">
            <summary>
            4D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.BinaryData">
            <summary>
            Binary data
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.TimeOnly">
            <summary>
            Time only
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.DateOnly">
            <summary>
            Date only
            </summary>
        </member>
        <member name="T:BrightData.ColumnClass">
            <summary>
            Column classifications
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Unknown">
            <summary>
            Unknown category
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Categorical">
            <summary>
            Forms a category - a set of possible values
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Numeric">
            <summary>
            Numbers (float, int etc)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Decimal">
            <summary>
            Floating point numbers (float, double, decimal)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Structable">
            <summary>
            Struct (blittable)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Tensor">
            <summary>
            Tensor (vector, matrix etc)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.IndexBased">
            <summary>
            Has an index (index list, weighted index list)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.DateTime">
            <summary>
            Date and time
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Integer">
            <summary>
            Whole number
            </summary>
        </member>
        <member name="T:BrightData.ISingleTypeTableSegment">
            <summary>
            A segment (series of values) in a table of which each element has the same type
            </summary>
        </member>
        <member name="P:BrightData.ISingleTypeTableSegment.SingleType">
            <summary>
            The single type of the segment
            </summary>
        </member>
        <member name="M:BrightData.ISingleTypeTableSegment.Enumerate">
            <summary>
            Enumerate each item (casting to object)
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ISingleTypeTableSegment.Size">
            <summary>
            Number of values (size of segment)
            </summary>
        </member>
        <member name="T:BrightData.IDataTableSegment">
            <summary>
            A series of values from a data table
            </summary>
        </member>
        <member name="P:BrightData.IDataTableSegment.Size">
            <summary>
            Number of values (size of segment)
            </summary>
        </member>
        <member name="P:BrightData.IDataTableSegment.Types">
            <summary>
            The column type of each value
            </summary>
        </member>
        <member name="P:BrightData.IDataTableSegment.Item(System.UInt32)">
            <summary>
            The value at each index (cast to object)
            </summary>
            <param name="index">Index to retrieve</param>
        </member>
        <member name="T:BrightData.IDataTableSegment`1">
            <summary>
            Typed data table segment (all of the same type)
            </summary>
            <typeparam name="T">Data type of values within the segment</typeparam>
        </member>
        <member name="M:BrightData.IDataTableSegment`1.EnumerateTyped">
            <summary>
            Enumerates the values
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDataTable">
            <summary>
            A data table is an immutable collection of data with columns and rows (in which the columns have the same type of data)
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.ColumnTypes">
            <summary>
            The type of each column
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.Orientation">
            <summary>
            How the table is aligned (either row or column)
            </summary>
        </member>
        <member name="M:BrightData.IDataTable.ForEachRow(System.Action{System.Object[],System.UInt32},System.UInt32)">
            <summary>
            Invokes the callback on each row of the data table
            </summary>
            <param name="callback">Callback for each row</param>
            <param name="maxRows">Maximum number of rows to process</param>
        </member>
        <member name="M:BrightData.IDataTable.ForEachRow(System.Action{System.Object[]},System.UInt32)">
            <summary>
            Invokes the callback on each row of the data table
            </summary>
            <param name="callback">Callback for each row</param>
            <param name="maxRows">Maximum number of rows to process</param>
        </member>
        <member name="M:BrightData.IDataTable.Columns(System.UInt32[])">
            <summary>
            Enumerates the columns of the data table
            </summary>
            <param name="columnIndices">Column indices to retrieve</param>
        </member>
        <member name="M:BrightData.IDataTable.ReadTyped(System.Collections.Generic.IEnumerable{BrightData.IConsumeColumnData},System.UInt32)">
            <summary>
            Consumes data in the table via an array of consumers, which will each consume data for each row in the table
            </summary>
            <param name="consumers">Array of consumers, for each column in the table</param>
            <param name="maxRows">Maximum number of rows to process</param>
        </member>
        <member name="M:BrightData.IDataTable.Column(System.UInt32)">
            <summary>
            Returns a single column from the table
            </summary>
            <param name="columnIndex">Column index to retrieve</param>
        </member>
        <member name="M:BrightData.IDataTable.ColumnAnalysis(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns analysed metadata for the specified columns
            </summary>
            <param name="columnIndices">Column indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTable.ColumnMetaData(System.UInt32)">
            <summary>
            Returns the metadata for a single column (without analysis)
            </summary>
            <param name="columnIndex">Column index to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTable.Project(System.Func{System.Object[],System.Object[]},System.String)">
            <summary>
            Applies a projection function to each row of this data table
            </summary>
            <param name="projector">Mutates the rows of each row by changing values, types, or both</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
        </member>
        <member name="M:BrightData.IDataTable.WriteTo(System.String)">
            <summary>
            Writes the data table to disk
            </summary>
            <param name="filePath">File path</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTable.ForEachRow(System.Collections.Generic.IEnumerable{System.UInt32},System.Action{System.Object[]})">
            <summary>
            Invokes the callback on each specified row of the table
            </summary>
            <param name="rowIndices">Row indices to select</param>
            <param name="callback">Callback to invoke on each selected row</param>
        </member>
        <member name="M:BrightData.IDataTable.GroupBy(System.UInt32[])">
            <summary>
            Groups columns into groups based on the specified column values
            </summary>
            <param name="columnIndices">Column indices to group on</param>
            <returns>Groups of column buffers</returns>
        </member>
        <member name="T:BrightData.IColumnOrientedDataTable">
            <summary>
            Column oriented data table
            </summary>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.AsRowOriented(System.String)">
            <summary>
            Converts to a row oriented data table
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Transform(System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,BrightData.IConvertColumn}},System.String)">
            <summary>
            Transforms the table
            </summary>
            <param name="transformations"></param>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.CopyColumns(System.String,System.UInt32[])">
            <summary>
            Copies the selected columns to a new data table
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="columnIndices">Column indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ConcatColumns(System.String,BrightData.IColumnOrientedDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="others">Other tables to concatenate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.FilterRows(System.Predicate{System.Object[]},System.String)">
            <summary>
            Creates a new data table of the rows that match the predicate
            </summary>
            <param name="predicate">Predicate function to evaluate which rows to include in the new table</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ReinterpretColumns(System.String,BrightData.IReinterpretColumns[])">
            <summary>
            Many to one or one to many style column transformations
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="columns">Parameters to determine which columns are reinterpreted</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Clone(System.String)">
            <summary>
            Clones the current data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ColumnAnalysis(System.UInt32,System.Boolean,System.UInt32,System.UInt32)">
            <summary>
            Returns the metadata for a single column after performing analysis on the column
            </summary>
            <param name="columnIndex">Column index to retrieve</param>
            <param name="force">True to force metadata analysis</param>
            <param name="writeCount">Maximum size of sequences to write in final meta data</param>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IRowOrientedDataTable">
            <summary>
            Row oriented data table
            </summary>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.AsColumnOriented(System.String)">
            <summary>
            Converts to a column oriented data table
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Bag(System.UInt32,System.String)">
            <summary>
            Samples (with replacement) from the data table
            </summary>
            <param name="sampleCount">Number of rows to sample</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Row(System.UInt32)">
            <summary>
            Returns the row at the specified index
            </summary>
            <param name="rowIndex">Row index to retrieve</param>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Rows(System.UInt32[])">
            <summary>
            Returns the rows at the specified indices
            </summary>
            <param name="rowIndices">Row indices to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.ConcatRows(System.String,BrightData.IRowOrientedDataTable[])">
            <summary>
            Creates a new table of this concatenated with other row oriented data tables
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="others">Other row oriented data tables to concatenate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.CopyRows(System.String,System.UInt32[])">
            <summary>
            Copy specified rows from this to a new data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="rowIndices">Row indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Shuffle(System.String)">
            <summary>
            Creates a new data table from the randomly shuffled rows of this data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Sort(System.UInt32,System.Boolean,System.String)">
            <summary>
            Creates a new sorted data table
            </summary>
            <param name="columnIndex">Column index to sort</param>
            <param name="ascending">True to sort ascending</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.FirstRow">
            <summary>
            Returns the first row as a string
            </summary>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.SecondRow">
            <summary>
            Returns the second row as a string
            </summary>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.ThirdRow">
            <summary>
            Returns the third row as a string
            </summary>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.LastRow">
            <summary>
            Returns the last row as a string
            </summary>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Clone(System.String)">
            <summary>
            Clones the current data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ColumnConversionType">
            <summary>
            Single column conversion options
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.Unchanged">
            <summary>
            Leave the column unchanged (nop)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToBoolean">
            <summary>
            Convert to boolean
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToDate">
            <summary>
            Convert to date
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToNumeric">
            <summary>
            Convert to numeric (best numeric size will be automatically determined)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToString">
            <summary>
            Convert to string
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToIndexList">
            <summary>
            Convert to index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToWeightedIndexList">
            <summary>
            Convert to weighted index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToVector">
            <summary>
            Convert to vector
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToCategoricalIndex">
            <summary>
            Convert each value to an index within a dictionary
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToByte">
            <summary>
            Convert to signed byte
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToShort">
            <summary>
            Convert to short
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToInt">
            <summary>
            Convert to int
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToLong">
            <summary>
            Convert to long 
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToFloat">
            <summary>
            Convert to float
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToDouble">
            <summary>
            Convert to double
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToDecimal">
            <summary>
            Convert to decimal
            </summary>
        </member>
        <member name="T:BrightData.IConvertColumn">
            <summary>
            Transforms columns
            </summary>
        </member>
        <member name="M:BrightData.IConvertColumn.Finalise(BrightData.IMetaData)">
            <summary>
            Complete the transformation
            </summary>
            <param name="metaData">Meta data store to receive transformation information</param>
        </member>
        <member name="T:BrightData.IConvertColumn`2">
            <summary>
            Typed column transformer
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.IConvertColumn`2.Convert(`0,BrightData.IHybridBuffer{`1},System.UInt32)">
            <summary>
            Writes the converted input to the buffer
            </summary>
            <param name="input"></param>
            <param name="buffer"></param>
            <param name="index">Index within the buffer</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITransformationContext">
            <summary>
            Transforms a column
            </summary>
        </member>
        <member name="M:BrightData.ITransformationContext.Transform(System.Action{System.Single},System.Threading.CancellationToken)">
            <summary>
            Performs the transformation
            </summary>
            <param name="progressNotification">Progress notification callback</param>
            <param name="ct">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITransformationContext.Buffer">
            <summary>
            Buffer that is written to
            </summary>
        </member>
        <member name="T:BrightData.IColumnInfo">
            <summary>
            Table column information
            </summary>
        </member>
        <member name="P:BrightData.IColumnInfo.Index">
            <summary>
            Column index
            </summary>
        </member>
        <member name="P:BrightData.IColumnInfo.ColumnType">
            <summary>
            Column type
            </summary>
        </member>
        <member name="P:BrightData.IColumnInfo.Dictionary">
            <summary>
            Encoded dictionary
            </summary>
        </member>
        <member name="T:BrightData.IColumnTransformationParam">
            <summary>
            Informtion about a column transformation
            </summary>
        </member>
        <member name="P:BrightData.IColumnTransformationParam.ColumnIndex">
            <summary>
            Column index
            </summary>
        </member>
        <member name="M:BrightData.IColumnTransformationParam.GetTransformer(BrightData.BrightDataContext,BrightData.BrightDataType,BrightData.ISingleTypeTableSegment,System.Func{BrightData.IMetaData},BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Gets a column transformer
            </summary>
            <param name="fromType">Convert from column type</param>
            <param name="column">Column to convert</param>
            <param name="analysedMetaData">Function to produce analysed column meta data if needed</param>
            <param name="tempStreams">Temp stream provider</param>
            <param name="inMemoryRowCount">Number of rows to cache in memory</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IConvertibleTable">
            <summary>
            A table that is easily convertible to other types
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleTable.Row(System.UInt32)">
            <summary>
            Returns a row that can be easily converted
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IConvertibleTable.Rows(System.UInt32[])">
            <summary>
            Returns rows that can be easily converted
            </summary>
            <param name="rowIndices">Row indices to return</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IConvertibleTable.DataTable">
            <summary>
            The underlying data table
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleTable.Map``1(System.Func{BrightData.IConvertibleRow,``0})">
            <summary>
            Maps each row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rowMapper">Callback that will be invoked on each convertible row</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IConvertibleTable.ForEachRow(System.Action{BrightData.IConvertibleRow})">
            <summary>
            Invokes a callback on each convertible row
            </summary>
            <param name="action">Callback</param>
        </member>
        <member name="T:BrightData.IHaveDataTable">
            <summary>
            Indicates that the type has a data table
            </summary>
        </member>
        <member name="P:BrightData.IHaveDataTable.DataTable">
            <summary>
            Data table
            </summary>
        </member>
        <member name="T:BrightData.IConvertibleRow">
            <summary>
            A row that whose elements can be converted to other types
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleRow.Get(System.UInt32)">
            <summary>
            Gets an element
            </summary>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IConvertibleRow.Segment">
            <summary>
            Returns the row segment
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleRow.GetTyped``1(System.UInt32)">
            <summary>
            Returns a value (dynamic conversion to type T)
            </summary>
            <typeparam name="T">Type to convert to</typeparam>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IConvertibleRow.RowIndex">
            <summary>
            Row index
            </summary>
        </member>
        <member name="T:BrightData.IConsumeColumnData">
            <summary>
            Interface that 
            </summary>
        </member>
        <member name="P:BrightData.IConsumeColumnData.ColumnIndex">
            <summary>
            Column index that will be consumed
            </summary>
        </member>
        <member name="P:BrightData.IConsumeColumnData.ColumnType">
            <summary>
            Column type of incoming data
            </summary>
        </member>
        <member name="T:BrightData.IConsumeColumnData`1">
            <summary>
            Typed column consumer that writes to a buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.IDataTableVectoriser">
            <summary>
            Data table vectoriser
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(System.Object[])">
            <summary>
            Vectorise a table row
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(BrightData.IDataTableSegment)">
            <summary>
            Vectorise a data table segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IDataTableVectoriser.OutputSize">
            <summary>
            Size of the output vectors
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.GetOutputLabel(System.UInt32,System.UInt32)">
            <summary>
            Returns the associated label from the one hot encoding dictionary
            </summary>
            <param name="vectorIndex">Index within one hot encoded vector</param>
            <param name="columnIndex">Data table column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Enumerate">
            <summary>
            Returns a sequence of vectorised table rows
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IReinterpretColumns">
            <summary>
            Reinterpret columns parameters
            </summary>
        </member>
        <member name="P:BrightData.IReinterpretColumns.SourceColumnIndices">
            <summary>
            Source column indices
            </summary>
        </member>
        <member name="P:BrightData.IReinterpretColumns.OutputColumnIndices">
            <summary>
            Source column indices
            </summary>
        </member>
        <member name="M:BrightData.IReinterpretColumns.GetNewColumnOperations(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,BrightData.ICanEnumerateDisposable[])">
            <summary>
            Gets new column operations
            </summary>
            <param name="context">Bright data context</param>
            <param name="tempStreams">Temp stream provider</param>
            <param name="columns">Source column data</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.DistanceMetric">
            <summary>
            Distance metrics
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Euclidean">
            <summary>
            Euclidean Distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Cosine">
            <summary>
            Cosine Distance Metric
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Manhattan">
            <summary>
            Manhattan Distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.MeanSquared">
            <summary>
            Means Square Error
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.SquaredEuclidean">
            <summary>
            Square Euclidean
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedLinearAlgebraProvider.CreateSegment(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.MetaData">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.#ctor(BrightData.IMetaData,System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="metaData">Existing meta data to copy from</param>
            <param name="keys">Keys to copy (or all if none specified)</param>
        </member>
        <member name="M:BrightData.MetaData.#ctor(BrightData.IHaveMetaData,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.#ctor(System.IO.BinaryReader)">
            <summary>
            Creates meta data from a binary reader
            </summary>
            <param name="reader">Reader</param>
        </member>
        <member name="M:BrightData.MetaData.CopyTo(BrightData.IMetaData)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.CopyTo(BrightData.IMetaData,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.CopyAllExcept(BrightData.IMetaData,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Get(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.GetNullable``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Get``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Get``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Set``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.MetaData.AsXml">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.ReadFrom(System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.GetStringsWithPrefix(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Has(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.MetaData.AllKeys">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Clone">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Serialisation.SerialisationHelper">
            <summary>
            Serialisation helpers
            </summary>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.String,System.IO.BinaryWriter)">
            <summary>
            Writes the string
            </summary>
            <param name="str"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Int32,System.IO.BinaryWriter)">
            <summary>
            Writes the integer
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.UInt32,System.IO.BinaryWriter)">
            <summary>
            Writes the uint
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Double,System.IO.BinaryWriter)">
            <summary>
            Writes the double
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Single,System.IO.BinaryWriter)">
            <summary>
            Writes the float
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo``1(System.Nullable{``0},System.IO.BinaryWriter,System.Action{``0})">
            <summary>
            Conditionally writes a nullable value
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
            <param name="onWrite"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadNullable``1(System.IO.BinaryReader,System.Func{``0})">
            <summary>
            Conditionally reads a nullable value
            </summary>
            <param name="reader"></param>
            <param name="onRead"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Collections.Generic.IReadOnlyCollection{BrightData.ICanWriteToBinaryWriter},System.IO.BinaryWriter)">
            <summary>
            Writes the collection of items
            </summary>
            <param name="list"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo``1(``0[],System.IO.BinaryWriter)">
            <summary>
            Writes the array
            </summary>
            <param name="array"></param>
            <param name="writer"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.String[],System.IO.BinaryWriter)">
            <summary>
            Writes the array of strings
            </summary>
            <param name="array"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.Create``1(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a new object after reading its serialized data from the reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadArray``1(System.IO.BinaryReader,BrightData.BrightDataContext)">
            <summary>
            Reads an array from the reader
            </summary>
            <param name="reader"></param>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadStructArray``1(System.IO.BinaryReader)">
            <summary>
            Reads an array of structs from the reader
            </summary>
            <param name="reader"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadStringArray(System.IO.BinaryReader)">
            <summary>
            Reads an array of strings from the reader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Transformation.ColumnConversion">
            <summary>
            Parameters that define a column conversion from one type to another
            </summary>
        </member>
        <member name="P:BrightData.Transformation.ColumnConversion.ColumnIndex">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Transformation.ColumnConversion.GetTransformer(BrightData.BrightDataContext,BrightData.BrightDataType,BrightData.ISingleTypeTableSegment,System.Func{BrightData.IMetaData},BrightData.IProvideTempStreams,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Transformation.ColumnNormalization">
            <summary>
            Parameters that define how to normalize a column of a data table
            </summary>
        </member>
        <member name="T:BrightData.Transformation.ManyToOneColumn">
            <summary>
            Parameters that define how to reinterpret the columns in a data table
            </summary>
        </member>
        <member name="T:BrightData.Transformation.NormalizeTransformation">
            <summary>
            Normalization parameters
            </summary>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.#ctor(BrightData.NormalizationType,BrightData.IMetaData)">
            <summary>
            Creates a new set of parameters based on supplied the numeric analysis
            </summary>
            <param name="type">Type of normalization</param>
            <param name="analysedMetaData">Numeric analysis</param>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.WriteTo(BrightData.IMetaData)">
            <summary>
            Writes the normalization parameters to a meta data store
            </summary>
            <param name="metaData"></param>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.NormalizationType">
            <summary>
            Type of normalization
            </summary>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.Divide">
            <summary>
            Value that will be divided (after subtraction)
            </summary>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.Subtract">
            <summary>
            Value that will be subtracted
            </summary>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.Normalize(System.Double)">
            <summary>
            Normalizes a value with the parameters
            </summary>
            <param name="val">Value to normalize</param>
            <returns>Normalized result</returns>
        </member>
        <member name="T:BrightData.Transformation.TransformationContext`2">
            <summary>
            A transformation context reads values from a column and writes transformed values to a buffer
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="T:BrightData.WeightedIndexList">
            <summary>
            A list of weighted indices is a sparse vector
            </summary>
        </member>
        <member name="T:BrightData.WeightedIndexList.Item">
            <summary>
            An item within a weighted index list
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Item.Index">
            <summary>
            Index of item
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Item.Weight">
            <summary>
            Weight of item
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.#ctor(System.UInt32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index of item</param>
            <param name="weight">Weight of item</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.Equals(BrightData.WeightedIndexList.Item)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.op_Equality(BrightData.WeightedIndexList.Item,BrightData.WeightedIndexList.Item)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.op_Inequality(BrightData.WeightedIndexList.Item,BrightData.WeightedIndexList.Item)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.WeightedIndexList.Indices">
            <summary>
            The list of indices
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.WeightedIndexList},BrightData.AggregationType)">
            <summary>
            Merges a sequence of weighted index lists into one list
            </summary>
            <param name="lists">Lists to merge</param>
            <param name="mergeOperation">How to merge item weights</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.WeightedIndexList.ToXml">
            <summary>
            Converts the weighted index list to XML
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsIndexList">
            <summary>
            Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Dot(BrightData.WeightedIndexList)">
            <summary>
            Dot product of this combined with the other weighted index list
            </summary>
            <param name="other">Other weighted index list</param>
        </member>
        <member name="P:BrightData.WeightedIndexList.Magnitude">
            <summary>
            Magnitude of weights
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.CosineSimilarity(BrightData.WeightedIndexList)">
            <summary>
            Cosine similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.GetMaxWeight">
            <summary>
            Returns the index with the highest weight
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.JaccardSimilarity(BrightData.WeightedIndexList)">
            <summary>
            Computes the jaccard similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsDense(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.UInt32})">
            <summary>
            Converts to a vector
            </summary>
            <param name="maxIndex">Inclusive highest index to copy (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Unique(BrightData.AggregationType)">
            <summary>
            Returns a new weighted index list with unique indices - duplicate values are treated according to the specified aggregation type
            </summary>
            <returns>New weighted index list with unique indices</returns>
        </member>
        <member name="P:BrightData.WeightedIndexList.Weights">
            <summary>
            All weights
            </summary>
        </member>
    </members>
</doc>
