<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BrightData</name>
    </assembly>
    <members>
        <member name="T:BrightData.Analysis.Readers.DateAnalysis">
            <summary>
            Date analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MinDate">
            <summary>
            Minimum date (null if none)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MaxDate">
            <summary>
            Maximum date (null if none)
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.DictionaryValues">
            <summary>
            Dictionary that holds category string indices
            </summary>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValues(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Converts from category indices to string
            </summary>
            <param name="categoryIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValue(System.Int32)">
            <summary>
            Gets the string associated with a category index
            </summary>
            <param name="categoryIndex"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Analysis.Readers.DimensionAnalysis">
            <summary>
            Dimension analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.XDimension">
            <summary>
            Max size of the x dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.YDimension">
            <summary>
            Max size of the y dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.ZDimension">
            <summary>
            Max size of the z dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.NumDistinct">
            <summary>
            Number of distinct size combinations
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.Size">
            <summary>
            Total size across all dimensions
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.FrequencyAnalysis">
            <summary>
            Frequency analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Total">
            <summary>
            Total number of items observed
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.MostFrequent">
            <summary>
            Most frequent item
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.IndexAnalysis">
            <summary>
            Index analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MinIndex">
            <summary>
            Lowest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MaxIndex">
            <summary>
            Highest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.NumericAnalysis">
            <summary>
            Numeric analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L1Norm">
            <summary>
            L1 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L2Norm">
            <summary>
            L2 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Min">
            <summary>
            Minimum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Max">
            <summary>
            Maximum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mean">
            <summary>
            Mean of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleVariance">
            <summary>
            Sample variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleStdDev">
            <summary>
            Sample standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationVariance">
            <summary>
            Population variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationStdDev">
            <summary>
            Population standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Median">
            <summary>
            Median value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mode">
            <summary>
            Mode (most frequent value)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.NumDistinct">
            <summary>
            Number of distinct values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Total">
            <summary>
            Total count of items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.FrequencyRange">
            <summary>
            Bucketed histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.StringAnalysis">
            <summary>
            String analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MinLength">
            <summary>
            Length of smallest observed string
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MaxLength">
            <summary>
            Length of largest observed string
            </summary>
        </member>
        <member name="T:BrightData.Analysis.StaticAnalysers">
            <summary>
            Static methods to create analyzers
            </summary>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDateAnalyser(System.UInt32)">
            <summary>
            Creates a date analyzer
            </summary>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <param name="writeCount">Number of items to write in histogram</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateConvertToStringAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that will convert each item to a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDimensionAnalyser(System.UInt32)">
            <summary>
            Creates a dimension analyzer (to analyze the shape of tensors)
            </summary>
            <param name="maxCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed frequency of items
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateIndexAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed indices (for index lists and weighted index lists)
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateStringAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser(System.Type,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer (each item will be converted to a string)
            </summary>
            <param name="type"></param>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.BinaryData">
            <summary>
            Blob of binary data
            </summary>
        </member>
        <member name="M:BrightData.BinaryData.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Binary data blob</param>
        </member>
        <member name="M:BrightData.BinaryData.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Constructor
            </summary>
            <param name="data">Binary data blob</param>
        </member>
        <member name="P:BrightData.BinaryData.Data">
            <summary>
            Returns the data as a span
            </summary>
        </member>
        <member name="M:BrightData.BinaryData.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.Equals(BrightData.BinaryData)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.op_Equality(BrightData.BinaryData,BrightData.BinaryData)">
            <summary>
            Binary data equality
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BinaryData.op_Inequality(BrightData.BinaryData,BrightData.BinaryData)">
            <summary>
            Binary data non equality
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.BrightDataContext">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="lap">Linear algebra provider to use (optional)</param>
            <param name="randomSeed">Initial value of random seed (or null to randomly initialize)</param>
        </member>
        <member name="M:BrightData.BrightDataContext.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.Random">
            <summary>
            Default random number generator
            </summary>
        </member>
        <member name="P:BrightData.BrightDataContext.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.CreateTempStreamProvider">
            <summary>
            Creates a new temp stream provider
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,``0)">
            <summary>
            Returns a typed property from the context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="defaultValue">Value to return if the property was not set</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,System.Func{``0})">
            <summary>
            Returns a typed property from the context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="defaultValueCreator">Callback to return a value if the property was not set</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String)">
            <summary>
            Returns a typed property from the context (or null if the property was not set)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.TryGet``1(System.String,``0@)">
            <summary>
            Tries to get a typed property from the context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="ret">The property value (if set)</param>
            <returns>True if the property was set</returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Set``1(System.String,``0)">
            <summary>
            Sets a typed property in this context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="value">Property value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Clear(System.String)">
            <summary>
            Removes a typed property from the context
            </summary>
            <param name="name">Property name</param>
        </member>
        <member name="P:BrightData.BrightDataContext.IsStochastic">
            <summary>
            True if the context does not use a predefined random seed
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.ResetRandom(System.Nullable{System.Int32})">
            <summary>
            Resets the random seed
            </summary>
            <param name="seed"></param>
        </member>
        <member name="P:BrightData.BrightDataContext.UserNotifications">
            <summary>
            Optional interface to provide user notification of long running operations
            </summary>
        </member>
        <member name="T:BrightData.Buffer.Composite.CompositeBufferBase`1">
            <summary>
            Composite buffers write to disk after their in memory cache is exhausted
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Buffer.Composite.CompositeBufferSegment`1">
            <summary>
            A single type data table segment that can grow in size
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Buffer.Composite.CompositeBufferSegment`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.Composite.CompositeBufferSegment`1.MetaData">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.Composite.CompositeBufferSegment`1.SegmentType">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.Composite.CompositeBufferSegment`1.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.Composite.CompositeBufferSegment`1.CopyTo(System.IO.Stream)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.EncodedStream.EncodedStreamReader">
            <summary>
            Reads from potentially encoded storage
            </summary>
        </member>
        <member name="T:BrightData.Buffer.EncodedStream.EncodedStreamWriter">
            <summary>
            Writes composite buffers to binary writers, potentially encoding along the way
            </summary>
        </member>
        <member name="M:BrightData.Buffer.EncodedStream.EncodedStreamWriter.CopyTo``1(BrightData.ICompositeBuffer{``0},System.IO.Stream)">
            <summary>
            Writes the composite buffer to a stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="buffer">Buffer to write</param>
            <param name="stream">Stream to write to</param>
        </member>
        <member name="M:BrightData.Buffer.EncodedStream.EncodedStreamWriter.GetWriter``1(BrightData.ICanEnumerateWithSize{``0},System.Boolean)">
            <summary>
            Returns an writer that can write the buffer to a binary writer
            </summary>
            <param name="buffer">Buffer to write</param>
            <param name="shouldEncode">If the values should be encoded</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Buffer.InMemory.InMemorySegment`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.InMemory.InMemorySegment`1.MetaData">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.InMemory.InMemorySegment`1.SegmentType">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.InMemory.InMemorySegment`1.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.ReadOnly.EmptyBlock`1">
            <summary>
            Represents an empty block of memory
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.EmptyBlock`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.ReadOnly.EmptyBlock`1.Size">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.EmptyBlock`1.Get(System.Int32,`0@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.EmptyBlock`1.Get(System.UInt32,`0@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.EmptyBlock`1.GetSpan(System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.ReadOnly.ReadOnlyFileBasedBuffer">
            <summary>
            A read only buffer from a file or memory mapped file
            </summary>
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyFileBasedBuffer.#ctor(System.IO.FileStream)">
            <summary>
            Creates from a file
            </summary>
            <param name="file">File to access</param>
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyFileBasedBuffer.#ctor(System.IO.MemoryMappedFiles.MemoryMappedFile)">
            <summary>
            Creates from a memory mapped file
            </summary>
            <param name="file">Memory mapped file to access</param>
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyFileBasedBuffer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyFileBasedBuffer.GetIterator``1(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyFileBasedBuffer.GetBlock``1(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.ReadOnly.ReadOnlyMemoryBasedBuffer">
            <summary>
            Read only buffer from memory block
            </summary>
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyMemoryBasedBuffer.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Creates from a memory buffer
            </summary>
            <param name="memory"></param>
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyMemoryBasedBuffer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyMemoryBasedBuffer.GetIterator``1(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.ReadOnly.ReadOnlyMemoryBasedBuffer.GetBlock``1(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.CompositeBuffersExtensionMethods">
            <summary>
            Static methods to create composite buffers
            </summary>
        </member>
        <member name="M:BrightData.CompositeBuffersExtensionMethods.CreateCompositeStructBuffer``1(BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store structs
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tempStream"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.CompositeBuffersExtensionMethods.CreateCompositeStructBuffer(BrightData.IProvideTempStreams,System.Type,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store structs
            </summary>
            <param name="tempStream"></param>
            <param name="type"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.CompositeBuffersExtensionMethods.CreateCompositeStringBuffer(BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store strings
            </summary>
            <param name="tempStream"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.CompositeBuffersExtensionMethods.CreateCompositeObjectBuffer``1(BrightData.IProvideTempStreams,BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Creates a buffer to store objects
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tempStream"></param>
            <param name="context"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.CompositeBuffersExtensionMethods.CreateCompositeObjectBuffer(BrightData.IProvideTempStreams,BrightData.BrightDataContext,System.Type,System.UInt32)">
            <summary>
            Creates a buffer to store objects
            </summary>
            <param name="tempStream"></param>
            <param name="context"></param>
            <param name="type"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Consts">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxDistinct">
            <summary>
            Default max distinct count
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxWriteCount">
            <summary>
            Default max write count
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultPreviewSize">
            <summary>
            Default number of items to preview
            </summary>
        </member>
        <member name="F:BrightData.Consts.MinimumSizeForParallel">
            <summary>
            Minimum size to use parallel processing
            </summary>
        </member>
        <member name="F:BrightData.Consts.MinimumSizeForVectorised">
            <summary>
            Minimum size to use SIMD processing
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultInMemoryBufferSize">
            <summary>
            Default in memory buffer size
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultMaxDistinctCount">
            <summary>
            Default max number of distinct items
            </summary>
        </member>
        <member name="F:BrightData.Consts.StandardMetaData">
            <summary>
            Standard metadata
            </summary>
        </member>
        <member name="T:BrightData.Converter.StaticConverters">
            <summary>
            Static methods to create converters
            </summary>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToDecimal``1">
            <summary>
            Creates a converter to decimals
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToDouble``1">
            <summary>
            Creates a converter to doubles
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToFloat``1">
            <summary>
            Creates a converter to floats
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToInt``1">
            <summary>
            Creates a converter to integers
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToLong``1">
            <summary>
            Creates a converter to longs (Int64)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToShort``1">
            <summary>
            Creates a converter to shorts (Int16)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToSignedByte``1">
            <summary>
            Creates a convert to signed bytes
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverter``2">
            <summary>
            Creates a converter from FT to TT
            </summary>
            <typeparam name="TF">Type to convert from</typeparam>
            <typeparam name="TT">Type to convert to</typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTable.BrightDataTable">
            <summary>
            Data table
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.ColumnTypes">
            <summary>
            Column data types
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.ColumnMetaData">
            <summary>
            Column meta data
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetColumnMetaData(System.UInt32)">
            <summary>
            Gets the meta data for a column
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.ColumnIndices">
            <summary>
            Enumerates the column indices
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.AllOrSpecifiedColumnIndices(System.UInt32[])">
            <summary>
            Enumerates specified column indices (or all if none specified)
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ReadColumn(System.UInt32)">
            <summary>
            Creates a column value enumerator
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ReadColumn``1(System.UInt32)">
            <summary>
            Returns a type column value enumerator
            </summary>
            <typeparam name="T"></typeparam>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetAllColumns">
            <summary>
            Gets all columns as typed segments
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns specified columns as type segments
            </summary>
            <param name="columnIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetColumn(System.UInt32)">
            <summary>
            Returns a column as a typed segment
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetColumn``1(System.UInt32)">
            <summary>
            Returns a column as a strongly typed segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.#ctor(BrightData.BrightDataContext,System.IO.Stream,System.UInt32)">
            <summary>
            Creates a data table from a stream
            </summary>
            <param name="context">Bright data context</param>
            <param name="stream">Stream with table data</param>
            <param name="bufferSize">In memory buffer size</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.Context">
            <inheritdoc />
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.TableMetaData">
            <summary>
            Table level meta data
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.Orientation">
            <summary>
            Data table orientation
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.DefaultColumnReaders">
            <summary>
            Column readers
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.StringTable">
            <summary>
            String table section
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.BinaryDataBlock">
            <summary>
            Binary data section
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.TensorDataBlock">
            <summary>
            Tensor data section
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.IndexDataBlock">
            <summary>
            Indices data section
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.WeightedIndexBlock">
            <summary>
            Weighted indices data section
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetRawColumnData``1(System.UInt32)">
            <summary>
            Gets a typed reader for a column
            </summary>
            <typeparam name="CT"></typeparam>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetColumnAnalysis(System.UInt32,System.Boolean,System.UInt32,System.UInt32)">
            <summary>
            Analyses column data
            </summary>
            <param name="columnIndex">Column index to analyse</param>
            <param name="force">True to reanalyse data</param>
            <param name="writeCount">Maximum size of meta data output</param>
            <param name="maxDistinctCount">Maximum number of distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetColumnAnalysis(System.Collections.Generic.IEnumerable{System.UInt32},System.UInt32,System.UInt32)">
            <summary>
            Gets column analysis for columns
            </summary>
            <param name="columnIndices">Column indices to analyse</param>
            <param name="writeCount">Maximum size of meta data output</param>
            <param name="maxDistinctCount">Maximum number of distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.AllColumnAnalysis(System.UInt32,System.UInt32)">
            <summary>
            Analysis for all columns
            </summary>
            <param name="writeCount">Maximum size of meta data output</param>
            <param name="maxDistinctCount">Maximum number of distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.PersistMetaData">
            <summary>
            Saves current meta data into the underlying stream
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.CopyToColumnConsumers(System.Collections.Generic.IEnumerable{BrightData.IConsumeColumnData},System.UInt32)">
            <summary>
            Creates column write operations to multiple consumers
            </summary>
            <param name="consumers">Column data consumers</param>
            <param name="maxRows">Maximum number of rows to write</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.FirstRow">
            <summary>
            Returns the first row as a string
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.SecondRow">
            <summary>
            Returns the second row as a string
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.ThirdRow">
            <summary>
            Returns the third row as a string
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.LastRow">
            <summary>
            Returns the last row as a string
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.CreateColumnAnalyser(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a column analyzer
            </summary>
            <param name="columnIndex">Column index</param>
            <param name="writeCount">Number of items to write in metadata</param>
            <param name="maxDistinctCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GroupBy(BrightData.IProvideTempStreams,System.UInt32[])">
            <summary>
            Groups rows into buffers by the string values of specified column indices
            </summary>
            <param name="tempStreams">Temp stream provider</param>
            <param name="groupByColumnIndices">Column indices on which to form the groups</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ConvertColumns(BrightData.IProvideTempStreams,System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,BrightData.IConvertColumn}})">
            <summary>
            Table operation that converts table columns (column count remains the same)
            </summary>
            <param name="temp">Temp stream provider</param>
            <param name="converters">Column converters</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ReinterpretColumns(BrightData.IProvideTempStreams,System.Collections.Generic.IEnumerable{BrightData.IReinterpretColumns})">
            <summary>
            Table operation that combines or expands columns (column count changes)
            </summary>
            <param name="temp"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.Project(System.Func{System.Object[],System.Object[]})">
            <summary>
            Builds a new table from rows via a projection function
            </summary>
            <param name="projector">Function that takes a row and returns a new row (returning null will skip this row from the new table)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.BagToStream(System.UInt32,System.IO.Stream)">
            <summary>
            Bags the table rows into a new stream backed data table
            </summary>
            <param name="sampleCount"></param>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ShuffleToStream(System.IO.Stream)">
            <summary>
            Shuffles the table rows into a new stream backed data table
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.WriteTo(System.String)">
            <summary>
            Writes table to a file
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.WriteColumnsTo(System.IO.Stream,System.UInt32[])">
            <summary>
            Writes specified columns to a stream
            </summary>
            <param name="stream">Output stream</param>
            <param name="columnIndices">Column indices to write (or all columns if none specified)</param>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.WriteColumnsTo(System.IO.Stream,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Writes specified columns to a stream
            </summary>
            <param name="stream">Output stream</param>
            <param name="columnIndices">Specified column indices</param>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ConcatenateColumns(System.IO.Stream,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Horizontally concatenates this data table with other data tables into a stream
            (Row counts must agree)
            </summary>
            <param name="stream">Output stream</param>
            <param name="tables">Other tables to concatenate </param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.ConcatenateRows(System.IO.Stream,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Vertically concatenates this data table with other data tables into a stream
            (Columns must be the same)
            </summary>
            <param name="stream">Output stream</param>
            <param name="tables">Other tables to concatenate</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.WriteRowsTo(System.IO.Stream,System.UInt32[])">
            <summary>
            Writes a subset of rows to a stream
            </summary>
            <param name="stream">Output stream</param>
            <param name="rowIndices">Row indices to write (or all if none specified)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.WriteRowsTo(System.IO.Stream,System.Predicate{BrightData.DataTable.BrightDataTableRow},System.UInt32[])">
            <summary>
            Writes rows that satisfy a predicate to a stream
            </summary>
            <param name="stream">Output stream</param>
            <param name="predicate">Row filter</param>
            <param name="rowIndices">Row indices to write (or all if none specified)</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.AllRowIndices">
            <summary>
            Enumerates row indices
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.AllOrSpecifiedRowIndices(System.UInt32[])">
            <summary>
            Enumerates specified row indices (or all if none specified)
            </summary>
            <param name="indices">Row indices (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.Get``1(System.UInt32,System.UInt32)">
            <summary>
            Returns a typed value from the table
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rowIndex">Row index</param>
            <param name="columnIndex">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetAllRowData(System.Boolean,System.UInt32[])">
            <summary>
            Enumerates the data from specified rows
            </summary>
            <param name="reuseArrayForEachIteration">True to reuse the same array for each iteration (allocates less memory)</param>
            <param name="rowIndices">Row indices to enumerate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetRow(System.UInt32)">
            <summary>
            Returns a row
            </summary>
            <param name="rowIndex">Row index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Enumerates specified rows
            </summary>
            <param name="rowIndices">Row indices to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetRows(System.UInt32[])">
            <summary>
            Enumerates all or specified row indices
            </summary>
            <param name="rowIndices">Row indices (optional)</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTable.AllRows">
            <summary>
            Enumerates all rows
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTable.GetSlice(System.UInt32,System.UInt32)">
            <summary>
            Enumerates a range of row indices
            </summary>
            <param name="offset">First inclusive row index</param>
            <param name="count">Number of rows to enumerate</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTable.BrightDataTableBuilder">
            <summary>
            Builds data tables
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.#ctor(BrightData.BrightDataContext,System.UInt32,System.UInt16)">
            <summary>
            Creates a data table builder
            </summary>
            <param name="context">Bright data context</param>
            <param name="inMemoryBufferSize">Size of in memory buffers</param>
            <param name="maxUniqueItemCount">Maximum number of unique items for dictionary based columns</param>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableBuilder.TableMetaData">
            <summary>
            Table level meta data
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableBuilder.Context">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddColumn(BrightData.BrightDataType,System.String)">
            <summary>
            Adds a new column
            </summary>
            <param name="type">New column type</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddColumn(BrightData.BrightDataType,BrightData.MetaData)">
            <summary>
            Adds a new column
            </summary>
            <param name="type">New column type</param>
            <param name="metaData">Column meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.CopyColumnsFrom(BrightData.DataTable.BrightDataTable,System.UInt32[])">
            <summary>
            Copies existing column definitions from another table
            </summary>
            <param name="table">Other table</param>
            <param name="columnIndices">Indices of column definitions to copy</param>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddColumn``1(System.String)">
            <summary>
            Adds a new column
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddRow(System.Object[])">
            <summary>
            Adds a row to the table
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.WriteTo(System.IO.Stream)">
            <summary>
            Writes the data table to a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddFixedSizeVectorColumn(System.UInt32,System.String)">
            <summary>
            Adds a fixed size vector column
            </summary>
            <param name="size">Size of the vector</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddFixedSizeMatrixColumn(System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a fixed size matrix column
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddFixedSize3DTensorColumn(System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a fixed size 3D tensor column 
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableBuilder.AddFixedSize4DTensorColumn(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a fixed size 4D tensor column
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTable.BrightDataTableRow">
            <summary>
            A row in data table
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableRow.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.Item(System.Int32)">
            <summary>
            Returns a value from the row
            </summary>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.Item(System.UInt32)">
            <summary>
            Returns a value from the row
            </summary>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.Types">
            <summary>
            Data types of the row
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.Size">
            <summary>
            Number of values within the row
            </summary>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.Data">
            <summary>
            Enumerates row values
            </summary>
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableRow.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.BrightDataTableRow.Get``1(System.UInt32)">
            <summary>
            Returns a value (converted to type T)
            </summary>
            <typeparam name="T">Type to convert to</typeparam>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.DataTable.BrightDataTableRow.RowIndex">
            <summary>
            Row index
            </summary>
        </member>
        <member name="T:BrightData.DataTable.DataRangeColumnType">
            <summary>
            Column type that references a range of other values
            </summary>
        </member>
        <member name="P:BrightData.DataTable.DataRangeColumnType.StartIndex">
            <summary>
            First inclusive index
            </summary>
        </member>
        <member name="P:BrightData.DataTable.DataRangeColumnType.Count">
            <summary>
            Number of items
            </summary>
        </member>
        <member name="T:BrightData.DataTable.MatrixColumnType">
            <summary>
            Column type that references a range of matrices
            </summary>
        </member>
        <member name="P:BrightData.DataTable.MatrixColumnType.StartIndex">
            <summary>
            First inclusive index
            </summary>
        </member>
        <member name="P:BrightData.DataTable.MatrixColumnType.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.DataTable.MatrixColumnType.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.DataTable.MatrixColumnType.Size">
            <summary>
            Total number of values
            </summary>
        </member>
        <member name="T:BrightData.DataTable.Tensor3DColumnType">
            <summary>
            Column type that references a range of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor3DColumnType.StartIndex">
            <summary>
            First inclusive index
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor3DColumnType.Depth">
            <summary>
            Number of matrices
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor3DColumnType.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor3DColumnType.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor3DColumnType.Size">
            <summary>
            Total number of values
            </summary>
        </member>
        <member name="T:BrightData.DataTable.Tensor4DColumnType">
            <summary>
            Column type that references a range of 4D tensors
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor4DColumnType.StartIndex">
            <summary>
            First inclusive index
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor4DColumnType.Count">
            <summary>
            Number of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor4DColumnType.Depth">
            <summary>
            Number of matrices
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor4DColumnType.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor4DColumnType.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Tensor4DColumnType.Size">
            <summary>
            Total number of values
            </summary>
        </member>
        <member name="T:BrightData.DataTable.ColumnTypeHelper">
            <summary>
            Column type helpers
            </summary>
        </member>
        <member name="M:BrightData.DataTable.ColumnTypeHelper.GetColumnType(BrightData.BrightDataType)">
            <summary>
            Returns the .net type and its size to represent a bright data type within a column
            </summary>
            <param name="dataType">Bright data type</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:BrightData.DataTable.SequentialColumnReader`2">
            <summary>
            Reads a series of objects from a sequence of structs
            </summary>
            <typeparam name="CT">Column type (unmanaged)</typeparam>
            <typeparam name="T">Object type (not null)</typeparam>
        </member>
        <member name="M:BrightData.DataTable.SequentialColumnReader`2.#ctor(BrightData.IReadOnlyUnmanagedEnumerator{`0},BrightData.IConvertStructsToObjects{`0,`1},System.IDisposable)">
            <summary>
            Constructor
            </summary>
            <param name="enumerator">Column data</param>
            <param name="converter">Struct to object converter</param>
            <param name="stream">Disposable to call at end</param>
        </member>
        <member name="P:BrightData.DataTable.SequentialColumnReader`2.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.SequentialColumnReader`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:BrightData.DataTable.SequentialColumnReader`2.Dispose">
            <inheritdoc />
        </member>
        <member name="T:BrightData.ExtensionMethods">
            <summary>
            Extension methods to attach analyser creation to the bright data context
            </summary>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalyser(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Creates a date analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalyser``1(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetConvertToStringAnalyser``1(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalyser(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Creates a dimension analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalyser``1(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalyser(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates an index analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalyser(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalyser(BrightData.BrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalyser(BrightData.BrightDataContext,System.Type,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <param name="_"></param>
            <param name="type"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalysis(BrightData.MetaData)">
            <summary>
            Gets the date analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalysis(BrightData.MetaData)">
            <summary>
            Gets the dimension analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalysis(BrightData.MetaData)">
            <summary>
            Gets the frequency analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalysis(BrightData.MetaData)">
            <summary>
            Gets the index analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalysis(BrightData.MetaData)">
            <summary>
            Gets the numeric analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalysis(BrightData.MetaData)">
            <summary>
            Gets the string analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDictionaryValues(BrightData.MetaData)">
            <summary>
            Gets the categories that were stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNormalization(BrightData.MetaData)">
            <summary>
            
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes numbers in a sequence
            </summary>
            <param name="data"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Analyzes dates in a sequence
            </summary>
            <param name="dates"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.ITensor})">
            <summary>
            Analyzes tensors in a sequence
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.IHaveIndices})">
            <summary>
            Analyzes indices in a sequence
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Analyzes a sequence of strings
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AnalyzeFrequency``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes the frequency of items
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCompositeStructBuffer``1(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a struct buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCompositeStructBuffer(BrightData.BrightDataContext,System.Type,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a struct buffer
            </summary>
            <param name="_"></param>
            <param name="type">Type of structs</param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCompositeStringBuffer(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a string buffer
            </summary>
            <param name="_"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCompositeObjectBuffer``1(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Creates an object buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCompositeObjectBuffer(BrightData.BrightDataContext,System.Type,BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Creates an object buffer
            </summary>
            <param name="context"></param>
            <param name="type">Type of objects</param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetBufferReader``1(BrightData.BrightDataContext,System.IO.BinaryReader,System.UInt32)">
            <summary>
            Returns a reader that buffers items in memory
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context">Bright data context</param>
            <param name="reader">Binary reader</param>
            <param name="inMemorySize">Number of bytes to use as an in memory buffer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyFrom(BrightData.ICompositeBuffer{System.Single},BrightData.ITensorSegment)">
            <summary>
            Copies all values from a tensor segment into a float buffer
            </summary>
            <param name="buffer"></param>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyFrom(BrightData.ICompositeBuffer{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>
            Copies all values from a span into a float buffer
            </summary>
            <param name="buffer"></param>
            <param name="span"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetSegmentWithCompositeBuffer``1(BrightData.BrightDataContext,BrightData.MetaData,BrightData.ICompositeBuffer{``0})">
            <summary>
            Creates a mutable typed segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context">Bright data context</param>
            <param name="metaData">Segment meta data</param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToType(System.TypeCode)">
            <summary>
            Converts a type code to a type
            </summary>
            <param name="code">Type code</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.MetaData,System.String,System.Nullable{``0})">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <typeparam name="T"></typeparam>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.MetaData,System.String,``0)">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.HasConversionOperator(System.Type,System.Type)">
            <summary>
            Checks if one type can be implicitly cast to another
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Randomly shuffles the items in the sequence
            </summary>
            <param name="seq"></param>
            <param name="rnd">Random number generator to use</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split``1(``0[],System.Double)">
            <summary>
            Randomly splits the sequence into a two arrays (either "training" or "test")
            </summary>
            <param name="seq"></param>
            <param name="trainPercentage">Percentage of items to add to the training array</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bag``1(``0[],System.UInt32,System.Random)">
            <summary>
            Sample with replacement
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">Number of samples</param>
            <param name="rnd">Random number generator to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetName(BrightData.MetaData)">
            <summary>
            Item name
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnIndex(BrightData.MetaData)">
            <summary>
            Item index
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.MetaData)">
            <summary>
            True if the item is numeric
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTarget(BrightData.MetaData)">
            <summary>
            True if the item is a target
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsCategorical(BrightData.MetaData)">
            <summary>
            True if the item is categorical
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsSequential(BrightData.MetaData)">
            <summary>
            True if the item is sequential
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMetaData(BrightData.IWriteToMetaData)">
            <summary>
            Writes available meta data to a new meta data store
            </summary>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFloatConverter``1(BrightData.BrightDataContext)">
            <summary>
            Lazy create a float converter per context
            </summary>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32,System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32,System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Aggregate(BrightData.AggregationType,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Aggregates a list of floats
            </summary>
            <param name="operation"></param>
            <param name="data">Data to aggregate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTarget(BrightData.MetaData,System.Boolean)">
            <summary>
            Sets this as a target
            </summary>
            <param name="metaData"></param>
            <param name="isTarget"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIsCategorical(BrightData.MetaData,System.Boolean)">
            <summary>
            Sets this as categorical
            </summary>
            <param name="metaData"></param>
            <param name="isCategorical"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetName(BrightData.MetaData,System.String)">
            <summary>
            Sets the name
            </summary>
            <param name="metaData"></param>
            <param name="name">Name</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFilePath(BrightData.MetaData)">
            <summary>
            Returns the file path associated with the meta data (if any)
            </summary>
            <param name="metaData"></param>
            <returns>File path</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupAndCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Groups items and counts each group
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Format``1(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,System.UInt32}},System.Char)">
            <summary>
            Formats groups of items
            </summary>
            <param name="items"></param>
            <param name="separator">Group separator</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.UseLegacySerializationInput(BrightData.BrightDataContext,System.Boolean)">
            <summary>
            Enables or disables legacy (version 2) binary serialization - only when reading
            </summary>
            <param name="context"></param>
            <param name="use">True to enable</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataEncoder(BrightData.BrightDataContext)">
            <summary>
            Creates a data encoder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetData(BrightData.ICanWriteToBinaryWriter)">
            <summary>
            Converts the object to a serialized buffer
            </summary>
            <param name="writable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.NotifyProgress(BrightData.INotifyUser,System.String,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Notifies about the progress of a multi part operation
            </summary>
            <param name="notify"></param>
            <param name="operationId">Unique operation id</param>
            <param name="index">Index of current part</param>
            <param name="total">Total number of parts</param>
            <param name="progress">Process within the part</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteProgressPercentage(System.Single,System.Int32@,System.Diagnostics.Stopwatch)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="progress">New progress (between 0 and 1)</param>
            <param name="previousPercentage">Current progress percentage (max 100)</param>
            <param name="sw">Stopwatch since start of operation</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsCommaSeparated``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes the enumerable to a comma separated string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items to write</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadArray``1(System.IO.Stream,System.UInt32)">
            <summary>
            Reads an array of T from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="size">Number of items to read</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadArray``1(System.IO.Stream,System.Int32)">
            <summary>
            Reads an array of T from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="size">Number of items to read</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindPermutations``1(``0[])">
            <summary>
            Finds all possible permutations of sub items from the array, including the array itself
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Array to permute</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindAllPairs``1(``0[])">
            <summary>
            Enumerates all unique pairs of items within the array
            [1, 2, 3] => [1,2], [1,3], [2,3]
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetGenericMethods(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Builds a table of the generic methods from a type
            </summary>
            <param name="type">Type to inspect</param>
            <param name="bindingFlags">Method flags</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Enumerate``1(System.IO.Stream,System.UInt32,System.Int32)">
            <summary>
            Enumerates a stream as a series of structs. This is best for small structs such as int32 etc as the values are not passed by reference.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="count">Total count to return</param>
            <param name="tempBufferSize">Size of temp buffer to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteTo``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,System.Int32)">
            <summary>
            Writes unmanaged items to a stream as a byte array
            </summary>
            <param name="items">Unmanaged items to write</param>
            <param name="stream">Destination stream</param>
            <param name="tempBufferSize">Size of buffer</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistinctContiguousRanges(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Finds the unique ranges of indices within a sequence
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTableBuilder(BrightData.BrightDataContext)">
            <summary>
            Creates a new table builder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.DisposeAll(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes a collection of disposables
            </summary>
            <param name="disposables"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToEnumerable``1(``0)">
            <summary>
            Converts a single object into a enumerator that will enumerate that object once
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj">Item to enumerate (once)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray(BrightData.IHaveSpanOfFloats)">
            <summary>
            Extracts an array of floats
            </summary>
            <param name="spanOwner"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.IHaveTensorSegment,BrightData.IHaveTensorSegment)">
            <summary>
            Copies tensor values to another tensor
            </summary>
            <param name="source">Copy from</param>
            <param name="target">Copy to</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToDateTime(System.String)">
            <summary>
            Attempts to parse a string into a date
            </summary>
            <param name="str">String that contains a valid date</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType(BrightData.BrightDataType)">
            <summary>
            Converts from a column type to a Type
            </summary>
            <param name="type">Column type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetBrightDataType(System.Type)">
            <summary>
            Converts from a Type to a ColumnType
            </summary>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsBlittable(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is blittable
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is numeric
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsDecimal(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is decimal
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsContinuous(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is continuous
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsInteger(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is an integer
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsIndexedList(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is an indexed list (or weighted index list)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTensor(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is a tensor
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RowIndices(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns all row indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndices(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns all column indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``1(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <param name="dataTable"></param>
            <typeparam name="T0"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``2(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="dataTable"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``3(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="dataTable"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``4(BrightData.DataTable.BrightDataTable)">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="dataTable"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnAnalyser(BrightData.BrightDataType,BrightData.MetaData,System.UInt32,System.UInt32)">
            <summary>
            Creates a column analyser
            </summary>
            <param name="type">Column type</param>
            <param name="metaData">Column meta data</param>
            <param name="writeCount">Maximum size of sequences to write in final meta data</param>
            <param name="maxDistinctCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ParseCsvIntoMemory(BrightData.BrightDataContext,System.IO.StreamReader,System.Boolean,System.Char,System.Int32,System.UInt16,System.Threading.CancellationToken)">
            <summary>
            Parse CSV in memory without writing to disk (for small data sets)
            </summary>
            <param name="context"></param>
            <param name="reader">Stream reader that contains CSV data</param>
            <param name="hasHeader">True if the data contains a header</param>
            <param name="delimiter">CSV delimiter character</param>
            <param name="maxRows">Maximum number of rows to read</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <param name="ct"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ParseCsv(BrightData.BrightDataContext,System.IO.StreamReader,System.Boolean,System.Char,System.String,System.Int32,System.UInt32,System.UInt16,System.Threading.CancellationToken)">
            <summary>
            Parse CSV into a column oriented data table using composite buffers
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">CSV</param>
            <param name="hasHeader">True if the CSV has a text based header</param>
            <param name="delimiter">CSV delimiter</param>
            <param name="fileOutputPath">Optional path to save final table</param>
            <param name="maxRows">Maximum number of rows of CSV to read</param>
            <param name="inMemoryRowCount">Number of rows to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <param name="ct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Head(BrightData.DataTable.BrightDataTable,System.UInt32)">
            <summary>
            Returns the head (first few rows) of the data table
            </summary>
            <param name="dataTable"></param>
            <param name="size">Number of rows to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadTable(BrightData.BrightDataContext,System.String,System.Boolean)">
            <summary>
            Loads a data table from disk
            </summary>
            <param name="context"></param>
            <param name="filePath">File path on disk</param>
            <param name="forModification">True if the table meta data might be updated</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyToFloatSegment``1(BrightData.ITypedSegment{``0},BrightData.ITensorSegment)">
            <summary>
            Copies a data table segment to a tensor segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="column">Data table segment</param>
            <param name="vector">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.ITypedSegment,BrightData.ITensorSegment)">
            <summary>
            Copies a data table segment to tensor segment
            </summary>
            <param name="column">Data table segment</param>
            <param name="vector">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTargetColumn(BrightData.DataTable.BrightDataTable,System.Nullable{System.UInt32})">
            <summary>
            Sets the target column of the data table
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to make target (or null to set no target)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumn(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns the target column of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumnOrThrow(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns the target column or throws an exception if none set
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndicesOfFeatures(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns the feature (non target) columns of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetType(BrightData.MetaData,BrightData.BrightDataType)">
            <summary>
            Sets the column type in a meta data store
            </summary>
            <param name="metaData"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetCompositeBufferWithMetaData(BrightData.BrightDataType,BrightData.MetaData,BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates an appendable buffer for a column type
            </summary>
            <param name="metaData"></param>
            <param name="type">Column type</param>
            <param name="context"></param>
            <param name="tempStream"></param>
            <param name="bufferSize">In memory cache size</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectorisedFeatures(BrightData.DataTable.BrightDataTable)">
            <summary>
            Converts the data table to a sequence of labeled vectors (feature columns are vectorised, target column is converted to a string)
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnType(BrightData.MetaData)">
            <summary>
            Gets the column type
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumDistinct(BrightData.MetaData)">
            <summary>
            Gets the number of distinct items
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split(BrightData.DataTable.BrightDataTable,System.Double,System.String,System.String)">
            <summary>
            Splits a data table into training and test tables (rows are randomly selected for either)
            </summary>
            <param name="table"></param>
            <param name="trainingFraction">Fraction (0..1) of rows to add to the training table</param>
            <param name="trainingFilePath">Path to write training table to disk (optional)</param>
            <param name="testFilePath">Path to write test table to disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Fold(BrightData.DataTable.BrightDataTable,System.Int32,System.Boolean)">
            <summary>
            Folds the data table into k buckets (for k fold cross validation)
            </summary>
            <param name="table"></param>
            <param name="k">Number of buckets to create</param>
            <param name="shuffle">True to shuffle the table before folding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsDataTableSegment``1(BrightData.ITypedSegment)">
            <summary>
            Strongly typed enumeration of items in segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray``1(BrightData.ITypedSegment)">
            <summary>
            Reads the segment as a strongly typed array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrices(BrightData.DataTable.BrightDataTable)">
            <summary>
            Converts the data table to feature and target matrices
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrix(BrightData.DataTable.BrightDataTable,System.UInt32[])">
            <summary>
            Converts data table columns to a matrix
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices to include in the matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.DataTable.BrightDataTable,System.Boolean,System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.DataTable.BrightDataTable,System.Boolean,System.Collections.Generic.IEnumerable{System.UInt32},System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="columnIndices">Columns to use</param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray``1(BrightData.ITypedSegment{``0})">
            <summary>
            Converts a data table segment to an array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Span{System.ValueTuple{System.String,BrightData.IndexList}},BrightData.BrightDataContext)">
            <summary>
            Converts indexed classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Span{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.BrightDataContext)">
            <summary>
            Converts weighted index classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Span{System.ValueTuple{System.String,BrightData.IVector}},System.Boolean,BrightData.BrightDataContext)">
            <summary>
            Converts the vector classifications into a data table
            </summary>
            <param name="data"></param>
            <param name="preserveVectors">True to create a data table with a vector column type, false to to convert to columns of floats</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(System.Span{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.BrightDataContext)">
            <summary>
            Converts the weighted index classification list to a list of dense vectors
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDefaultValue(BrightData.BrightDataType)">
            <summary>
            Returns a default value for a column type
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectoriser(BrightData.DataTable.BrightDataTable,System.Boolean,System.UInt32[])">
            <summary>
            Returns a vectoriser
            </summary>
            <param name="table"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="columnIndices">Column indices to vectorise</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadVectoriser(BrightData.DataTable.BrightDataTable,System.IO.BinaryReader)">
            <summary>
            Loads a previously created data table vectoriser
            </summary>
            <param name="dataTable"></param>
            <param name="reader">Reader to load parameters from</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertColumn(BrightData.ColumnConversionOperation,System.UInt32)">
            <summary>
            Creates a column conversion parameter
            </summary>
            <param name="type">Type of column conversion</param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertColumn(BrightData.NormalizationType,System.UInt32)">
            <summary>
            Creates a column normalization parameter
            </summary>
            <param name="type"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReinterpretColumns(System.UInt32[],BrightData.BrightDataType,System.String)">
            <summary>
            Creates a reinterpret columns parameter
            </summary>
            <param name="sourceColumnIndices"></param>
            <param name="newColumnType"></param>
            <param name="newColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray(BrightData.ICanRandomlyAccessData)">
            <summary>
            Converts the segment to an array
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Get``1(BrightData.ICanRandomlyAccessData,System.UInt32)">
            <summary>
            Casts the value at column index to type T
            </summary>
            <param name="segment"></param>
            <param name="columnIndex"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sample(BrightData.DataTable.BrightDataTable,System.UInt32)">
            <summary>
            Samples rows from the data table
            </summary>
            <param name="table"></param>
            <param name="sampleSize">Number of rows to sample</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCustomColumnMutator``2(BrightData.DataTable.BrightDataTable,System.UInt32,System.Func{``0,``1},System.Action{BrightData.MetaData})">
            <summary>
            Creates a custom column mutator
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to convert</param>
            <param name="converter">Column converter</param>
            <param name="columnFinaliser">Called after each row </param>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Convert(BrightData.DataTable.BrightDataTable,System.String,BrightData.IColumnTransformationParam[])">
            <summary>
            Creates a new table with columns that have been converted
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="conversion">Column conversion parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Convert(BrightData.DataTable.BrightDataTable,BrightData.IColumnTransformationParam[])">
            <summary>
            Creates a new table with columns that have been converted
            </summary>
            <param name="dataTable"></param>
            <param name="conversion">Column transformation parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Convert(BrightData.DataTable.BrightDataTable,BrightData.ColumnConversionOperation[])">
            <summary>
            Creates a new table with columns that have been converted
            </summary>
            <param name="dataTable"></param>
            <param name="conversionOperations">Array of column conversion operations (one for each column)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,BrightData.IColumnTransformationParam[])">
            <summary>
            Normalizes the table data per column
            </summary>
            <param name="dataTable"></param>
            <param name="conversion">Column normalization parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,System.String,BrightData.IColumnTransformationParam[])">
            <summary>
            Normalizes the table data per column
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="conversion">Column normalization parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateColumns(BrightData.DataTable.BrightDataTable,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="dataTable"></param>
            <param name="others">Other tables to concatenate</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateRows(BrightData.DataTable.BrightDataTable,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="dataTable"></param>
            <param name="others">Other tables to concatenate</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReinterpretColumns(BrightData.DataTable.BrightDataTable,BrightData.IProvideTempStreams,System.String,BrightData.IReinterpretColumns[])">
            <summary>
            Many to one or one to many style column transformations
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="columns">Parameters to determine which columns are reinterpreted</param>
            <param name="tempStreams">Temp stream provider</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateColumns(BrightData.DataTable.BrightDataTable,System.String,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Horizontally concatenates other data tables with this data table
            </summary>
            <param name="table"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="others">Other data tables</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateRows(BrightData.DataTable.BrightDataTable,System.String,BrightData.DataTable.BrightDataTable[])">
            <summary>
            Vertically concatenates other data tables with this data table
            </summary>
            <param name="table"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="others">Other data tables</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyRowsToNewTable(BrightData.DataTable.BrightDataTable,System.String,System.UInt32[])">
            <summary>
            Copy specified rows from this to a new data table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath"></param>
            <param name="rowIndices">Row indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyColumnsToNewTable(BrightData.DataTable.BrightDataTable,System.String,System.UInt32[])">
            <summary>
            Copies all or specified columns to a new data table
            </summary>
            <param name="table"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="columnIndices">Specified column indices (or all columns if none specified)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnTransformers(BrightData.DataTable.BrightDataTable,BrightData.IProvideTempStreams,System.Collections.Generic.IEnumerable{BrightData.IColumnTransformationParam})">
            <summary>
            Gets column transformers
            </summary>
            <param name="dataTable"></param>
            <param name="temp">Temp stream provider</param>
            <param name="input">Column transformation parameter objects</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateColumns(BrightData.DataTable.BrightDataTable,System.String,BrightData.IColumnTransformationParam[])">
            <summary>
            Mutates table columns
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="conversionParams">Column transformation parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnInfo(BrightData.DataTable.BrightDataTable)">
            <summary>
            Returns column information
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,BrightData.NormalizationType)">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="type">Normalization type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.DataTable.BrightDataTable,System.String,BrightData.NormalizationType)">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="type">Normalization type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Project(BrightData.DataTable.BrightDataTable,System.String,System.Func{System.Object[],System.Object[]})">
            <summary>
            Projects (transforms) table data to a new table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="projector">Projection function</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bag(BrightData.DataTable.BrightDataTable,System.String,System.UInt32)">
            <summary>
            Bags (random sample with duplication) table data to a new table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="sampleCount">Number of rows to sample</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Shuffle(BrightData.DataTable.BrightDataTable,System.String)">
            <summary>
            Shuffles all table rows into a new table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Clone(BrightData.DataTable.BrightDataTable,System.String)">
            <summary>
            Clones the data table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupBy(BrightData.DataTable.BrightDataTable,System.UInt32[])">
            <summary>
            Groups table data into multiple new tables based on the value(s) from columns
            </summary>
            <param name="dataTable"></param>
            <param name="groupByColumnIndices">Column indices that form the group</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupBy(BrightData.DataTable.BrightDataTable,System.Func{System.String,System.String},System.UInt32[])">
            <summary>
            Groups table data into multiple new tables based on the value(s) from columns
            </summary>
            <param name="dataTable"></param>
            <param name="filePathProvider">Provides file paths to save new table</param>
            <param name="groupByColumnIndices">Column indices that form the group</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTableSignature(BrightData.DataTable.BrightDataTable)">
            <summary>
            Gets the table signature based on column types
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildInMemory(BrightData.DataTable.BrightDataTableBuilder)">
            <summary>
            Builds a table in memory
            </summary>
            <param name="builder">Data table builder</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildToFile(BrightData.DataTable.BrightDataTableBuilder,System.String)">
            <summary>
            Builds a table on disk
            </summary>
            <param name="builder"></param>
            <param name="filePath">File path</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildToStream(BrightData.DataTable.BrightDataTableBuilder,System.IO.Stream)">
            <summary>
            Builds a data table to a stream
            </summary>
            <param name="builder"></param>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Build(BrightData.DataTable.BrightDataTableBuilder,System.String)">
            <summary>
            Builds a data table
            </summary>
            <param name="builder"></param>
            <param name="filePath">File path to save new table (optional - will be built in memory if not specified)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CompleteInParallel``1(BrightData.IOperation{``0}[])">
            <summary>
            Returns the results from a collection of operations that might be run in parallel
            </summary>
            <typeparam name="T"></typeparam>
            <param name="operations"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CompleteInParallel``1(System.Collections.Generic.IReadOnlyList{BrightData.IOperation{``0}})">
            <summary>
            Returns the results from a collection of operations that might be run in parallel
            </summary>
            <param name="operations"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.EnsureCompleted``1(``0)">
            <summary>
            Checks that operation was complete
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result">Operation result</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.EnsureAllCompleted``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Ensures that all operations have completed
            </summary>
            <typeparam name="T"></typeparam>
            <param name="results">Operation results</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteDataTable(BrightData.BrightDataContext,BrightData.MetaData,BrightData.ITypedSegment[],System.IO.Stream)">
            <summary>
            Writes a data table to a stream
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table meta data</param>
            <param name="columns">Data table columns</param>
            <param name="stream">Output stream</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildDataTable(BrightData.BrightDataContext,BrightData.MetaData,BrightData.ITypedSegment[],System.IO.Stream)">
            <summary>
            Builds a data table from an array of typed segments
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table level meta data</param>
            <param name="columns">Typed segments (table columns)</param>
            <param name="stream">Output stream</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildDataTableInMemory(BrightData.BrightDataContext,BrightData.MetaData,BrightData.ITypedSegment[])">
            <summary>
            Builds a data table in memory
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table level meta data</param>
            <param name="columns">Typed segments (table columns)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildDataTable(BrightData.BrightDataContext,BrightData.MetaData,BrightData.ITypedSegment[],System.String)">
            <summary>
            Builds a data table (and writes table data to a file)
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table level meta data</param>
            <param name="columns">Typed segments (table columns)</param>
            <param name="filePath">File path</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MapRows``1(BrightData.DataTable.BrightDataTable,System.Func{BrightData.DataTable.BrightDataTableRow,``0})">
            <summary>
            Maps table rows to another type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dataTable"></param>
            <param name="mapper"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetCustomColumnReaders(BrightData.DataTable.BrightDataTable,BrightData.ICanRandomlyAccessData[])">
            <summary>
            Replaces the default column readers with other column readers
            </summary>
            <param name="dataTable"></param>
            <param name="columnReaders">New column readers</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.NextRandomFloat(BrightData.BrightDataContext)">
            <summary>
            Returns a randomly initialized float greater than or equal to 0f, and less than 1f
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.BrightDataContext,System.Int32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBernoulliDistribution(BrightData.BrightDataContext,System.Single)">
            <summary>
            Create a bernoulli distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBinomialDistribution(BrightData.BrightDataContext,System.Single,System.UInt32)">
            <summary>
            Create a binomial distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <param name="numTrials"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCategoricalDistribution(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Create a categorical distribution
            </summary>
            <param name="context"></param>
            <param name="categoricalValues"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateContinuousDistribution(BrightData.BrightDataContext,System.Single,System.Single)">
            <summary>
            Create a continuous distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiscreteUniformDistribution(BrightData.BrightDataContext,System.Int32,System.Int32)">
            <summary>
            Create a discrete uniform distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateNormalDistribution(BrightData.BrightDataContext,System.Single,System.Single)">
            <summary>
            Create a normal distribution
            </summary>
            <param name="context"></param>
            <param name="mean"></param>
            <param name="stdDev">Standard deviation</param>
            <returns></returns>
        </member>
        <member name="F:BrightData.ExtensionMethods.NumericsVectorSize">
            <summary>
            Hardware dependent size of a numeric vector of floats
            </summary>
        </member>
        <member name="M:BrightData.ExtensionMethods.CosineDistance(System.Single[],System.Single[])">
            <summary>
            Vectorized cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite)
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>Cosine distance between the two vectors</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Minimum(System.Single[])">
            <summary>
            Find the minimum value and index in a vector
            </summary>
            <param name="vector">Vector to analyze</param>
            <returns>Tuple containing the minimum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumIndex(System.Single[])">
            <summary>
            Returns the index of the minimum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumValue(System.Single[])">
            <summary>
            Returns the minimum value
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Maximum(System.Single[])">
            <summary>
            Returns the maximum value and index within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns>Tuple containing the maximum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumIndex(System.Single[])">
            <summary>
            Returns the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumValue(System.Single[])">
            <summary>
            Returns the index of the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Softmax(System.Single[])">
            <summary>
            Calculates the softmax of a vector
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.UInt32[])">
            <summary>
            Creates an index list from indices
            </summary>
            <param name="_"></param>
            <param name="indices">Indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates an index list from indices
            </summary>
            <param name="_"></param>
            <param name="indices">Indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates an index list from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.ValueTuple{System.UInt32,System.Single}[])">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="_"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,System.Single}})">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="_"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{BrightData.WeightedIndexList.Item})">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="_"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a weighted index list from a binary reader
            </summary>
            <param name="_"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToWeightedIndexList(System.ValueTuple{System.String,BrightData.IndexList}[],System.Boolean)">
            <summary>
            Converts the indexed classifications to weighted indexed classifications
            </summary>
            <param name="data"></param>
            <param name="groupByClassification">True to group by classification (i.e convert the bag to a set)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxWeight(System.Span{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Finds the greatest weight within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex(System.Span{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Find the greatest index within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex(System.Span{System.ValueTuple{System.String,BrightData.IndexList}})">
            <summary>
            Find the greatest index within the index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(System.Span{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Normalizes the weighted index classification list to fit between 0 and 1
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Tfidf``1(System.ValueTuple{``0,BrightData.WeightedIndexList}[])">
            <summary>
            Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Tf%E2%80%93idf
            </summary>
            <returns>A newly weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bm25Plus``1(System.ValueTuple{``0,BrightData.WeightedIndexList}[],System.Single,System.Single,System.Single)">
            <summary>
            Okapi B525+ modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Okapi_BM25
            </summary>
            <returns>Newly weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="_"></param>
            <param name="size">Size of vector</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.Int32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.UInt32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="_"></param>
            <param name="size">Size of vector</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.Int32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.Single[])">
            <summary>
            Creates a vector
            </summary>
            <param name="_"></param>
            <param name="initialData">Initial data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a vector from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrix(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <param name="_"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrix(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Creates a matrix
            </summary>
            <param name="_"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrix(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a matrix from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromRows(BrightData.BrightDataContext,BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from vectors (each will become a row)
            </summary>
            <param name="_"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromRows(BrightData.BrightDataContext,System.Single[][])">
            <summary>
            Creates a matrix from rows (each will become a row)
            </summary>
            <param name="_"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromColumns(BrightData.BrightDataContext,BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <param name="_"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromColumns(BrightData.BrightDataContext,System.Single[][])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <param name="_"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor3D(BrightData.BrightDataContext,BrightData.IReadOnlyMatrix[])">
            <summary>
            Creates a 3D tensor from matrices
            </summary>
            <param name="_"></param>
            <param name="matrices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor3D(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Create a 3D tensor from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor4D(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a 4D tensor from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIdentityMatrix(BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32)">
            <summary>
            Creates an identity matrix (each diagonal element is 1, each other element is 0)
            </summary>
            <param name="lap"></param>
            <param name="size">Width and height of the new matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiagonalMatrix(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Single[])">
            <summary>
            Creates a diagonal matrix
            </summary>
            <param name="lap"></param>
            <param name="values">Diagonal values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.InitializeRandomly(BrightData.ITensor)">
            <summary>
            Randomly initialize a tensor
            </summary>
            <param name="tensor"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize(BrightData.ITensor,System.Single)">
            <summary>
            Initialize a tensor to a single value
            </summary>
            <param name="tensor"></param>
            <param name="value">Value to initialize each element of the tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize(BrightData.ITensor,System.Func{System.UInt32,System.Single})">
            <summary>
            Initialize a tensor using a callback
            </summary>
            <param name="tensor"></param>
            <param name="initializer">Callback for each element</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.ITensorSegment)">
            <summary>
            Converts the tensor segment to a sparse format (only non zero entries are preserved)
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadReadOnlyVectorFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a vector from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadReadOnlyVectorAndThenGetArrayFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reacts a float array from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadMatrixFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a matrix from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReduceDimensionsWithSvd(BrightData.IMatrix,System.UInt32)">
            <summary>
            Reduce dimensions of the matrix with a singular value decomposition
            </summary>
            <param name="matrix"></param>
            <param name="dimensions">Number of dimensions to reduce to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Average``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Calculates an average from a collection of tensors
            </summary>
            <param name="tensors">Tensors to average</param>
            <param name="dispose">True to dispose each of the input vectors</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetLocalOrNewArray(BrightData.ITensorSegment)">
            <summary>
            Returns an array from a tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ZipParallel(BrightData.ITensorSegment,BrightData.ITensorSegment,System.Func{System.Single,System.Single,System.Single})">
            <summary>
            Creates a new tensor segment from each pairwise combination of this and another tensor segment (in parallel)
            </summary>
            <param name="segment">This tensor</param>
            <param name="other">Other tensor</param>
            <param name="func">Pairwise combiner function</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ZipVectorized(BrightData.ITensorSegment,BrightData.ITensorSegment,BrightData.SpanExtensions.ComputeVectorisedTwo{System.Single},System.Func{System.Single,System.Single,System.Single})">
            <summary>
            Creates a new tensor segment from each pairwise combination of this and another tensor segment (vectorized)
            </summary>
            <param name="segment">This tensor</param>
            <param name="other">Other tensor</param>
            <param name="func1">Vectorized combiner combiner</param>
            <param name="func2">Pairwise combiner function</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.TransformParallel(BrightData.ITensorSegment,System.Func{System.Single,System.Single})">
            <summary>
            Creates a new tensor segment from this tensor segment (in parallel)
            </summary>
            <param name="segment">This tensor</param>
            <param name="transformer">Value transformer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TransformVectorized(BrightData.ITensorSegment,BrightData.SpanExtensions.ComputeVectorisedOne{System.Single},System.Func{System.Single,System.Single})">
            <summary>
            Creates a new tensor segment from this tensor segment (vectorized)
            </summary>
            <param name="segment">This segment</param>
            <param name="transformer1">Vectorized value transformer</param>
            <param name="transformer2">Value transformer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TransformParallelIndexed(BrightData.ITensorSegment,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a new tensor segment from this tensor segment (in parallel)
            </summary>
            <param name="segment">This tensor</param>
            <param name="transformer">Indexed transformer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateParallel(BrightData.ITensorSegment,BrightData.ITensorSegment,System.Func{System.Single,System.Single,System.Single})">
            <summary>
            In place update of this tensor segment with pairwise values from another tensor segment (in parallel)
            </summary>
            <param name="segment">This tensor</param>
            <param name="other">Other tensor</param>
            <param name="func">Update function</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateVectorized(BrightData.ITensorSegment,BrightData.ITensorSegment,BrightData.SpanExtensions.ComputeVectorisedTwo{System.Single},System.Func{System.Single,System.Single,System.Single})">
            <summary>
            In place update of this tensor segment with pairwise values from another tensor segment (vectorized)
            </summary>
            <param name="segment">This tensor</param>
            <param name="other">Other tensor</param>
            <param name="func1">Vectorized update function</param>
            <param name="func2">Update function</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateInPlaceParallel(BrightData.ITensorSegment,System.Func{System.Single,System.Single})">
            <summary>
            In place update of tensor segment (in parallel)
            </summary>
            <param name="segment">This tensor</param>
            <param name="mutator">Update function</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateInPlaceVectorized(BrightData.ITensorSegment,BrightData.SpanExtensions.ComputeVectorisedOne{System.Single},System.Func{System.Single,System.Single})">
            <summary>
            In place update of tensor segment (vectorized)
            </summary>
            <param name="segment">This tensor</param>
            <param name="mutator1">Vectorized update function</param>
            <param name="mutator2">Update function</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sum(BrightData.ITensorSegment)">
            <summary>
            Sums all values
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Add(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Pairwise addition of this with another tensor segment into a new tensor segment
            </summary>
            <param name="tensor1">This tensor</param>
            <param name="tensor2">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Add(BrightData.ITensorSegment,BrightData.ITensorSegment,System.Single,System.Single)">
            <summary>
            Pairwise addition of this with another tensor segment into a new tensor segment
            </summary>
            <param name="tensor1">This tensor</param>
            <param name="tensor2">Other tensor</param>
            <param name="coefficient1">Value to multiply each value in this tensor</param>
            <param name="coefficient2">Value to multiply each value in the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Add(BrightData.ITensorSegment,System.Single)">
            <summary>
            Adds a scalar to each value in this tensor segment into a new tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="scalar">Scalar to add to each value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AddInPlace(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Adds another tensor segment in place to this tensor segment
            </summary>
            <param name="target">This tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.AddInPlace(BrightData.ITensorSegment,BrightData.ITensorSegment,System.Single,System.Single)">
            <summary>
            Adds another tensor segment in place to this tensor segment
            </summary>
            <param name="target">This tensor</param>
            <param name="other">Other tensor</param>
            <param name="coefficient1">Value to multiply each value in this tensor</param>
            <param name="coefficient2">Value to multiply each value in the other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.AddInPlace(BrightData.ITensorSegment,System.Single)">
            <summary>
            Adds a scalar to each value in this tensor segment in place
            </summary>
            <param name="target">This tensor</param>
            <param name="scalar">Scalar to add to each value</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.MultiplyInPlace(BrightData.ITensorSegment,System.Single)">
            <summary>
            Multiplies each value in this tensor segment by a scalar (in place)
            </summary>
            <param name="target">This tensor</param>
            <param name="scalar">Scalar to multiply</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Multiply(BrightData.ITensorSegment,System.Single)">
            <summary>
            Multiplies each value in this tensor segment by a scalar into a new tensor segment
            </summary>
            <param name="target">This tensor</param>
            <param name="scalar">Scalar to multiply</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Subtract(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Subtracts another tensor segment from this tensor segment into a new tensor segment
            </summary>
            <param name="tensor1">This tensor</param>
            <param name="tensor2">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Subtract(BrightData.ITensorSegment,BrightData.ITensorSegment,System.Single,System.Single)">
            <summary>
            Subtracts another tensor segment from this tensor segment into a new tensor segment
            </summary>
            <param name="tensor1">This tensor</param>
            <param name="tensor2">Other tensor</param>
            <param name="coefficient1">Value to multiply each value in this tensor</param>
            <param name="coefficient2">Value to multiply each value in the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SubtractInPlace(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Subtracts another tensor segment from this tensor segment in place
            </summary>
            <param name="target">This tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.SubtractInPlace(BrightData.ITensorSegment,BrightData.ITensorSegment,System.Single,System.Single)">
            <summary>
            Subtracts another tensor segment from this tensor segment in place
            </summary>
            <param name="target">This tensor</param>
            <param name="other">Other tensor</param>
            <param name="coefficient1">Value to multiply each value in this tensor</param>
            <param name="coefficient2">Value to multiply each value in the other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseMultiply(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Pairwise multiply each value in this tensor segment with the corresponding value from another tensor segment into a new tensor segment
            </summary>
            <param name="tensor1">This tensor</param>
            <param name="tensor2">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseMultiplyInPlace(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Pairwise multiply each value in this tensor segment with the corresponding value from another tensor segment in place
            </summary>
            <param name="target">This tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseDivide(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Pairwise divide each value in this tensor segment with the corresponding value from another tensor segment into a new tensor segment
            </summary>
            <param name="tensor1">This tensor</param>
            <param name="tensor2">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseDivideInPlace(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Pairwise divide each value in this tensor segment with the corresponding value from another tensor segment in place
            </summary>
            <param name="target">This tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.DotProduct(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Calculates the dot product of this with another tensor
            </summary>
            <param name="segment">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sqrt(BrightData.ITensorSegment,System.Single)">
            <summary>
            Creates a new tensor segment that contains the square root of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="adjustment">A non zero value to use in place of zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Search(BrightData.ITensorSegment,System.Single,System.Single)">
            <summary>
            Searches this tensor segment for the index of the first value that matches the specified value within a level of tolerance
            </summary>
            <param name="segment">This tensor</param>
            <param name="value">Value to find</param>
            <param name="tolerance">Degree of tolerance</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConstrainInPlace(BrightData.ITensorSegment,System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Constrains each value in this tensor segment to fit between a supplied minimum and maximum value
            </summary>
            <param name="segment">This tensor</param>
            <param name="minInclusiveValue">Minimum allowed inclusive value (optional)</param>
            <param name="maxInclusiveValue">Maximum allowed inclusive value (optional)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Average(BrightData.ITensorSegment)">
            <summary>
            Finds the average value in this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.L1Norm(BrightData.ITensorSegment)">
            <summary>
            Calculates the L1 norm of this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.L2Norm(BrightData.ITensorSegment)">
            <summary>
            Calculates the L2 norm of this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMinAndMaxValues(BrightData.ITensorSegment)">
            <summary>
            Finds the min and max values (and their indices) of this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsEntirelyFinite(BrightData.ITensorSegment)">
            <summary>
            Checks if this tensor segment is finite for each value (not NaN or Infinity)
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Reverse(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment that is the reverse of this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split(BrightData.ITensorSegment,System.UInt32)">
            <summary>
            Splits this tensor segment into multiple contiguous tensor segments
            </summary>
            <param name="segment">This tensor</param>
            <param name="blockCount">Number of blocks</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CosineDistance(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Calculates the cosine distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.EuclideanDistance(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Calculates the euclidean distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MeanSquaredDistance(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Calculates the mean squared distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SquaredEuclideanDistance(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Calculates the squared euclidean distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ManhattanDistance(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Calculates the manhattan distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Abs(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment that contains the absolute value of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Log(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment that contains the natural logarithm of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Exp(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment that contains the exponent of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Pow(BrightData.ITensorSegment,System.Single)">
            <summary>
            Creates a new tensor segment that contains each value raised by the specified power in this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <param name="power">Specified power</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Squared(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment that contains each value squared in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.StdDev(BrightData.ITensorSegment,System.Nullable{System.Single})">
            <summary>
            Calculates the standard deviation of this tensor segment
            </summary>
            <param name="segment">This tensor segment</param>
            <param name="mean">Mean of the tensor segment (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sigmoid(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with sigmoid function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SigmoidDerivative(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with sigmoid derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Tanh(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with tanh function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TanhDerivative(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with tanh derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Relu(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with RELU function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReluDerivative(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with RELU derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LeakyRelu(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with Leaky RELU function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LeakyReluDerivative(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with Leaky RELU derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Softmax(BrightData.ITensorSegment)">
            <summary>
            Creates a new tensor segment with softmax function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SoftmaxDerivative(BrightData.ITensorSegment,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a new tensor segment with softmax derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CherryPickIndices(BrightData.ITensorSegment,System.UInt32[])">
            <summary>
            Returns a new tensor segment from the values at the supplied indices from this tensor segment
            </summary>
            <param name="segment"></param>
            <param name="indices">Indices to copy to new tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RoundInPlace(BrightData.ITensorSegment,System.Single,System.Single)">
            <summary>
            Rounds each value in this tensor segment to be either the lower or upper supplied parameters
            </summary>
            <param name="segment"></param>
            <param name="lower"></param>
            <param name="upper"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(BrightData.ITensorSegment,System.Action{System.Single,System.UInt32})">
            <summary>
            Invokes a callback on each element of the tensor segment
            </summary>
            <param name="segment"></param>
            <param name="analyser">Callback that will receive each value and its corresponding index in the segment</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.L1Regularization(BrightData.ITensorSegment,System.Single)">
            <summary>
            In place L1 regularization of the tensor segment
            </summary>
            <param name="segment"></param>
            <param name="coefficient">Coefficient to apply to each adjusted value</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistance(BrightData.IVector,BrightData.IVector,BrightData.DistanceMetric)">
            <summary>
            Applies a distance metric to two vectors and returns the distance between them
            </summary>
            <param name="vector">First vector</param>
            <param name="other">Second vector</param>
            <param name="distance">Distance metric</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistances(BrightData.IVector,System.Collections.Generic.IReadOnlyList{BrightData.IVector},BrightData.DistanceMetric)">
            <summary>
            Applies a distance metric to this and a list of other vectors
            </summary>
            <param name="compareTo">This vector</param>
            <param name="vectors">List of other vectors</param>
            <param name="distanceMetric">Distance metric</param>
            <returns>A vector in which each value is the distance between this and the corresponding other vector</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Set(BrightData.ITensorSegment,System.Func{System.UInt32,System.Single})">
            <summary>
            Sets all values of the tensor segment via a callback that receives the index of each value
            </summary>
            <param name="segment"></param>
            <param name="getValue"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Set(BrightData.ITensorSegment,System.Single)">
            <summary>
            Sets all values of the tensor segment to a single value
            </summary>
            <param name="segment"></param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetToRandom(BrightData.ITensorSegment,System.Random)">
            <summary>
            Sets all values of this tensor segment to a random floating point number
            </summary>
            <param name="segment"></param>
            <param name="random">Random number generator</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.IVector)">
            <summary>
            Converts the vector a weighted index list (sparse vector)
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToReadOnlyVector(BrightData.ITensorSegment)">
            <summary>
            Converts the tensor segment to a read only vector
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToReadOnlyVector(System.Single[])">
            <summary>
            Converts the float array to a read only vector
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToVector(BrightData.ITensorSegment,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a vector from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToMatrix(BrightData.ITensorSegment,BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32,System.UInt32)">
            <summary>
            Creates a matrix from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <param name="rows">Number of rows in matrix</param>
            <param name="columns">Number of columns in matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToTensor3D(BrightData.ITensorSegment,BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 3D tensor from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToTensor4D(BrightData.ITensorSegment,BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 4D tensor from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.ITensor,BrightData.ITensor)">
            <summary>
            Copies all values from this tensor to another tensor
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.UseDefaultLinearAlgebraProvider(BrightData.BrightDataContext)">
            <summary>
            Sets the context to use the default linear algebra provider
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMinimumIndex(BrightData.IHaveTensorSegment)">
            <summary>
            Returns the index with the minimum value from this tensor segment
            </summary>
            <param name="tensorSegment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaximumIndex(BrightData.IHaveTensorSegment)">
            <summary>
            Returns the index with the maximum value from this tensor segment
            </summary>
            <param name="tensorSegment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsDataFieldSpecification(BrightData.BrightDataType,System.String,System.Boolean)">
            <summary>
            Creates a data field specification for a data type
            </summary>
            <param name="dataType"></param>
            <param name="name"></param>
            <param name="canRepeat"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTypeSpecification(BrightData.DataTable.BrightDataTable)">
            <summary>
            Creates a type specification for a data table
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindNonConformingRows(BrightData.IDataTypeSpecification,BrightData.DataTable.BrightDataTable)">
            <summary>
            Finds the row indices of any row that does not conform to the type specification
            </summary>
            <param name="typeInfo"></param>
            <param name="dataTable"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:BrightData.Helper.ColumnTypeClassifier">
            <summary>
            Classifies data table column types
            </summary>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsDecimal(BrightData.BrightDataType)">
            <summary>
            Checks for a decimal type (floating point)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsNumeric(BrightData.BrightDataType)">
            <summary>
            Checks for a numeric type (floating point or integer)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsContinuous(BrightData.BrightDataType)">
            <summary>
            Checks for a continuous type (non categorical)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsCategorical(BrightData.BrightDataType)">
            <summary>
            Checks for a categorical type (non continuous)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsBlittable(BrightData.BrightDataType)">
            <summary>
            Checks if the type has an independent memory layout across managed and unmanaged code
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.GetClass(BrightData.BrightDataType,BrightData.MetaData)">
            <summary>
            Returns the set of possible column classifications
            </summary>
            <param name="type">Column type to check</param>
            <param name="metaData">Column metadata</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ConsoleProgressNotification">
            <summary>
            Writes progress notifications to the console
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnStartOperation(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnOperationProgress(System.String,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnCompleteOperation(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.WriteProgress(System.Int32,System.Int32@,System.Int32)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="newProgress">New progress</param>
            <param name="oldProgress">Current progress</param>
            <param name="max">Max progress amount (default 100)</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.WriteProgress(System.Single,System.Int32@,System.Diagnostics.Stopwatch)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="progress">New progress (between 0 and 1)</param>
            <param name="previousPercentage">Current progress percentage (max 100)</param>
            <param name="sw">Stopwatch since start of operation</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper">
            <summary>
            Helper class to calculate convolutional indices
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.LeftToRight(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from left to right
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.TopToBottom(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from top to bottom
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper.ConvolutionalDelegate">
            <inheritdoc />
        </member>
        <member name="F:BrightData.Helper.ConvolutionHelper.Default">
            <summary>
            Default convolutional direction
            </summary>
        </member>
        <member name="T:BrightData.Helper.DataEncoder">
            <summary>
            Encodes types from/to bytes
            </summary>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Read``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read from a binary reader
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read an array from a binary reader
            </summary>
            <typeparam name="T">Type within the array</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0)">
            <summary>
            Generic method to write to binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="val">Item to write</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0[])">
            <summary>
            Generic method to write an array to a binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="values">Array to write</param>
        </member>
        <member name="T:BrightData.Helper.DoubleMath">
            <summary>
            Helpers for double based math
            </summary>
        </member>
        <member name="F:BrightData.Helper.DoubleMath.AlmostZero">
            <summary>
            A number that is close to zero
            </summary>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Double,System.Double,System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Nullable{System.Double},System.Nullable{System.Double},System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.FloatMath">
            <summary>
            Constrained float math helpers - if the value is too small or too big it will be capped. Also NaN values are replaced with zero.
            </summary>
        </member>
        <member name="T:BrightData.Helper.GenericActivator">
            <summary>
            Generic object creator
            </summary>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``2(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T1">Type to cast created object to</typeparam>
            <typeparam name="T2">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1">
            <summary>
            Creates a new object (via default constructor)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1">
            <summary>
            Creates a new uninitialized object (constructor is not invoked)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1(System.Type)">
            <summary>
            Creates a new uninitialized object (constructor is not invoked)
            </summary>
            <param name="type">Type to create</param>
            <typeparam name="T">Type to return (created object cast to this type)</typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ShapedBase">
            <summary>
            Tensor shape
            </summary>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Shape">
            <summary>
            Array of sizes
            </summary>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.#ctor(System.UInt32[])">
            <summary>
            Constructor
            </summary>
            <param name="shape">Array of sizes</param>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Size">
            <summary>
            Total size of the shape
            </summary>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Rank">
            <summary>
            Number of sizes within the shape
            </summary>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ShapedBase.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads the shape from a binary reader
            </summary>
            <param name="reader">Reader</param>
            <returns>Size of tensor</returns>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.ResolveShape(System.UInt32,System.Nullable{System.UInt32}[])">
            <summary>
            Works out the shape from a possibly incomplete list of sizes
            </summary>
            <param name="total">Total size</param>
            <param name="shape">List of sizes that form the shape (one can be null)</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.StreamCloner">
            <summary>
            Clones streams
            </summary>
        </member>
        <member name="T:BrightData.Helper.StringIndexer">
            <summary>
            Builds a string table
            </summary>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.#ctor(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.Create(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.GetIndex(System.String)">
            <summary>
            Returns the index of a string (creates it if not already in table)
            </summary>
            <param name="str">String to search</param>
            <returns>String index</returns>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OutputSize">
            <summary>
            Size of the string table
            </summary>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OrderedStrings">
            <summary>
            Returns all strings by indexed order
            </summary>
        </member>
        <member name="T:BrightData.Helper.TempStreamManager">
            <summary>
            Manages a collection of temp files
            </summary>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="basePath">Location on disk to write new temp files</param>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.GetNewTempPath">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.Get(System.String)">
            <summary>
            Returns an existing (or creates a new) temp stream
            </summary>
            <param name="uniqueId">Unique identifier</param>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.HasStream(System.String)">
            <summary>
            Checks if the the stream has been created
            </summary>
            <param name="uniqueId">Unique identifier</param>
            <returns>True if the stream has been created</returns>
        </member>
        <member name="T:BrightData.Helper.ThreadSafeHashSet`1">
            <summary>
            A hash set that can be accessed by more than one thread at the same time
            </summary>
            <typeparam name="T">The wrapped type</typeparam>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Finalize">
            <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Add(`0)">
            <summary>
            Adds a new item
            </summary>
            <param name="item">Item to add</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Clear">
            <summary>
            Clears all items
            </summary>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Contains(`0)">
            <summary>
            Checks if the set contains the specified item
            </summary>
            <param name="item">Item to find</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Remove(`0)">
            <summary>
            Removes an item
            </summary>
            <param name="item">Item to remove</param>
            <returns>True if the item was removed</returns>
        </member>
        <member name="P:BrightData.Helper.ThreadSafeHashSet`1.Count">
            <summary>
            The number of items in the set
            </summary>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.ForEach(System.Action{`0})">
            <summary>
            Applies a callback to each item in the set
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.TryPop(`0@)">
            <summary>
            Tries to pop an item from the set
            </summary>
            <param name="ret">Item that was removed</param>
            <returns>True if there was an item to remove</returns>
        </member>
        <member name="T:BrightData.IndexList">
            <summary>
            Contains a list of indices
            </summary>
        </member>
        <member name="M:BrightData.IndexList.#ctor(System.UInt32[])">
            <summary>
            Constructor
            </summary>
            <param name="indices">Initial indices</param>
        </member>
        <member name="P:BrightData.IndexList.Indices">
            <summary>
            Current indices in list
            </summary>
        </member>
        <member name="M:BrightData.IndexList.AsSpan">
            <summary>
            Indices as a span
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.Create(System.UInt32[])">
            <summary>
            Creates an index list
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.Create(System.ReadOnlySpan{System.UInt32})">
            <summary>
            Creates an index list
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.Create(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates an index list
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.IndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.IndexList.Equals(BrightData.IndexList)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.op_Equality(BrightData.IndexList,BrightData.IndexList)">
            <summary>
            Checks for index list equality
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.op_Inequality(BrightData.IndexList,BrightData.IndexList)">
            <summary>
            Checks for index list inequality
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.IndexList})">
            <summary>
            Merges a sequence of index lists into a single index list
            </summary>
            <param name="lists">Lists to merge</param>
        </member>
        <member name="M:BrightData.IndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.IndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.IndexList.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.ToXml">
            <summary>
            Converts the index list to XML
            </summary>
        </member>
        <member name="M:BrightData.IndexList.JaccardSimilarity(BrightData.IndexList)">
            <summary>
            Calculates the jaccard similarity between this and another index list
            </summary>
            <param name="other">Index list to compare to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.AsDense(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.UInt32})">
            <summary>
            Converts to a dense vector in which each set index is 1
            </summary>
            <param name="lap">Linear algebra provider</param>
            <param name="maxIndex">Maximum index to include</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.HasIndex(System.UInt32)">
            <summary>
            Checks if the specified index has been set
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.OverlapSimilarity(BrightData.IndexList)">
            <summary>
            Calculates the overlap similarity between this and another index list
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveBrightDataContext">
            <summary>
            Indicates that the type has a data context
            </summary>
        </member>
        <member name="P:BrightData.IHaveBrightDataContext.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="T:BrightData.IHaveIndices">
            <summary>
            Indicates that the type has a list of indices
            </summary>
        </member>
        <member name="P:BrightData.IHaveIndices.Indices">
            <summary>
            Enumerates the indices
            </summary>
        </member>
        <member name="T:BrightData.IHaveSpanOfFloats">
            <summary>
            Indicates that the type can create a readonly span of floats
            </summary>
        </member>
        <member name="M:BrightData.IHaveSpanOfFloats.GetFloatSpan(Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <summary>
            Returns a span of floats
            </summary>
            <param name="temp">Optional temporary memory buffer</param>
            <param name="wasTempUsed">True if the memory buffer was used</param>
            <returns>Span of floats</returns>
        </member>
        <member name="T:BrightData.ICanWriteToBinaryWriter">
            <summary>
            Indicates that the type can serialize to a binary writer
            </summary>
        </member>
        <member name="M:BrightData.ICanWriteToBinaryWriter.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Serialize to binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:BrightData.ICanInitializeFromBinaryReader">
            <summary>
            Indicates that the type can initialize from a binary reader
            </summary>
        </member>
        <member name="M:BrightData.ICanInitializeFromBinaryReader.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Initialize from a binary reader
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">Reader to read from to initialize</param>
        </member>
        <member name="T:BrightData.IAmSerializable">
            <summary>
            Supports both writing and reading from binary
            </summary>
        </member>
        <member name="T:BrightData.IHaveMetaData">
            <summary>
            Indicates that the type has a meta data store
            </summary>
        </member>
        <member name="P:BrightData.IHaveMetaData.MetaData">
            <summary>
            Meta data store
            </summary>
        </member>
        <member name="T:BrightData.IDataReader">
            <summary>
            Typed data reader
            </summary>
        </member>
        <member name="M:BrightData.IDataReader.Read``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed value from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataReader.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed array from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IWriteToMetaData">
            <summary>
            Indicates that the type can write values to meta data
            </summary>
        </member>
        <member name="M:BrightData.IWriteToMetaData.WriteTo(BrightData.MetaData)">
            <summary>
            Writes values to meta data
            </summary>
            <param name="metadata">Meta data store</param>
        </member>
        <member name="T:BrightData.IDataAnalyser">
            <summary>
            Base data analyzer type
            </summary>
        </member>
        <member name="M:BrightData.IDataAnalyser.AddObject(System.Object)">
            <summary>
            Adds an object to analyze
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IAcceptSequentialTypedData`1">
            <summary>
            Typed data can be sequentially added
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IAcceptSequentialTypedData`1.Add(`0)">
            <summary>
            Adds a typed object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IDataAnalyser`1">
            <summary>
            Typed data analyser
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.NormalizationType">
            <summary>
            Types of data normalization
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Standard">
            <summary>
            Standard deviation
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Euclidean">
            <summary>
            Euclidean norm
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Manhattan">
            <summary>
            Manhattan
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.FeatureScale">
            <summary>
            Between 0..1
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert">
            <summary>
            Indicates that the type can convert different types
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.From">
            <summary>
            Type that is converted from
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.To">
            <summary>
            Type that is converted to
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert`2">
            <summary>
            Typed converter interface
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.ICanConvert`2.Convert(`0)">
            <summary>
            Converts a type from one to another
            </summary>
            <param name="data">Object to convert</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.INormalize">
            <summary>
            Data normalizer
            </summary>
        </member>
        <member name="P:BrightData.INormalize.NormalizationType">
            <summary>
            Type of data normalization
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Divide">
            <summary>
            Value to divide each value
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Subtract">
            <summary>
            Value to subtract from each value
            </summary>
        </member>
        <member name="T:BrightData.AggregationType">
            <summary>
            Types of aggregations
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Sum">
            <summary>
            Sums values to a final value
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Average">
            <summary>
            Averages values
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Max">
            <summary>
            Finds the maximum value
            </summary>
        </member>
        <member name="T:BrightData.IDistribution`1">
            <summary>
            Data distribution
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDistribution`1.Sample">
            <summary>
            Samples a value from the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDiscreteDistribution">
            <summary>
            Discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.INonNegativeDiscreteDistribution">
            <summary>
            Positive discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.IContinuousDistribution">
            <summary>
            Continuous data distribution
            </summary>
        </member>
        <member name="T:BrightData.IProvideTempStreams">
            <summary>
            Temp stream provider
            </summary>
        </member>
        <member name="M:BrightData.IProvideTempStreams.GetNewTempPath">
            <summary>
            Returns the path to a new temp file
            </summary>
        </member>
        <member name="M:BrightData.IProvideTempStreams.Get(System.String)">
            <summary>
            Returns an existing or creates a new temporary stream
            </summary>
            <param name="uniqueId">Id that uniquely identifies the context</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IProvideTempStreams.HasStream(System.String)">
            <summary>
            Checks if a stream has been created
            </summary>
            <param name="uniqueId">Id that uniquely identifies the context</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICompositeBuffer">
            <summary>
            Composite buffers write first to memory but then to disk once it's cache is exhausted
            </summary>
        </member>
        <member name="M:BrightData.ICompositeBuffer.CopyTo(System.IO.Stream)">
            <summary>
            Copies the buffer to a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:BrightData.ICompositeBuffer.NumDistinct">
            <summary>
            Number of distinct items in the buffer (or null if not known)
            </summary>
        </member>
        <member name="M:BrightData.ICompositeBuffer.AddObject(System.Object)">
            <summary>
            Adds an object to the buffer
            </summary>
            <param name="obj">Object to add</param>
        </member>
        <member name="P:BrightData.ICompositeBuffer.DataType">
            <summary>
            Buffer data type
            </summary>
        </member>
        <member name="T:BrightData.ICompositeBuffer`1">
            <summary>
            Typed composite buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.ICompositeBuffer`1.DistinctItems">
            <summary>
            (Optional) set of the distinct items in the buffer
            </summary>
        </member>
        <member name="T:BrightData.ICompositeBufferWithMetaData">
            <summary>
            Composite buffer with metadata
            </summary>
        </member>
        <member name="T:BrightData.ICompositeBufferWithMetaData`1">
            <summary>
            Typed composite buffer with metadata
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.CompositeBufferType">
            <summary>
            Type of composite buffer
            </summary>
        </member>
        <member name="F:BrightData.CompositeBufferType.Unknown">
            <summary>
            Unknown type
            </summary>
        </member>
        <member name="F:BrightData.CompositeBufferType.Struct">
            <summary>
            Buffer of structs
            </summary>
        </member>
        <member name="F:BrightData.CompositeBufferType.String">
            <summary>
            Buffer of strings
            </summary>
        </member>
        <member name="F:BrightData.CompositeBufferType.EncodedStruct">
            <summary>
            Buffer of encoded structs
            </summary>
        </member>
        <member name="F:BrightData.CompositeBufferType.EncodedString">
            <summary>
            Buffer of encoded strings
            </summary>
        </member>
        <member name="F:BrightData.CompositeBufferType.Object">
            <summary>
            Buffer of objects
            </summary>
        </member>
        <member name="T:BrightData.IHaveSize">
            <summary>
            Indicates that the type has a size
            </summary>
        </member>
        <member name="P:BrightData.IHaveSize.Size">
            <summary>
            Number of items
            </summary>
        </member>
        <member name="T:BrightData.ICanEnumerate">
            <summary>
            Indicates that the type can enumerate items
            </summary>
        </member>
        <member name="P:BrightData.ICanEnumerate.Values">
            <summary>
            Enumerates all items
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanEnumerate`1">
            <summary>
            Indicates that the type can enumerate items of this type
            </summary>
            <typeparam name="T">Type to enumerate</typeparam>
        </member>
        <member name="P:BrightData.ICanEnumerate`1.Values">
            <summary>
            Enumerates all items
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanEnumerateDisposable`1">
            <summary>
            Indicates that the type can enumerate items of this type (disposable)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.ICanEnumerateDisposable">
            <summary>
            Indicates that the type can enumerate items (disposable)
            </summary>
        </member>
        <member name="T:BrightData.ICanEnumerateWithSize`1">
            <summary>
            Indicates that the type can enumerate items of this type and has a predetermined size
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.IIndexStrings">
            <summary>
            Indicates that the type can convert string to string indices
            </summary>
        </member>
        <member name="M:BrightData.IIndexStrings.GetIndex(System.String)">
            <summary>
            Returns the index for a string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IIndexStrings.OutputSize">
            <summary>
            Gets the total number of possible string indices
            </summary>
        </member>
        <member name="T:BrightData.IHaveStringIndexer">
            <summary>
            Indicates that the type has string indexer
            </summary>
        </member>
        <member name="P:BrightData.IHaveStringIndexer.Indexer">
            <summary>
            String indexer
            </summary>
        </member>
        <member name="T:BrightData.IHaveStringTable">
            <summary>
            Indicates that the type has a string table
            </summary>
        </member>
        <member name="P:BrightData.IHaveStringTable.StringTable">
            <summary>
            Current string table
            </summary>
        </member>
        <member name="T:BrightData.IStructByReferenceEnumerator`1">
            <summary>
            Allows readonly reference enumeration
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IStructByReferenceEnumerator`1.GetEnumerator">
            <summary>
            Gets an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IStructByReferenceEnumerator`1.MoveNext">
            <summary>
            Moves to the next item
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IStructByReferenceEnumerator`1.Reset">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:BrightData.IStructByReferenceEnumerator`1.Current">
            <summary>
            Gets the current item
            </summary>
        </member>
        <member name="T:BrightData.ICanReadSection">
            <summary>
            Implemented by types that can repeatedly read the same section of a stream
            </summary>
        </member>
        <member name="M:BrightData.ICanReadSection.GetReader">
            <summary>
            Creates a new reader for the readable section of the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ICanReadSection.GetStructByReferenceEnumerator``1(System.UInt32)">
            <summary>
            Returns an readonly reference enumerator for a block of data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="count">Size of block to enumerate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ICanReadSection.Enumerate``1(System.UInt32)">
            <summary>
            Enumerates a block of data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="count">Size of block to enumerate</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICloneStreams">
            <summary>
            Clones streams
            </summary>
        </member>
        <member name="M:BrightData.ICloneStreams.Clone(System.Nullable{System.Int64})">
            <summary>
            Creates a new repeatable section reader
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataSpecificationType">
            <summary>
            Type of data specification
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.Field">
            <summary>
            Represents a field of data
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.Composite">
            <summary>
            Represents an item that holds a set of other items
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.FieldSet">
            <summary>
            Represents a field that takes a value from one of a set of possibilities
            </summary>
        </member>
        <member name="T:BrightData.IDataTypeSpecification">
            <summary>
            Data type specifications can validate a data source
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.Name">
            <summary>
            Name of this item
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.Children">
            <summary>
            Children of this item (optional)
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.UnderlyingType">
            <summary>
            Underlying .net type for this item
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.SpecificationType">
            <summary>
            Item type
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.CanRepeat">
            <summary>
            True if the item can repeat
            </summary>
        </member>
        <member name="T:BrightData.IDataTypeSpecification`1">
            <summary>
            Typed data specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDataTypeSpecification`1.IsValid(`0)">
            <summary>
            Checks if the typed instance is valid against the specification
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTypeSpecification`1.AddPredicate(System.Predicate{`0})">
            <summary>
            Adds an additional predicate that must match to be considered valid
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="T:BrightData.INotifyUser">
            <summary>
            Notifies the user of operations and messages
            </summary>
        </member>
        <member name="M:BrightData.INotifyUser.OnStartOperation(System.String,System.String)">
            <summary>
            Called at the start of an operation
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="msg">Optional message associated with the operation</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnOperationProgress(System.String,System.Single)">
            <summary>
            Called when the operation has progressed
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="progressPercent">Progress percentage (between 0 and 1)</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnCompleteOperation(System.String,System.Boolean)">
            <summary>
            Called when the operation has completed
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="wasCancelled">True if the operation was cancelled</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnMessage(System.String)">
            <summary>
            Called to notify the user
            </summary>
            <param name="msg">Message to user</param>
        </member>
        <member name="T:BrightData.ICountReferences">
            <summary>
            Reference counter
            </summary>
        </member>
        <member name="M:BrightData.ICountReferences.AddRef">
            <summary>
            Adds a reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ICountReferences.Release">
            <summary>
            Removes a reference (and might release the data)
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ICountReferences.IsValid">
            <summary>
            Checks if there is still a valid reference count (and that the data has not been released)
            </summary>
        </member>
        <member name="T:BrightData.ICanIterateData`1">
            <summary>
            Indicates that the type can iterate data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ICanIterateData`1.Enumerate">
            <summary>
            Iterates the data
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ICanIterateData`1.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanRandomlyAccessUnmanagedData`1">
            <summary>
            Indicates that the type can randomly access typed data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ICanRandomlyAccessUnmanagedData`1.Get(System.Int32,`0@)">
            <summary>
            Returns a randomly accessed item
            </summary>
            <param name="index">Item index</param>
            <param name="value">Item value</param>
        </member>
        <member name="M:BrightData.ICanRandomlyAccessUnmanagedData`1.Get(System.UInt32,`0@)">
            <summary>
            Returns a randomly accessed item
            </summary>
            <param name="index">Item index</param>
            <param name="value">Item value</param>
        </member>
        <member name="M:BrightData.ICanRandomlyAccessUnmanagedData`1.GetSpan(System.UInt32,System.UInt32)">
            <summary>
            Returns a span of data
            </summary>
            <param name="startIndex">Inclusive first index of the span</param>
            <param name="count">Size of the span</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanRandomlyAccessData">
            <summary>
            Indicates that the type can randomly access untyped data
            </summary>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData.Item(System.Int32)">
            <summary>
            Returns the untyped item at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData.Item(System.UInt32)">
            <summary>
            Returns the untyped item at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanRandomlyAccessData`1">
            <summary>
            Indicates that the type can randomly access typed data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData`1.Item(System.Int32)">
            <summary>
            Returns the typed at at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData`1.Item(System.UInt32)">
            <summary>
            Returns the typed at at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveMutableReference`1">
            <summary>
            Indicates that type exposes a mutable reference
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.IHaveMutableReference`1.Current">
            <summary>
            The current mutable reference
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyUnmanagedEnumerator`1">
            <summary>
            A read only reference enumerator for unmanaged types
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IReadOnlyUnmanagedEnumerator`1.MoveNext">
            <summary>
            Moves to the next item
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyUnmanagedEnumerator`1.Reset">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyUnmanagedEnumerator`1.Current">
            <summary>
            Returns a readonly reference to the current item
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyBuffer">
            <summary>
            A readonly buffer
            </summary>
        </member>
        <member name="M:BrightData.IReadOnlyBuffer.GetIterator``1(System.Int64,System.Int64)">
            <summary>
            Returns an iterator into the buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="offset">First inclusive byte index to iterate</param>
            <param name="sizeInBytes">Size in bytes of the block to iterate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyBuffer.GetBlock``1(System.Int64,System.Int64)">
            <summary>
            Returns a block of memory from the buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="offset">First inclusive byte index of the block</param>
            <param name="sizeInBytes">Size of the block in bytes</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IConvertStructsToObjects`2">
            <summary>
            Indicates that the type can convert structs to other types
            </summary>
            <typeparam name="CT"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IConvertStructsToObjects`2.Convert(`0@)">
            <summary>
            Converts a struct to another type
            </summary>
            <param name="item">The item to convert</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IOperation`1">
            <summary>
            A generic operation that might require user notification and that can be cancelled
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IOperation`1.Complete(BrightData.INotifyUser,System.Threading.CancellationToken)">
            <summary>
            Tries to complete the operation
            </summary>
            <param name="notifyUser">Optional interface to notify the user of progress</param>
            <param name="cancellationToken">Cancellation token to cancel operation</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTableOrientation">
            <summary>
            Determines if the data table is oriented as either rows or columns
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.Unknown">
            <summary>
            Pathological case
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.RowOriented">
            <summary>
            Data table is stored as a series of rows
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.ColumnOriented">
            <summary>
            Data table is stored as aa series of columns
            </summary>
        </member>
        <member name="T:BrightData.BrightDataType">
            <summary>
            Data types enumeration
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Unknown">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Boolean">
            <summary>
            Boolean values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.SByte">
            <summary>
            Signed byte values (-128 to 128)
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Short">
            <summary>
            Short values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Int">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Long">
            <summary>
            Long values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Float">
            <summary>
            Float values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Double">
            <summary>
            Double values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Decimal">
            <summary>
            Decimal values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.String">
            <summary>
            String values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Date">
            <summary>
            Date values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.IndexList">
            <summary>
            List of indices
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.WeightedIndexList">
            <summary>
            Weighted list of indices
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Vector">
            <summary>
            Vector of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Matrix">
            <summary>
            Matrix of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Tensor3D">
            <summary>
            3D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Tensor4D">
            <summary>
            4D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.BinaryData">
            <summary>
            Binary data
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.TimeOnly">
            <summary>
            Time only
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.DateOnly">
            <summary>
            Date only
            </summary>
        </member>
        <member name="T:BrightData.ColumnClass">
            <summary>
            Column classifications
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Unknown">
            <summary>
            Unknown category
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Categorical">
            <summary>
            Forms a category - a set of possible values
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Numeric">
            <summary>
            Numbers (float, int etc)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Decimal">
            <summary>
            Floating point numbers (float, double, decimal)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Struct">
            <summary>
            Struct (blittable)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Tensor">
            <summary>
            Tensor (vector, matrix etc)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.IndexBased">
            <summary>
            Has an index (index list, weighted index list)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.DateTime">
            <summary>
            Date and time
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Integer">
            <summary>
            Whole number
            </summary>
        </member>
        <member name="T:BrightData.ITypedSegment">
            <summary>
            A segment (series of values) in a table of which each element has the same type
            </summary>
        </member>
        <member name="P:BrightData.ITypedSegment.SegmentType">
            <summary>
            The single type of the segment
            </summary>
        </member>
        <member name="T:BrightData.ITypedSegment`1">
            <summary>
            Typed data table segment (all of the same type)
            </summary>
            <typeparam name="T">Data type of values within the segment</typeparam>
        </member>
        <member name="P:BrightData.ITypedSegment`1.Values">
            <summary>
            Enumerates the values
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ColumnConversionOperation">
            <summary>
            Single column conversion options
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.Unchanged">
            <summary>
            Leave the column unchanged (nop)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToBoolean">
            <summary>
            Convert to boolean
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToDate">
            <summary>
            Convert to date
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToNumeric">
            <summary>
            Convert to numeric (best numeric size will be automatically determined)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToString">
            <summary>
            Convert to string
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToIndexList">
            <summary>
            Convert to index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToWeightedIndexList">
            <summary>
            Convert to weighted index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToVector">
            <summary>
            Convert to vector
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToCategoricalIndex">
            <summary>
            Convert each value to an index within a dictionary
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToByte">
            <summary>
            Convert to signed byte
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToShort">
            <summary>
            Convert to short
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToInt">
            <summary>
            Convert to int
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToLong">
            <summary>
            Convert to long 
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToFloat">
            <summary>
            Convert to float
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToDouble">
            <summary>
            Convert to double
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionOperation.ToDecimal">
            <summary>
            Convert to decimal
            </summary>
        </member>
        <member name="T:BrightData.IConvertColumn">
            <summary>
            Transforms columns
            </summary>
        </member>
        <member name="M:BrightData.IConvertColumn.Finalise(BrightData.MetaData)">
            <summary>
            Complete the transformation
            </summary>
            <param name="metaData">Meta data store to receive transformation information</param>
        </member>
        <member name="T:BrightData.IConvertColumn`2">
            <summary>
            Typed column transformer
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.IConvertColumn`2.Convert(`0,BrightData.ICompositeBuffer{`1},System.UInt32)">
            <summary>
            Writes the converted input to the buffer
            </summary>
            <param name="input"></param>
            <param name="buffer"></param>
            <param name="index">Index within the buffer</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IColumnTransformationParam">
            <summary>
            Information about a column transformation
            </summary>
        </member>
        <member name="P:BrightData.IColumnTransformationParam.ColumnIndex">
            <summary>
            Column index
            </summary>
        </member>
        <member name="M:BrightData.IColumnTransformationParam.GetTransformer(BrightData.BrightDataContext,BrightData.BrightDataType,BrightData.ITypedSegment,System.Func{BrightData.MetaData},BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Gets a column transformer
            </summary>
            <param name="context">Bright data context</param>
            <param name="fromType">Convert from column type</param>
            <param name="column">Column to convert</param>
            <param name="analysedMetaData">Function to produce analysed column meta data if needed</param>
            <param name="tempStreams">Temp stream provider</param>
            <param name="inMemoryRowCount">Number of rows to cache in memory</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IConsumeColumnData">
            <summary>
            Interface that 
            </summary>
        </member>
        <member name="P:BrightData.IConsumeColumnData.ColumnIndex">
            <summary>
            Column index that will be consumed
            </summary>
        </member>
        <member name="P:BrightData.IConsumeColumnData.ColumnType">
            <summary>
            Column type of incoming data
            </summary>
        </member>
        <member name="T:BrightData.IConsumeColumnData`1">
            <summary>
            Typed column consumer that writes to a buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.IDataTableVectoriser">
            <summary>
            Data table vectoriser
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(System.Object[])">
            <summary>
            Vectorise a table row
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(BrightData.ICanRandomlyAccessData)">
            <summary>
            Vectorise a data table segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IDataTableVectoriser.OutputSize">
            <summary>
            Size of the output vectors
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.GetOutputLabel(System.UInt32,System.UInt32)">
            <summary>
            Returns the associated label from the one hot encoding dictionary
            </summary>
            <param name="vectorIndex">Index within one hot encoded vector</param>
            <param name="columnIndex">Data table column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Enumerate">
            <summary>
            Returns a sequence of vectorised table rows
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IReinterpretColumns">
            <summary>
            Reinterpret columns parameters
            </summary>
        </member>
        <member name="P:BrightData.IReinterpretColumns.SourceColumnIndices">
            <summary>
            Source column indices
            </summary>
        </member>
        <member name="M:BrightData.IReinterpretColumns.GetNewColumnOperations(BrightData.BrightDataContext,BrightData.IProvideTempStreams,System.UInt32,BrightData.ICanEnumerateDisposable[])">
            <summary>
            Gets new column operations
            </summary>
            <param name="context">Bright data context</param>
            <param name="tempStreams">Temp stream provider</param>
            <param name="rowCount">Number of rows</param>
            <param name="columns">Source column data</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveLinearAlgebraProvider">
            <summary>
            Gives access to a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.IHaveLinearAlgebraProvider.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.ISetLinearAlgebraProvider">
            <summary>
            Indicates that the type can set a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.ISetLinearAlgebraProvider.LinearAlgebraProvider">
            <summary>
            Property to set the linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.DistanceMetric">
            <summary>
            Distance metrics
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Euclidean">
            <summary>
            Euclidean Distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Cosine">
            <summary>
            Cosine Distance Metric
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Manhattan">
            <summary>
            Manhattan Distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.MeanSquared">
            <summary>
            Means Square Error
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.SquaredEuclidean">
            <summary>
            Square Euclidean
            </summary>
        </member>
        <member name="T:BrightData.ITensorSegment">
            <summary>
            A segment of a float tensor
            </summary>
        </member>
        <member name="P:BrightData.ITensorSegment.SegmentType">
            <summary>
            Segment type
            </summary>
        </member>
        <member name="P:BrightData.ITensorSegment.Item(System.Int32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment.Item(System.UInt32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment.Item(System.Int64)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment.Item(System.UInt64)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment.Values">
            <summary>
            Iterates all values in the segment
            </summary>
        </member>
        <member name="M:BrightData.ITensorSegment.GetArrayIfEasilyAvailable">
            <summary>
            Returns a contiguous array of data only if this is the easily available (null otherwise)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorSegment.ToNewArray">
            <summary>
            Creates a new array from the segment
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorSegment.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <summary>
            Copies from the span into the segment
            </summary>
            <param name="span">Span to copy from</param>
            <param name="targetOffset">Index into this segment to replace from</param>
        </member>
        <member name="M:BrightData.ITensorSegment.CopyTo(BrightData.ITensorSegment,System.UInt32,System.UInt32)">
            <summary>
            Copies this segment to another segment
            </summary>
            <param name="segment">Segment to copy to</param>
            <param name="sourceOffset">Index within this segment to copy from</param>
            <param name="targetOffset">Index within other segment to replace from</param>
        </member>
        <member name="M:BrightData.ITensorSegment.CopyTo(System.Span{System.Single})">
            <summary>
            Copies this segment to a span
            </summary>
            <param name="destination">Destination span</param>
        </member>
        <member name="M:BrightData.ITensorSegment.CopyTo(System.Single*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies to a pointer
            </summary>
            <param name="destination">Pointer to memory to copy to</param>
            <param name="sourceOffset">Index within this segment to copy from</param>
            <param name="stride">Increment after each copy</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="M:BrightData.ITensorSegment.Clear">
            <summary>
            Sets each value within the segment to zero
            </summary>
        </member>
        <member name="M:BrightData.ITensorSegment.GetSpan(Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <summary>
            Returns a span from the current segment
            </summary>
            <param name="temp">Optional buffer that might be needed when creating the span</param>
            <param name="wasTempUsed">True if the buffer was used</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorSegment.GetSpan(System.UInt32)">
            <summary>
            Returns a span from the current segment
            </summary>
            <param name="offset">Index within this segment to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorSegment.GetUnderlyingArray">
            <summary>
            Returns the underlying array used by the segment (if available)
            </summary>
            <returns>Array, segment offset and segment stride</returns>
        </member>
        <member name="P:BrightData.ITensorSegment.IsWrapper">
            <summary>
            True if the segment wraps another segment
            </summary>
        </member>
        <member name="T:BrightData.IHaveTensorSegment">
            <summary>
            Indicates that there is an underlying tensor segment
            </summary>
        </member>
        <member name="P:BrightData.IHaveTensorSegment.Segment">
            <summary>
            Underlying tensor segment
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyVector">
            <summary>
            Vector that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyVector.Item(System.Int32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyVector.Item(System.UInt32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyVector.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a mutable version of this vector
            </summary>
            <param name="lap"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IReadOnlyMatrix">
            <summary>
            Matrix that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyMatrix.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyMatrix.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyMatrix.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a mutable version of this matrix
            </summary>
            <param name="lap"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.GetRow(System.UInt32)">
            <summary>
            Returns a row from the matrix
            </summary>
            <param name="rowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.GetColumn(System.UInt32)">
            <summary>
            Returns a column from the matrix
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.AllRows(System.Boolean)">
            <summary>
            Returns all rows as an array
            </summary>
            <param name="makeCopy">True to make a copy of each row</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.AllColumns(System.Boolean)">
            <summary>
            Returns all columns as an array
            </summary>
            <param name="makeCopy">True to make a copy of each column</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IReadOnlyTensor3D">
            <summary>
            3D tensor that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.Depth">
            <summary>
            Number of matrices
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.MatrixSize">
            <summary>
            Rows * Columns
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor3D.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a mutable version of this 3D tensor
            </summary>
            <param name="lap"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor3D.GetReadOnlyMatrix(System.UInt32)">
            <summary>
            Returns a matrix from the 3D tensor
            </summary>
            <param name="index">Matrix index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor3D.AllMatrices">
            <summary>
            Returns all matrices as an array
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IReadOnlyTensor4D">
            <summary>
            4D tensor that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.Count">
            <summary>
            Number of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.Depth">
            <summary>
            Number of matrices in each 3D tensor
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.RowCount">
            <summary>
            Number of rows in each matrix
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.ColumnCount">
            <summary>
            Number of columns in each matrix
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.MatrixSize">
            <summary>
            RowCount * ColumnCount
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.TensorSize">
            <summary>
            MatrixSize * Depth
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor4D.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a mutable 4D version of this 4D tensor
            </summary>
            <param name="lap"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor">
            <summary>
            Untyped tensor interface - vector, matrix, 3D tensor etc
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Context">
            <summary>
            Underlying bright data context
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Segment">
            <summary>
            Underlying segment
            </summary>
        </member>
        <member name="M:BrightData.ITensor.Reshape">
            <summary>
            Reshapes to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a matrix
            </summary>
            <param name="rows">Row count of each matrix (one parameter is optional null)</param>
            <param name="columns">Column count of each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 3D tensor
            </summary>
            <param name="depth">Number of matrices (one parameter is optional null)</param>
            <param name="rows">Number of rows in each matrix (one parameter is optional null)</param>
            <param name="columns">Number of columns in each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors (one parameter is optional null)</param>
            <param name="depth">Number of matrices in each 3D tensor (one parameter is optional null)</param>
            <param name="rows">Number of rows in each matrix (one parameter is optional null)</param>
            <param name="columns">Number of columns in each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Clear">
            <summary>
            Sets all values to zero
            </summary>
        </member>
        <member name="M:BrightData.ITensor.Clone">
            <summary>
            Creates a copy of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor.TotalSize">
            <summary>
            Total count of all values
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Shape">
            <summary>
            Tensor shape - for a vector the array will have a single element, for a matrix it will be [columns, rows], a 3D tensor will be [columns, rows, depth] etc
            </summary>
        </member>
        <member name="M:BrightData.ITensor.AddInPlace(BrightData.ITensor)">
            <summary>
            Adds a tensor to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.AddInPlace(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Adds a tensor to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.AddInPlace(System.Single)">
            <summary>
            Adds a value to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="scalar">Value to add</param>
        </member>
        <member name="M:BrightData.ITensor.MultiplyInPlace(System.Single)">
            <summary>
            Multiplies a value to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="scalar">Value to multiply</param>
        </member>
        <member name="M:BrightData.ITensor.SubtractInPlace(BrightData.ITensor)">
            <summary>
            Subtracts a tensor from this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.SubtractInPlace(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Subtracts a tensor from this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.PointwiseMultiplyInPlace(BrightData.ITensor)">
            <summary>
            Multiplies each value in this tensor with the corresponding value in the other tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.PointwiseDivideInPlace(BrightData.ITensor)">
            <summary>
            Divides each value in this tensor with the corresponding value in the other tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.DotProduct(BrightData.ITensor)">
            <summary>
            Computes the dot product of this tensor with another tensor (of same length)
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Search(System.Single,System.Single)">
            <summary>
            Returns the index of the value in this tensor (if any)
            </summary>
            <param name="value">Value to find</param>
            <param name="tolerance">Maximum difference between values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.ConstrainInPlace(System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Modifies this tensor so that no value is less than or greater than supplied parameters
            </summary>
            <param name="minValue">Minimum value to allow (optional)</param>
            <param name="maxValue">Maximum value to allow (optional)</param>
        </member>
        <member name="M:BrightData.ITensor.Average">
            <summary>
            Finds the average value of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.L1Norm">
            <summary>
            Returns the L1 norm of this tensor (manhattan distance)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.L2Norm">
            <summary>
            Returns the L2 norm of this tensor (euclidean norm)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.GetMinAndMaxValues">
            <summary>
            Finds the minimum and maximum values (and those indices) from this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.GetMinIndex">
            <summary>
            Returns the index of the minimum value from this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.GetMaxIndex">
            <summary>
            Returns the index of the maximum value from this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.GetMin">
            <summary>
            Returns the minimum value from this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.GetMax">
            <summary>
            Returns the maximum value from this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.IsEntirelyFinite">
            <summary>
            Checks if the tensor is entirely finite (does not contain NAN or Infinity)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.CosineDistance(BrightData.ITensor)">
            <summary>
            Calculates the cosine distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.EuclideanDistance(BrightData.ITensor)">
            <summary>
            Calculates the euclidean distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.MeanSquaredDistance(BrightData.ITensor)">
            <summary>
            Calculates the mean squared distance between this and another tensor
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.SquaredEuclideanDistance(BrightData.ITensor)">
            <summary>
            Calculates the squared euclidean distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.ManhattanDistance(BrightData.ITensor)">
            <summary>
            Calculates the manhattan distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.StdDev(System.Nullable{System.Single})">
            <summary>
            Calculates the standard deviation of this tensor
            </summary>
            <param name="mean">Existing mean of tensor if available (otherwise it will be calculated)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.RoundInPlace(System.Single,System.Single)">
            <summary>
            Rounds each value in this tensor to either the lower or upper parameter (the result will be stored in this tensor)
            </summary>
            <param name="lower"></param>
            <param name="upper"></param>
        </member>
        <member name="M:BrightData.ITensor.MapInPlace(System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value of this tensor (the result will be stored in this tensor)
            </summary>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.ITensor.L1RegularisationInPlace(System.Single)">
            <summary>
            Applies L1 regularization to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="coefficient"></param>
        </member>
        <member name="M:BrightData.ITensor.Sum">
            <summary>
            Sums all values of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor`1">
            <summary>
            Typed tensor interface - vector, matrix, 3D tensor etc
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ITensor`1.Clone">
            <summary>
            Creates a clone of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Add(BrightData.ITensor)">
            <summary>
            Adds a tensor to this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Add(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Adds a tensor to this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Coefficient to multiply each value in this tensor</param>
            <param name="coefficient2">Coefficient to multiply each value in the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Add(System.Single)">
            <summary>
            Adds a value to each element in this tensor
            </summary>
            <param name="scalar">Value to add</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Multiply(System.Single)">
            <summary>
            Multiplies a value to each element in this tensor
            </summary>
            <param name="scalar">Value to multiply</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Subtract(BrightData.ITensor)">
            <summary>
            Subtracts another tensor from this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Subtract(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Subtracts another tensor from this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Coefficient to multiply each value in this tensor</param>
            <param name="coefficient2">Coefficient to multiply each value in the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.PointwiseMultiply(BrightData.ITensor)">
            <summary>
            Multiplies each value in this tensor with the corresponding value in another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.PointwiseDivide(BrightData.ITensor)">
            <summary>
            Divides each value in this tensor with the corresponding value in another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Sqrt">
            <summary>
            Returns the square root of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Reverse">
            <summary>
            Reverses the order of the elements in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Split(System.UInt32)">
            <summary>
            Splits this tensor into multiple contiguous tensors
            </summary>
            <param name="blockCount">Number of blocks</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Abs">
            <summary>
            Computes the absolute value of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Log">
            <summary>
            Computes the natural logarithm of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Exp">
            <summary>
            Computes the exponent of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Squared">
            <summary>
            Computes the square of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Sigmoid">
            <summary>
            Computes the sigmoid function of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.SigmoidDerivative">
            <summary>
            Computes the sigmoid derivative for each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Tanh">
            <summary>
            Computes the hyperbolic tangent of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.TanhDerivative">
            <summary>
            Computes the derivative of the hyperbolic tangent for each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Relu">
            <summary>
            Computes the RELU activation for each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.ReluDerivative">
            <summary>
            Computes the RELU derivative of each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.LeakyRelu">
            <summary>
            Computes the Leaky RELU action for each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.LeakyReluDerivative">
            <summary>
            Computes the Leaky RELU derivative for each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Softmax">
            <summary>
            Computes the softmax of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.SoftmaxDerivative">
            <summary>
            Computes the softmax derivative of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Pow(System.Single)">
            <summary>
            Raises each element in this tensor by power
            </summary>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.CherryPick(System.UInt32[])">
            <summary>
            Returns a new tensor with the values specified in indices
            </summary>
            <param name="indices">Indices to return in new tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Map(System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to this tensor
            </summary>
            <param name="mutator">Mapping function</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IVector">
            <summary>
            Vector interface
            </summary>
        </member>
        <member name="P:BrightData.IVector.Item(System.Int32)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IVector.Item(System.UInt32)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IVector.Item(System.Int64)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IVector.Item(System.UInt64)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IVector.MapIndexed(System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function that also accepts the vector index
            </summary>
            <param name="mutator"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IVector.MapIndexedInPlace(System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function that also accepts the vector index (vector will be modified in place)
            </summary>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.IVector.ToArray">
            <summary>
            Returns all values in an array
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IMatrix">
            <summary>
            Matrix interface
            </summary>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.Int64,System.Int64)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Row(System.UInt32,BrightData.ITensorSegment)">
            <summary>
            Returns a row from the matrix
            </summary>
            <param name="index">Row index</param>
            <param name="segment">Optional segment to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Column(System.UInt32,BrightData.ITensorSegment)">
            <summary>
            Returns a column from the matrix
            </summary>
            <param name="index">Column index</param>
            <param name="segment">Optional segment to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetRowSpan(System.UInt32,Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@)">
            <summary>
            Returns a row as a span
            </summary>
            <param name="rowY">Row index</param>
            <param name="temp">Temporary buffer in which to write the contiguous row values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetColumnSpan(System.UInt32)">
            <summary>
            Returns a column as a span
            </summary>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetRowVector(System.UInt32)">
            <summary>
            Returns a row as a vector
            </summary>
            <param name="rowY">Row index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetColumnVector(System.UInt32)">
            <summary>
            Returns a column as a vector
            </summary>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Transpose">
            <summary>
            Returns the transpose of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Multiply(BrightData.IMatrix)">
            <summary>
            Multiply this matrix with another matrix (matrix multiplication)
            </summary>
            <param name="other">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.TransposeAndMultiply(BrightData.IMatrix)">
            <summary>
            Transpose the other matrix and then multiply with this matrix
            </summary>
            <param name="other">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.TransposeThisAndMultiply(BrightData.IMatrix)">
            <summary>
            Transpose this matrix and then multiply with another matrix
            </summary>
            <param name="other">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetDiagonal">
            <summary>
            Returns the diagonal of this matrix 
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.RowSums">
            <summary>
            Returns the sum of all rows in this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.ColumnSums">
            <summary>
            Returns the sum of all columns in this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Multiply(BrightData.IVector)">
            <summary>
            Multiplies this matrix with a vector
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.SplitAtColumn(System.UInt32)">
            <summary>
            Splits this matrix into two matrices from a column index
            </summary>
            <param name="columnIndex">Column index at which to split</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.SplitAtRow(System.UInt32)">
            <summary>
            Splits this matrix into two matrices from a row index
            </summary>
            <param name="rowIndex">Row index at which to split</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.ConcatBelow(BrightData.IMatrix)">
            <summary>
            Concatenates this matrix with another matrix (column counts must agree)
            </summary>
            <param name="bottom"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.ConcatRight(BrightData.IMatrix)">
            <summary>
            Concatenates this matrix with another matrix (row counts must agree)
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.MapIndexed(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <summary>
            Applies an indexed mapping function to this matrix
            </summary>
            <param name="mutator"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.MapIndexedInPlace(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <summary>
            Applies an indexed mapping function to this matrix (matrix will be modified in place)
            </summary>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.IMatrix.Svd">
            <summary>
            Computes the singular value decomposition of this matrix
            https://en.wikipedia.org/wiki/Singular_value_decomposition
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetNewMatrixFromRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates a new matrix from the specified rows of this matrix
            </summary>
            <param name="rowIndices">Row indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetNewMatrixFromColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates a new matrix from the specified columns of this matrix
            </summary>
            <param name="columnIndices">Column indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.AddToEachRow(BrightData.ITensorSegment)">
            <summary>
            Adds a tensor segment to each row of this matrix (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.AddToEachColumn(BrightData.ITensorSegment)">
            <summary>
            Adds a tensor segment to each column of this matrix (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.MultiplyEachRowWith(BrightData.ITensorSegment)">
            <summary>
            Multiplies each row of this matrix with a tensor segment (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.MultiplyEachColumnWith(BrightData.ITensorSegment)">
            <summary>
            Multiplies each column of this matrix with a tensor segment (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.SoftmaxPerRow">
            <summary>
            Computes the per row software of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.SoftmaxDerivativePerRow(BrightData.ITensorSegment[])">
            <summary>
            Computes the per row softmax derivative of this matrix
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor3D">
            <summary>
            3D tensor - a block of matrices
            </summary>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.GetMatrix(System.UInt32)">
            <summary>
            Returns a matrix from the tensor
            </summary>
            <param name="index">Matrix index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AddPadding(System.UInt32)">
            <summary>
            Creates a new 3D tensor with a "padding" of zeroes around the edge of each matrix
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.RemovePadding(System.UInt32)">
            <summary>
            Removes previously added "padding" from the edge of each matrix
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Image to column (convolution operator)
            </summary>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="xStride">Horizontal stride</param>
            <param name="yStride">Vertical stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a previous image to column operation (convolution)
            </summary>
            <param name="filter"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="outputDepth"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Computes a max pooling operation
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <param name="saveIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.ReverseMaxPool(BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a max pooling operation
            </summary>
            <param name="indices"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AddAllMatrices">
            <summary>
            Adds all matrices into one new matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.MultiplyEachMatrixBy(BrightData.IMatrix)">
            <summary>
            Multiply each matrix individually by another matrix
            </summary>
            <param name="matrix">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.TransposeAndMultiplyEachMatrixBy(BrightData.IMatrix)">
            <summary>
            Transpose another matrix and multiply each matrix individually by the result
            </summary>
            <param name="matrix">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AddToEachRow(BrightData.IVector)">
            <summary>
            Adds a vector to each row of each matrix (tensor will be modified in place)
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.ITensor3D.AddToEachColumn(BrightData.IVector)">
            <summary>
            Adds a vector to each column of each matrix (tensor will be modified in place)
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.ITensor3D.Multiply(BrightData.ITensor4D)">
            <summary>
            Multiplies this matrix with a 4D tensor
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.TransposeAndMultiply(BrightData.ITensor4D)">
            <summary>
            Transposes the 4D matrix and multiplies this tensor with the result
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.TransposeThisAndMultiply(BrightData.ITensor4D)">
            <summary>
            Transposes this tensor and multiply the result with another 4D tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor4D">
            <summary>
            4D tensor - a block of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.GetTensor(System.UInt32)">
            <summary>
            Returns a 3D tensor
            </summary>
            <param name="index">3D tensor index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.AddPadding(System.UInt32)">
            <summary>
            Adds padding to each 3D tensor
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.RemovePadding(System.UInt32)">
            <summary>
            Removes padding from each 3D tensor
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Max pooling operation
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <param name="saveIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.ReverseMaxPool(BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverse max pooling operation
            </summary>
            <param name="indices"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Image to column (convolution operator)
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverse of image to column (convolution operator)
            </summary>
            <param name="filter"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="outputDepth"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.ColumnSums">
            <summary>
            Computes the sum of all columns
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.RowSums">
            <summary>
            Computes the sum of all rows
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.LinearAlgebra.ArrayBasedLinearAlgebraProvider">
            <summary>
            Array based linear algebra provider
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedLinearAlgebraProvider.CreateSegment(System.UInt32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.ArrayBasedTensorSegment">
            <summary>
            A tensor segment based on a float array
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.#ctor(System.Single[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Array of values</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.IsValid">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.SegmentType">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Item(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Item(System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Item(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.GetArrayIfEasilyAvailable">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.ToNewArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.CopyTo(BrightData.ITensorSegment,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.CopyTo(System.Span{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.CopyTo(System.Single*,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.GetSpan(Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.GetSpan(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.GetUnderlyingArray">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayBasedTensorSegment.IsWrapper">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayBasedTensorSegment.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.ArrayPoolTensorSegment">
            <summary>
            A tensor segment that temporarily owns a buffer from an array pool
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.#ctor(Microsoft.Toolkit.HighPerformance.Buffers.MemoryOwner{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="data">Rented buffer from pool</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.IsValid">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.SegmentType">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.IsWrapper">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Item(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Item(System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Item(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.GetArrayIfEasilyAvailable">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.ToNewArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.CopyTo(BrightData.ITensorSegment,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.CopyTo(System.Span{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.CopyTo(System.Single*,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.GetSpan(Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.GetSpan(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.GetUnderlyingArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ArrayPoolTensorSegment.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightMatrix`1">
            <summary>
            Matrix type
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.Int64,System.Int64)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Row(System.UInt32,BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Column(System.UInt32,BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetRowSpan(System.UInt32,Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetColumnSpan(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Create(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetRow(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetColumn(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AllRows(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AllColumns(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetRowVector(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetColumnVector(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Transpose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Multiply(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetDiagonal">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.RowSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ColumnSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Multiply(BrightData.IVector)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.TransposeAndMultiply(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.TransposeThisAndMultiply(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MapIndexed(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MapIndexedInPlace(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SplitAtColumn(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SplitAtRow(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ConcatBelow(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ConcatRight(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Svd">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetNewMatrixFromRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetNewMatrixFromColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AddToEachRow(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AddToEachColumn(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MultiplyEachRowWith(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MultiplyEachColumnWith(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SoftmaxPerRow">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SoftmaxDerivativePerRow(BrightData.ITensorSegment[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightMatrix">
            <summary>
            Matrix type
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor3D`1">
            <summary>
            3D tensor
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,System.UInt32,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Rows in each matrix</param>
            <param name="columns">Columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Create(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Depth">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.MatrixSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AllMatrices">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.GetMatrix(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddPadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.RemovePadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.ReverseMaxPool(BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddAllMatrices">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.MultiplyEachMatrixBy(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.TransposeAndMultiplyEachMatrixBy(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddToEachRow(BrightData.IVector)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddToEachColumn(BrightData.IVector)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Multiply(BrightData.ITensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.TransposeAndMultiply(BrightData.ITensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.TransposeThisAndMultiply(BrightData.ITensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor3D">
            <summary>
            3D tensor 
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,System.UInt32,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Rows in each matrix</param>
            <param name="columns">Columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor4D`1">
            <summary>
            4D tensor
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,System.UInt32,System.UInt32,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.Create(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Count">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Depth">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.MatrixSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.TensorSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.GetTensor(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.AddPadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.RemovePadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ReverseMaxPool(BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ColumnSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.RowSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor4D">
            <summary>
            4D tensor
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,System.UInt32,System.UInt32,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensorBase`2">
            <summary>
            Base tensor type
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="F:BrightData.LinearAlgebra.BrightTensorBase`2.Lap">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Create(BrightData.ITensorSegment)">
            <summary>
            Creates a typed tensor from a tensor segment
            </summary>
            <param name="segment">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.Segment">
            <summary>
            Underlying tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.Context">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.LinearAlgebraProvider">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetFloatSpan(Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Map(System.Func{System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.MapInPlace(System.Func{System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Clone">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Add(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Add(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Add(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.AddInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.AddInPlace(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.AddInPlace(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.MultiplyInPlace(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Multiply(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Subtract(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Subtract(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SubtractInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SubtractInPlace(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseMultiply(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseMultiplyInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseDivide(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseDivideInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.DotProduct(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Sqrt">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Search(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.ConstrainInPlace(System.Nullable{System.Single},System.Nullable{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Average">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.L1Norm">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.L2Norm">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetMinAndMaxValues">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetMinIndex">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetMaxIndex">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetMin">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetMax">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.IsEntirelyFinite">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reverse">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Split(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.CosineDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.EuclideanDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.MeanSquaredDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SquaredEuclideanDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.ManhattanDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Abs">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Log">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Exp">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Squared">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.StdDev(System.Nullable{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Sigmoid">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SigmoidDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Tanh">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.TanhDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Relu">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.ReluDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.LeakyRelu">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.LeakyReluDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Softmax">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SoftmaxDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Pow(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.RoundInPlace(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.CherryPick(System.UInt32[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.L1RegularisationInPlace(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Sum">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightVector`1">
            <summary>
            Vector
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.#ctor(BrightData.ITensorSegment,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.Int32)">
            <summary>
            Returns a value from the vector
            </summary>
            <param name="index">Index to return</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.UInt32)">
            <summary>
            Returns a value from the vector
            </summary>
            <param name="index">Index to return</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.Int64)">
            <summary>
            Returns a value from the vector
            </summary>
            <param name="index">Index to return</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.UInt64)">
            <summary>
            Returns a value from the vector
            </summary>
            <param name="index">Index to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.ToArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.Create(BrightData.ITensorSegment)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.MapIndexed(System.Func{System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.MapIndexedInPlace(System.Func{System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightVector">
            <summary>
            Vector
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector.#ctor(BrightData.ITensorSegment,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="F:BrightData.LinearAlgebra.LinearAlgebraProvider.Scope">
            <summary>
            A scope of disposable objects
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.#ctor(BrightData.BrightDataContext)">
            <summary>
            Constructor
            </summary>
            <param name="context">Bright data context</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Finalize">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.ProviderName">
            <summary>
            Provider name
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.VectorType">
            <summary>
            Type of vectors that will be created
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.MatrixType">
            <summary>
            Type of matrices that will be created
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.Tensor3DType">
            <summary>
            Type of 3D tensors that will be created
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.Tensor4DType">
            <summary>
            Type of 4D tensors that will be created
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PushScope">
            <summary>
            Adds a new scope
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PopScope">
            <summary>
            Pops that last scope and disposes all objects within that scope
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateSegment(System.Single[])">
            <summary>
            Creates a tensor segment from an array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateSegment(System.UInt32,System.Boolean)">
            <summary>
            Creates a tensor segment
            </summary>
            <param name="size">Segment size</param>
            <param name="initialiseToZero">True to initialize the all values in the segment to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateSegment(System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a tensor segment
            </summary>
            <param name="size">Segment size</param>
            <param name="initializer">Function to initialize each value in the segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Clone(BrightData.ITensorSegment)">
            <summary>
            Creates a clone of the tensor segment
            </summary>
            <param name="segment">Segment to clone</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.ITensorSegment)">
            <summary>
            Creates a vector from a tensor segment
            </summary>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.UInt32,System.Boolean)">
            <summary>
            Creates a vector
            </summary>
            <param name="size">Size of the vector</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.Single[])">
            <summary>
            Creates a vector from an array of floats
            </summary>
            <param name="data">Float array</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.UInt32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="size">Size of the vector</param>
            <param name="value">Initial value of each item in the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.ReadOnlySpan{System.Single})">
            <summary>
            Creates a vector from a span of floats
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="size">Size of the vector</param>
            <param name="initializer">Function to initialize each value in the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.IVector)">
            <summary>
            Creates a new vector from an existing vector
            </summary>
            <param name="vector">Vector to clone</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.IReadOnlyVector)">
            <summary>
            Creates a vector from a read only vector
            </summary>
            <param name="vector">Read only vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Creates a vector from an enumerable of floats
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,BrightData.ITensorSegment)">
            <summary>
            Creates a matrix from a segment
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a matrix
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="initializer">Function to initialize each value in the matrix that will receive (row index, column index)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(BrightData.IMatrix)">
            <summary>
            Creates a new matrix from an existing matrix
            </summary>
            <param name="matrix">Matrix to clone</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(BrightData.IReadOnlyMatrix)">
            <summary>
            Creates a matrix from a read only matrix
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(BrightData.IVector[])">
            <summary>
            Creates a matrix from the rows supplied as vectors
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from the rows supplied as read only vectors
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.Collections.Generic.IEnumerable{System.Single[]})">
            <summary>
            Creates a matrix from the rows supplied
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.Single[][])">
            <summary>
            Creates a matrix from the rows supplied
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRowsAndThenDisposeInput(BrightData.IVector[])">
            <summary>
            Creates a matrix from the rows supplied as vectors and then disposes each input vector
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(BrightData.ITensorSegment[])">
            <summary>
            Creates a matrix from the rows supplied as tensor segments
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.ReadOnlySpan{BrightData.ITensorSegment})">
            <summary>
            Creates a matrix from the rows supplied as tensor segments
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.ReadOnlySpan{System.Single[]})">
            <summary>
            Creates a matrix from rows supplied
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(BrightData.IVector[])">
            <summary>
            Creates a matrix from the columns supplied as vectors
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from the columns supplied as read only vectors
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.Collections.Generic.IEnumerable{System.Single[]})">
            <summary>
            Creates a matrix from the columns supplied
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.Single[][])">
            <summary>
            Creates a matrix from the columns supplied
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumnsAndThenDisposeInput(BrightData.IVector[])">
            <summary>
            Creates a matrix from the columns supplied as vectors and then disposes each input vector
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(BrightData.ITensorSegment[])">
            <summary>
            Creates a matrix from the columns supplied as tensor segments
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.ReadOnlySpan{BrightData.ITensorSegment})">
            <summary>
            Creates a matrix from the columns supplied as tensor segments
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.ReadOnlySpan{System.Single[]})">
            <summary>
            Creates a matrix from the columns supplied
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(System.UInt32,System.UInt32,System.UInt32,BrightData.ITensorSegment)">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rowCount">Rows in each matrix</param>
            <param name="columnCount">Columns in each matrix</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rowCount">Rows in each matrix</param>
            <param name="columnCount">Columns in each matrix</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.IMatrix[])">
            <summary>
            Creates a 3D tensor from existing matrices
            </summary>
            <param name="matrices">Matrices that will form the 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.IReadOnlyMatrix[])">
            <summary>
            Creates a 3D tensor from existing matrices
            </summary>
            <param name="matrices">Matrices that will form the 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.ITensor3D)">
            <summary>
            Creates a 3D tensor from another 3D tensor (clone)
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.IReadOnlyTensor3D)">
            <summary>
            Creates a 3D tensor from a read only 3D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3DAndThenDisposeInput(BrightData.IMatrix[])">
            <summary>
            Creates a 3D tensor from existing matrices and then disposes each matrix
            </summary>
            <param name="matrices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3DAndThenDisposeInput(System.Span{BrightData.IMatrix})">
            <summary>
            Creates a 3D tensor from existing matrices and then disposes each matrix
            </summary>
            <param name="matrices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D``1(System.Span{``0})">
            <summary>
            Creates a 3D tensor from existing matrices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matrices"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(System.UInt32,System.UInt32,System.UInt32,System.UInt32,BrightData.ITensorSegment)">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rowCount">Number of rows in each matrix</param>
            <param name="columnCount">Number of columns in each matrix</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rowCount">Number of rows in each matrix</param>
            <param name="columnCount">Number of columns in each matrix</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.ITensor3D[])">
            <summary>
            Creates a 4D tensor from existing 3D tensors
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.IReadOnlyTensor3D[])">
            <summary>
            Creates a 4D tensor from existing 3D tensors
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.ITensor4D)">
            <summary>
            Clones this 4D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.IReadOnlyTensor4D)">
            <summary>
            Creates a 4D tensor from an existing 4D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4DAndThenDisposeInput(BrightData.ITensor3D[])">
            <summary>
            Creates a 4D tensor from existing 3D tensors and then disposes each 3D tensor
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4DAndThenDisposeInput(System.Span{BrightData.ITensor3D})">
            <summary>
            Creates a 4D tensor from existing 3D tensors and then disposes each 3D tensor
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D``1(System.Span{``0})">
            <summary>
            Creates a 4D tensor from existing 3D tensors
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensors"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetSize(BrightData.ITensorSegment,BrightData.ITensorSegment)">
            <summary>
            Returns the size from both tensors (the size is expected to be the same)
            </summary>
            <param name="tensor"></param>
            <param name="tensor2"></param>
            <returns></returns>
            <exception cref="T:System.Exception">Throws an exception if the tensors are a different size</exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallel(BrightData.ITensorSegment,System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment to create a new segment (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives each value from the segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallelInPlace(BrightData.ITensorSegment,System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment in place (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives each value from the segment</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallel(BrightData.ITensorSegment,System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment to create a new segment (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives the index and each value from the segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallelInPlace(BrightData.ITensorSegment,System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment in place (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives the index and each value from the segment</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor(System.UInt32[],BrightData.ITensorSegment)">
            <summary>
            Creates a tensor from a tensor shape
            </summary>
            <param name="shape">Array containing the size of each dimension in the tensor</param>
            <param name="segment">Tensor segment</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:BrightData.LinearAlgebra.TensorSegmentWrapper">
            <summary>
            A tensor segment that wraps another tensor segment
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.#ctor(BrightData.ITensorSegment,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="segment">Tensor segment to wrap</param>
            <param name="offset">First index within the wrapped tensor segment</param>
            <param name="stride">Stride within the wrapped tensor segment</param>
            <param name="length">Number of values in this tensor segment</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.IsValid">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.SegmentType">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.UnderlyingSegment">
            <summary>
            The segment that was wrapped by this tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Offset">
            <summary>
            First index within the wrapped tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Stride">
            <summary>
            Stride within the wrapped tensor segment 
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.IsWrapper">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Item(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Item(System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Item(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorSegmentWrapper.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.GetArrayIfEasilyAvailable">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.ToNewArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.CopyTo(BrightData.ITensorSegment,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.CopyTo(System.Span{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.CopyTo(System.Single*,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.GetSpan(Microsoft.Toolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.GetSpan(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.GetUnderlyingArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorSegmentWrapper.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.MetaData">
            <summary>
            Unstructured meta data store
            </summary>
        </member>
        <member name="M:BrightData.MetaData.#ctor(BrightData.MetaData,System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="metaData">Existing meta data to copy from</param>
            <param name="keys">Keys to copy (or all if none specified)</param>
        </member>
        <member name="M:BrightData.MetaData.#ctor(BrightData.IHaveMetaData,System.String[])">
            <summary>
            
            </summary>
            <param name="metaData"></param>
            <param name="keys"></param>
        </member>
        <member name="M:BrightData.MetaData.#ctor(System.IO.BinaryReader)">
            <summary>
            Creates meta data from a binary reader
            </summary>
            <param name="reader">Reader</param>
        </member>
        <member name="M:BrightData.MetaData.CopyTo(BrightData.MetaData)">
            <summary>
            Copies this to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
        </member>
        <member name="M:BrightData.MetaData.CopyTo(BrightData.MetaData,System.String[])">
            <summary>
            Copies the specified values to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keysToCopy">Values to copy</param>
        </member>
        <member name="M:BrightData.MetaData.CopyAllExcept(BrightData.MetaData,System.String[])">
            <summary>
            Copies all except for the specified values to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keys">Values NOT to copy (i.e. skip)</param>
        </member>
        <member name="M:BrightData.MetaData.Get(System.String)">
            <summary>
            Returns a value
            </summary>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.GetNullable``1(System.String)">
            <summary>
            Returns a typed nullable value
            </summary>
            <param name="name">Name of the value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.Get``1(System.String,``0)">
            <summary>
            Returns a typed value
            </summary>
            <param name="name">Name of the value</param>
            <param name="valueIfMissing">Value to return if the value has not been set</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.Get``1(System.String)">
            <summary>
            Returns an existing value (throws if not found)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.Set``1(System.String,``0)">
            <summary>
            Sets a named value
            </summary>
            <param name="name">Name of the value</param>
            <param name="value">Value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:BrightData.MetaData.AsXml">
            <summary>
            XML representation of the meta data
            </summary>
        </member>
        <member name="M:BrightData.MetaData.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes meta data
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.MetaData.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads values from a binary reader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:BrightData.MetaData.GetStringsWithPrefix(System.String)">
            <summary>
            Returns all value names with the specified prefix
            </summary>
            <param name="prefix">Prefix to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.GetNonEmpty">
            <summary>
            Returns non empty metadata
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Has(System.String)">
            <summary>
            Checks if a value has been set
            </summary>
            <param name="key">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.MetaData.Remove(System.String)">
            <summary>
            Removes a value
            </summary>
            <param name="key">Name of the value</param>
        </member>
        <member name="P:BrightData.MetaData.AllKeys">
            <summary>
            Returns all keys that have been set
            </summary>
        </member>
        <member name="M:BrightData.MetaData.Clone">
            <summary>
            Creates a clone of the current metadata
            </summary>
        </member>
        <member name="T:BrightData.Serialisation.SerialisationHelper">
            <summary>
            Serialisation helpers
            </summary>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.String,System.IO.BinaryWriter)">
            <summary>
            Writes the string
            </summary>
            <param name="str"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Int32,System.IO.BinaryWriter)">
            <summary>
            Writes the integer
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.UInt32,System.IO.BinaryWriter)">
            <summary>
            Writes the uint
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Double,System.IO.BinaryWriter)">
            <summary>
            Writes the double
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Single,System.IO.BinaryWriter)">
            <summary>
            Writes the float
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo``1(System.Nullable{``0},System.IO.BinaryWriter,System.Action{``0})">
            <summary>
            Conditionally writes a nullable value
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
            <param name="onWrite"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadNullable``1(System.IO.BinaryReader,System.Func{``0})">
            <summary>
            Conditionally reads a nullable value
            </summary>
            <param name="reader"></param>
            <param name="onRead"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.Collections.Generic.IReadOnlyCollection{BrightData.ICanWriteToBinaryWriter},System.IO.BinaryWriter)">
            <summary>
            Writes the collection of items
            </summary>
            <param name="list"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo``1(``0[],System.IO.BinaryWriter)">
            <summary>
            Writes the array
            </summary>
            <param name="array"></param>
            <param name="writer"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo``1(``0[][],System.IO.BinaryWriter)">
            <summary>
            Writes an array of arrays to a binary writer
            </summary>
            <param name="arrayOfArrays"></param>
            <param name="writer"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadArrayOfArrays``1(System.IO.BinaryReader)">
            <summary>
            Reads an array of arrays from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.String[],System.IO.BinaryWriter)">
            <summary>
            Writes the array of strings
            </summary>
            <param name="array"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.Create``1(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a new object after reading its serialized data from the reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadArray``1(System.IO.BinaryReader,BrightData.BrightDataContext)">
            <summary>
            Reads an array from the reader
            </summary>
            <param name="reader"></param>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadStructArray``1(System.IO.BinaryReader)">
            <summary>
            Reads an array of structs from the reader
            </summary>
            <param name="reader"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.ReadStringArray(System.IO.BinaryReader)">
            <summary>
            Reads an array of strings from the reader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.SpanExtensions">
            <summary>
            Extensions that work with a span of numbers
            </summary>
        </member>
        <member name="T:BrightData.SpanExtensions.ComputeVectorisedTwo`1">
            <summary>
            Callback to calculate a new vector of Ts from two existing vectors
            </summary>
            <param name="a">First input vector</param>
            <param name="b">Second input vector</param>
            <param name="r">Result (output) vector</param>
        </member>
        <member name="T:BrightData.SpanExtensions.ComputeVectorisedOne`1">
            <summary>
            Callback to calculate a new vector of Ts from an existing vector
            </summary>
            <param name="a">Input vector</param>
            <param name="r">Result (output) vector</param>
        </member>
        <member name="M:BrightData.SpanExtensions.ZipParallel``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <summary>
            Creates a new span of numbers from applying an operation to each pair of elements from this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="func">Function that computes a new value from a pair of values</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.SpanExtensions.ZipVectorised``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},BrightData.SpanExtensions.ComputeVectorisedTwo{``0},System.Func{``0,``0,``0})">
            <summary>
            Applies a function across each pair of elements from this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="func1">Vector callback</param>
            <param name="func2">Element callback</param>
            <returns>Memory buffer that holds results from each callback</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.SpanExtensions.TransformParallel``1(System.ReadOnlySpan{``0},System.Func{``0,``0})">
            <summary>
            Applies a callback to each item in the span
            </summary>
            <param name="span">Vector</param>
            <param name="transformer">Callback</param>
            <returns>Memory buffer that holds results from each callback</returns>
        </member>
        <member name="M:BrightData.SpanExtensions.TransformVectorised``1(System.ReadOnlySpan{``0},BrightData.SpanExtensions.ComputeVectorisedOne{``0},System.Func{``0,``0})">
            <summary>
            Creates a new span from an existing span via a vectorization function
            </summary>
            <param name="span">Input buffer</param>
            <param name="transformer1">Vectorized transformer</param>
            <param name="transformer2">Sequential transformer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.TransformParallelIndexed``1(System.ReadOnlySpan{``0},System.Func{System.UInt32,``0})">
            <summary>
            Creates a new span from an existing span via a function (possibly executed in parallel) that receives an index and returns a new value
            </summary>
            <param name="span">Input span</param>
            <param name="transformer">Transformation function (possibly executed in parallel)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Mutate``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <summary>
            Updates a buffer by applying an update function that receives pairs of values from this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="func">Update function</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.SpanExtensions.MutateVectorised``1(System.Span{``0},System.ReadOnlySpan{``0},BrightData.SpanExtensions.ComputeVectorisedTwo{``0},System.Func{``0,``0,``0})">
            <summary>
            Updates a buffer by applying a vectorized transformation function to each pair of elements in this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="transformer1">Vectorized transformer</param>
            <param name="transformer2">Sequential transformer</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.SpanExtensions.MutateInPlace``1(System.Span{``0},System.Func{``0,``0})">
            <summary>
            Updates a span in place by applying a mutation function (potentially called in parallel) to each element
            </summary>
            <param name="span"></param>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.SpanExtensions.MutateInPlaceVectorised``1(System.Span{``0},BrightData.SpanExtensions.ComputeVectorisedOne{``0},System.Func{``0,``0})">
            <summary>
            Updates a span in place by applying a vectorization function to each value
            </summary>
            <param name="span"></param>
            <param name="mutator1"></param>
            <param name="mutator2"></param>
        </member>
        <member name="M:BrightData.SpanExtensions.Sum``1(System.Span{``0})">
            <summary>
            Calculates the sum of all values in this span
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Sum``1(System.ReadOnlySpan{``0})">
            <summary>
            Calculates the sum of all values in this span
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Returns a new buffer that contains this span added to another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Returns a new buffer that contains this span added to another span where each value is multiplied by coefficients
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Add``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Returns a new buffer that contains each value added to a scalar
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.AddInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Adds another span to this span in place
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.SpanExtensions.AddInPlace``1(System.Span{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Adds another span to this span and applies coefficients to each value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
        </member>
        <member name="M:BrightData.SpanExtensions.AddInPlace``1(System.Span{``0},``0)">
            <summary>
            Adds a scalar to each value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:BrightData.SpanExtensions.MultiplyInPlace``1(System.Span{``0},``0)">
            <summary>
            Multiplies each value by a scalar
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:BrightData.SpanExtensions.Multiply``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Creates a new buffer that contains each value multiplied by a scalar
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in another span is subtracted from the values in this span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Creates a new buffer in which each value in another span is multiplied by the second coefficient and then subtracted from the values in this span multiplied by the first coefficient
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.SubtractInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Subtracts another span from this span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.SpanExtensions.SubtractInPlace``1(System.Span{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Modifies this span so that each value in another span is multiplied by the second coefficient and then subtracted from the values in this span multiplied by the first coefficient
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
        </member>
        <member name="M:BrightData.SpanExtensions.PointwiseMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in this span is multiplied by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.PointwiseMultiplyInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Modifies this span so that each value is multiplied by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.SpanExtensions.PointwiseDivide``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in this span is divided by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.PointwiseDivideInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Modifies this span so that each value in this span is divided by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.SpanExtensions.DotProduct``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the dot product between this span and another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.SpanExtensions.ConstrainInPlace``1(System.Span{``0},System.Nullable{``0},System.Nullable{``0})">
            <summary>
            Modifies this span so that each value falls between the min and max values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
        </member>
        <member name="M:BrightData.SpanExtensions.IsEntirelyFinite``1(System.ReadOnlySpan{``0})">
            <summary>
            Checks if each value in this span is finite (not NaN or Infinity)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Reverse``1(System.ReadOnlySpan{``0})">
            <summary>
            Reverses the span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Squared``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in this span is squared
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.CherryPickIndices``1(System.ReadOnlySpan{``0},System.UInt32[])">
            <summary>
            Creates a new buffer from the specified indices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="arrayIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.SpanExtensions.Analyse``1(System.ReadOnlySpan{``0},System.Action{``0,System.UInt32})">
            <summary>
            Applies a callback (that might be executed in parallel) against each element in this span and its index
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="analyser">Callback that receives each value and its index</param>
        </member>
        <member name="T:BrightData.Transformation.ColumnConversion">
            <summary>
            Parameters that define a column conversion from one type to another
            </summary>
        </member>
        <member name="P:BrightData.Transformation.ColumnConversion.ColumnIndex">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Transformation.ColumnConversion.GetTransformer(BrightData.BrightDataContext,BrightData.BrightDataType,BrightData.ITypedSegment,System.Func{BrightData.MetaData},BrightData.IProvideTempStreams,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Transformation.ColumnNormalization">
            <summary>
            Parameters that define how to normalize a column of a data table
            </summary>
        </member>
        <member name="T:BrightData.Transformation.ManyToOneColumn">
            <summary>
            Parameters that define how to reinterpret the columns in a data table
            </summary>
        </member>
        <member name="T:BrightData.Transformation.NormalizeTransformation">
            <summary>
            Normalization parameters
            </summary>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.#ctor(BrightData.NormalizationType,BrightData.MetaData)">
            <summary>
            Creates a new set of parameters based on supplied the numeric analysis
            </summary>
            <param name="type">Type of normalization</param>
            <param name="analysedMetaData">Numeric analysis</param>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.WriteTo(BrightData.MetaData)">
            <summary>
            Writes the normalization parameters to a meta data store
            </summary>
            <param name="metaData"></param>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.NormalizationType">
            <summary>
            Type of normalization
            </summary>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.Divide">
            <summary>
            Value that will be divided (after subtraction)
            </summary>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.Subtract">
            <summary>
            Value that will be subtracted
            </summary>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.Normalize(System.Double)">
            <summary>
            Normalizes a value with the parameters
            </summary>
            <param name="val">Value to normalize</param>
            <returns>Normalized result</returns>
        </member>
        <member name="T:BrightData.WeightedIndexList">
            <summary>
            A list of weighted indices is a sparse vector
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.#ctor(BrightData.WeightedIndexList.Item[])">
            <summary>
            Constructor
            </summary>
            <param name="indices">Weighted indices</param>
        </member>
        <member name="P:BrightData.WeightedIndexList.Indices">
            <summary>
            Weighted indices
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsSpan">
            <summary>
            Returns a span of the weighted indices
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.WeightedIndexList.Item">
            <summary>
            An item within a weighted index list
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Item.Index">
            <summary>
            Index of item
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Item.Weight">
            <summary>
            Weight of item
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.#ctor(System.UInt32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index of item</param>
            <param name="weight">Weight of item</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Create(BrightData.WeightedIndexList.Item[])">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Create(System.ReadOnlySpan{BrightData.WeightedIndexList.Item})">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Create(System.Collections.Generic.IEnumerable{BrightData.WeightedIndexList.Item})">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Create(System.ValueTuple{System.UInt32,System.Single}[])">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Create(System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,System.Single}})">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.WeightedIndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.WeightedIndexList},BrightData.AggregationType)">
            <summary>
            Merges a sequence of weighted index lists into one list
            </summary>
            <param name="lists">Lists to merge</param>
            <param name="mergeOperation">How to merge item weights</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.WeightedIndexList.ToXml">
            <summary>
            Converts the weighted index list to XML
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsIndexList">
            <summary>
            Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Dot(BrightData.WeightedIndexList)">
            <summary>
            Dot product of this combined with the other weighted index list
            </summary>
            <param name="other">Other weighted index list</param>
        </member>
        <member name="P:BrightData.WeightedIndexList.Magnitude">
            <summary>
            Magnitude of weights
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.CosineSimilarity(BrightData.WeightedIndexList)">
            <summary>
            Cosine similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.GetMaxWeight">
            <summary>
            Returns the index with the highest weight
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.JaccardSimilarity(BrightData.WeightedIndexList)">
            <summary>
            Computes the jaccard similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsDense(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.UInt32})">
            <summary>
            Converts to a vector
            </summary>
            <param name="lap">Linear algebra provider</param>
            <param name="maxIndex">Inclusive highest index to copy (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Unique(BrightData.AggregationType)">
            <summary>
            Returns a new weighted index list with unique indices - duplicate values are treated according to the specified aggregation type
            </summary>
            <returns>New weighted index list with unique indices</returns>
        </member>
        <member name="P:BrightData.WeightedIndexList.Weights">
            <summary>
            All weights
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Equals(BrightData.WeightedIndexList)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
    </members>
</doc>
