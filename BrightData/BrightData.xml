<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BrightData</name>
    </assembly>
    <members>
        <member name="T:BrightData.Analysis.CastToDoubleNumericAnalysis`1">
            <summary>
            Used to cast other numeric types to doubles for numeric analysis
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Analysis.ConvertToStringFrequencyAnalysis`1">
            <summary>
            Used to convert other types to strings for frequency analysis
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Analysis.DateTimeAnalyser">
            <summary>
            Date time analysis
            </summary>
        </member>
        <member name="T:BrightData.Analysis.DimensionAnalyser">
            <summary>
            Tensor analysis
            </summary>
        </member>
        <member name="T:BrightData.Analysis.FrequencyAnalyser`1">
            <summary>
            Frequency analysis
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Analysis.IndexAnalyser">
            <summary>
            Index based type analysis
            </summary>
        </member>
        <member name="T:BrightData.Analysis.LinearBinnedFrequencyAnalysis">
            <summary>
            Binned frequency analysis
            </summary>
        </member>
        <member name="T:BrightData.Analysis.NormalisationModel">
            <summary>
            Normalization parameters
            </summary>
        </member>
        <member name="M:BrightData.Analysis.NormalisationModel.#ctor(BrightData.NormalizationType,BrightData.Types.MetaData)">
            <summary>
            Creates a new set of parameters based on supplied the numeric analysis
            </summary>
            <param name="type">Type of normalization</param>
            <param name="analysedMetaData">Numeric analysis</param>
        </member>
        <member name="M:BrightData.Analysis.NormalisationModel.WriteTo(BrightData.Types.MetaData)">
            <summary>
            Writes the normalization parameters to a meta data store
            </summary>
            <param name="metaData"></param>
        </member>
        <member name="P:BrightData.Analysis.NormalisationModel.NormalizationType">
            <summary>
            Type of normalization
            </summary>
        </member>
        <member name="P:BrightData.Analysis.NormalisationModel.Divide">
            <summary>
            Value that will be divided (after subtraction)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.NormalisationModel.Subtract">
            <summary>
            Value that will be subtracted
            </summary>
        </member>
        <member name="M:BrightData.Analysis.NormalisationModel.Normalize(System.Double)">
            <summary>
            Normalizes a value with the parameters
            </summary>
            <param name="val">Value to normalize</param>
            <returns>Normalized result</returns>
        </member>
        <member name="M:BrightData.Analysis.NormalisationModel.ReverseNormalize(System.Double)">
            <summary>
            Reverse a normalized value
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Analysis.NumericAnalyser">
            <summary>
            Numeric analysis
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.DateAnalysis">
            <summary>
            Date analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MinDate">
            <summary>
            Minimum date (null if none)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MaxDate">
            <summary>
            Maximum date (null if none)
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.DictionaryValues">
            <summary>
            Dictionary that holds category string indices
            </summary>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValues(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Converts from category indices to string
            </summary>
            <param name="categoryIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValue(System.Int32)">
            <summary>
            Gets the string associated with a category index
            </summary>
            <param name="categoryIndex"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Analysis.Readers.DimensionAnalysis">
            <summary>
            Dimension analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.XDimension">
            <summary>
            Max size of the x dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.YDimension">
            <summary>
            Max size of the y dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.ZDimension">
            <summary>
            Max size of the z dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.NumDistinct">
            <summary>
            Number of distinct size combinations
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.Size">
            <summary>
            Total size across all dimensions
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.FrequencyAnalysis">
            <summary>
            Frequency analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Total">
            <summary>
            Total number of items observed
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.MostFrequent">
            <summary>
            Most frequent item
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.IndexAnalysis">
            <summary>
            Index analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MinIndex">
            <summary>
            Lowest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MaxIndex">
            <summary>
            Highest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.NumericAnalysis">
            <summary>
            Numeric analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L1Norm">
            <summary>
            L1 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L2Norm">
            <summary>
            L2 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Min">
            <summary>
            Minimum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Max">
            <summary>
            Maximum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mean">
            <summary>
            Mean of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleVariance">
            <summary>
            Sample variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleStdDev">
            <summary>
            Sample standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationVariance">
            <summary>
            Population variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationStdDev">
            <summary>
            Population standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Median">
            <summary>
            Median value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mode">
            <summary>
            Mode (most frequent value)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.NumDistinct">
            <summary>
            Number of distinct values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Total">
            <summary>
            Total count of items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.FrequencyRange">
            <summary>
            Bucketed histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.StringAnalysis">
            <summary>
            String analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MinLength">
            <summary>
            Length of smallest observed string
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MaxLength">
            <summary>
            Length of largest observed string
            </summary>
        </member>
        <member name="T:BrightData.Analysis.StaticAnalysers">
            <summary>
            Static methods to create analyzers
            </summary>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDateAnalyser">
            <summary>
            Creates a date analyzer
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser``1(System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="writeCount">Number of items to write in histogram</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateConvertToStringAnalyser``1(System.UInt32)">
            <summary>
            Creates an analyzer that will convert each item to a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDimensionAnalyser">
            <summary>
            Creates a dimension analyzer (to analyze the shape of tensors)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser``1(System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed frequency of items
            </summary>
            <typeparam name="T"></typeparam>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateIndexAnalyser(System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed indices (for index lists and weighted index lists)
            </summary>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser(System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateStringAnalyser(System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser(System.Type,System.UInt32)">
            <summary>
            Creates a frequency analyzer (each item will be converted to a string)
            </summary>
            <param name="type"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Analysis.StringAnalyser">
            <summary>
            String analysis
            </summary>
        </member>
        <member name="T:BrightData.BrightDataContext">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.#ctor(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Nullable{System.Int32})">
            <summary>
            Constructor
            </summary>
            <param name="lap">Linear algebra provider to use (optional)</param>
            <param name="randomSeed">Initial value of random seed (or null to randomly initialize)</param>
        </member>
        <member name="M:BrightData.BrightDataContext.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.Random">
            <summary>
            Default random number generator
            </summary>
        </member>
        <member name="P:BrightData.BrightDataContext.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.BrightDataContext.LinearAlgebraProviderFactory">
            <summary>
            Linear algebra provider factory
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.CreateTempDataBlockProvider">
            <summary>
            Creates a new temp stream provider
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,``0)">
            <summary>
            Returns a typed property from the context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="defaultValue">Value to return if the property was not set</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,System.Func{``0})">
            <summary>
            Returns a typed property from the context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="defaultValueCreator">Callback to return a value if the property was not set</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String)">
            <summary>
            Returns a typed property from the context (or null if the property was not set)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.TryGet``1(System.String,``0@)">
            <summary>
            Tries to get a typed property from the context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="ret">The property value (if set)</param>
            <returns>True if the property was set</returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Set``1(System.String,``0)">
            <summary>
            Sets a typed property in this context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Property name</param>
            <param name="value">Property value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.BrightDataContext.Clear(System.String)">
            <summary>
            Removes a typed property from the context
            </summary>
            <param name="name">Property name</param>
        </member>
        <member name="P:BrightData.BrightDataContext.IsStochastic">
            <summary>
            True if the context does not use a predefined random seed
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.ResetRandom(System.Nullable{System.Int32})">
            <summary>
            Resets the random seed
            </summary>
            <param name="seed"></param>
        </member>
        <member name="P:BrightData.BrightDataContext.UserNotifications">
            <summary>
            Optional interface to provide user notification of long running operations
            </summary>
        </member>
        <member name="T:BrightData.Buffer.Composite.UnmanagedCompositeBuffer`1">
            <summary>
            Buffer that writes to disk after exhausting its in memory limit - not thread safe
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Consts">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxDistinct">
            <summary>
            Default max distinct count
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxWriteCount">
            <summary>
            Default max write count
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultPreviewSize">
            <summary>
            Default number of items to preview
            </summary>
        </member>
        <member name="F:BrightData.Consts.MinimumSizeForParallel">
            <summary>
            Minimum size to use parallel processing
            </summary>
        </member>
        <member name="F:BrightData.Consts.MinimumSizeForVectorised">
            <summary>
            Minimum size to use SIMD processing
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultInMemoryBufferSize">
            <summary>
            Default in memory buffer size
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultTableRowCacheSize">
            <summary>
            Default number of table rows to cache in memory
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultBlockSize">
            <summary>
            Default size of a small buffer
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultMaxBlocksInMemory">
            <summary>
            Default maximum number of blocks to keep in memory
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultMaxDistinctCount">
            <summary>
            Default max number of distinct items
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxMetaDataWriteCount">
            <summary>
            Default max write count
            </summary>
        </member>
        <member name="T:BrightData.Converter.StaticConverters">
            <summary>
            Static methods to create converters
            </summary>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToDecimal``1">
            <summary>
            Creates a converter to decimals
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToDouble``1">
            <summary>
            Creates a converter to doubles
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToFloat``1">
            <summary>
            Creates a converter to floats
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToInt``1">
            <summary>
            Creates a converter to integers
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToLong``1">
            <summary>
            Creates a converter to longs (Int64)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToShort``1">
            <summary>
            Creates a converter to shorts (Int16)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetConverterToSignedByte``1">
            <summary>
            Creates a convert to signed bytes
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.GetNumericConverter``2">
            <summary>
            Creates a converter from FT to TT
            </summary>
            <typeparam name="TF">Type to convert from</typeparam>
            <typeparam name="TT">Type to convert to</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.ColumnOrientedDataTable.PersistMetaData">
            <summary>
            Saves current meta data into the underlying stream
            </summary>
        </member>
        <member name="T:BrightData.DataTable.ColumnOrientedDataTableBuilder">
            <summary>
            Builds a data table dynamically
            </summary>
        </member>
        <member name="T:BrightData.DataTable.ColumnOrientedDataTableWriter">
            <summary>
            Writes buffers to a data table
            </summary>
        </member>
        <member name="T:BrightData.ExtensionMethods">
            <summary>
            Extension methods to attach analyser creation to the bright data context
            </summary>
            <summary>
            Extensions that work with a span of numbers
            </summary>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalysis(BrightData.Types.MetaData)">
            <summary>
            Gets the date analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalysis(BrightData.Types.MetaData)">
            <summary>
            Gets the dimension analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalysis(BrightData.Types.MetaData)">
            <summary>
            Gets the frequency analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalysis(BrightData.Types.MetaData)">
            <summary>
            Gets the index analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalysis(BrightData.Types.MetaData)">
            <summary>
            Gets the numeric analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalysis(BrightData.Types.MetaData)">
            <summary>
            Gets the string analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDictionaryValues(BrightData.Types.MetaData)">
            <summary>
            Gets the categories that were stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNormalization(BrightData.Types.MetaData)">
            <summary>
            Returns a normalization that was previously stored in the metadata
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnNormalization(BrightData.IDataTable,System.UInt32)">
            <summary>
            Returns the normalization that was applied to the specified data table column
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndex">Column index to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes numbers in a sequence
            </summary>
            <param name="data"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Analyzes dates in a sequence
            </summary>
            <param name="dates"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.IReadOnlyTensor})">
            <summary>
            Analyzes tensors in a sequence
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.IHaveIndices})">
            <summary>
            Analyzes indices in a sequence
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Analyzes a sequence of strings
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AnalyzeFrequency``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes the frequency of items
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyFrom(BrightData.ICompositeBuffer{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Copies all values from a tensor segment into a float buffer
            </summary>
            <param name="buffer"></param>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyFrom(BrightData.ICompositeBuffer{System.Single},System.ReadOnlySpan{System.Single})">
            <summary>
            Copies all values from a span into a float buffer
            </summary>
            <param name="buffer"></param>
            <param name="span"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Encode``1(BrightData.ICompositeBuffer{``0},BrightData.IProvideDataBlocks,System.Int32,System.Nullable{System.UInt32})">
            <summary>
            Encoding a composite buffer maps each item to an index and returns both the mapping table and a new composite buffer of the indices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="buffer"></param>
            <param name="tempStreams"></param>
            <param name="blockSize"></param>
            <param name="maxInMemoryBlocks"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetAnalyser(BrightData.IReadOnlyBuffer,BrightData.Types.MetaData,System.UInt32)">
            <summary>
            Creates a column analyser
            </summary>
            <param name="buffer">Buffer to analyse</param>
            <param name="metaData"></param>
            <param name="maxMetaDataWriteCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToType(System.TypeCode)">
            <summary>
            Converts a type code to a type
            </summary>
            <param name="code">Type code</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.Types.MetaData,System.String,System.Nullable{``0})">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <typeparam name="T"></typeparam>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.Types.MetaData,System.String,``0)">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.HasConversionOperator(System.Type,System.Type)">
            <summary>
            Checks if one type can be implicitly cast to another
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Randomly shuffles the items in the sequence
            </summary>
            <param name="seq"></param>
            <param name="rnd">Random number generator to use</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split``1(``0[],System.Double)">
            <summary>
            Randomly splits the sequence into a two arrays (either "training" or "test")
            </summary>
            <param name="seq"></param>
            <param name="trainPercentage">Percentage of items to add to the training array</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bag``1(``0[],System.UInt32,System.Random)">
            <summary>
            Sample with replacement
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">Number of samples</param>
            <param name="rnd">Random number generator to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetName(BrightData.Types.MetaData,System.String)">
            <summary>
            Item name
            </summary>
            <param name="metadata"></param>
            <param name="defaultName">Name to use if no name was set</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnIndex(BrightData.Types.MetaData)">
            <summary>
            Item index
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.Types.MetaData)">
            <summary>
            True if the item is numeric
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTarget(BrightData.Types.MetaData)">
            <summary>
            True if the item is a target
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsCategorical(BrightData.Types.MetaData)">
            <summary>
            True if the item is categorical
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsSequential(BrightData.Types.MetaData)">
            <summary>
            True if the item is sequential
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMetaData(BrightData.IWriteToMetaData)">
            <summary>
            Writes available meta data to a new meta data store
            </summary>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFloatConverter``1(BrightData.BrightDataContext)">
            <summary>
            Lazy create a float converter per context
            </summary>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32,System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32,System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Aggregate(BrightData.AggregationType,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Aggregates a list of floats
            </summary>
            <param name="operation"></param>
            <param name="data">Data to aggregate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTarget(BrightData.Types.MetaData,System.Boolean)">
            <summary>
            Sets this as a target
            </summary>
            <param name="metaData"></param>
            <param name="isTarget"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIsCategorical(BrightData.Types.MetaData,System.Boolean)">
            <summary>
            Sets this as categorical
            </summary>
            <param name="metaData"></param>
            <param name="isCategorical"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetName(BrightData.Types.MetaData,System.String)">
            <summary>
            Sets the name
            </summary>
            <param name="metaData"></param>
            <param name="name">Name</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFilePath(BrightData.Types.MetaData)">
            <summary>
            Returns the file path associated with the meta data (if any)
            </summary>
            <param name="metaData"></param>
            <returns>File path</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupAndCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Groups items and counts each group
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Format``1(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,System.UInt32}},System.Char)">
            <summary>
            Formats groups of items
            </summary>
            <param name="items"></param>
            <param name="separator">Group separator</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.UseLegacySerializationInput(BrightData.BrightDataContext,System.Boolean)">
            <summary>
            Enables or disables legacy (version 2) binary serialization - only when reading
            </summary>
            <param name="context"></param>
            <param name="use">True to enable</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataEncoder(BrightData.BrightDataContext)">
            <summary>
            Creates a data encoder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetData(BrightData.ICanWriteToBinaryWriter)">
            <summary>
            Converts the object to a serialized buffer
            </summary>
            <param name="writable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.NotifyProgress(BrightData.INotifyUser,System.Guid,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Notifies about the progress of a multi part operation
            </summary>
            <param name="notify"></param>
            <param name="operationId">Unique operation id</param>
            <param name="index">Index of current part</param>
            <param name="total">Total number of parts</param>
            <param name="progress">Process within the part</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteProgressPercentage(System.Single,System.Int32@,System.Diagnostics.Stopwatch)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="progress">New progress (between 0 and 1)</param>
            <param name="previousPercentage">Current progress percentage (max 100)</param>
            <param name="sw">Stopwatch since start of operation</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsCommaSeparated``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes the enumerable to a comma separated string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Items to write</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadArray``1(System.IO.Stream,System.UInt32)">
            <summary>
            Reads an array of T from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="size">Number of items to read</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadArray``1(System.IO.Stream,System.Int32)">
            <summary>
            Reads an array of T from the stream
            </summary>
            <param name="stream">Stream to read from</param>
            <param name="size">Number of items to read</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindPermutations``1(``0[])">
            <summary>
            Finds all possible permutations of sub items from the array, including the array itself
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">Array to permute</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindAllPairs``1(``0[])">
            <summary>
            Enumerates all unique pairs of items within the array
            [1, 2, 3] => [1,2], [1,3], [2,3]
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetGenericMethods(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Builds a table of the generic methods from a type
            </summary>
            <param name="type">Type to inspect</param>
            <param name="bindingFlags">Method flags</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Enumerate``1(System.IO.Stream,System.UInt32,System.Int32)">
            <summary>
            Enumerates a stream as a series of structs. This is best for small structs such as int32 etc as the values are not passed by reference.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="count">Total count to return</param>
            <param name="tempBufferSize">Size of temp buffer to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteTo``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,System.Int32)">
            <summary>
            Writes unmanaged items to a stream as a byte array
            </summary>
            <param name="items">Unmanaged items to write</param>
            <param name="stream">Destination stream</param>
            <param name="tempBufferSize">Size of buffer</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistinctContiguousRanges(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Finds the unique ranges of indices within a sequence
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTableBuilder(BrightData.BrightDataContext)">
            <summary>
            Creates a new table builder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.DisposeAll(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Disposes a collection of disposables
            </summary>
            <param name="disposables"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToEnumerable``1(``0)">
            <summary>
            Converts a single object into a enumerator that will enumerate that object once
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj">Item to enumerate (once)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray(BrightData.IHaveSpanOf{System.Single})">
            <summary>
            Extracts an array of floats
            </summary>
            <param name="spanOwner"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.IHaveReadOnlyTensorSegment{System.Single},BrightData.IHaveTensorSegment{System.Single})">
            <summary>
            Copies tensor values to another tensor
            </summary>
            <param name="source">Copy from</param>
            <param name="target">Copy to</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToDateTime(System.String)">
            <summary>
            Attempts to parse a string into a date
            </summary>
            <param name="str">String that contains a valid date</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.HierarchicalCluster(BrightData.IReadOnlyVector[],System.UInt32,BrightData.DistanceMetric)">
            <summary>
            Hierarchical clustering successively finds the closest distance between pairs of centroids until k is reached
            </summary>
            <param name="data">The list of vectors to cluster</param>
            <param name="k">The number of clusters to find</param>
            <returns>A list of k clusters</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.KMeansCluster(BrightData.IReadOnlyVector[],BrightData.BrightDataContext,System.UInt32,System.UInt32,BrightData.DistanceMetric)">
            <summary>
            K Means uses coordinate descent and a distance metric between randomly selected centroids to cluster the data
            </summary>
            <param name="data">The list of vectors to cluster</param>
            <param name="context">Bright data context</param>
            <param name="k">The number of clusters to find</param>
            <param name="maxIterations">The maximum number of iterations</param>
            <param name="distanceMetric">Distance metric to use to compare centroids</param>
            <returns>A list of k clusters</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType(BrightData.BrightDataType)">
            <summary>
            Converts from a column type to a Type
            </summary>
            <param name="type">Column type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetBrightDataType(System.Type)">
            <summary>
            Converts from a Type to a ColumnType
            </summary>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsBlittable(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is blittable
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is numeric
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsDecimal(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is decimal
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsContinuous(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is continuous
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsInteger(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is an integer
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsIndexedList(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is an indexed list (or weighted index list)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTensor(BrightData.BrightDataType)">
            <summary>
            Checks if the column type is a tensor
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RowIndices(BrightData.IDataTable)">
            <summary>
            Returns all row indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndices(BrightData.IDataTable)">
            <summary>
            Returns all column indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetAnalyser(BrightData.BrightDataType,BrightData.Types.MetaData,System.UInt32)">
            <summary>
            Creates a column analyser
            </summary>
            <param name="type">Column type</param>
            <param name="metaData">Column meta data</param>
            <param name="writeCount">Maximum size of sequences to write in final meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ParseCsv(BrightData.BrightDataContext,System.IO.StreamReader,System.Boolean,System.Char,System.String,System.UInt32,System.Threading.CancellationToken)">
            <summary>
            Parse CSV in memory without writing to disk (for small data sets)
            </summary>
            <param name="context"></param>
            <param name="reader">Stream reader that contains CSV data</param>
            <param name="hasHeader">True if the data contains a header</param>
            <param name="delimiter">CSV delimiter character</param>
            <param name="fileOutputPath">Path to write data table on disk (optional)</param>
            <param name="maxRows">Maximum number of rows to read</param>
            <param name="ct"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Head(BrightData.IDataTable,System.UInt32)">
            <summary>
            Returns the head (first few rows) of the data table
            </summary>
            <param name="dataTable"></param>
            <param name="size">Number of rows to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadTable(BrightData.BrightDataContext,System.String)">
            <summary>
            Loads a data table from disk
            </summary>
            <param name="context"></param>
            <param name="filePath">File path on disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTargetColumn(BrightData.Types.MetaData[],System.Nullable{System.UInt32})">
            <summary>
            Sets the target column across an array of meta data
            </summary>
            <param name="metaData"></param>
            <param name="columnIndex">Column index to make target (or null to set no target)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTargetColumn(BrightData.IDataTable,System.Nullable{System.UInt32})">
            <summary>
            Sets the target column of the data table
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndex">Column index to make target (or null to set no target)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumn(BrightData.IDataTable)">
            <summary>
            Returns the target column of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumnOrThrow(BrightData.IDataTable)">
            <summary>
            Returns the target column or throws an exception if none set
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndicesOfFeatures(BrightData.IDataTable)">
            <summary>
            Returns the feature (non target) columns of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetType(BrightData.Types.MetaData,BrightData.BrightDataType)">
            <summary>
            Sets the column type in a meta data store
            </summary>
            <param name="metaData"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectorisedFeatures(BrightData.IDataTable,System.Boolean)">
            <summary>
            Converts the data table to a sequence of labeled vectors (feature columns are vectorised, target column is converted to a string)
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnType(BrightData.Types.MetaData)">
            <summary>
            Gets the column type
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumDistinct(BrightData.Types.MetaData)">
            <summary>
            Gets the number of distinct items
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split(BrightData.IDataTable,System.Double,System.String,System.String)">
            <summary>
            Splits a data table into training and test tables (rows are randomly selected for either)
            </summary>
            <param name="table"></param>
            <param name="trainingFraction">Fraction (0..1) of rows to add to the training table</param>
            <param name="trainingFilePath">Path to write training table to disk (optional)</param>
            <param name="testFilePath">Path to write test table to disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Fold(BrightData.IDataTable,System.Int32,System.Boolean)">
            <summary>
            Folds the data table into k buckets (for k fold cross validation)
            </summary>
            <param name="table"></param>
            <param name="k">Number of buckets to create</param>
            <param name="shuffle">True to shuffle the table before folding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrices(BrightData.IDataTable)">
            <summary>
            Converts the data table to feature and target matrices
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrix(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Converts data table columns to a matrix
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices to include in the matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.IDataTable,System.Boolean,System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.IDataTable,System.Boolean,System.Collections.Generic.IEnumerable{System.UInt32},System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="columnIndices">Columns to use</param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Span{BrightData.IndexListWithLabel{System.String}},BrightData.BrightDataContext)">
            <summary>
            Converts indexed classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Span{BrightData.WeightedIndexListWithLabel{System.String}},BrightData.BrightDataContext)">
            <summary>
            Converts weighted index classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Span{System.ValueTuple{System.String,BrightData.IVector}},System.Boolean,BrightData.BrightDataContext)">
            <summary>
            Converts the vector classifications into a data table
            </summary>
            <param name="data"></param>
            <param name="preserveVectors">True to create a data table with a vector column type, false to to convert to columns of floats</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(System.Span{BrightData.WeightedIndexListWithLabel{System.String}},BrightData.BrightDataContext)">
            <summary>
            Converts the weighted index classification list to a list of dense vectors
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDefaultValue(BrightData.BrightDataType)">
            <summary>
            Returns a default value for a column type
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray(BrightData.ICanRandomlyAccessData)">
            <summary>
            Converts the segment to an array
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Get``1(BrightData.ICanRandomlyAccessData,System.UInt32)">
            <summary>
            Casts the value at column index to type T
            </summary>
            <param name="segment"></param>
            <param name="columnIndex"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sample(BrightData.IDataTable,System.UInt32)">
            <summary>
            Samples rows from the data table
            </summary>
            <param name="table"></param>
            <param name="sampleSize">Number of rows to sample</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateColumns(BrightData.IDataTable,System.String,BrightData.IDataTable[])">
            <summary>
            Horizontally concatenates other data tables with this data table
            </summary>
            <param name="table"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="others">Other data tables</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConcatenateRows(BrightData.IDataTable,System.String,BrightData.IDataTable[])">
            <summary>
            Vertically concatenates other data tables with this data table
            </summary>
            <param name="table"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="others">Other data tables</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyRowsToNewTable(BrightData.IDataTable,System.String,System.UInt32[])">
            <summary>
            Copy specified rows from this to a new data table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath"></param>
            <param name="rowIndices">Row indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyColumnsToNewTable(BrightData.IDataTable,System.String,System.UInt32[])">
            <summary>
            Copies all or specified columns to a new data table
            </summary>
            <param name="table"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="columnIndices">Specified column indices (or all columns if none specified)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnInfo(BrightData.IDataTable)">
            <summary>
            Returns column information
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.IDataTable,BrightData.NormalizationType,System.String,System.UInt32[])">
            <summary>
            Normalizes the data in specified columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="type">Normalization type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(BrightData.IDataTable,System.String,BrightData.NormalizationType[])">
            <summary>
            Normalizes the data in specified columns of the table
            </summary>
            <param name="dataTable"></param>
            <param name="columnNormalizationTypes">Normalization types per column</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bag(BrightData.IDataTable,System.String,System.UInt32)">
            <summary>
            Bags (random sample with duplication) table data to a new table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <param name="sampleCount">Number of rows to sample</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Shuffle(BrightData.IDataTable,System.String)">
            <summary>
            Shuffles all table rows into a new table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Clone(BrightData.IDataTable,System.String)">
            <summary>
            Clones the data table
            </summary>
            <param name="dataTable"></param>
            <param name="filePath">File path to save new table (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupBy(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Groups table data into multiple new tables based on the value(s) from columns
            </summary>
            <param name="dataTable"></param>
            <param name="groupByColumnIndices">Column indices that form the group</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupBy(BrightData.IDataTable,System.Func{System.String,System.String},System.UInt32[])">
            <summary>
            Groups table data into multiple new tables based on the value(s) from columns
            </summary>
            <param name="dataTable"></param>
            <param name="filePathProvider">Provides file paths to save new table</param>
            <param name="groupByColumnIndices">Column indices that form the group</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTableSignature(BrightData.IDataTable)">
            <summary>
            Gets the table signature based on column types
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CompleteInParallel``1(BrightData.IOperation{``0}[])">
            <summary>
            Returns the results from a collection of operations that might be run in parallel
            </summary>
            <typeparam name="T"></typeparam>
            <param name="operations"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CompleteInParallel``1(System.Collections.Generic.IReadOnlyList{BrightData.IOperation{``0}})">
            <summary>
            Returns the results from a collection of operations that might be run in parallel
            </summary>
            <param name="operations"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteDataTable(BrightData.BrightDataContext,BrightData.Types.MetaData,BrightData.IReadOnlyBufferWithMetaData[],System.IO.Stream)">
            <summary>
            Writes a data table to a stream
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table meta data</param>
            <param name="columns">Data table columns</param>
            <param name="stream">Output stream</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildDataTable(BrightData.BrightDataContext,BrightData.Types.MetaData,BrightData.IReadOnlyBufferWithMetaData[],System.IO.Stream)">
            <summary>
            Builds a data table from an array of typed segments
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table level meta data</param>
            <param name="columns">Typed segments (table columns)</param>
            <param name="stream">Output stream</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildDataTableInMemory(BrightData.BrightDataContext,BrightData.Types.MetaData,BrightData.IReadOnlyBufferWithMetaData[])">
            <summary>
            Builds a data table in memory
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table level meta data</param>
            <param name="columns">Typed segments (table columns)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildDataTable(BrightData.BrightDataContext,BrightData.Types.MetaData,BrightData.IReadOnlyBufferWithMetaData[],System.String)">
            <summary>
            Builds a data table (and writes table data to a file)
            </summary>
            <param name="context">Bright data context</param>
            <param name="tableMetaData">Table level meta data</param>
            <param name="columns">Typed segments (table columns)</param>
            <param name="filePath">File path</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MapRows``1(BrightData.IDataTable,System.Func{BrightData.TableRow,``0},System.Threading.CancellationToken)">
            <summary>
            Maps table rows to another type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dataTable"></param>
            <param name="mapper"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnType(BrightData.BrightDataType)">
            <summary>
            Returns the .net type and its size to represent a bright data type within a column
            </summary>
            <param name="dataType">Bright data type</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.AllOrSpecifiedRowIndices(BrightData.IDataTable,System.Boolean,System.UInt32[])">
            <summary>
            Enumerates specified row indices (or all if none specified)
            </summary>
            <param name="indices">Row indices (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildInMemory(BrightData.IBuildDataTables)">
            <summary>
            Builds a data table in memory
            </summary>
            <param name="builder"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.NextRandomFloat(BrightData.BrightDataContext)">
            <summary>
            Returns a randomly initialized float greater than or equal to 0f, and less than 1f
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.BrightDataContext,System.Int32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.BrightDataContext,System.UInt32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBernoulliDistribution(BrightData.BrightDataContext,System.Single)">
            <summary>
            Create a bernoulli distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBinomialDistribution(BrightData.BrightDataContext,System.Single,System.UInt32)">
            <summary>
            Create a binomial distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <param name="numTrials"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCategoricalDistribution(BrightData.BrightDataContext,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Create a categorical distribution
            </summary>
            <param name="context"></param>
            <param name="categoricalValues"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateContinuousDistribution(BrightData.BrightDataContext,System.Single,System.Single)">
            <summary>
            Create a continuous distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiscreteUniformDistribution(BrightData.BrightDataContext,System.Int32,System.Int32)">
            <summary>
            Create a discrete uniform distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateNormalDistribution(BrightData.BrightDataContext,System.Single,System.Single)">
            <summary>
            Create a normal distribution
            </summary>
            <param name="context"></param>
            <param name="mean"></param>
            <param name="stdDev">Standard deviation</param>
            <returns></returns>
        </member>
        <member name="F:BrightData.ExtensionMethods.NumericsVectorSize">
            <summary>
            Hardware dependent size of a numeric vector of floats
            </summary>
        </member>
        <member name="M:BrightData.ExtensionMethods.CosineDistance(System.Single[],System.Single[])">
            <summary>
            Vectorized cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite)
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>Cosine distance between the two vectors</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Minimum(System.Single[])">
            <summary>
            Find the minimum value and index in a vector
            </summary>
            <param name="vector">Vector to analyze</param>
            <returns>Tuple containing the minimum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumIndex(System.Single[])">
            <summary>
            Returns the index of the minimum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumValue(System.Single[])">
            <summary>
            Returns the minimum value
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Maximum(System.Single[])">
            <summary>
            Returns the maximum value and index within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns>Tuple containing the maximum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumIndex(System.Single[])">
            <summary>
            Returns the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumValue(System.Single[])">
            <summary>
            Returns the index of the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Softmax(System.Single[])">
            <summary>
            Calculates the softmax of a vector
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetAverage(System.Collections.Generic.IEnumerable{System.Single[]})">
            <summary>
            Finds the average of each value from a collection of vectors
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToReadOnlyVector(System.Single[])">
            <summary>
            Converts the float array to a read only vector
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Reshape(BrightData.IHaveReadOnlyTensorSegment{System.Single})">
            <summary>
            Reshapes to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Reshape(BrightData.IHaveReadOnlyTensorSegment{System.Single},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a matrix
            </summary>
            <param name="vector"></param>
            <param name="rows">Row count of each matrix (one parameter is optional null)</param>
            <param name="columns">Column count of each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Reshape(BrightData.IHaveReadOnlyTensorSegment{System.Single},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 3D tensor
            </summary>
            <param name="vector"></param>
            <param name="depth">Number of matrices (one parameter is optional null)</param>
            <param name="rows">Number of rows in each matrix (one parameter is optional null)</param>
            <param name="columns">Number of columns in each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Reshape(BrightData.IHaveReadOnlyTensorSegment{System.Single},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 4D tensor
            </summary>
            <param name="vector"></param>
            <param name="count">Number of 3D tensors (one parameter is optional null)</param>
            <param name="depth">Number of matrices in each 3D tensor (one parameter is optional null)</param>
            <param name="rows">Number of rows in each matrix (one parameter is optional null)</param>
            <param name="columns">Number of columns in each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates an index list from a binary reader
            </summary>
            <param name="_"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a weighted index list from a binary reader
            </summary>
            <param name="_"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToWeightedIndexList(System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,System.UInt32}})">
            <summary>
            Creates a weighted index list from indexed counts
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToIndexList(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Converts the indices to an index list
            </summary>
            <param name="indices">Indices to convert</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToWeightedIndexList(System.Collections.Generic.IEnumerable{System.UInt32},System.Single)">
            <summary>
            Converts the indices to a weighted index list
            </summary>
            <param name="indices">Indices to convert</param>
            <param name="weight">Weight to give each index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToWeightedIndexList``1(System.Collections.Generic.IReadOnlyList{BrightData.IndexListWithLabel{``0}},System.Boolean)">
            <summary>
            Converts the indexed classifications to weighted indexed classifications
            </summary>
            <param name="data"></param>
            <param name="groupByClassification">True to group by classification (i.e convert the bag to a set)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxWeight``1(System.Span{BrightData.WeightedIndexListWithLabel{``0}})">
            <summary>
            Finds the greatest weight within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex``1(System.Span{BrightData.WeightedIndexListWithLabel{``0}})">
            <summary>
            Find the greatest index within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex``1(System.Span{BrightData.IndexListWithLabel{``0}})">
            <summary>
            Find the greatest index within the index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize``1(System.Span{BrightData.WeightedIndexListWithLabel{``0}})">
            <summary>
            Normalizes the weighted index classification list to fit between 0 and 1
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Tfidf``1(System.Collections.Generic.IReadOnlyList{BrightData.WeightedIndexListWithLabel{``0}})">
            <summary>
            Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Tf%E2%80%93idf
            </summary>
            <returns>A newly weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bm25Plus``1(System.Collections.Generic.IReadOnlyList{BrightData.WeightedIndexListWithLabel{``0}},System.Single,System.Single,System.Single)">
            <summary>
            Okapi B525+ modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Okapi_BM25
            </summary>
            <returns>Newly weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="_"></param>
            <param name="size">Size of vector</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.Int32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.UInt32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="_"></param>
            <param name="size">Size of vector</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.Int32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.Single[])">
            <summary>
            Creates a vector
            </summary>
            <param name="_"></param>
            <param name="initialData">Initial data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyVector(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a vector from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrix(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <param name="_"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrix(BrightData.BrightDataContext,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Creates a matrix
            </summary>
            <param name="_"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrix(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a matrix from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromRows(BrightData.BrightDataContext,BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from vectors (each will become a row)
            </summary>
            <param name="_"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromRows(BrightData.BrightDataContext,BrightData.LinearAlgebra.ReadOnly.ReadOnlyVector[])">
            <summary>
            Creates a matrix from vectors (each will become a row)
            </summary>
            <param name="_"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromRows(BrightData.BrightDataContext,System.Single[][])">
            <summary>
            Creates a matrix from rows (each will become a row)
            </summary>
            <param name="_"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromColumns(BrightData.BrightDataContext,BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <param name="_"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyMatrixFromColumns(BrightData.BrightDataContext,System.Single[][])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <param name="_"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor3D(BrightData.BrightDataContext,BrightData.IReadOnlyMatrix[])">
            <summary>
            Creates a 3D tensor from matrices
            </summary>
            <param name="_"></param>
            <param name="matrices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor3D(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Create a 3D tensor from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor4D(BrightData.BrightDataContext,BrightData.IReadOnlyTensor3D[])">
            <summary>
            Creates a 4D tensor from matrices
            </summary>
            <param name="_"></param>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateReadOnlyTensor4D(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a 4D tensor from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIdentityMatrix(BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32)">
            <summary>
            Creates an identity matrix (each diagonal element is 1, each other element is 0)
            </summary>
            <param name="lap"></param>
            <param name="size">Width and height of the new matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiagonalMatrix(BrightData.LinearAlgebra.LinearAlgebraProvider,System.Single[])">
            <summary>
            Creates a diagonal matrix
            </summary>
            <param name="lap"></param>
            <param name="values">Diagonal values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.InitializeRandomly(BrightData.ITensor)">
            <summary>
            Randomly initialize a tensor
            </summary>
            <param name="tensor"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize(BrightData.ITensor,System.Single)">
            <summary>
            Initialize a tensor to a single value
            </summary>
            <param name="tensor"></param>
            <param name="value">Value to initialize each element of the tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize(BrightData.ITensor,System.Func{System.UInt32,System.Single})">
            <summary>
            Initialize a tensor using a callback
            </summary>
            <param name="tensor"></param>
            <param name="initializer">Callback for each element</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadReadOnlyVectorFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a vector from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadReadOnlyVectorAndThenGetArrayFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reacts a float array from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadMatrixFrom(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a matrix from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReduceDimensionsWithSvd(BrightData.IMatrix,System.UInt32)">
            <summary>
            Reduce dimensions of the matrix with a singular value decomposition
            </summary>
            <param name="matrix"></param>
            <param name="dimensions">Number of dimensions to reduce to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Average``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Calculates an average from a collection of tensors
            </summary>
            <param name="tensors">Tensors to average</param>
            <param name="dispose">True to dispose each of the input vectors</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistance(BrightData.IVector,BrightData.IVector,BrightData.DistanceMetric)">
            <summary>
            Applies a distance metric to two vectors and returns the distance between them
            </summary>
            <param name="vector">First vector</param>
            <param name="other">Second vector</param>
            <param name="distance">Distance metric</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistances(BrightData.IVector,System.Collections.Generic.IReadOnlyList{BrightData.IVector},BrightData.DistanceMetric)">
            <summary>
            Applies a distance metric to this and a list of other vectors
            </summary>
            <param name="compareTo">This vector</param>
            <param name="vectors">List of other vectors</param>
            <param name="distanceMetric">Distance metric</param>
            <returns>A vector in which each value is the distance between this and the corresponding other vector</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.IVector)">
            <summary>
            Converts the vector a weighted index list (sparse vector)
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.ITensor,BrightData.ITensor)">
            <summary>
            Copies all values from this tensor to another tensor
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.UseDefaultLinearAlgebraProvider(BrightData.BrightDataContext)">
            <summary>
            Sets the context to use the default linear algebra provider
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.IReadOnlyVector)">
            <summary>
            Converts the vector to a sparse format (only non zero entries are preserved)
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMinAndMaxValues(BrightData.IReadOnlyVector)">
            <summary>
            Returns the index with the minimum value from this tensor segment
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMinimumIndex(BrightData.IReadOnlyVector)">
            <summary>
            Returns the index with the minimum value from this tensor segment
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaximumIndex(BrightData.IReadOnlyVector)">
            <summary>
            Returns the index with the maximum value from this tensor segment
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sum(BrightData.IReadOnlyVector)">
            <summary>
            Sums all values
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Softmax(BrightData.IReadOnlyVector)">
            <summary>
            Returns the index with the minimum value from this tensor segment
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CosineDistance(BrightData.IReadOnlyVector,BrightData.IReadOnlyVector)">
            <summary>
            Finds cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite) between this and another vector
            </summary>
            <param name="vector"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ExtensionMethods.ComputeVectorisedTwo`1">
            <summary>
            Callback to calculate a new vector of Ts from two existing vectors
            </summary>
            <param name="a">First input vector</param>
            <param name="b">Second input vector</param>
            <param name="r">Result (output) vector</param>
        </member>
        <member name="T:BrightData.ExtensionMethods.ComputeVectorisedOne`1">
            <summary>
            Callback to calculate a new vector of Ts from an existing vector
            </summary>
            <param name="a">Input vector</param>
            <param name="r">Result (output) vector</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ZipParallel``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <summary>
            Creates a new span of numbers from applying an operation to each pair of elements from this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="func">Function that computes a new value from a pair of values</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.ZipVectorized``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},BrightData.ExtensionMethods.ComputeVectorisedTwo{``0},System.Func{``0,``0,``0})">
            <summary>
            Applies a function across each pair of elements from this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="func1">Vector callback</param>
            <param name="func2">Element callback</param>
            <returns>Memory buffer that holds results from each callback</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.MapParallel``1(System.ReadOnlySpan{``0},System.Func{``0,``0})">
            <summary>
            Applies a callback to each item in the span
            </summary>
            <param name="span">Vector</param>
            <param name="transformer">Callback</param>
            <returns>Memory buffer that holds results from each callback</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MapParallel``1(System.ReadOnlySpan{``0},System.Func{System.UInt32,``0,``0})">
            <summary>
            Applies a callback to each item in the span
            </summary>
            <param name="span">Vector</param>
            <param name="transformer">Callback</param>
            <returns>Memory buffer that holds results from each callback</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TransformVectorized``1(System.ReadOnlySpan{``0},BrightData.ExtensionMethods.ComputeVectorisedOne{``0},System.Func{``0,``0})">
            <summary>
            Creates a new span from an existing span via a vectorization function
            </summary>
            <param name="span">Input buffer</param>
            <param name="transformer1">Vectorized transformer</param>
            <param name="transformer2">Sequential transformer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TransformParallelIndexed``1(System.ReadOnlySpan{``0},System.Func{System.UInt32,``0})">
            <summary>
            Creates a new span from an existing span via a function (possibly executed in parallel) that receives an index and returns a new value
            </summary>
            <param name="span">Input span</param>
            <param name="transformer">Transformation function (possibly executed in parallel)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TransformParallelIndexed``1(System.ReadOnlySpan{``0},System.Func{System.UInt32,``0,``0})">
            <summary>
            Creates a new span from an existing span via a function (possibly executed in parallel) that receives an index and returns a new value
            </summary>
            <param name="span">Input span</param>
            <param name="transformer">Transformation function (possibly executed in parallel)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Mutate``1(System.Span{``0},System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <summary>
            Updates a buffer by applying an update function that receives pairs of values from this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="func">Update function</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateVectorized``1(System.Span{``0},System.ReadOnlySpan{``0},BrightData.ExtensionMethods.ComputeVectorisedTwo{``0},System.Func{``0,``0,``0})">
            <summary>
            Updates a buffer by applying a vectorized transformation function to each pair of elements in this and another span
            </summary>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="transformer1">Vectorized transformer</param>
            <param name="transformer2">Sequential transformer</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateInPlace``1(System.Span{``0},System.Func{``0,``0})">
            <summary>
            Updates a span in place by applying a mutation function (potentially called in parallel) to each element
            </summary>
            <param name="span"></param>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateInPlaceVectorized``1(System.Span{``0},BrightData.ExtensionMethods.ComputeVectorisedOne{``0},System.Func{``0,``0})">
            <summary>
            Updates a span in place by applying a vectorization function to each value
            </summary>
            <param name="span"></param>
            <param name="mutator1"></param>
            <param name="mutator2"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyse``1(System.ReadOnlySpan{``0},System.Action{``0,System.UInt32})">
            <summary>
            Applies a callback (that might be executed in parallel) against each element in this span and its index
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="analyser">Callback that receives each value and its index</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsReadOnly``1(System.Span{``0})">
            <summary>
            Calculates the sum of all values in this span
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sum``1(System.ReadOnlySpan{``0})">
            <summary>
            Calculates the sum of all values in this span
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Returns a new buffer that contains this span added to another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Returns a new buffer that contains this span added to another span where each value is multiplied by coefficients
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Add``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Returns a new buffer that contains each value added to a scalar
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AddInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Adds another span to this span in place
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.AddInPlace``1(System.Span{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Adds another span to this span and applies coefficients to each value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.AddInPlace``1(System.Span{``0},``0)">
            <summary>
            Adds a scalar to each value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.MultiplyInPlace``1(System.Span{``0},``0)">
            <summary>
            Multiplies each value by a scalar
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Multiply``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Creates a new buffer that contains each value multiplied by a scalar
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in another span is subtracted from the values in this span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Creates a new buffer in which each value in another span is multiplied by the second coefficient and then subtracted from the values in this span multiplied by the first coefficient
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SubtractInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Subtracts another span from this span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.SubtractInPlace``1(System.Span{``0},System.ReadOnlySpan{``0},``0,``0)">
            <summary>
            Modifies this span so that each value in another span is multiplied by the second coefficient and then subtracted from the values in this span multiplied by the first coefficient
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <param name="coefficient1">Coefficient to apply to each value in this span</param>
            <param name="coefficient2">Coefficient to apply to each value in the other span</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in this span is multiplied by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseMultiplyInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Modifies this span so that each value is multiplied by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseDivide``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in this span is divided by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.PointwiseDivideInPlace``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Modifies this span so that each value in this span is divided by the pairwise value from another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.DotProduct``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the dot product between this span and another span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span">This span</param>
            <param name="other">Other span</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sqrt``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Creates a new vector that contains the square root of each value in this tensor segment
            </summary>
            <param name="span">This tensor</param>
            <param name="adjustment">A small value to add to each value in case of zeros</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConstrainInPlace``1(System.Span{``0},System.Nullable{``0},System.Nullable{``0})">
            <summary>
            Modifies this span so that each value falls between the min and max values
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Average``1(System.ReadOnlySpan{``0})">
            <summary>
            Finds the average value in this vector
            </summary>
            <param name="vector">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.L1Norm``1(System.ReadOnlySpan{``0})">
            <summary>
            Calculates the L1 norm of this vector
            </summary>
            <param name="vector">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.L2Norm``1(System.ReadOnlySpan{``0})">
            <summary>
            Calculates the L2 norm of this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMinAndMaxValues``1(System.ReadOnlySpan{``0})">
            <summary>
            Finds the min and max values (and their indices) of this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsEntirelyFinite``1(System.ReadOnlySpan{``0})">
            <summary>
            Checks if each value in this span is finite (not NaN or Infinity)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Reverse``1(System.ReadOnlySpan{``0})">
            <summary>
            Reverses the span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MeanSquaredDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the mean squared distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SquaredEuclideanDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the squared euclidean distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ManhattanDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the manhattan distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.EuclideanDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the euclidean distance between this and another tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Abs``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment that contains the absolute value of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Log``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment that contains the natural logarithm of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Exp``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment that contains the exponent of each value in this tensor segment
            </summary>
            <param name="tensor">This tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Pow``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Creates a new tensor segment that contains each value raised by the specified power in this tensor segment
            </summary>
            <param name="segment">This tensor</param>
            <param name="power">Specified power</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Squared``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new buffer in which each value in this span is squared
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.StdDev``1(System.ReadOnlySpan{``0},System.Nullable{``0})">
            <summary>
            Calculates the standard deviation of this tensor segment
            </summary>
            <param name="segment">This tensor segment</param>
            <param name="mean">Mean of the tensor segment (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sigmoid``1(``0)">
            <summary>
            Calculates sigmoid
            </summary>
            <param name="val"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SigmoidDerivative``1(``0)">
            <summary>
            Calculates sigmoid derivative
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TanhDerivative``1(``0)">
            <summary>
            Calculates tanh derivative
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Relu``1(``0)">
            <summary>
            Calculates RELU
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReluDerivative``1(``0)">
            <summary>
            Calculates RELU derivative
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LeakyRelu``1(``0)">
            <summary>
            Calculates leaky RELU
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LeakyReluDerivative``1(``0)">
            <summary>
            Calculates leaky RELU derivative
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sigmoid``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with sigmoid function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SigmoidDerivative``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with sigmoid derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Tanh``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with tanh function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.TanhDerivative``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with tanh derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Relu``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with RELU function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReluDerivative``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with RELU derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LeakyRelu``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with Leaky RELU function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LeakyReluDerivative``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with Leaky RELU derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Softmax``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a new tensor segment with softmax function applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SoftmaxDerivative``1(System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Creates a new tensor segment with softmax derivative applied to each value in this tensor segment
            </summary>
            <param name="segment"></param>
            <param name="rowCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CherryPickIndices``1(System.ReadOnlySpan{``0},System.UInt32[])">
            <summary>
            Creates a new buffer from the specified indices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="span"></param>
            <param name="arrayIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RoundInPlace``1(System.Span{``0},``0,``0)">
            <summary>
            Rounds each value in this tensor segment to be either the lower or upper supplied parameters
            </summary>
            <param name="segment"></param>
            <param name="lower"></param>
            <param name="upper"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.L1Regularization``1(System.Span{``0},``0)">
            <summary>
            In place L1 regularization of the tensor segment
            </summary>
            <param name="segment"></param>
            <param name="coefficient">Coefficient to apply to each adjusted value</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},BrightData.DistanceMetric)">
            <summary>
            Applies a distance metric to two vectors and returns the distance between them
            </summary>
            <param name="vector">First vector</param>
            <param name="other">Second vector</param>
            <param name="distance">Distance metric</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.CosineDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Vectorized cosine distance (0 for perpendicular, 1 for orthogonal, 2 for opposite)
            </summary>
            <param name="v1">First vector</param>
            <param name="v2">Second vector</param>
            <returns>Cosine distance between the two vectors</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.AngularDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Angular distance between two vectors
            </summary>
            <typeparam name="T"></typeparam>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.InnerProductSpaceDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Inner space distance between two vectors
            </summary>
            <typeparam name="T"></typeparam>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Minimum``1(System.ReadOnlySpan{``0})">
            <summary>
            Find the minimum value and index in a vector
            </summary>
            <param name="vector">Vector to analyze</param>
            <returns>Tuple containing the minimum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumIndex``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns the index of the minimum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MinimumValue``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns the minimum value
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Maximum``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns the maximum value and index within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns>Tuple containing the maximum value and its index</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumIndex``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MaximumValue``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns the index of the maximum value within a vector
            </summary>
            <param name="vector">Vector to analyse</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.PearsonCorrelationCoefficient``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Calculates the pearson correlation coefficient metric between two tensor segments
            https://en.wikipedia.org/wiki/Pearson_correlation_coefficient
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.DivideByZeroException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.Search``1(System.ReadOnlySpan{``0},``0,System.Nullable{``0})">
            <summary>
            Searches the span for the index of the first value that matches the specified value within a level of tolerance
            </summary>
            <param name="segment">This tensor</param>
            <param name="value">Value to find</param>
            <param name="tolerance">Degree of tolerance</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Transpose``1(System.ReadOnlySpan{``0},System.UInt32,System.UInt32)">
            <summary>
            Calculate the matrix transpose
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Converts the tensor segment to a sparse format (only non zero entries are preserved)
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split(BrightData.IReadOnlyNumericSegment{System.Single},System.UInt32)">
            <summary>
            Splits this tensor segment into multiple contiguous tensor segments
            </summary>
            <param name="segment">This tensor</param>
            <param name="blockCount">Number of blocks</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Set(BrightData.INumericSegment{System.Single},System.Func{System.Single,System.Single})">
            <summary>
            Sets all values of the tensor segment via a callback that receives each value
            </summary>
            <param name="segment"></param>
            <param name="setValue"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Set(BrightData.INumericSegment{System.Single},System.Func{System.UInt32,System.Single})">
            <summary>
            Sets all values of the tensor segment via a callback that receives the index of each value
            </summary>
            <param name="segment"></param>
            <param name="setValue"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Set(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Sets all values of the tensor segment to a single value
            </summary>
            <param name="segment"></param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetToRandom(BrightData.INumericSegment{System.Single},System.Random)">
            <summary>
            Sets all values of this tensor segment to a random floating point number
            </summary>
            <param name="segment"></param>
            <param name="random">Random number generator</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToReadOnlyVector(BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Converts the tensor segment to a read only vector
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToVector(BrightData.IReadOnlyNumericSegment{System.Single},BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a vector from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToMatrix(BrightData.IReadOnlyNumericSegment{System.Single},BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32,System.UInt32)">
            <summary>
            Creates a matrix from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <param name="rows">Number of rows in matrix</param>
            <param name="columns">Number of columns in matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToTensor3D(BrightData.IReadOnlyNumericSegment{System.Single},BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 3D tensor from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToTensor4D(BrightData.IReadOnlyNumericSegment{System.Single},BrightData.LinearAlgebra.LinearAlgebraProvider,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 4D tensor from a tensor segment
            </summary>
            <param name="segment"></param>
            <param name="lap">Linear algebra provider</param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ExtensionMethods.OnReadOnlySpan`2">
            <summary>
            Callback that takes a readonly span
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RT"></typeparam>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetReadOnlySpan``1(BrightData.INumericSegment{System.Single},BrightData.ExtensionMethods.OnReadOnlySpan{System.Single,``0})">
            <summary>
            Passes the segment as a readonly span to the callback
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="segment"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetReadOnlySpan``2(``0,BrightData.ExtensionMethods.OnReadOnlySpan{System.Single,``1})">
            <summary>
            Passes the segment as a readonly span to the callback
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RT"></typeparam>
            <param name="segment"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ExtensionMethods.OnReadOnlySpans`2">
            <summary>
            Callback that takes two readonly spans
            </summary>
            <typeparam name="RT"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetReadOnlySpans``1(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single},BrightData.ExtensionMethods.OnReadOnlySpans{System.Single,``0})">
            <summary>
            Passes the readonly spans from the supplied segments into a callback function
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="segment1"></param>
            <param name="segment2"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetReadOnlySpans``2(``0,BrightData.IReadOnlyNumericSegment{System.Single},BrightData.ExtensionMethods.OnReadOnlySpans{System.Single,``1})">
            <summary>
            Passes the readonly spans from the supplied segments into a callback function
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RT"></typeparam>
            <param name="segment1"></param>
            <param name="segment2"></param>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ExtensionMethods.OnSpans`1">
            <summary>
            Callback that takes one mutable span and one readonly span
            </summary>
            <param name="span1"></param>
            <param name="span2"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetSpans(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single},BrightData.ExtensionMethods.OnSpans{System.Single})">
            <summary>
            Passes the first as a mutable span and the second as a readonly span from the supplied segments into a callback function
            </summary>
            <param name="segment1"></param>
            <param name="segment2"></param>
            <param name="callback"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:BrightData.ExtensionMethods.OnSpan`1">
            <summary>
            Callback that takes a single mutable span
            </summary>
            <param name="span"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetSpan(BrightData.INumericSegment{System.Single},BrightData.ExtensionMethods.OnSpan{System.Single})">
            <summary>
            Passes the segment as a mutable span into a callback function
            </summary>
            <param name="segment"></param>
            <param name="callback"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsDataFieldSpecification(BrightData.BrightDataType,System.String,System.Boolean)">
            <summary>
            Creates a data field specification for a data type
            </summary>
            <param name="dataType"></param>
            <param name="name"></param>
            <param name="canRepeat"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTypeSpecification(BrightData.IDataTable)">
            <summary>
            Creates a type specification for a data table
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.FindNonConformingRows(BrightData.IDataTypeSpecification,BrightData.IDataTable)">
            <summary>
            Finds the row indices of any row that does not conform to the type specification
            </summary>
            <param name="typeInfo"></param>
            <param name="dataTable"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:BrightData.Helper.ColumnTypeClassifier">
            <summary>
            Classifies data table column types
            </summary>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsDecimal(BrightData.BrightDataType)">
            <summary>
            Checks for a decimal type (floating point)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsNumeric(BrightData.BrightDataType)">
            <summary>
            Checks for a numeric type (floating point or integer)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsContinuous(BrightData.BrightDataType)">
            <summary>
            Checks for a continuous type (non categorical)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsCategorical(BrightData.BrightDataType)">
            <summary>
            Checks for a categorical type (non continuous)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsBlittable(BrightData.BrightDataType)">
            <summary>
            Checks if the type has an independent memory layout across managed and unmanaged code
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.GetClass(BrightData.BrightDataType,BrightData.Types.MetaData)">
            <summary>
            Returns the set of possible column classifications
            </summary>
            <param name="type">Column type to check</param>
            <param name="metaData">Column metadata</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ConsoleProgressNotification">
            <summary>
            Writes progress notifications to the console
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnStartOperation(System.Guid,System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnOperationProgress(System.Guid,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnCompleteOperation(System.Guid,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.OnMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.WriteProgress(System.Int32,System.Int32@,System.Int32)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="newProgress">New progress</param>
            <param name="oldProgress">Current progress</param>
            <param name="max">Max progress amount (default 100)</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="M:BrightData.Helper.ConsoleProgressNotification.WriteProgress(System.Single,System.Int32@,System.Diagnostics.Stopwatch)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="progress">New progress (between 0 and 1)</param>
            <param name="previousPercentage">Current progress percentage (max 100)</param>
            <param name="sw">Stopwatch since start of operation</param>
            <returns>True if the progress has increased</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper">
            <summary>
            Helper class to calculate convolutional indices
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.LeftToRight(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from left to right
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.TopToBottom(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from top to bottom
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper.ConvolutionalDelegate">
            <inheritdoc />
        </member>
        <member name="F:BrightData.Helper.ConvolutionHelper.Default">
            <summary>
            Default convolutional direction
            </summary>
        </member>
        <member name="T:BrightData.Helper.DataEncoder">
            <summary>
            Encodes types from/to bytes
            </summary>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Read``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read from a binary reader
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read an array from a binary reader
            </summary>
            <typeparam name="T">Type within the array</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0)">
            <summary>
            Generic method to write to binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="val">Item to write</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0[])">
            <summary>
            Generic method to write an array to a binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="values">Array to write</param>
        </member>
        <member name="T:BrightData.Helper.DoubleMath">
            <summary>
            Helpers for double based math
            </summary>
        </member>
        <member name="F:BrightData.Helper.DoubleMath.AlmostZero">
            <summary>
            A number that is close to zero
            </summary>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Double,System.Double,System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Nullable{System.Double},System.Nullable{System.Double},System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.FloatMath">
            <summary>
            Constrained float math helpers - if the value is too small or too big it will be capped. Also NaN values are replaced with zero.
            </summary>
        </member>
        <member name="T:BrightData.Helper.GenericActivator">
            <summary>
            Generic object creator
            </summary>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1">
            <summary>
            Creates a new object (via default constructor)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1">
            <summary>
            Creates a new uninitialized object (constructor is not invoked)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1(System.Type)">
            <summary>
            Creates a new uninitialized object (constructor is not invoked)
            </summary>
            <param name="type">Type to create</param>
            <typeparam name="T">Type to return (created object cast to this type)</typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.GenericIndexedEnumerator`1">
            <summary>
            Generic enumerator of indexed values within a span
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Helper.GenericIndexedEnumerator`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.UInt32})">
            <summary>
            Constructor
            </summary>
            <param name="data"></param>
            <param name="indices"></param>
        </member>
        <member name="P:BrightData.Helper.GenericIndexedEnumerator`1.Current">
            <summary>
            Current item
            </summary>
        </member>
        <member name="M:BrightData.Helper.GenericIndexedEnumerator`1.MoveNext">
            <summary>
            Moves to next item
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericIndexedEnumerator`1.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.SerialisationHelper">
            <summary>
            Serialisation helpers
            </summary>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.String,System.IO.BinaryWriter)">
            <summary>
            Writes the string
            </summary>
            <param name="str"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.Int32,System.IO.BinaryWriter)">
            <summary>
            Writes the integer
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.UInt32,System.IO.BinaryWriter)">
            <summary>
            Writes the uint
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.Double,System.IO.BinaryWriter)">
            <summary>
            Writes the double
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.Single,System.IO.BinaryWriter)">
            <summary>
            Writes the float
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo``1(System.Nullable{``0},System.IO.BinaryWriter,System.Action{``0})">
            <summary>
            Conditionally writes a nullable value
            </summary>
            <param name="val"></param>
            <param name="writer"></param>
            <param name="onWrite"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.ReadNullable``1(System.IO.BinaryReader,System.Func{``0})">
            <summary>
            Conditionally reads a nullable value
            </summary>
            <param name="reader"></param>
            <param name="onRead"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.Collections.Generic.IReadOnlyCollection{BrightData.ICanWriteToBinaryWriter},System.IO.BinaryWriter)">
            <summary>
            Writes the collection of items
            </summary>
            <param name="list"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo``1(``0[],System.IO.BinaryWriter)">
            <summary>
            Writes the array
            </summary>
            <param name="array"></param>
            <param name="writer"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo``1(``0[][],System.IO.BinaryWriter)">
            <summary>
            Writes an array of arrays to a binary writer
            </summary>
            <param name="arrayOfArrays"></param>
            <param name="writer"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.ReadArrayOfArrays``1(System.IO.BinaryReader)">
            <summary>
            Reads an array of arrays from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.WriteTo(System.String[],System.IO.BinaryWriter)">
            <summary>
            Writes the array of strings
            </summary>
            <param name="array"></param>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.Create``1(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a new object after reading its serialized data from the reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.ReadObjectArray``1(System.IO.BinaryReader,BrightData.BrightDataContext)">
            <summary>
            Reads an array of objects from the reader
            </summary>
            <param name="reader"></param>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.ReadStructArray``1(System.IO.BinaryReader)">
            <summary>
            Reads an array of structs from the reader
            </summary>
            <param name="reader"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.SerialisationHelper.ReadStringArray(System.IO.BinaryReader)">
            <summary>
            Reads an array of strings from the reader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.SpanAggregationOperation`1">
            <summary>
            Defines a span aggregation operation that will apply to each element within the span
            </summary>
            <typeparam name="T"></typeparam>
            <param name="existingVal">Previous value</param>
            <param name="val">New value</param>
            <param name="total">Number of previous aggregation operations (including this one)</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.SpanAggregator`1">
            <summary>
            A span aggregator
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Helper.SpanAggregator`1.GetOnlineAverage(System.UInt32)">
            <summary>
            Creates a span aggregator that calculates the average of each value (online algorithm)
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.SpanAggregator`1.Dispose">
            <summary>
            Disposes the span aggregation
            </summary>
        </member>
        <member name="M:BrightData.Helper.SpanAggregator`1.Add(System.ReadOnlySpan{`0})">
            <summary>
            Adds a new operation
            </summary>
            <param name="span"></param>
        </member>
        <member name="P:BrightData.Helper.SpanAggregator`1.Span">
            <summary>
            The aggregation result
            </summary>
        </member>
        <member name="F:BrightData.Helper.SpanAggregator`1.OnlineAverage">
            <summary>
            Online average aggregation
            </summary>
        </member>
        <member name="T:BrightData.Helper.StringIndexer">
            <summary>
            Builds a string table
            </summary>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.#ctor(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.Create(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.GetIndex(System.String)">
            <summary>
            Returns the index of a string (creates it if not already in table)
            </summary>
            <param name="str">String to search</param>
            <returns>String index</returns>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OutputSize">
            <summary>
            Size of the string table
            </summary>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OrderedStrings">
            <summary>
            Returns all strings by indexed order
            </summary>
        </member>
        <member name="T:BrightData.Helper.ThreadSafeHashSet`1">
            <summary>
            A hash set that can be accessed by more than one thread at the same time
            </summary>
            <typeparam name="T">The wrapped type</typeparam>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Finalize">
            <summary>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</summary>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Add(`0)">
            <summary>
            Adds a new item
            </summary>
            <param name="item">Item to add</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Clear">
            <summary>
            Clears all items
            </summary>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Contains(`0)">
            <summary>
            Checks if the set contains the specified item
            </summary>
            <param name="item">Item to find</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.Remove(`0)">
            <summary>
            Removes an item
            </summary>
            <param name="item">Item to remove</param>
            <returns>True if the item was removed</returns>
        </member>
        <member name="P:BrightData.Helper.ThreadSafeHashSet`1.Count">
            <summary>
            The number of items in the set
            </summary>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.ForEach(System.Action{`0})">
            <summary>
            Applies a callback to each item in the set
            </summary>
            <param name="callback"></param>
        </member>
        <member name="M:BrightData.Helper.ThreadSafeHashSet`1.TryPop(`0@)">
            <summary>
            Tries to pop an item from the set
            </summary>
            <param name="ret">Item that was removed</param>
            <returns>True if there was an item to remove</returns>
        </member>
        <member name="T:BrightData.IHaveBrightDataContext">
            <summary>
            Indicates that the type has a data context
            </summary>
        </member>
        <member name="P:BrightData.IHaveBrightDataContext.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="T:BrightData.IHaveIndices">
            <summary>
            Indicates that the type has a list of indices
            </summary>
        </member>
        <member name="P:BrightData.IHaveIndices.Indices">
            <summary>
            Enumerates the indices
            </summary>
        </member>
        <member name="T:BrightData.IHaveSpanOf`1">
            <summary>
            Indicates that the type can create a readonly span of floats
            </summary>
        </member>
        <member name="M:BrightData.IHaveSpanOf`1.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{`0}@,System.Boolean@)">
            <summary>
            Returns a span of floats
            </summary>
            <param name="temp">Optional buffer that might be needed when creating the span</param>
            <param name="wasTempUsed">True if the buffer was used</param>
            <returns>Span of floats</returns>
        </member>
        <member name="T:BrightData.ICanWriteToBinaryWriter">
            <summary>
            Indicates that the type can serialize to a binary writer
            </summary>
        </member>
        <member name="M:BrightData.ICanWriteToBinaryWriter.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Serialize to binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:BrightData.ICanInitializeFromBinaryReader">
            <summary>
            Indicates that the type can initialize from a binary reader
            </summary>
        </member>
        <member name="M:BrightData.ICanInitializeFromBinaryReader.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <summary>
            Initialize from a binary reader
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">Reader to read from to initialize</param>
        </member>
        <member name="T:BrightData.IAmSerializable">
            <summary>
            Supports both writing and reading from binary
            </summary>
        </member>
        <member name="T:BrightData.IHaveMetaData">
            <summary>
            Indicates that the type has a meta data store
            </summary>
        </member>
        <member name="P:BrightData.IHaveMetaData.MetaData">
            <summary>
            Meta data store
            </summary>
        </member>
        <member name="T:BrightData.IDataReader">
            <summary>
            Typed data reader
            </summary>
        </member>
        <member name="M:BrightData.IDataReader.Read``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed value from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataReader.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed array from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IWriteToMetaData">
            <summary>
            Indicates that the type can write values to meta data
            </summary>
        </member>
        <member name="M:BrightData.IWriteToMetaData.WriteTo(BrightData.Types.MetaData)">
            <summary>
            Writes values to meta data
            </summary>
            <param name="metadata">Meta data store</param>
        </member>
        <member name="T:BrightData.IDataAnalyser">
            <summary>
            Base data analyzer type
            </summary>
        </member>
        <member name="M:BrightData.IDataAnalyser.AddObject(System.Object)">
            <summary>
            Adds an object to analyze
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IAcceptSequentialTypedData`1">
            <summary>
            Typed data can be sequentially added
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IAcceptSequentialTypedData`1.Add(`0)">
            <summary>
            Adds a typed object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IDataAnalyser`1">
            <summary>
            Typed data analyser
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.NormalizationType">
            <summary>
            Types of data normalization
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Standard">
            <summary>
            Standard deviation
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Euclidean">
            <summary>
            Euclidean norm
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Manhattan">
            <summary>
            Manhattan
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.FeatureScale">
            <summary>
            Between 0..1
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert">
            <summary>
            Indicates that the type can convert different types
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.From">
            <summary>
            Type that is converted from
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.To">
            <summary>
            Type that is converted to
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert`2">
            <summary>
            Typed converter interface
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.ICanConvert`2.Convert(`0)">
            <summary>
            Converts a type from one to another
            </summary>
            <param name="data">Object to convert</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.INormalize">
            <summary>
            Data normalizer
            </summary>
        </member>
        <member name="P:BrightData.INormalize.NormalizationType">
            <summary>
            Type of data normalization
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Divide">
            <summary>
            Value to divide each value
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Subtract">
            <summary>
            Value to subtract from each value
            </summary>
        </member>
        <member name="T:BrightData.AggregationType">
            <summary>
            Types of aggregations
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Sum">
            <summary>
            Sums values to a final value
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Average">
            <summary>
            Averages values
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Max">
            <summary>
            Finds the maximum value
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Min">
            <summary>
            Finds the minimum value
            </summary>
        </member>
        <member name="T:BrightData.IDistribution`1">
            <summary>
            Data distribution
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDistribution`1.Sample">
            <summary>
            Samples a value from the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDiscreteDistribution">
            <summary>
            Discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.INonNegativeDiscreteDistribution">
            <summary>
            Positive discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.IContinuousDistribution">
            <summary>
            Continuous data distribution
            </summary>
        </member>
        <member name="T:BrightData.IHaveSize">
            <summary>
            Indicates that the type has a size
            </summary>
        </member>
        <member name="P:BrightData.IHaveSize.Size">
            <summary>
            Number of items
            </summary>
        </member>
        <member name="T:BrightData.IIndexStrings">
            <summary>
            Indicates that the type can convert string to string indices
            </summary>
        </member>
        <member name="M:BrightData.IIndexStrings.GetIndex(System.String)">
            <summary>
            Returns the index for a string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IIndexStrings.OutputSize">
            <summary>
            Gets the total number of possible string indices
            </summary>
        </member>
        <member name="T:BrightData.IHaveStringIndexer">
            <summary>
            Indicates that the type has string indexer
            </summary>
        </member>
        <member name="P:BrightData.IHaveStringIndexer.Indexer">
            <summary>
            String indexer
            </summary>
        </member>
        <member name="T:BrightData.DataSpecificationType">
            <summary>
            Type of data specification
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.Field">
            <summary>
            Represents a field of data
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.Composite">
            <summary>
            Represents an item that holds a set of other items
            </summary>
        </member>
        <member name="F:BrightData.DataSpecificationType.FieldSet">
            <summary>
            Represents a field that takes a value from one of a set of possibilities
            </summary>
        </member>
        <member name="T:BrightData.IDataTypeSpecification">
            <summary>
            Data type specifications can validate a data source
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.Name">
            <summary>
            Name of this item
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.Children">
            <summary>
            Children of this item (optional)
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.UnderlyingType">
            <summary>
            Underlying .net type for this item
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.SpecificationType">
            <summary>
            Item type
            </summary>
        </member>
        <member name="P:BrightData.IDataTypeSpecification.CanRepeat">
            <summary>
            True if the item can repeat
            </summary>
        </member>
        <member name="T:BrightData.IDataTypeSpecification`1">
            <summary>
            Typed data specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDataTypeSpecification`1.IsValid(`0)">
            <summary>
            Checks if the typed instance is valid against the specification
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTypeSpecification`1.AddPredicate(System.Predicate{`0})">
            <summary>
            Adds an additional predicate that must match to be considered valid
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="T:BrightData.INotifyUser">
            <summary>
            Notifies the user of operations and messages
            </summary>
        </member>
        <member name="M:BrightData.INotifyUser.OnStartOperation(System.Guid,System.String)">
            <summary>
            Called at the start of an operation
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="msg">Optional message associated with the operation</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnOperationProgress(System.Guid,System.Single)">
            <summary>
            Called when the operation has progressed
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="progressPercent">Progress percentage (between 0 and 1)</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnCompleteOperation(System.Guid,System.Boolean)">
            <summary>
            Called when the operation has completed
            </summary>
            <param name="operationId">Unique id for this operation</param>
            <param name="wasCancelled">True if the operation was cancelled</param>
        </member>
        <member name="M:BrightData.INotifyUser.OnMessage(System.String)">
            <summary>
            Called to notify the user
            </summary>
            <param name="msg">Message to user</param>
        </member>
        <member name="T:BrightData.ICountReferences">
            <summary>
            Reference counter
            </summary>
        </member>
        <member name="M:BrightData.ICountReferences.AddRef">
            <summary>
            Adds a reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ICountReferences.Release">
            <summary>
            Removes a reference (and might release the data)
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ICountReferences.IsValid">
            <summary>
            Checks if there is still a valid reference count (and that the data has not been released)
            </summary>
        </member>
        <member name="T:BrightData.ICanRandomlyAccessUnmanagedData`1">
            <summary>
            Indicates that the type can randomly access typed data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ICanRandomlyAccessUnmanagedData`1.Get(System.Int32,`0@)">
            <summary>
            Returns a randomly accessed item
            </summary>
            <param name="index">Item index</param>
            <param name="value">Item value</param>
        </member>
        <member name="M:BrightData.ICanRandomlyAccessUnmanagedData`1.Get(System.UInt32,`0@)">
            <summary>
            Returns a randomly accessed item
            </summary>
            <param name="index">Item index</param>
            <param name="value">Item value</param>
        </member>
        <member name="M:BrightData.ICanRandomlyAccessUnmanagedData`1.GetSpan(System.UInt32,System.UInt32)">
            <summary>
            Returns a span of data
            </summary>
            <param name="startIndex">Inclusive first index of the span</param>
            <param name="count">Size of the span</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanRandomlyAccessData">
            <summary>
            Indicates that the type can randomly access untyped data
            </summary>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData.Item(System.Int32)">
            <summary>
            Returns the untyped item at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData.Item(System.UInt32)">
            <summary>
            Returns the untyped item at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanRandomlyAccessData`1">
            <summary>
            Indicates that the type can randomly access typed data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData`1.Item(System.Int32)">
            <summary>
            Returns the typed at at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ICanRandomlyAccessData`1.Item(System.UInt32)">
            <summary>
            Returns the typed at at this index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveMutableReference`1">
            <summary>
            Indicates that type exposes a mutable reference
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.IHaveMutableReference`1.Current">
            <summary>
            The current mutable reference
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyUnmanagedEnumerator`1">
            <summary>
            A read only reference enumerator for unmanaged types
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IReadOnlyUnmanagedEnumerator`1.MoveNext">
            <summary>
            Moves to the next item
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyUnmanagedEnumerator`1.Reset">
            <summary>
            Resets the enumerator
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyUnmanagedEnumerator`1.Current">
            <summary>
            Returns a readonly reference to the current item
            </summary>
        </member>
        <member name="T:BrightData.IConvertStructsToObjects`2">
            <summary>
            Indicates that the type can convert structs to other types
            </summary>
            <typeparam name="CT"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IConvertStructsToObjects`2.Convert(`0@)">
            <summary>
            Converts a struct to another type
            </summary>
            <param name="item">The item to convert</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IOperation`1">
            <summary>
            A generic operation that might require user notification and that can be cancelled
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IOperation`1.Complete(BrightData.INotifyUser,System.Threading.CancellationToken)">
            <summary>
            Tries to complete the operation
            </summary>
            <param name="notifyUser">Optional interface to notify the user of progress</param>
            <param name="cancellationToken">Cancellation token to cancel operation</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IndexListWithLabel`1">
            <summary>
            An index list with a typed label
            </summary>
            <param name="Label"></param>
            <param name="Data"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IndexListWithLabel`1.#ctor(`0,BrightData.Types.IndexList)">
            <summary>
            An index list with a typed label
            </summary>
            <param name="Label"></param>
            <param name="Data"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.IndexListWithLabel`1.Label">
            <summary></summary>
        </member>
        <member name="P:BrightData.IndexListWithLabel`1.Data">
            <summary></summary>
        </member>
        <member name="T:BrightData.WeightedIndexListWithLabel`1">
            <summary>
            A weighted index list with a typed label
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Label"></param>
            <param name="Data"></param>
        </member>
        <member name="M:BrightData.WeightedIndexListWithLabel`1.#ctor(`0,BrightData.Types.WeightedIndexList)">
            <summary>
            A weighted index list with a typed label
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Label"></param>
            <param name="Data"></param>
        </member>
        <member name="P:BrightData.WeightedIndexListWithLabel`1.Label">
            <summary></summary>
        </member>
        <member name="P:BrightData.WeightedIndexListWithLabel`1.Data">
            <summary></summary>
        </member>
        <member name="T:BrightData.DataTableOrientation">
            <summary>
            Determines if the data table is oriented as either rows or columns
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.Unknown">
            <summary>
            Pathological case
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.RowOriented">
            <summary>
            Data table is stored as a series of rows
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.ColumnOriented">
            <summary>
            Data table is stored as aa series of columns
            </summary>
        </member>
        <member name="T:BrightData.BrightDataType">
            <summary>
            Data types enumeration
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Unknown">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Boolean">
            <summary>
            Boolean values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.SByte">
            <summary>
            Signed byte values (-128 to 128)
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Short">
            <summary>
            Short values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Int">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Long">
            <summary>
            Long values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Float">
            <summary>
            Float values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Double">
            <summary>
            Double values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Decimal">
            <summary>
            Decimal values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.String">
            <summary>
            String values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Date">
            <summary>
            Date values
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.IndexList">
            <summary>
            List of indices
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.WeightedIndexList">
            <summary>
            Weighted list of indices
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Vector">
            <summary>
            Vector of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Matrix">
            <summary>
            Matrix of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Tensor3D">
            <summary>
            3D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.Tensor4D">
            <summary>
            4D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.BinaryData">
            <summary>
            Binary data
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.TimeOnly">
            <summary>
            Time only
            </summary>
        </member>
        <member name="F:BrightData.BrightDataType.DateOnly">
            <summary>
            Date only
            </summary>
        </member>
        <member name="T:BrightData.ColumnClass">
            <summary>
            Column classifications
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Unknown">
            <summary>
            Unknown category
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Categorical">
            <summary>
            Forms a category - a set of possible values
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Numeric">
            <summary>
            Numbers (float, int etc)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Decimal">
            <summary>
            Floating point numbers (float, double, decimal)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Struct">
            <summary>
            Struct (blittable)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Tensor">
            <summary>
            Tensor (vector, matrix etc)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.IndexBased">
            <summary>
            Has an index (index list, weighted index list)
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.DateTime">
            <summary>
            Date and time
            </summary>
        </member>
        <member name="F:BrightData.ColumnClass.Integer">
            <summary>
            Whole number
            </summary>
        </member>
        <member name="T:BrightData.ColumnConversion">
            <summary>
            Single column conversion options
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.Unchanged">
            <summary>
            Leave the column unchanged (nop)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToBoolean">
            <summary>
            Convert to boolean
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToDateTime">
            <summary>
            Convert to date time
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToDate">
            <summary>
            Convert to date
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToTime">
            <summary>
            Convert to time
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToNumeric">
            <summary>
            Convert to numeric (best numeric size will be automatically determined)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToString">
            <summary>
            Convert to string
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToIndexList">
            <summary>
            Convert to index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToWeightedIndexList">
            <summary>
            Convert to weighted index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToVector">
            <summary>
            Convert to vector
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToCategoricalIndex">
            <summary>
            Convert each value to an index within a dictionary
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToByte">
            <summary>
            Convert to signed byte
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToShort">
            <summary>
            Convert to short
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToInt">
            <summary>
            Convert to int
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToLong">
            <summary>
            Convert to long 
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToFloat">
            <summary>
            Convert to float
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToDouble">
            <summary>
            Convert to double
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.ToDecimal">
            <summary>
            Convert to decimal
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversion.Custom">
            <summary>
            Custom conversion
            </summary>
        </member>
        <member name="T:BrightData.IDataTableVectoriser">
            <summary>
            Data table vectoriser
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(System.Object[])">
            <summary>
            Vectorise a table row
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(BrightData.ICanRandomlyAccessData)">
            <summary>
            Vectorise a data table segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IDataTableVectoriser.OutputSize">
            <summary>
            Size of the output vectors
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.GetOutputLabel(System.UInt32,System.UInt32)">
            <summary>
            Returns the associated label from the one hot encoding dictionary
            </summary>
            <param name="vectorIndex">Index within one hot encoded vector</param>
            <param name="columnIndex">Data table column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Enumerate">
            <summary>
            Returns a sequence of vectorised table rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.TableRow.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.ICompositeBuffer`1">
            <summary>
            Composite buffers add data in memory until a pre specified limit and then store the remainder in a temp file
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.IBuildDataTables.TableMetaData">
            <summary>
            Table level meta data
            </summary>
        </member>
        <member name="P:BrightData.IBuildDataTables.ColumnMetaData">
            <summary>
            Per column meta data
            </summary>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateColumnsFrom(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Copies existing column definitions from another table
            </summary>
            <param name="table">Other table</param>
            <param name="columnIndices">Indices of column definitions to copy</param>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateColumn(BrightData.BrightDataType,System.String)">
            <summary>
            Adds a new column
            </summary>
            <param name="type">New column type</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateColumn(BrightData.BrightDataType,BrightData.Types.MetaData)">
            <summary>
            Adds a new column
            </summary>
            <param name="type">New column type</param>
            <param name="metaData">Column meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateColumn``1(System.String)">
            <summary>
            Adds a new column
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBuildDataTables.AddRow(System.Object[])">
            <summary>
            Adds a row to the table
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:BrightData.IBuildDataTables.WriteTo(System.IO.Stream)">
            <summary>
            Writes the data table to a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateFixedSizeVectorColumn(System.UInt32,System.String)">
            <summary>
            Adds a fixed size vector column
            </summary>
            <param name="size">Size of the vector</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateFixedSizeMatrixColumn(System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a fixed size matrix column
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateFixedSize3DTensorColumn(System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a fixed size 3D tensor column 
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBuildDataTables.CreateFixedSize4DTensorColumn(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a fixed size 4D tensor column
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="name">New column name</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveLinearAlgebraProvider">
            <summary>
            Gives access to a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.IHaveLinearAlgebraProvider.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.ISetLinearAlgebraProvider">
            <summary>
            Indicates that the type can set a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.ISetLinearAlgebraProvider.LinearAlgebraProvider">
            <summary>
            Property to set the linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.ISetLinearAlgebraProvider.LinearAlgebraProviderFactory">
            <summary>
            Linear algebra provider factory
            </summary>
        </member>
        <member name="T:BrightData.DistanceMetric">
            <summary>
            Distance metrics
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Euclidean">
            <summary>
            Euclidean Distance - https://en.wikipedia.org/wiki/Euclidean_distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Cosine">
            <summary>
            Cosine Distance Metric - https://en.wikipedia.org/wiki/Cosine_similarity
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Manhattan">
            <summary>
            Manhattan Distance - https://en.wikipedia.org/wiki/Taxicab_geometry
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.MeanSquared">
            <summary>
            Means Square Error
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.SquaredEuclidean">
            <summary>
            Square Euclidean - https://en.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Angular">
            <summary>
            Angular distance - https://en.wikipedia.org/wiki/Angular_distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.InnerProductSpace">
            <summary>
            Inner product distance - https://en.wikipedia.org/wiki/Inner_product_space
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyNumericSegment`1">
            <summary>
            Read only tensor segment
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.SegmentType">
            <summary>
            Segment type
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.Item(System.Int32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.Item(System.UInt32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.Item(System.Int64)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.Item(System.UInt64)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyNumericSegment`1.ToNewArray">
            <summary>
            Creates a new array from the segment
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.Values">
            <summary>
            Iterates all values in the segment
            </summary>
        </member>
        <member name="M:BrightData.IReadOnlyNumericSegment`1.CopyTo(BrightData.INumericSegment{`0},System.UInt32,System.UInt32)">
            <summary>
            Copies this segment to another segment
            </summary>
            <param name="segment">Segment to copy to</param>
            <param name="sourceOffset">Index within this segment to copy from</param>
            <param name="targetOffset">Index within other segment to replace from</param>
        </member>
        <member name="M:BrightData.IReadOnlyNumericSegment`1.CopyTo(System.Span{`0})">
            <summary>
            Copies this segment to a span
            </summary>
            <param name="destination">Destination span</param>
        </member>
        <member name="M:BrightData.IReadOnlyNumericSegment`1.CopyTo(`0*,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies to a pointer
            </summary>
            <param name="destination">Pointer to memory to copy to</param>
            <param name="sourceOffset">Index within this segment to copy from</param>
            <param name="stride">Increment after each copy</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.Contiguous">
            <summary>
            Tries to return a contiguous span from the current segment if possible
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyNumericSegment`1.IsWrapper">
            <summary>
            True if the segment wraps another segment
            </summary>
        </member>
        <member name="T:BrightData.INumericSegment`1">
            <summary>
            A segment of a float tensor
            </summary>
        </member>
        <member name="P:BrightData.INumericSegment`1.Item(System.Int32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.INumericSegment`1.Item(System.UInt32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.INumericSegment`1.Item(System.Int64)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.INumericSegment`1.Item(System.UInt64)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.INumericSegment`1.CopyFrom(System.ReadOnlySpan{`0},System.UInt32)">
            <summary>
            Copies from the span into the segment
            </summary>
            <param name="span">Span to copy from</param>
            <param name="targetOffset">Index into this segment to replace from</param>
        </member>
        <member name="M:BrightData.INumericSegment`1.Clear">
            <summary>
            Sets each value within the segment to zero
            </summary>
        </member>
        <member name="M:BrightData.INumericSegment`1.GetUnderlyingArray">
            <summary>
            Returns the underlying array used by the segment (if available)
            </summary>
            <returns>Array, segment offset and segment stride</returns>
        </member>
        <member name="T:BrightData.IHaveReadOnlyTensorSegment`1">
            <summary>
            Indicates that there is an underlying tensor segment
            </summary>
        </member>
        <member name="P:BrightData.IHaveReadOnlyTensorSegment`1.ReadOnlySegment">
            <summary>
            Underlying tensor segment
            </summary>
        </member>
        <member name="T:BrightData.IHaveTensorSegment`1">
            <summary>
            Indicates that there is an underlying tensor segment
            </summary>
        </member>
        <member name="P:BrightData.IHaveTensorSegment`1.Segment">
            <summary>
            Underlying tensor segment
            </summary>
        </member>
        <member name="T:BrightData.IHaveReadOnlyContiguousSpan`1">
            <summary>
            Indicates that the type has a contiguous read only float span
            </summary>
        </member>
        <member name="P:BrightData.IHaveReadOnlyContiguousSpan`1.ReadOnlySpan">
            <summary>
            A read only span of floats
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyVector">
            <summary>
            Vector that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyVector.Item(System.Int32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyVector.Item(System.UInt32)">
            <summary>
            Returns a value at the index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyVector.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a new mutable vector that is a copy of this vector
            </summary>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveMatrixDimensions">
            <summary>
            Matrix dimensions
            </summary>
        </member>
        <member name="P:BrightData.IHaveMatrixDimensions.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.IHaveMatrixDimensions.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyMatrix">
            <summary>
            Matrix that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyMatrix.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.GetRow(System.UInt32)">
            <summary>
            Returns a row from the matrix
            </summary>
            <param name="rowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.GetColumn(System.UInt32)">
            <summary>
            Returns a column from the matrix
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.AllRows">
            <summary>
            Returns all rows as an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.AllColumns">
            <summary>
            Returns all columns as an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyMatrix.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a new mutable matrix that is a copy of this matrix
            </summary>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveTensor3DDimensions">
            <summary>
            3D tensor dimensions
            </summary>
        </member>
        <member name="P:BrightData.IHaveTensor3DDimensions.Depth">
            <summary>
            Number of matrices
            </summary>
        </member>
        <member name="P:BrightData.IHaveTensor3DDimensions.MatrixSize">
            <summary>
            Rows * Columns
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyTensor3D">
            <summary>
            3D tensor that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyTensor3D.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor3D.GetMatrix(System.UInt32)">
            <summary>
            Returns a matrix from the 3D tensor
            </summary>
            <param name="index">Matrix index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor3D.AllMatrices">
            <summary>
            Returns all matrices as an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor3D.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a new mutable tensor that is a copy of this tensor
            </summary>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveTensor4DDimensions">
            <summary>
            4D tensor dimensions
            </summary>
        </member>
        <member name="P:BrightData.IHaveTensor4DDimensions.Count">
            <summary>
            Number of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.IHaveTensor4DDimensions.TensorSize">
            <summary>
            MatrixSize * Depth
            </summary>
        </member>
        <member name="T:BrightData.IReadOnlyTensor4D">
            <summary>
            4D tensor that cannot be modified
            </summary>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IReadOnlyTensor4D.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor4D.GetTensor3D(System.UInt32)">
            <summary>
            Returns a 3D tensor from the 4D tensor
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor4D.AllTensors">
            <summary>
            Returns all tensors as an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IReadOnlyTensor4D.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Creates a new mutable tensor that is a copy of this tensor
            </summary>
            <param name="lap">Linear algebra provider</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor">
            <summary>
            Untyped tensor interface - vector, matrix, 3D tensor etc
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Context">
            <summary>
            Underlying bright data context
            </summary>
        </member>
        <member name="M:BrightData.ITensor.Reshape">
            <summary>
            Reshapes to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a matrix
            </summary>
            <param name="rows">Row count of each matrix (one parameter is optional null)</param>
            <param name="columns">Column count of each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 3D tensor
            </summary>
            <param name="depth">Number of matrices (one parameter is optional null)</param>
            <param name="rows">Number of rows in each matrix (one parameter is optional null)</param>
            <param name="columns">Number of columns in each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors (one parameter is optional null)</param>
            <param name="depth">Number of matrices in each 3D tensor (one parameter is optional null)</param>
            <param name="rows">Number of rows in each matrix (one parameter is optional null)</param>
            <param name="columns">Number of columns in each matrix (one parameter is optional null)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.Clear">
            <summary>
            Sets all values to zero
            </summary>
        </member>
        <member name="M:BrightData.ITensor.Clone">
            <summary>
            Creates a copy of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor.TotalSize">
            <summary>
            Total count of all values
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Shape">
            <summary>
            Tensor shape - for a vector the array will have a single element, for a matrix it will be [columns, rows], a 3D tensor will be [columns, rows, depth] etc
            </summary>
        </member>
        <member name="M:BrightData.ITensor.AddInPlace(BrightData.ITensor)">
            <summary>
            Adds a tensor to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.AddInPlace(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Adds a tensor to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.AddInPlace(System.Single)">
            <summary>
            Adds a value to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="scalar">Value to add</param>
        </member>
        <member name="M:BrightData.ITensor.MultiplyInPlace(System.Single)">
            <summary>
            Multiplies a value to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="scalar">Value to multiply</param>
        </member>
        <member name="M:BrightData.ITensor.SubtractInPlace(BrightData.ITensor)">
            <summary>
            Subtracts a tensor from this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.SubtractInPlace(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Subtracts a tensor from this tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.PointwiseMultiplyInPlace(BrightData.ITensor)">
            <summary>
            Multiplies each value in this tensor with the corresponding value in the other tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.PointwiseDivideInPlace(BrightData.ITensor)">
            <summary>
            Divides each value in this tensor with the corresponding value in the other tensor (the result will be stored in this tensor)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.ITensor.DotProduct(BrightData.ITensor)">
            <summary>
            Computes the dot product of this tensor with another tensor (of same length)
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.ConstrainInPlace(System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Modifies this tensor so that no value is less than or greater than supplied parameters
            </summary>
            <param name="minValue">Minimum value to allow (optional)</param>
            <param name="maxValue">Maximum value to allow (optional)</param>
        </member>
        <member name="M:BrightData.ITensor.Average">
            <summary>
            Finds the average value of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.L1Norm">
            <summary>
            Returns the L1 norm of this tensor (manhattan distance)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.L2Norm">
            <summary>
            Returns the L2 norm of this tensor (euclidean norm)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.IsEntirelyFinite">
            <summary>
            Checks if the tensor is entirely finite (does not contain NAN or Infinity)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.CosineDistance(BrightData.ITensor)">
            <summary>
            Calculates the cosine distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.EuclideanDistance(BrightData.ITensor)">
            <summary>
            Calculates the euclidean distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.MeanSquaredDistance(BrightData.ITensor)">
            <summary>
            Calculates the mean squared distance between this and another tensor
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.SquaredEuclideanDistance(BrightData.ITensor)">
            <summary>
            Calculates the squared euclidean distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.ManhattanDistance(BrightData.ITensor)">
            <summary>
            Calculates the manhattan distance between this and another tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.StdDev(System.Nullable{System.Single})">
            <summary>
            Calculates the standard deviation of this tensor
            </summary>
            <param name="mean">Existing mean of tensor if available (otherwise it will be calculated)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor.RoundInPlace(System.Single,System.Single)">
            <summary>
            Rounds each value in this tensor to either the lower or upper parameter (the result will be stored in this tensor)
            </summary>
            <param name="lower"></param>
            <param name="upper"></param>
        </member>
        <member name="M:BrightData.ITensor.MapInPlace(System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value of this tensor (the result will be stored in this tensor)
            </summary>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.ITensor.L1RegularisationInPlace(System.Single)">
            <summary>
            Applies L1 regularization to this tensor (the result will be stored in this tensor)
            </summary>
            <param name="coefficient"></param>
        </member>
        <member name="M:BrightData.ITensor.Sum">
            <summary>
            Sums all values of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor`1">
            <summary>
            Typed tensor interface - vector, matrix, 3D tensor etc
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ITensor`1.Clone">
            <summary>
            Creates a clone of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Add(BrightData.ITensor)">
            <summary>
            Adds a tensor to this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Add(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Adds a tensor to this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Coefficient to multiply each value in this tensor</param>
            <param name="coefficient2">Coefficient to multiply each value in the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Add(System.Single)">
            <summary>
            Adds a value to each element in this tensor
            </summary>
            <param name="scalar">Value to add</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Multiply(System.Single)">
            <summary>
            Multiplies a value to each element in this tensor
            </summary>
            <param name="scalar">Value to multiply</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Subtract(BrightData.ITensor)">
            <summary>
            Subtracts another tensor from this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Subtract(BrightData.ITensor,System.Single,System.Single)">
            <summary>
            Subtracts another tensor from this tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Coefficient to multiply each value in this tensor</param>
            <param name="coefficient2">Coefficient to multiply each value in the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.PointwiseMultiply(BrightData.ITensor)">
            <summary>
            Multiplies each value in this tensor with the corresponding value in another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.PointwiseDivide(BrightData.ITensor)">
            <summary>
            Divides each value in this tensor with the corresponding value in another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Sqrt">
            <summary>
            Returns the square root of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Reverse">
            <summary>
            Reverses the order of the elements in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Split(System.UInt32)">
            <summary>
            Splits this tensor into multiple contiguous tensors
            </summary>
            <param name="blockCount">Number of blocks</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Abs">
            <summary>
            Computes the absolute value of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Log">
            <summary>
            Computes the natural logarithm of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Exp">
            <summary>
            Computes the exponent of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Squared">
            <summary>
            Computes the square of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Sigmoid">
            <summary>
            Computes the sigmoid function of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.SigmoidDerivative">
            <summary>
            Computes the sigmoid derivative for each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Tanh">
            <summary>
            Computes the hyperbolic tangent of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.TanhDerivative">
            <summary>
            Computes the derivative of the hyperbolic tangent for each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Relu">
            <summary>
            Computes the RELU activation for each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.ReluDerivative">
            <summary>
            Computes the RELU derivative of each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.LeakyRelu">
            <summary>
            Computes the Leaky RELU action for each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.LeakyReluDerivative">
            <summary>
            Computes the Leaky RELU derivative for each value in this tensor
            https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Softmax">
            <summary>
            Computes the softmax of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.SoftmaxDerivative">
            <summary>
            Computes the softmax derivative of each value in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Pow(System.Single)">
            <summary>
            Raises each element in this tensor by power
            </summary>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.CherryPick(System.UInt32[])">
            <summary>
            Returns a new tensor with the values specified in indices
            </summary>
            <param name="indices">Indices to return in new tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor`1.Map(System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to this tensor
            </summary>
            <param name="mutator">Mapping function</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IVector">
            <summary>
            Vector interface
            </summary>
        </member>
        <member name="P:BrightData.IVector.Item(System.Int32)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IVector.Item(System.UInt32)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IVector.Item(System.Int64)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IVector.Item(System.UInt64)">
            <summary>
            Returns a value at the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IVector.MapIndexed(System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function that also accepts the vector index
            </summary>
            <param name="mutator"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IVector.MapIndexedInPlace(System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function that also accepts the vector index (vector will be modified in place)
            </summary>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.IVector.ToArray">
            <summary>
            Returns all values in an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IVector.Clone">
            <summary>
            Clones the vector
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IMatrix">
            <summary>
            Matrix interface
            </summary>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.Int32,System.Int32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.Int64,System.Int64)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMatrix.Item(System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the matrix
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Row(System.UInt32)">
            <summary>
            Returns a row from the matrix
            </summary>
            <param name="index">Row index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Column(System.UInt32)">
            <summary>
            Returns a column from the matrix
            </summary>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetRowSpan(System.UInt32,CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@)">
            <summary>
            Returns a row as a span
            </summary>
            <param name="rowY">Row index</param>
            <param name="temp">Temporary buffer in which to write the contiguous row values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetColumnSpan(System.UInt32)">
            <summary>
            Returns a column as a span
            </summary>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetRowVector(System.UInt32)">
            <summary>
            Returns a row as a vector
            </summary>
            <param name="rowY">Row index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetColumnVector(System.UInt32)">
            <summary>
            Returns a column as a vector
            </summary>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Transpose">
            <summary>
            Returns the transpose of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Multiply(BrightData.IMatrix)">
            <summary>
            Multiply this matrix with another matrix (matrix multiplication)
            </summary>
            <param name="other">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.TransposeAndMultiply(BrightData.IMatrix)">
            <summary>
            Transpose the other matrix and then multiply with this matrix
            </summary>
            <param name="other">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.TransposeThisAndMultiply(BrightData.IMatrix)">
            <summary>
            Transpose this matrix and then multiply with another matrix
            </summary>
            <param name="other">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetDiagonal">
            <summary>
            Returns the diagonal of this matrix 
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.RowSums">
            <summary>
            Returns the sum of all rows in this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.ColumnSums">
            <summary>
            Returns the sum of all columns in this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Multiply(BrightData.IVector)">
            <summary>
            Multiplies this matrix with a vector
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.SplitAtColumn(System.UInt32)">
            <summary>
            Splits this matrix into two matrices from a column index
            </summary>
            <param name="columnIndex">Column index at which to split</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.SplitAtRow(System.UInt32)">
            <summary>
            Splits this matrix into two matrices from a row index
            </summary>
            <param name="rowIndex">Row index at which to split</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.ConcatBelow(BrightData.IMatrix)">
            <summary>
            Concatenates this matrix with another matrix (column counts must agree)
            </summary>
            <param name="bottom"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.ConcatRight(BrightData.IMatrix)">
            <summary>
            Concatenates this matrix with another matrix (row counts must agree)
            </summary>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.MapIndexed(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <summary>
            Applies an indexed mapping function to this matrix
            </summary>
            <param name="mutator"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.MapIndexedInPlace(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <summary>
            Applies an indexed mapping function to this matrix (matrix will be modified in place)
            </summary>
            <param name="mutator"></param>
        </member>
        <member name="M:BrightData.IMatrix.Svd">
            <summary>
            Computes the singular value decomposition of this matrix
            https://en.wikipedia.org/wiki/Singular_value_decomposition
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetNewMatrixFromRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates a new matrix from the specified rows of this matrix
            </summary>
            <param name="rowIndices">Row indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetNewMatrixFromColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates a new matrix from the specified columns of this matrix
            </summary>
            <param name="columnIndices">Column indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.AddToEachRow(BrightData.INumericSegment{System.Single})">
            <summary>
            Adds a tensor segment to each row of this matrix (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.AddToEachColumn(BrightData.INumericSegment{System.Single})">
            <summary>
            Adds a tensor segment to each column of this matrix (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.MultiplyEachRowWith(BrightData.INumericSegment{System.Single})">
            <summary>
            Multiplies each row of this matrix with a tensor segment (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.MultiplyEachColumnWith(BrightData.INumericSegment{System.Single})">
            <summary>
            Multiplies each column of this matrix with a tensor segment (matrix will be modified in place)
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.IMatrix.SoftmaxPerRow">
            <summary>
            Computes the per row software of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.SoftmaxDerivativePerRow(BrightData.INumericSegment{System.Single}[])">
            <summary>
            Computes the per row softmax derivative of this matrix
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.Clone">
            <summary>
            Clones the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetRowAsReadOnly(System.UInt32)">
            <summary>
            Returns a row as a read only vector
            </summary>
            <param name="rowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.GetColumnAsReadOnly(System.UInt32)">
            <summary>
            Returns a column as a read only vector
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.AllRowsAsReadOnly(System.Boolean)">
            <summary>
            Returns all rows as read only vectors
            </summary>
            <param name="makeCopy">True to make a copy of each row</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMatrix.AllColumnsAsReadOnly(System.Boolean)">
            <summary>
            Returns all columns as read only vectors
            </summary>
            <param name="makeCopy">True to make a copy of each column</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor3D">
            <summary>
            3D tensor - a block of matrices
            </summary>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor3D.Item(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from this 3D tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.GetMatrix(System.UInt32)">
            <summary>
            Returns a matrix from the tensor
            </summary>
            <param name="index">Matrix index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AddPadding(System.UInt32)">
            <summary>
            Creates a new 3D tensor with a "padding" of zeroes around the edge of each matrix
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.RemovePadding(System.UInt32)">
            <summary>
            Removes previously added "padding" from the edge of each matrix
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Image to column (convolution operator)
            </summary>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="xStride">Horizontal stride</param>
            <param name="yStride">Vertical stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a previous image to column operation (convolution)
            </summary>
            <param name="filter"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="outputDepth"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Computes a max pooling operation
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <param name="saveIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.ReverseMaxPool(BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a max pooling operation
            </summary>
            <param name="indices"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AddAllMatrices">
            <summary>
            Adds all matrices into one new matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.MultiplyEachMatrixBy(BrightData.IMatrix)">
            <summary>
            Multiply each matrix individually by another matrix
            </summary>
            <param name="matrix">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.TransposeAndMultiplyEachMatrixBy(BrightData.IMatrix)">
            <summary>
            Transpose another matrix and multiply each matrix individually by the result
            </summary>
            <param name="matrix">Other matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AddToEachRow(BrightData.IVector)">
            <summary>
            Adds a vector to each row of each matrix (tensor will be modified in place)
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.ITensor3D.AddToEachColumn(BrightData.IVector)">
            <summary>
            Adds a vector to each column of each matrix (tensor will be modified in place)
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.ITensor3D.Multiply(BrightData.ITensor4D)">
            <summary>
            Multiplies this matrix with a 4D tensor
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.TransposeAndMultiply(BrightData.ITensor4D)">
            <summary>
            Transposes the 4D matrix and multiplies this tensor with the result
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.TransposeThisAndMultiply(BrightData.ITensor4D)">
            <summary>
            Transposes this tensor and multiply the result with another 4D tensor
            </summary>
            <param name="other">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.Clone">
            <summary>
            Clones the tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.GetMatrixAsReadOnly(System.UInt32)">
            <summary>
            Returns a sub matrix
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor3D.AllMatricesAsReadOnly">
            <summary>
            Returns all sub matrices
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensor4D">
            <summary>
            4D tensor - a block of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor4D.Item(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from this 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.GetTensor(System.UInt32)">
            <summary>
            Returns a 3D tensor
            </summary>
            <param name="index">3D tensor index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.AddPadding(System.UInt32)">
            <summary>
            Adds padding to each 3D tensor
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.RemovePadding(System.UInt32)">
            <summary>
            Removes padding from each 3D tensor
            </summary>
            <param name="padding">Size of padding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Max pooling operation
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <param name="saveIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.ReverseMaxPool(BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverse max pooling operation
            </summary>
            <param name="indices"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Image to column (convolution operator)
            </summary>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverse of image to column (convolution operator)
            </summary>
            <param name="filter"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="outputDepth"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.ColumnSums">
            <summary>
            Computes the sum of all columns
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.RowSums">
            <summary>
            Computes the sum of all rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.Clone">
            <summary>
            Clones the tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.GetTensorAsReadOnly(System.UInt32)">
            <summary>
            Returns a sub tensor
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensor4D.AllTensorsAsReadOnly">
            <summary>
            Returns all sub tensors
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightMatrix`1">
            <summary>
            Row major matrix type
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.Int32,System.Int32)">
            <inheritdoc cref="T:BrightData.IMatrix" />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.UInt32,System.UInt32)">
            <inheritdoc cref="T:BrightData.IMatrix" />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.Int64,System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightMatrix`1.Item(System.UInt64,System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Row(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Column(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetRowSpan(System.UInt32,CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetColumnSpan(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Create(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetRowAsReadOnly(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetColumnAsReadOnly(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AllRowsAsReadOnly(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AllColumnsAsReadOnly(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetRowVector(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetColumnVector(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Transpose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Multiply(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetDiagonal">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.RowSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ColumnSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Multiply(BrightData.IVector)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.TransposeAndMultiply(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.TransposeThisAndMultiply(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MapIndexed(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MapIndexedInPlace(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SplitAtColumn(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SplitAtRow(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ConcatBelow(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ConcatRight(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Svd">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetNewMatrixFromRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.GetNewMatrixFromColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AddToEachRow(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.AddToEachColumn(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MultiplyEachRowWith(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.MultiplyEachColumnWith(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SoftmaxPerRow">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.SoftmaxDerivativePerRow(BrightData.INumericSegment{System.Single}[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix`1.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightMatrix">
            <summary>
            Matrix type
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightMatrix.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor3D`1">
            <summary>
            Row major 3D tensor
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,System.UInt32,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Rows in each matrix</param>
            <param name="columns">Columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Create(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.GetMatrixAsReadOnly(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Depth">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.MatrixSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor3D`1.Item(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AllMatricesAsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.GetMatrix(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddPadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.RemovePadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.ReverseMaxPool(BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddAllMatrices">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.MultiplyEachMatrixBy(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.TransposeAndMultiplyEachMatrixBy(BrightData.IMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddToEachRow(BrightData.IVector)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.AddToEachColumn(BrightData.IVector)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Multiply(BrightData.ITensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.TransposeAndMultiply(BrightData.ITensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.TransposeThisAndMultiply(BrightData.ITensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D`1.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor3D">
            <summary>
            3D tensor 
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor3D.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,System.UInt32,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Rows in each matrix</param>
            <param name="columns">Columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor4D`1">
            <summary>
            Row major 4D tensor
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,System.UInt32,System.UInt32,`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.Create(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Count">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Depth">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.MatrixSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.TensorSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensor4D`1.Item(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Returns a value from the 4D tensor
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix index</param>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.GetTensor(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.AddPadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.RemovePadding(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ReverseMaxPool(BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ReverseIm2Col(BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ColumnSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.RowSums">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.GetTensorAsReadOnly(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.AllTensorsAsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D`1.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensor4D">
            <summary>
            4D tensor
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensor4D.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,System.UInt32,System.UInt32,BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightTensorBase`2">
            <summary>
            Base tensor type
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="F:BrightData.LinearAlgebra.BrightTensorBase`2.Lap">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Create(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a typed tensor from a tensor segment
            </summary>
            <param name="segment">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.Segment">
            <summary>
            Underlying tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.Context">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.LinearAlgebraProvider">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Map(System.Func{System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.MapInPlace(System.Func{System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Clone">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Add(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Add(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Add(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.AddInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.AddInPlace(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.AddInPlace(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.MultiplyInPlace(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Multiply(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Subtract(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Subtract(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SubtractInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SubtractInPlace(BrightData.ITensor,System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseMultiply(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseMultiplyInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseDivide(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.PointwiseDivideInPlace(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.DotProduct(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Sqrt">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.ConstrainInPlace(System.Nullable{System.Single},System.Nullable{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Average">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.L1Norm">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.L2Norm">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.IsEntirelyFinite">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Reverse">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Split(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.CosineDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.EuclideanDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.MeanSquaredDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SquaredEuclideanDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.ManhattanDistance(BrightData.ITensor)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Abs">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Log">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Exp">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Squared">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.StdDev(System.Nullable{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Sigmoid">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SigmoidDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Tanh">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.TanhDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Relu">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.ReluDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.LeakyRelu">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.LeakyReluDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Softmax">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.SoftmaxDerivative">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Pow(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.RoundInPlace(System.Single,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.CherryPick(System.UInt32[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.L1RegularisationInPlace(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightTensorBase`2.Sum">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.ReadOnlySegment">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightTensorBase`2.IsReadOnly">
            <inheritdoc cref="T:BrightData.ITensor" />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightVector`1">
            <summary>
            Vector
            </summary>
            <typeparam name="LAP"></typeparam>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.#ctor(BrightData.INumericSegment{System.Single},`0)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.TotalSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Shape">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.Int32)">
            <inheritdoc cref="T:BrightData.IVector" />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.BrightVector`1.Item(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.ToArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.Create(BrightData.INumericSegment{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.MapIndexed(System.Func{System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.MapIndexedInPlace(System.Func{System.UInt32,System.Single,System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector`1.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.BrightVector">
            <summary>
            Vector
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.BrightVector.#ctor(BrightData.INumericSegment{System.Single},BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <summary>
            Constructor
            </summary>
            <param name="data">Tensor segment</param>
            <param name="lap">Linear algebra provider</param>
        </member>
        <member name="T:BrightData.LinearAlgebra.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="F:BrightData.LinearAlgebra.LinearAlgebraProvider.Scope">
            <summary>
            A scope of disposable objects
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.#ctor(BrightData.BrightDataContext)">
            <summary>
            Constructor
            </summary>
            <param name="context">Bright data context</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Finalize">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.ProviderName">
            <summary>
            Provider name
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.VectorType">
            <summary>
            Type of vectors that will be created
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.MatrixType">
            <summary>
            Type of matrices that will be created
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.Tensor3DType">
            <summary>
            Type of 3D tensors that will be created
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.LinearAlgebraProvider.Tensor4DType">
            <summary>
            Type of 4D tensors that will be created
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PushScope">
            <summary>
            Adds a new scope
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PopScope">
            <summary>
            Pops that last scope and disposes all objects within that scope
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateSegment(System.Single[])">
            <summary>
            Creates a tensor segment from an array
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateSegment(System.UInt32,System.Boolean)">
            <summary>
            Creates a tensor segment
            </summary>
            <param name="size">Segment size</param>
            <param name="initialiseToZero">True to initialize the all values in the segment to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateSegment(System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a tensor segment
            </summary>
            <param name="size">Segment size</param>
            <param name="initializer">Function to initialize each value in the segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Clone(BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Creates a clone of the tensor segment
            </summary>
            <param name="segment">Segment to clone</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a vector from a tensor segment
            </summary>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Creates a vector from a read only tensor segment
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.UInt32,System.Boolean)">
            <summary>
            Creates a vector
            </summary>
            <param name="size">Size of the vector</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.Single[])">
            <summary>
            Creates a vector from an array of floats
            </summary>
            <param name="data">Float array</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.UInt32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="size">Size of the vector</param>
            <param name="value">Initial value of each item in the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.ReadOnlySpan{System.Single})">
            <summary>
            Creates a vector from a span of floats
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="size">Size of the vector</param>
            <param name="initializer">Function to initialize each value in the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.IVector)">
            <summary>
            Creates a new vector from an existing vector
            </summary>
            <param name="vector">Vector to clone</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(BrightData.IReadOnlyVector)">
            <summary>
            Creates a vector from a read only vector
            </summary>
            <param name="vector">Read only vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateVector(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Creates a vector from an enumerable of floats
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a matrix from a segment
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Creates a matrix from a segment
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a matrix
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <param name="rowCount">Number of rows</param>
            <param name="columnCount">Number of columns</param>
            <param name="initializer">Function to initialize each value in the matrix that will receive (row index, column index)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(BrightData.IMatrix)">
            <summary>
            Creates a new matrix from an existing matrix
            </summary>
            <param name="matrix">Matrix to clone</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrix(BrightData.IReadOnlyMatrix)">
            <summary>
            Creates a matrix from a read only matrix
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(BrightData.IVector[])">
            <summary>
            Creates a matrix from the rows supplied as vectors
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from the rows supplied as read only vectors
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.Collections.Generic.IEnumerable{System.Single[]})">
            <summary>
            Creates a matrix from the rows supplied
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.Single[][])">
            <summary>
            Creates a matrix from the rows supplied
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRowsAndThenDisposeInput(BrightData.IVector[])">
            <summary>
            Creates a matrix from the rows supplied as vectors and then disposes each input vector
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(BrightData.IReadOnlyNumericSegment{System.Single}[])">
            <summary>
            Creates a matrix from the rows supplied as tensor segments
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.ReadOnlySpan{BrightData.IReadOnlyNumericSegment{System.Single}})">
            <summary>
            Creates a matrix from the rows supplied as tensor segments
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromRows(System.ReadOnlySpan{System.Single[]})">
            <summary>
            Creates a matrix from rows supplied
            </summary>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(BrightData.IVector[])">
            <summary>
            Creates a matrix from the columns supplied as vectors
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(BrightData.IReadOnlyVector[])">
            <summary>
            Creates a matrix from the columns supplied as read only vectors
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.Collections.Generic.IEnumerable{System.Single[]})">
            <summary>
            Creates a matrix from the columns supplied
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.Single[][])">
            <summary>
            Creates a matrix from the columns supplied
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumnsAndThenDisposeInput(BrightData.IVector[])">
            <summary>
            Creates a matrix from the columns supplied as vectors and then disposes each input vector
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(BrightData.IReadOnlyNumericSegment{System.Single}[])">
            <summary>
            Creates a matrix from the columns supplied as tensor segments
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.ReadOnlySpan{BrightData.IReadOnlyNumericSegment{System.Single}})">
            <summary>
            Creates a matrix from the columns supplied as tensor segments
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateMatrixFromColumns(System.ReadOnlySpan{System.Single[]})">
            <summary>
            Creates a matrix from the columns supplied
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(System.UInt32,System.UInt32,System.UInt32,BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rowCount">Rows in each matrix</param>
            <param name="columnCount">Columns in each matrix</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(System.UInt32,System.UInt32,System.UInt32,BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rowCount">Rows in each matrix</param>
            <param name="columnCount">Columns in each matrix</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rowCount">Rows in each matrix</param>
            <param name="columnCount">Columns in each matrix</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.IMatrix[])">
            <summary>
            Creates a 3D tensor from existing matrices
            </summary>
            <param name="matrices">Matrices that will form the 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.IReadOnlyMatrix[])">
            <summary>
            Creates a 3D tensor from existing matrices
            </summary>
            <param name="matrices">Matrices that will form the 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.ITensor3D)">
            <summary>
            Creates a 3D tensor from another 3D tensor (clone)
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D(BrightData.IReadOnlyTensor3D)">
            <summary>
            Creates a 3D tensor from a read only 3D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3DAndThenDisposeInput(BrightData.IMatrix[])">
            <summary>
            Creates a 3D tensor from existing matrices and then disposes each matrix
            </summary>
            <param name="matrices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3DAndThenDisposeInput(System.Span{BrightData.IMatrix})">
            <summary>
            Creates a 3D tensor from existing matrices and then disposes each matrix
            </summary>
            <param name="matrices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor3D``1(System.Span{``0})">
            <summary>
            Creates a 3D tensor from existing matrices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matrices"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(System.UInt32,System.UInt32,System.UInt32,System.UInt32,BrightData.IReadOnlyNumericSegment{System.Single})">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rowCount">Number of rows in each matrix</param>
            <param name="columnCount">Number of columns in each matrix</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(System.UInt32,System.UInt32,System.UInt32,System.UInt32,BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rowCount">Number of rows in each matrix</param>
            <param name="columnCount">Number of columns in each matrix</param>
            <param name="data">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rowCount">Number of rows in each matrix</param>
            <param name="columnCount">Number of columns in each matrix</param>
            <param name="initialiseToZero">True to initialize each value to zero</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.ITensor3D[])">
            <summary>
            Creates a 4D tensor from existing 3D tensors
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.IReadOnlyTensor3D[])">
            <summary>
            Creates a 4D tensor from existing 3D tensors
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.ITensor4D)">
            <summary>
            Clones this 4D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D(BrightData.IReadOnlyTensor4D)">
            <summary>
            Creates a 4D tensor from an existing 4D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4DAndThenDisposeInput(BrightData.ITensor3D[])">
            <summary>
            Creates a 4D tensor from existing 3D tensors and then disposes each 3D tensor
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4DAndThenDisposeInput(System.Span{BrightData.ITensor3D})">
            <summary>
            Creates a 4D tensor from existing 3D tensors and then disposes each 3D tensor
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor4D``1(System.Span{``0})">
            <summary>
            Creates a 4D tensor from existing 3D tensors
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensors"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetSize(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Returns the size from both tensors (the size is expected to be the same)
            </summary>
            <param name="tensor"></param>
            <param name="tensor2"></param>
            <returns></returns>
            <exception cref="T:System.Exception">Throws an exception if the tensors are a different size</exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallel(BrightData.INumericSegment{System.Single},System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment to create a new segment (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives each value from the segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallelInPlace(BrightData.INumericSegment{System.Single},System.Func{System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment in place (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives each value from the segment</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallel(BrightData.INumericSegment{System.Single},System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment to create a new segment (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives the index and each value from the segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MapParallelInPlace(BrightData.INumericSegment{System.Single},System.Func{System.UInt32,System.Single,System.Single})">
            <summary>
            Applies a mapping function to each value in the segment in place (potentially in parallel)
            </summary>
            <param name="segment"></param>
            <param name="mapper">Mapping function that receives the index and each value from the segment</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CreateTensor(System.UInt32[],BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a tensor from a tensor shape
            </summary>
            <param name="shape">Array containing the size of each dimension in the tensor</param>
            <param name="segment">Tensor segment</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Add(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Adds two tensors into a new tensor
            </summary>
            <param name="tensor"></param>
            <param name="tensor2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Add(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single},System.Single,System.Single)">
            <summary>
            Adds two tensors into a new tensor and applies coefficients to each element in the two tensors
            </summary>
            <param name="tensor"></param>
            <param name="tensor2"></param>
            <param name="coefficient1"></param>
            <param name="coefficient2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Add(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Creates a new tensor from adding a scalar to each element in the tensor 
            </summary>
            <param name="tensor"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddInPlace(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Adds another tensor to the first tensor which will be modified in place
            </summary>
            <param name="target">First tensor</param>
            <param name="other">Other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddInPlace(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single},System.Single,System.Single)">
            <summary>
            Adds another tensor to the first tensor and applies coefficients to each element in each tensor
            </summary>
            <param name="target">First tensor</param>
            <param name="other">Other tensor</param>
            <param name="coefficient1">Coefficient applied to each element of the first tensor</param>
            <param name="coefficient2">Coefficient applied to each element of the other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddInPlace(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Adds a scalar to each element of this tensor - modified in place
            </summary>
            <param name="target"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MultiplyInPlace(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Multiplies each element of the tensor by a scalar - modified in place
            </summary>
            <param name="target"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Multiply(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Creates a new tensor by multiplying each element of the tensor with a scalar
            </summary>
            <param name="target"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Subtract(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Subtracts the second tensor from the first tensor into a new tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Subtract(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single},System.Single,System.Single)">
            <summary>
            Subtracts the second tensor from the first tensor into a new tensor and applies coefficients to each value in each tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <param name="coefficient1">Coefficient to apply to each element in the first tensor</param>
            <param name="coefficient2">Coefficient to apply to each element in the second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SubtractInPlace(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Subtracts the second tensor from the first tensor - first tensor modified in place
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SubtractInPlace(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single},System.Single,System.Single)">
            <summary>
            Subtracts the second tensor from the first tensor and applies coefficient to each value in the tensors - first tensor modified in place
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <param name="coefficient1">Coefficient to apply to each element in the first tensor</param>
            <param name="coefficient2">Coefficient to apply to each element in the second tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PointwiseMultiply(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor by multiplying each element in the first tensor with the corresponding value in the second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PointwiseMultiplyInPlace(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Multiplies each element in the first tensor with the corresponding value in the second tensor - first tensor modified in place
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PointwiseDivide(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor by dividing each element in the first tensor with the corresponding value in the second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.PointwiseDivideInPlace(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Dividing each element in the first tensor with the corresponding value in the second tensor - first tensor is modified in place
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.DotProduct(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Calculates the dot product of the first with the second tensor
            </summary>
            <param name="tensor1"></param>
            <param name="tensor2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Sqrt(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Creates a new tensor that contains the square root of each value in this tensor
            </summary>
            <param name="tensor"></param>
            <param name="adjustment">A small value to add to each value in case of zeros</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ConstrainInPlace(BrightData.INumericSegment{System.Single},System.Nullable{System.Single},System.Nullable{System.Single})">
            <summary>
            Constrains each value in this tensor to lie between the min and max values (if supplied)
            </summary>
            <param name="tensor"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Average(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the average of the values in the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.L1Norm(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the L1 norm (manhattan distance) of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.L2Norm(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the L2 norm (euclidean distance) of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetMinAndMaxValues(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the minimum and maximum values of the tensor (and their corresponding indices)
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetMinIndex(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the index of the minimum value of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetMaxIndex(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the index of the maximum value of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetMin(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the minimum value of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetMax(BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the maximum value of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.IsEntirelyFinite(BrightData.INumericSegment{System.Single})">
            <summary>
            Checks if the tensor is entirely finite (not NaN or Infinity)
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Reverse(BrightData.INumericSegment{System.Single})">
            <summary>
            Reverse the order of the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Split(BrightData.IReadOnlyNumericSegment{System.Single},System.UInt32)">
            <summary>
            Splits the tensor into separate (contiguous) sub tensors
            </summary>
            <param name="tensor"></param>
            <param name="blockCount">Number of blocks to split into</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CosineDistance(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the cosine distance between the first and second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.EuclideanDistance(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the euclidean distance between the first and second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MeanSquaredDistance(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the mean squared distance between the first and second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SquaredEuclideanDistance(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the squared euclidean distance between the first and second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ManhattanDistance(BrightData.INumericSegment{System.Single},BrightData.INumericSegment{System.Single})">
            <summary>
            Finds the manhattan distance between the first and second tensor
            </summary>
            <param name="tensor1">First tensor</param>
            <param name="tensor2">Second tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Abs(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the absolute value of each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Log(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the natural logarithm of each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Exp(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the exponent of each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Squared(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the square of each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.StdDev(BrightData.INumericSegment{System.Single},System.Nullable{System.Single})">
            <summary>
            Finds the standard deviation of each element in the tensor
            </summary>
            <param name="tensor"></param>
            <param name="mean">Pre calculated mean of the tensor or null to calculate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Sigmoid(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the sigmoid function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SigmoidDerivative(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the derivative of the sigmoid function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Tanh(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the tanh function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.TanhDerivative(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the derivative of the tanh function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Relu(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the relu function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ReluDerivative(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the derivative of the relu function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.LeakyRelu(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the leaky relu function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.LeakyReluDerivative(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the derivative of the leaky relu function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Softmax(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the softmax function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SoftmaxDerivative(BrightData.INumericSegment{System.Single})">
            <summary>
            Creates a new tensor that contains the derivative of the softmax function applied to each element in this tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Pow(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            Creates a new tensor that each element of the tensor raised to the specified power
            </summary>
            <param name="tensor"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.RoundInPlace(BrightData.INumericSegment{System.Single},System.Single,System.Single)">
            <summary>
            Rounds each element in the tensor to be either the lower or the upper parameter depending on its distance
            </summary>
            <param name="tensor"></param>
            <param name="lower"></param>
            <param name="upper"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.CherryPickIndices(BrightData.INumericSegment{System.Single},System.UInt32[])">
            <summary>
            Returns a new tensor with only the supplied indices
            </summary>
            <param name="tensor"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Transpose(BrightData.IMatrix)">
            <summary>
            Calculate the matrix transpose
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Multiply(BrightData.IMatrix,BrightData.IVector)">
            <summary>
            Multiplies the matrix with a vector
            </summary>
            <param name="matrix"></param>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Multiply(BrightData.IMatrix,BrightData.IMatrix)">
            <summary>
            Matrix multiplication
            </summary>
            <param name="matrix1"></param>
            <param name="matrix2"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.TransposeSecondAndMultiply(BrightData.IMatrix,BrightData.IMatrix)">
            <summary>
            Transposes the second matrix and then multiplies the first with the second matrix
            </summary>
            <param name="matrix1"></param>
            <param name="matrix2"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.TransposeFirstAndMultiply(BrightData.IMatrix,BrightData.IMatrix)">
            <summary>
            Transposes the first matrix and then multiplies with the second matrix
            </summary>
            <param name="matrix"></param>
            <param name="other"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetDiagonal(BrightData.IMatrix)">
            <summary>
            Returns the matrix diagonal
            </summary>
            <param name="matrix"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.RowSums(BrightData.IMatrix)">
            <summary>
            Returns the sum of each row
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ColumnSums(BrightData.IMatrix)">
            <summary>
            Returns the sum of each column
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ColumnSums(BrightData.ITensor4D)">
            <summary>
            Returns the sum of each matrix column
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.RowSums(BrightData.ITensor4D)">
            <summary>
            Returns the sum of each matrix row
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Svd(BrightData.IMatrix)">
            <summary>
            Calculates the singular value decomposition of the matrix
            </summary>
            <param name="matrix"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.L1Regularisation(BrightData.INumericSegment{System.Single},System.Single)">
            <summary>
            In place L1 regularization of the tensor
            </summary>
            <param name="segment"></param>
            <param name="coefficient"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SplitAtColumn(BrightData.IMatrix,System.UInt32)">
            <summary>
            Splits the matrix at the specified column index into two sub matrices
            </summary>
            <param name="matrix"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SplitAtRow(BrightData.IMatrix,System.UInt32)">
            <summary>
            Splits the matrix at the specified row index into two sub matrices
            </summary>
            <param name="matrix"></param>
            <param name="rowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ConcatColumns(BrightData.IMatrix,BrightData.IMatrix)">
            <summary>
            Concatenates the two matrices (column count must agree)
            </summary>
            <param name="top"></param>
            <param name="bottom"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ConcatRows(BrightData.IMatrix,BrightData.IMatrix)">
            <summary>
            Concatenates the two matrices (row count must agree)
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddPadding(BrightData.ITensor3D,System.UInt32)">
            <summary>
            Applies zero padding to the each matrix in the tensor
            </summary>
            <param name="tensor"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.RemovePadding(BrightData.ITensor3D,System.UInt32)">
            <summary>
            Removes padding from each matrix in a tensor
            </summary>
            <param name="tensor"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Im2Col(BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Applies the convolutional operator the 3D tensor to obtain a matrix
            </summary>
            <param name="tensor"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ReverseIm2Col(BrightData.ITensor3D,BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a previous Im2Col operation
            </summary>
            <param name="tensor"></param>
            <param name="filter"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="outputDepth"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MaxPool(BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Calculates the max pooling operator of the 3D tensor
            </summary>
            <param name="tensor"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <param name="saveIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ReverseMaxPool(BrightData.ITensor3D,BrightData.ITensor3D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Calculates a reverse max pool operation
            </summary>
            <param name="tensor"></param>
            <param name="indices"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddMatrices(BrightData.ITensor3D)">
            <summary>
            Creates the pointwise sum of each matrix within the 3D tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Multiply(BrightData.ITensor3D,BrightData.IMatrix)">
            <summary>
            Multiplies each sub matrix within the 3D tensor with another matrix
            </summary>
            <param name="tensor"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.TransposeFirstAndMultiply(BrightData.ITensor3D,BrightData.IMatrix)">
            <summary>
            Transposes each sub matrix within the 3D tensor and then multiplies them with another matrix
            </summary>
            <param name="tensor"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddToEachRow(BrightData.ITensor3D,BrightData.IVector)">
            <summary>
            Adds a vector to each row of each matrix within the tensor
            </summary>
            <param name="tensor"></param>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddToEachColumn(BrightData.ITensor3D,BrightData.IVector)">
            <summary>
            Adds a vector to each column of each matrix within the tensor
            </summary>
            <param name="tensor"></param>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Multiply(BrightData.ITensor3D,BrightData.ITensor4D)">
            <summary>
            Multiplies each sub matrix within the 3D tensor with a reshaped matrix from each sub 3D tensor within the 4D tensor
            </summary>
            <param name="tensor"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.TransposeFirstAndMultiply(BrightData.ITensor3D,BrightData.ITensor4D)">
            <summary>
            Multiplies each transposed sub matrix within the 3D tensor with a reshaped matrix from each sub 3D tensor within the 4D tensor
            </summary>
            <param name="tensor"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.TransposeSecondAndMultiply(BrightData.ITensor3D,BrightData.ITensor4D)">
            <summary>
            Multiplies each sub matrix within the 3D tensor with the transposed reshaped matrix from each sub 3D tensor within the 4D tensor
            </summary>
            <param name="tensor"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddPadding(BrightData.ITensor4D,System.UInt32)">
            <summary>
            Adds padding to each sub matrix
            </summary>
            <param name="tensor"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.RemovePadding(BrightData.ITensor4D,System.UInt32)">
            <summary>
            Removes padding from each sub matrix
            </summary>
            <param name="tensor"></param>
            <param name="padding"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MaxPool(BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Applies a max pooling operation to the 4D tensor
            </summary>
            <param name="tensor"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <param name="saveIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ReverseMaxPool(BrightData.ITensor4D,BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a max pooling operation
            </summary>
            <param name="tensor"></param>
            <param name="indices"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Im2Col(BrightData.ITensor4D,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Convolutional operation applied to each sub tensor
            </summary>
            <param name="tensor"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.ReverseIm2Col(BrightData.ITensor4D,BrightData.IMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses the convolutional operator on each sub tensor
            </summary>
            <param name="tensor"></param>
            <param name="filter"></param>
            <param name="outputRows"></param>
            <param name="outputColumns"></param>
            <param name="outputDepth"></param>
            <param name="filterWidth"></param>
            <param name="filterHeight"></param>
            <param name="xStride"></param>
            <param name="yStride"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetMatrix(BrightData.ITensor3D,System.UInt32)">
            <summary>
            Returns a sub matrix from the 3D tensor
            </summary>
            <param name="tensor"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetTensor(BrightData.ITensor4D,System.UInt32)">
            <summary>
            Returns a sub tensor from the 4D tensor
            </summary>
            <param name="tensor"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetNewMatrixFromRows(BrightData.IMatrix,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns a new matrix from the specified row indices
            </summary>
            <param name="matrix"></param>
            <param name="rowIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.GetNewMatrixFromColumns(BrightData.IMatrix,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns a new matrix from the specified column indices
            </summary>
            <param name="matrix"></param>
            <param name="columnIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddToEachRow(BrightData.IMatrix,BrightData.INumericSegment{System.Single})">
            <summary>
            Adds a tensor to each row of the matrix
            </summary>
            <param name="matrix"></param>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.AddToEachColumn(BrightData.IMatrix,BrightData.INumericSegment{System.Single})">
            <summary>
            Adds a tensor to each column of the matrix
            </summary>
            <param name="matrix"></param>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MultiplyEachRowWith(BrightData.IMatrix,BrightData.INumericSegment{System.Single})">
            <summary>
            Multiplies each row of the matrix with the tensor
            </summary>
            <param name="matrix"></param>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MultiplyEachColumnWith(BrightData.IMatrix,BrightData.INumericSegment{System.Single})">
            <summary>
            Multiplies each column of the matrix with the tensor
            </summary>
            <param name="matrix"></param>
            <param name="segment"></param>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.FindDistances(BrightData.IVector[],System.Collections.Generic.IReadOnlyList{BrightData.IVector},BrightData.DistanceMetric)">
            <summary>
            Finds the distance between each pair of vectors
            </summary>
            <param name="vectors">First set of vectors</param>
            <param name="compareTo">Second set of vectors</param>
            <param name="distanceMetric">Distance metric</param>
            <returns>Matrix with the rows corresponding to the first set and columns corresponding to the second set and each element containing the distance</returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.BindThread">
            <summary>
            Binds a new thread to this provider
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.Sum(BrightData.INumericSegment{System.Single})">
            <summary>
            Returns the sum of values in the tensor
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MultiSoftmax(System.ArraySegment{BrightData.INumericSegment{System.Single}})">
            <summary>
            Calculates the softmax of a set of tensors
            </summary>
            <param name="segments"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.MultiSoftmaxDerivative(BrightData.INumericSegment{System.Single}[])">
            <summary>
            Calculates the softmax derivative of a set of tensors
            </summary>
            <param name="segments"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.LinearAlgebraProvider.SoftmaxDerivativePerRow(BrightData.IMatrix,BrightData.INumericSegment{System.Single}[])">
            <summary>
            Computes the per row softmax derivative
            </summary>
            <param name="matrix"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Helper.ToSegment(CommunityToolkit.HighPerformance.Buffers.MemoryOwner{System.Single})">
            <summary>
            Creates a tensor segment from a memory owner
            </summary>
            <param name="memoryOwner"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.ReadOnlySegment">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Item(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Item(System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.GetRow(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.GetColumn(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.AllRows">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.AllColumns">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Equals(BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.ToString">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.Values">
            <summary>
            Enumerates all values in the matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyMatrix.DataAsBytes">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.ReadOnlySegment">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Depth">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.MatrixSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Item(System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Item(System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.GetMatrix(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.AllMatrices">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.Equals(BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.ToString">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor3D.DataAsBytes">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Count">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Depth">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.RowCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.ColumnCount">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.MatrixSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.TensorSize">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.ReadOnlySegment">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Create(BrightData.LinearAlgebra.LinearAlgebraProvider)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.GetTensor3D(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.AllTensors">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.Equals(BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.ToString">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.ReadOnly.ReadOnlyTensor4D.DataAsBytes">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment">
            <summary>
            A tensor segment based on a float array
            </summary>
        </member>
        <member name="F:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment._data">
            <summary>
            Underlying array
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.#ctor(System.Single[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Array of values</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.IsValid">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.SegmentType">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.ToNewArray">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.CopyTo(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.CopyTo(System.Span{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.CopyTo(System.Single*,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Contiguous">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.IsWrapper">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.ToString">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Item(System.Int32)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Item(System.UInt32)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Item(System.Int64)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Item(System.UInt64)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.GetUnderlyingArray">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayBasedTensorSegment.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment">
            <summary>
            A tensor segment that temporarily owns a buffer from an array pool
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.#ctor(CommunityToolkit.HighPerformance.Buffers.MemoryOwner{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="data">Rented buffer from pool</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.IsValid">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.SegmentType">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.ToNewArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.CopyTo(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ArrayPoolTensorSegment.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment">
            <summary>
            A tensor segment that temporarily owns a buffer from an array pool
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.#ctor(CommunityToolkit.HighPerformance.Buffers.MemoryOwner{System.Single})">
            <summary>
            Constructor
            </summary>
            <param name="data">Rented buffer from pool</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.IsValid">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.SegmentType">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.ToNewArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.CopyTo(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.MemoryOwnerTensorSegment.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper">
            <summary>
            Read only tensor segment wrapper
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.#ctor(BrightData.IReadOnlyNumericSegment{System.Single},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="segment">Tensor segment to wrap</param>
            <param name="offset">First index within the wrapped tensor segment</param>
            <param name="stride">Stride within the wrapped tensor segment</param>
            <param name="length">Number of values in this tensor segment</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.AddRef">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Release">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.IsValid">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.SegmentType">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.UnderlyingSegment">
            <summary>
            The segment that was wrapped by this tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Offset">
            <summary>
            First index within the wrapped tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Stride">
            <summary>
            Stride within the wrapped tensor segment 
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.IsWrapper">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Item(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Item(System.Int64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Item(System.UInt64)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Values">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.ToNewArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.CopyTo(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.CopyTo(System.Span{System.Single})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.CopyTo(System.Single*,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.Contiguous">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.Single}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.ReadOnlyTensorSegmentWrapper.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper">
            <summary>
            A tensor segment that wraps another tensor segment
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.#ctor(BrightData.INumericSegment{System.Single},System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor
            </summary>
            <param name="segment">Tensor segment to wrap</param>
            <param name="offset">First index within the wrapped tensor segment</param>
            <param name="stride">Stride within the wrapped tensor segment</param>
            <param name="length">Number of values in this tensor segment</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.UnderlyingSegment">
            <summary>
            The segment that was wrapped by this tensor segment
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.Item(System.Int32)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.Item(System.UInt32)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.Item(System.Int64)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="P:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.Item(System.UInt64)">
            <inheritdoc cref="T:BrightData.INumericSegment`1" />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.CopyFrom(System.ReadOnlySpan{System.Single},System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.Clear">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.GetUnderlyingArray">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Segments.TensorSegmentWrapper.ToString">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Types.BinaryData">
            <summary>
            Blob of binary data
            </summary>
        </member>
        <member name="M:BrightData.Types.BinaryData.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Binary data blob</param>
        </member>
        <member name="M:BrightData.Types.BinaryData.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Constructor
            </summary>
            <param name="data">Binary data blob</param>
        </member>
        <member name="P:BrightData.Types.BinaryData.Data">
            <summary>
            Returns the data as a span
            </summary>
        </member>
        <member name="M:BrightData.Types.BinaryData.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.BinaryData.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.BinaryData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.BinaryData.Equals(BrightData.Types.BinaryData)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.BinaryData.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.BinaryData.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.BinaryData.op_Equality(BrightData.Types.BinaryData,BrightData.Types.BinaryData)">
            <summary>
            Binary data equality
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.BinaryData.op_Inequality(BrightData.Types.BinaryData,BrightData.Types.BinaryData)">
            <summary>
            Binary data non equality
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.Types.BinaryData.DataAsBytes">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Types.BinaryData.Size">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Types.BinaryData.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Types.BinaryData.ReadOnlyMemory">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Types.IndexList">
            <summary>
            Contains a list of indices
            </summary>
        </member>
        <member name="T:BrightData.Types.IndexList.ItemIterator">
            <summary>
            Index iterator
            </summary>
        </member>
        <member name="P:BrightData.Types.IndexList.ItemIterator.Current">
            <summary>
            Current value
            </summary>
        </member>
        <member name="M:BrightData.Types.IndexList.ItemIterator.MoveNext">
            <summary>
            Advances the iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.ItemIterator.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.GetEnumerator">
            <summary>
            Enumerates the indices in the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.#ctor(System.UInt32[])">
            <summary>
            Creates an index list from an array of indices
            </summary>
            <param name="indices">Initial indices</param>
        </member>
        <member name="M:BrightData.Types.IndexList.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates an index list from a byte span
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:BrightData.Types.IndexList.ReadOnlyMemory">
            <summary>
            Returns the indices
            </summary>
        </member>
        <member name="P:BrightData.Types.IndexList.Indices">
            <summary>
            Current indices in list
            </summary>
        </member>
        <member name="M:BrightData.Types.IndexList.AsSpan">
            <summary>
            Indices as a span
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.Create(System.UInt32[])">
            <summary>
            Creates an index list
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.Create(System.ReadOnlySpan{System.UInt32})">
            <summary>
            Creates an index list
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.Create(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates an index list
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.Types.IndexList.Size">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.Types.IndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.Types.IndexList.Equals(BrightData.Types.IndexList)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.IndexList.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{System.UInt32}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.IndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.IndexList.op_Equality(BrightData.Types.IndexList,BrightData.Types.IndexList)">
            <summary>
            Checks for index list equality
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.op_Inequality(BrightData.Types.IndexList,BrightData.Types.IndexList)">
            <summary>
            Checks for index list inequality
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.Types.IndexList})">
            <summary>
            Merges a sequence of index lists into a single index list
            </summary>
            <param name="lists">Lists to merge</param>
        </member>
        <member name="M:BrightData.Types.IndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.IndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.Types.IndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Types.IndexList.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.IndexList.ToXml">
            <summary>
            Converts the index list to XML
            </summary>
        </member>
        <member name="M:BrightData.Types.IndexList.JaccardSimilarity(BrightData.Types.IndexList)">
            <summary>
            Calculates the jaccard similarity between this and another index list
            </summary>
            <param name="other">Index list to compare to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.AsDense(System.Nullable{System.UInt32})">
            <summary>
            Converts to a dense vector in which each set index is 1
            </summary>
            <param name="maxIndex">Maximum index to include</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.HasIndex(System.UInt32)">
            <summary>
            Checks if the specified index has been set
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.IndexList.OverlapSimilarity(BrightData.Types.IndexList)">
            <summary>
            Calculates the overlap similarity between this and another index list
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.Types.IndexList.DataAsBytes">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Types.IndexList.ReadOnlySpan">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.IndexList.AsWeightedIndexList">
            <summary>
            Converts to a weighted index list
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.Types.MetaData">
            <summary>
            Unstructured meta data store
            </summary>
        </member>
        <member name="M:BrightData.Types.MetaData.#ctor(BrightData.Types.MetaData,System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="metaData">Existing meta data to copy from</param>
            <param name="keys">Keys to copy (or all if none specified)</param>
        </member>
        <member name="M:BrightData.Types.MetaData.#ctor(BrightData.IHaveMetaData,System.String[])">
            <summary>
            
            </summary>
            <param name="metaData"></param>
            <param name="keys"></param>
        </member>
        <member name="M:BrightData.Types.MetaData.#ctor(System.IO.BinaryReader)">
            <summary>
            Creates meta data from a binary reader
            </summary>
            <param name="reader">Reader</param>
        </member>
        <member name="M:BrightData.Types.MetaData.CopyTo(BrightData.Types.MetaData,System.String[])">
            <summary>
            Copies this to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keys">Keys to copy (optional)</param>
        </member>
        <member name="M:BrightData.Types.MetaData.Get(System.String)">
            <summary>
            Returns a value
            </summary>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.GetNullable``1(System.String)">
            <summary>
            Returns a typed nullable value
            </summary>
            <param name="name">Name of the value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.Get``1(System.String,``0)">
            <summary>
            Returns a typed value
            </summary>
            <param name="name">Name of the value</param>
            <param name="valueIfMissing">Value to return if the value has not been set</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.GetOrThrow``1(System.String)">
            <summary>
            Returns an existing value (throws if not found)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.Set``1(System.String,``0)">
            <summary>
            Sets a named value
            </summary>
            <param name="name">Name of the value</param>
            <param name="value">Value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:BrightData.Types.MetaData.AsXml">
            <summary>
            XML representation of the meta data
            </summary>
        </member>
        <member name="M:BrightData.Types.MetaData.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes meta data
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Types.MetaData.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads values from a binary reader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:BrightData.Types.MetaData.GetStringsWithPrefix(System.String)">
            <summary>
            Returns all value names with the specified prefix
            </summary>
            <param name="prefix">Prefix to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.GetNonEmpty">
            <summary>
            Returns non empty metadata
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.MetaData.Has(System.String)">
            <summary>
            Checks if a value has been set
            </summary>
            <param name="key">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.MetaData.Remove(System.String)">
            <summary>
            Removes a value
            </summary>
            <param name="key">Name of the value</param>
        </member>
        <member name="P:BrightData.Types.MetaData.AllKeys">
            <summary>
            Returns all keys that have been set
            </summary>
        </member>
        <member name="M:BrightData.Types.MetaData.Clone">
            <summary>
            Creates a clone of the current metadata
            </summary>
        </member>
        <member name="T:BrightData.Types.VectorSet">
            <summary>
            Represents a set of vectors
            </summary>
        </member>
        <member name="T:BrightData.Types.WeightedIndexList">
            <summary>
            A list of weighted indices is a sparse vector
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.#ctor(BrightData.Types.WeightedIndexList.Item[])">
            <summary>
            Creates a weighted index list from an array of indices
            </summary>
            <param name="indices">Weighted indices</param>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.#ctor(System.ReadOnlyMemory{BrightData.Types.WeightedIndexList.Item})">
            <summary>
            Creates a weighted index list from a buffer of items
            </summary>
            <param name="indices"></param>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates a weighted index list from a byte span
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.Indices">
            <summary>
            Weighted indices
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.AsSpan">
            <summary>
            Returns a span of the weighted indices
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.Types.WeightedIndexList.Item">
            <summary>
            An item within a weighted index list
            </summary>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.Item.Index">
            <summary>
            Index of item
            </summary>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.Item.Weight">
            <summary>
            Weight of item
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Item.#ctor(System.UInt32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index of item</param>
            <param name="weight">Weight of item</param>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Item.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Item.Equals(BrightData.Types.WeightedIndexList.Item)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Types.WeightedIndexList.ItemIterator">
            <summary>
            Index iterator
            </summary>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.ItemIterator.Current">
            <summary>
            Current item
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.ItemIterator.MoveNext">
            <summary>
            Advances the iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.ItemIterator.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.GetEnumerator">
            <summary>
            Enumerates the weighted indices in the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Create(BrightData.Types.WeightedIndexList.Item[])">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Create(System.ReadOnlySpan{BrightData.Types.WeightedIndexList.Item})">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Create(System.Collections.Generic.IEnumerable{BrightData.Types.WeightedIndexList.Item})">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Create(System.ValueTuple{System.UInt32,System.Single}[])">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Create(System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,System.Single}})">
            <summary>
            Creates a new weighted index list
            </summary>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.Size">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.ReadOnlyMemory">
            <summary>
            Returns the indices
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Initialize(BrightData.BrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.Types.WeightedIndexList},BrightData.AggregationType)">
            <summary>
            Merges a sequence of weighted index lists into one list
            </summary>
            <param name="lists">Lists to merge</param>
            <param name="mergeOperation">How to merge item weights</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.Types.WeightedIndexList.Item},BrightData.AggregationType)">
            <summary>
            Merges a sequence of weighted index items into one list
            </summary>
            <param name="items">Lists to merge</param>
            <param name="mergeOperation">How to merge item weights</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.ToXml">
            <summary>
            Converts the weighted index list to XML
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.AsIndexList">
            <summary>
            Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Dot(BrightData.Types.WeightedIndexList)">
            <summary>
            Dot product of this combined with the other weighted index list
            </summary>
            <param name="other">Other weighted index list</param>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.Magnitude">
            <summary>
            Magnitude of weights
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.CosineSimilarity(BrightData.Types.WeightedIndexList)">
            <summary>
            Cosine similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.EuclideanDistance(BrightData.Types.WeightedIndexList)">
            <summary>
            Calculates the euclidean distance between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.GetMaxWeight">
            <summary>
            Returns the index with the highest weight
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.JaccardSimilarity(BrightData.Types.WeightedIndexList)">
            <summary>
            Computes the jaccard similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.AsDense(System.Nullable{System.UInt32})">
            <summary>
            Converts to a vector
            </summary>
            <param name="maxIndex">Inclusive highest index to copy (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Unique(BrightData.AggregationType)">
            <summary>
            Returns a new weighted index list with unique indices - duplicate values are treated according to the specified aggregation type
            </summary>
            <returns>New weighted index list with unique indices</returns>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.Weights">
            <summary>
            All weights
            </summary>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Equals(BrightData.Types.WeightedIndexList)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.GetSpan(CommunityToolkit.HighPerformance.Buffers.SpanOwner{BrightData.Types.WeightedIndexList.Item}@,System.Boolean@)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.op_Equality(BrightData.Types.WeightedIndexList,BrightData.Types.WeightedIndexList)">
            <summary>
            Structural equality operator
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Types.WeightedIndexList.op_Inequality(BrightData.Types.WeightedIndexList,BrightData.Types.WeightedIndexList)">
            <summary>
            Structural inequality operator
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.DataAsBytes">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Types.WeightedIndexList.ReadOnlySpan">
            <inheritdoc />
        </member>
    </members>
</doc>
