<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BrightData</name>
    </assembly>
    <members>
        <member name="T:BrightData.Analysis.Readers.DateAnalysis">
            <summary>
            Date analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MinDate">
            <summary>
            Minimum date (null if none)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DateAnalysis.MaxDate">
            <summary>
            Maximum date (null if none)
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.DictionaryValues">
            <summary>
            Dictionary that holds category string indices
            </summary>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValues(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Converts from category indices to string
            </summary>
            <param name="categoryIndices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.Readers.DictionaryValues.GetValue(System.Int32)">
            <summary>
            Gets the string associated with a category index
            </summary>
            <param name="categoryIndex"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Analysis.Readers.DimensionAnalysis">
            <summary>
            Dimension analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.XDimension">
            <summary>
            Max size of the x dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.YDimension">
            <summary>
            Max size of the y dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.ZDimension">
            <summary>
            Max size of the z dimension
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.NumDistinct">
            <summary>
            Number of distinct size combinations
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.DimensionAnalysis.Size">
            <summary>
            Total size across all dimensions
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.FrequencyAnalysis">
            <summary>
            Frequency analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Total">
            <summary>
            Total number of items observed
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.MostFrequent">
            <summary>
            Most frequent item
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.FrequencyAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.IndexAnalysis">
            <summary>
            Index analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MinIndex">
            <summary>
            Lowest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.MaxIndex">
            <summary>
            Highest observed index
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.NumDistinct">
            <summary>
            Number of distinct items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.IndexAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.NumericAnalysis">
            <summary>
            Numeric analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L1Norm">
            <summary>
            L1 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.L2Norm">
            <summary>
            L2 Norm
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Min">
            <summary>
            Minimum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Max">
            <summary>
            Maximum observed value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mean">
            <summary>
            Mean of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleVariance">
            <summary>
            Sample variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.SampleStdDev">
            <summary>
            Sample standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationVariance">
            <summary>
            Population variance of values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.PopulationStdDev">
            <summary>
            Population standard deviation
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Median">
            <summary>
            Median value
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Mode">
            <summary>
            Mode (most frequent value)
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.NumDistinct">
            <summary>
            Number of distinct values
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Total">
            <summary>
            Total count of items
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.Frequency">
            <summary>
            Ranked histogram
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.NumericAnalysis.FrequencyRange">
            <summary>
            Bucketed histogram
            </summary>
        </member>
        <member name="T:BrightData.Analysis.Readers.StringAnalysis">
            <summary>
            String analysis results
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MinLength">
            <summary>
            Length of smallest observed string
            </summary>
        </member>
        <member name="P:BrightData.Analysis.Readers.StringAnalysis.MaxLength">
            <summary>
            Length of largest observed string
            </summary>
        </member>
        <member name="T:BrightData.Analysis.StaticAnalysers">
            <summary>
            Static methods to create analyzers
            </summary>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDateAnalyser(System.UInt32)">
            <summary>
            Creates a date analyzer
            </summary>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <param name="writeCount">Number of items to write in histogram</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateConvertToStringAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that will convert each item to a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateDimensionAnalyser(System.UInt32)">
            <summary>
            Creates a dimension analyzer (to analyze the shape of tensors)
            </summary>
            <param name="maxCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser``1(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed frequency of items
            </summary>
            <typeparam name="T"></typeparam>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateIndexAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates an analyzer that tracks observed indices (for index lists and weighted index lists)
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateNumericAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateStringAnalyser(System.UInt32,System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Analysis.StaticAnalysers.CreateFrequencyAnalyser(System.Type,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer (each item will be converted to a string)
            </summary>
            <param name="type"></param>
            <param name="maxCount"></param>
            <param name="writeCount"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.BinaryData">
            <summary>
            Blob of binary data
            </summary>
        </member>
        <member name="M:BrightData.BinaryData.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="data">Binary data</param>
        </member>
        <member name="M:BrightData.BinaryData.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="reader">Binary reader to read binary data from</param>
        </member>
        <member name="M:BrightData.BinaryData.Initialize(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BinaryData.Data">
            <summary>
            Byte array of binary data
            </summary>
        </member>
        <member name="M:BrightData.BinaryData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BinaryData.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:BrightData.BrightDataContext">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="M:BrightData.BrightDataContext.#ctor(System.Nullable{System.Int32},System.Int64)">
            <summary>
            Constructor
            </summary>
            <param name="randomSeed">Initial value of random seed (or null to randomly initialize)</param>
            <param name="maxCacheSize">Max size of cache to store in memory</param>
        </member>
        <member name="M:BrightData.BrightDataContext.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.Random">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.TensorPool">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.MemoryLayer">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.DataReader">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.GetComputation``1">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.BrightDataContext.TempStreamProvider">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Get``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Set``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.Set``1(System.String,System.Func{``0})">
            <inheritdoc />
        </member>
        <member name="P:BrightData.BrightDataContext.IsStochastic">
            <inheritdoc />
        </member>
        <member name="M:BrightData.BrightDataContext.ResetRandom(System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.EncodedStreamReader">
            <summary>
            Reads from potentially encoded storage
            </summary>
        </member>
        <member name="T:BrightData.Buffer.EncodedStreamWriter">
            <summary>
            Writes hybrid buffers to binary writers, potentially encoding along the way
            </summary>
        </member>
        <member name="M:BrightData.Buffer.EncodedStreamWriter.CopyTo``1(BrightData.IHybridBuffer{``0},System.IO.Stream)">
            <summary>
            Writes the hybrid buffer to a stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="buffer">Buffer to write</param>
            <param name="stream">Stream to write to</param>
        </member>
        <member name="T:BrightData.Buffer.GrowableSegment`1">
            <summary>
            A single type data table segment that can grow in size
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.Buffer.GrowableSegment`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.GrowableSegment`1.MetaData">
            <inheritdoc />
        </member>
        <member name="P:BrightData.Buffer.GrowableSegment`1.SingleType">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.GrowableSegment`1.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Buffer.GrowableSegment`1.CopyTo(System.IO.Stream)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Buffer.HybridBufferBase`1">
            <summary>
            Hybrid buffers write to disk after their in memory cache is exhausted
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Buffer.StaticBuffers">
            <summary>
            Static methods to create hybrid buffers
            </summary>
        </member>
        <member name="M:BrightData.Buffer.StaticBuffers.CreateHybridStructBuffer``1(BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store structs
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tempStream"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Buffer.StaticBuffers.CreateHybridStructBuffer(BrightData.IProvideTempStreams,System.Type,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store structs
            </summary>
            <param name="tempStream"></param>
            <param name="type"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Buffer.StaticBuffers.CreateHybridStringBuffer(BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a buffer to store strings
            </summary>
            <param name="tempStream"></param>
            <param name="bufferSize"></param>
            <param name="maxDistinct"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Buffer.StaticBuffers.CreateHybridObjectBuffer``1(BrightData.IProvideTempStreams,BrightData.IBrightDataContext,System.UInt32)">
            <summary>
            Creates a buffer to store objects
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tempStream"></param>
            <param name="context"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Buffer.StaticBuffers.CreateHybridObjectBuffer(BrightData.IProvideTempStreams,BrightData.IBrightDataContext,System.Type,System.UInt32)">
            <summary>
            Creates a buffer to store objects
            </summary>
            <param name="tempStream"></param>
            <param name="context"></param>
            <param name="type"></param>
            <param name="bufferSize"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Consts">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:BrightData.Consts.DataTableVersion">
            <summary>
            Data table version
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxDistinct">
            <summary>
            Default max distinct count
            </summary>
        </member>
        <member name="F:BrightData.Consts.MaxWriteCount">
            <summary>
            Default max write count
            </summary>
        </member>
        <member name="F:BrightData.Consts.DefaultMemoryCacheSize">
            <summary>
            Default memory cache size
            </summary>
        </member>
        <member name="F:BrightData.Consts.StandardMetaData">
            <summary>
            Standard metadata
            </summary>
        </member>
        <member name="T:BrightData.Converter.StaticConverters">
            <summary>
            Static methods to create converters
            </summary>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToDecimal``1">
            <summary>
            Creates a converter to decimals
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToDouble``1">
            <summary>
            Creates a converter to doubles
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToFloat``1">
            <summary>
            Creates a converter to floats
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToInt``1">
            <summary>
            Creates a converter to ints
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToLong``1">
            <summary>
            Creates a converter to longs (Int64)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToShort``1">
            <summary>
            Creates a converter to shorts (Int16)
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Converter.StaticConverters.ConvertToSignedByte``1">
            <summary>
            Creates a convert to signed bytes
            </summary>
            <typeparam name="T">Type to convert from</typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTable.Builders.ColumnOrientedTableBuilder">
            <summary>
            Builds column oriented data tables
            </summary>
        </member>
        <member name="T:BrightData.DataTable.Builders.InMemoryTableBuilder">
            <summary>
            Builds tables dynamically in memory
            </summary>
        </member>
        <member name="P:BrightData.DataTable.Builders.InMemoryTableBuilder.Context">
            <inheritdoc />
        </member>
        <member name="P:BrightData.DataTable.Builders.InMemoryTableBuilder.MetaData">
            <summary>
            Table meta data
            </summary>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.CopyColumnsFrom(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Copies column definitions from an existing table
            </summary>
            <param name="table">Table to copy from</param>
            <param name="columnIndices">Column indices to copy</param>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.AddColumn(BrightData.ColumnType,System.String)">
            <summary>
            Adds a new column
            </summary>
            <param name="type">Type of the column</param>
            <param name="name">Name of the column</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.AddFixedSizeVectorColumn(System.UInt32,System.String)">
            <summary>
            Adds a new fixed size vector column
            </summary>
            <param name="size">Size of the vector</param>
            <param name="name">Name of the column (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.AddFixedSizeMatrixColumn(System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a new fixed size matrix column
            </summary>
            <param name="rows">Row count of each matrix</param>
            <param name="columns">Column count of each matrix</param>
            <param name="name">Name of the column (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.AddFixedSize3DTensorColumn(System.UInt32,System.UInt32,System.UInt32,System.String)">
            <summary>
            Adds a new fixed size 3D tensor column
            </summary>
            <param name="depth">Depth of each 3D tensor</param>
            <param name="rows">Row count of each matrix</param>
            <param name="columns">Column count of each matrix</param>
            <param name="name">Name of the column (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.AddRow(System.Object[])">
            <summary>
            Adds a new row
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.BuildRowOriented">
            <summary>
            Creates a row oriented table
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.DataTable.Builders.InMemoryTableBuilder.BuildColumnOriented">
            <summary>
            Creates a column oriented table
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTable.Builders.RowOrientedTableBuilder">
            <summary>
            Builds row oriented data tables
            </summary>
        </member>
        <member name="T:BrightData.DataTable.Column`1">
            <summary>
            A data table column
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.DataTable.ColumnInfo">
            <summary>
            Data table column information
            </summary>
        </member>
        <member name="T:BrightData.DataTable.ColumnOrientedDataTable">
            <summary>
            Data table in which the columns are stored contiguously
            </summary>
        </member>
        <member name="T:BrightData.DataTable.Consumers.GrowableDataTableSegment`1">
            <summary>
            A typed data table segment that can grow in size
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.DataTable.DataTableBase">
            <summary>
            Data table base class
            </summary>
        </member>
        <member name="T:BrightData.DataTable.Row">
            <summary>
            A row within a data table
            </summary>
        </member>
        <member name="T:BrightData.DataTable.RowOrientedDataTable">
            <summary>
            Data table in which the rows are stored contiguously
            </summary>
        </member>
        <member name="T:BrightData.ExtensionMethods">
            <summary>
            Extension methods to attach analyser creation to the bright data context
            </summary>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalyser(BrightData.IBrightDataContext,System.UInt32)">
            <summary>
            Creates a date analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalyser``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetConvertToStringAnalyser``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalyser(BrightData.IBrightDataContext,System.UInt32)">
            <summary>
            Creates a dimension analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalyser``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalyser(BrightData.IBrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates an index analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalyser(BrightData.IBrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a numeric analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalyser(BrightData.IBrightDataContext,System.UInt32,System.UInt32)">
            <summary>
            Creates a string analyzer
            </summary>
            <param name="_"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalyser(BrightData.IBrightDataContext,System.Type,System.UInt32,System.UInt32)">
            <summary>
            Creates a frequency analyzer
            </summary>
            <param name="_"></param>
            <param name="type"></param>
            <param name="maxCount">Max distinct items</param>
            <param name="writeCount">Maximum count to write to meta data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDateAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the date analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDimensionAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the dimension analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFrequencyAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the frequency analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndexAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the index analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumericAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the numeric analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetStringAnalysis(BrightData.IMetaData)">
            <summary>
            Gets the string analysis that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDictionaryValues(BrightData.IMetaData)">
            <summary>
            Gets the categories that was stored in meta data
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNormalization(BrightData.IMetaData)">
            <summary>
            
            </summary>
            <param name="metaData">Meta data store</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes numbers in a sequence
            </summary>
            <param name="data"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{System.DateTime})">
            <summary>
            Analyzes dates in a sequence
            </summary>
            <param name="dates"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.ITensor{System.Single}})">
            <summary>
            Analyzes tensors in a sequence
            </summary>
            <param name="tensors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze(System.Collections.Generic.IEnumerable{BrightData.IHaveIndices})">
            <summary>
            Analyzes indices in a sequence
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Analyze``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Analyzes a sequence of strings
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AnalyzeFrequency``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Analyzes the frequency of items
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridStructBuffer``1(BrightData.IBrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a struct buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridStructBuffer(BrightData.IBrightDataContext,System.Type,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a struct buffer
            </summary>
            <param name="_"></param>
            <param name="type">Type of structs</param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridStringBuffer(BrightData.IBrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates a string buffer
            </summary>
            <param name="_"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items (to encode)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridObjectBuffer``1(BrightData.IBrightDataContext,BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Creates an object buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateHybridObjectBuffer(BrightData.IBrightDataContext,System.Type,BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Creates an object buffer
            </summary>
            <param name="context"></param>
            <param name="type">Type of objects</param>
            <param name="tempStream">Temp stream provider</param>
            <param name="bufferSize">Max items to cache in memory</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetBufferReader``1(BrightData.IBrightDataContext,System.IO.BinaryReader,System.UInt32)">
            <summary>
            Returns a reader that buffers items in memory
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context">Bright data context</param>
            <param name="reader">Binary reader</param>
            <param name="inMemorySize">Number of bytes to use as an in memory buffer</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToType(System.TypeCode)">
            <summary>
            Converts a type code to a type
            </summary>
            <param name="code">Type code</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.IBrightDataContext,System.UInt32[])">
            <summary>
            Creates an index list from indices
            </summary>
            <param name="context"></param>
            <param name="indices">Indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.IBrightDataContext,System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Creates an index list from indices
            </summary>
            <param name="context"></param>
            <param name="indices">Indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIndexList(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates an index list from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.IBrightDataContext,System.ValueTuple{System.UInt32,System.Single}[])">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="context"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.IBrightDataContext,System.Collections.Generic.IEnumerable{System.ValueTuple{System.UInt32,System.Single}})">
            <summary>
            Creates a weighted index list from weighted indices
            </summary>
            <param name="context"></param>
            <param name="indexList">Weighted indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateWeightedIndexList(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a weighted index list from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader">The binary reader</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.IMetaData,System.String,System.Nullable{``0})">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <typeparam name="T"></typeparam>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIfNotNull``1(BrightData.IMetaData,System.String,``0)">
            <summary>
            Sets a value only if the value is not null
            </summary>
            <param name="metadata"></param>
            <param name="name"></param>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.HasConversionOperator(System.Type,System.Type)">
            <summary>
            Checks if one type can be implicitly cast to another
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <summary>
            Randomly shuffles the items in the sequence
            </summary>
            <param name="seq"></param>
            <param name="rnd">Random number generator to use</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split``1(``0[],System.Double)">
            <summary>
            Randomly splits the sequence into a two arrays (either "training" or "test")
            </summary>
            <param name="seq"></param>
            <param name="trainPercentage">Percentage of items to add to the training array</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Bag``1(``0[],System.UInt32,System.Random)">
            <summary>
            Sample with replacement
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">Number of samples</param>
            <param name="rnd">Random number generator to use</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetName(BrightData.IMetaData)">
            <summary>
            Item name
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetIndex(BrightData.IMetaData)">
            <summary>
            Item index
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.IMetaData)">
            <summary>
            True if the item is numeric
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTarget(BrightData.IMetaData)">
            <summary>
            True if the item is a target
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsCategorical(BrightData.IMetaData)">
            <summary>
            True if the item is categorical
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsSequential(BrightData.IMetaData)">
            <summary>
            True if the item is sequential
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMetaData(BrightData.IWriteToMetaData)">
            <summary>
            Writes available meta data to a new meta data store
            </summary>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetFloatConverter``1(BrightData.IBrightDataContext)">
            <summary>
            Lazy create a float converter per context
            </summary>
            <param name="context"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetConverter``1(System.Type)">
            <summary>
            Creates a type converter
            </summary>
            <param name="toType">Type converter type</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count">Upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.UInt32,System.UInt32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsRange(System.Int32,System.Int32)">
            <summary>
            Generates a range of positive integers
            </summary>
            <param name="count"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Aggregate(BrightData.AggregationType,System.Collections.Generic.List{System.Single})">
            <summary>
            Aggregates a list of floats
            </summary>
            <param name="operation"></param>
            <param name="data">Data to aggregate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTarget(BrightData.IMetaData,System.Boolean)">
            <summary>
            Sets this as a target
            </summary>
            <param name="metaData"></param>
            <param name="isTarget"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetIsCategorical(BrightData.IMetaData,System.Boolean)">
            <summary>
            Sets this as categorical
            </summary>
            <param name="metaData"></param>
            <param name="isCategorical"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToWeightedIndexList(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IndexList}},BrightData.IBrightDataContext,System.Boolean)">
            <summary>
            Converts the indexed classifications to weighted indexed classifications
            </summary>
            <param name="data"></param>
            <param name="context"></param>
            <param name="groupByClassification">True to group by classification (i.e convert the bag to a set)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxWeight(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Finds the greatest weight within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}})">
            <summary>
            Find the greatest index within the weighted index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetMaxIndex(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IndexList}})">
            <summary>
            Find the greatest index within the index classification list
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Tfidf(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.IBrightDataContext)">
            <summary>
            Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
            https://en.wikipedia.org/wiki/Tf%E2%80%93idf
            </summary>
            <returns>A new weighted classification set</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Normalize(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.IBrightDataContext)">
            <summary>
            Normalizes the weighted index classification list to fit between 0 and 1
            </summary>
            <param name="data"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GroupAndCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Groups items and counts each group
            </summary>
            <param name="items"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Format``1(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,System.UInt32}},System.Char)">
            <summary>
            Formats groups of items
            </summary>
            <param name="items"></param>
            <param name="separator">Group separator</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.UseLegacySerializationInput(BrightData.IBrightDataContext,System.Boolean)">
            <summary>
            Enables or disables legacy (version 2) binary serialization - only when reading
            </summary>
            <param name="context"></param>
            <param name="use">True to enable</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataEncoder(BrightData.IBrightDataContext)">
            <summary>
            Creates a data encoder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetData(BrightData.ICanWriteToBinaryWriter)">
            <summary>
            Converts the object to a serialized buffer
            </summary>
            <param name="writable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType(BrightData.ColumnType)">
            <summary>
            Converts from a column type to a Type
            </summary>
            <param name="type">Column type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnType(System.Type)">
            <summary>
            Converts from a Type to a ColumnType
            </summary>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsStructable(BrightData.ColumnType)">
            <summary>
            Checks if the column type is blittable
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsNumeric(BrightData.ColumnType)">
            <summary>
            Checks if the column type is numeric
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsDecimal(BrightData.ColumnType)">
            <summary>
            Checks if the column type is decimal
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsContinuous(BrightData.ColumnType)">
            <summary>
            Checks if the column type is continuous
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsInteger(BrightData.ColumnType)">
            <summary>
            Checks if the column type is an integer
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsIndexedList(BrightData.ColumnType)">
            <summary>
            Checks if the column type is an indexed list (or weighted index list)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.IsTensor(BrightData.ColumnType)">
            <summary>
            Checks if the column type is a tensor
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.DataType(BrightData.IDataTableSegment)">
            <summary>
            Returns the underlying Type for a data table segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDataType``1(BrightData.IDataTableSegment{``0})">
            <summary>
            Returns the underlying Type for a data table segment
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RowIndices(BrightData.IDataTable)">
            <summary>
            Returns all row indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndices(BrightData.IDataTable)">
            <summary>
            Returns all column indices as an enumerable
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow(BrightData.IDataTable,System.Action{System.Object[]})">
            <summary>
            Invokes a callback on each row of a data table
            </summary>
            <param name="dataTable"></param>
            <param name="callback"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``1(BrightData.IDataTable,System.Action{``0})">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <param name="dataTable"></param>
            <param name="callback"></param>
            <typeparam name="T0"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``2(BrightData.IDataTable,System.Action{``0,``1})">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="dataTable"></param>
            <param name="callback"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``3(BrightData.IDataTable,System.Action{``0,``1,``2})">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="dataTable"></param>
            <param name="callback"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ForEachRow``4(BrightData.IDataTable,System.Action{``0,``1,``2,``3})">
            <summary>
            Invokes a typed callback on each row of a data table
            </summary>
            <typeparam name="T0"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="dataTable"></param>
            <param name="callback"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.AllColumnsMetaData(BrightData.IDataTable)">
            <summary>
            Returns meta data for all columns
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnMetaData(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Enumerates metadata for each specified column
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices to retrieve</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnAnalyser(BrightData.ColumnType,BrightData.IMetaData,System.UInt32,System.UInt32)">
            <summary>
            Creates a column analyser
            </summary>
            <param name="type">Column type</param>
            <param name="metaData">Column meta data</param>
            <param name="writeCount">Maximum size of sequences to write in final meta data</param>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ParseCsv(BrightData.IBrightDataContext,System.IO.StreamReader,System.Boolean,System.Char,System.String,System.Boolean,System.Int32,System.UInt32,System.UInt16,System.String)">
            <summary>
            Parse CSV into a column oriented data table
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">CSV</param>
            <param name="hasHeader">True if the CSV has a text based header</param>
            <param name="delimiter">CSV delimiter</param>
            <param name="fileOutputPath">Optional path to save final table</param>
            <param name="writeProgress"></param>
            <param name="maxRows">Maximum number of rows of CSV to read</param>
            <param name="inMemoryRowCount">Number of rows to cache in memory</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <param name="tempBasePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.WriteProgress(System.Int32,System.Int32@,System.Int32)">
            <summary>
            Writes a progress bar to the console
            </summary>
            <param name="newProgress">Current progress</param>
            <param name="oldProgress">Previous progress</param>
            <param name="max">Maximum progress</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.Head(BrightData.IDataTable,System.UInt32)">
            <summary>
            Returns the head (first few rows) of the data table
            </summary>
            <param name="dataTable"></param>
            <param name="size">Number of rows to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadTable(BrightData.IBrightDataContext,System.String)">
            <summary>
            Loads a data table from disk
            </summary>
            <param name="context"></param>
            <param name="filePath">File path on disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyToFloatSegment``1(BrightData.IDataTableSegment{``0},BrightData.ITensorSegment{System.Single})">
            <summary>
            Copies a data table segment to a tensor segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="column">Data table segment</param>
            <param name="vector">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CopyTo(BrightData.ISingleTypeTableSegment,BrightData.ITensorSegment{System.Single})">
            <summary>
            Copies a data table segment to tensor segment
            </summary>
            <param name="column">Data table segment</param>
            <param name="vector">Tensor segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetTargetColumn(BrightData.IDataTable,System.Nullable{System.UInt32})">
            <summary>
            Sets the target column of the data table
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to make target (or null to set no target)</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumn(BrightData.IDataTable)">
            <summary>
            Returns the target column of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetTargetColumnOrThrow(BrightData.IDataTable)">
            <summary>
            Returns the target column or throws an exception if none set
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnIndicesOfFeatures(BrightData.IDataTable)">
            <summary>
            Returns the feature (non target) columns of the data table
            </summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.SetType(BrightData.IMetaData,BrightData.ColumnType)">
            <summary>
            Sets the column type in a meta data store
            </summary>
            <param name="metaData"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetGrowableSegment(BrightData.IMetaData,BrightData.ColumnType,BrightData.IBrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.UInt16)">
            <summary>
            Creates an appendable buffer for a column type
            </summary>
            <param name="metaData"></param>
            <param name="type">Column type</param>
            <param name="context"></param>
            <param name="tempStream"></param>
            <param name="bufferSize">In memory cache size</param>
            <param name="maxDistinct">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildColumnOrientedTable(System.Collections.Generic.List{BrightData.ISingleTypeTableSegment},BrightData.IMetaData,BrightData.IBrightDataContext,System.UInt32,System.String,System.Action{BrightData.ISingleTypeTableSegment},System.Action{System.Int64})">
            <summary>
            Creates a column oriented data table from a list of segments
            </summary>
            <param name="segments"></param>
            <param name="metaData">Table meta data</param>
            <param name="context"></param>
            <param name="rowCount">Number of rows</param>
            <param name="filePath">File path to save on disk (optional)</param>
            <param name="onBeforeWrite">Callback before writing each column (optional)</param>
            <param name="onAfterWrite">Callback after writing each column (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildRowOrientedTable(System.Collections.Generic.List{BrightData.ISingleTypeTableSegment},BrightData.IMetaData,BrightData.IBrightDataContext,System.UInt32,System.String)">
            <summary>
            Creates a row oriented data table from a list of segments
            </summary>
            <param name="segments"></param>
            <param name="metaData">Table meta data</param>
            <param name="context"></param>
            <param name="rowCount">Number of rows</param>
            <param name="filePath">File path to save on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ChangeColumnType(BrightData.IColumnInfo,BrightData.ColumnType)">
            <summary>
            Creates a column info with a new column type
            </summary>
            <param name="column">Column info source</param>
            <param name="newType">New column type</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsConvertible(BrightData.IRowOrientedDataTable)">
            <summary>
            Creates a convertible data table
            </summary>
            <param name="dataTable">Data table to use as basis</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectorisedFeatures(BrightData.IDataTable)">
            <summary>
            Converts the data table to a sequence of labeled vectors (feature columns are vectorised, target column is converted to a string)
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnType(BrightData.IMetaData)">
            <summary>
            Gets the column type
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetNumDistinct(BrightData.IMetaData)">
            <summary>
            Gets the number of distinct items
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.BuildTable(BrightData.IBrightDataContext)">
            <summary>
            Creates a table builder
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Split(BrightData.IRowOrientedDataTable,System.Double,System.String,System.String)">
            <summary>
            Splits a data table into training and test tables (rows are randomly selected for either)
            </summary>
            <param name="table"></param>
            <param name="trainingFraction">Fraction (0..1) of rows to add to the training table</param>
            <param name="trainingFilePath">Path to write training table to disk (optional)</param>
            <param name="testFilePath">Path to write test table to disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Fold(BrightData.IRowOrientedDataTable,System.Int32,System.Boolean)">
            <summary>
            Folds the data table into k buckets (for k fold cross validation)
            </summary>
            <param name="table"></param>
            <param name="k">Number of buckets to create</param>
            <param name="shuffle">True to shuffle the table before folding</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnsAsVectors(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Returns columns as vectors
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices to return as vectors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ColumnAnalysis(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Returns analysed column meta data
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AllColumnAnalysis(BrightData.IDataTable)">
            <summary>
            Returns analysed column meta data for all columns in the data table
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.EnumerateTyped``1(BrightData.ISingleTypeTableSegment)">
            <summary>
            Strongly typed enumeration of items in segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray``1(BrightData.ISingleTypeTableSegment)">
            <summary>
            Reads the segment as a strongly typed array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrices(BrightData.IDataTable)">
            <summary>
            Converts the data table to feature and target matrices
            </summary>
            <param name="dataTable"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsMatrix(BrightData.IDataTable,System.UInt32[])">
            <summary>
            Converts data table columns to a matrix
            </summary>
            <param name="dataTable"></param>
            <param name="columnIndices">Column indices to include in the matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(BrightData.IDataTable,System.Boolean,System.String)">
            <summary>
            Creates a new data table that has two vector columns, one for the features and the other for the target
            </summary>
            <param name="dataTable"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="filePath">Optional path to save data table to disk</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Column``1(BrightData.IDataTable,System.UInt32)">
            <summary>
            Returns a data table segment from the data table
            </summary>
            <typeparam name="T"></typeparam>
            <param name="dataTable"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray``1(BrightData.IDataTableSegment{``0})">
            <summary>
            Converts a data table segment to an array
            </summary>
            <typeparam name="T"></typeparam>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.IndexList}},BrightData.IBrightDataContext)">
            <summary>
            Converts indexed classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.IBrightDataContext)">
            <summary>
            Converts weighted index classifications to a data table
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertToTable(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.LinearAlgebra.Vector{System.Single}}},System.Boolean,BrightData.IBrightDataContext)">
            <summary>
            Converts the vector classifications into a data table
            </summary>
            <param name="data"></param>
            <param name="preserveVectors">True to create a data table with a vector column type, false to to convert to columns of floats</param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Vectorise(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,BrightData.WeightedIndexList}},BrightData.IBrightDataContext)">
            <summary>
            Converts the weighted index classification list to a list of dense vectors
            </summary>
            <param name="data"></param>
            <param name="context"></param>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDefaultValue(BrightData.ColumnType)">
            <summary>
            Returns a default value for a column type
            </summary>
            <param name="columnType"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetVectoriser(BrightData.IDataTable,System.Boolean,System.UInt32[])">
            <summary>
            Returns a vectoriser
            </summary>
            <param name="table"></param>
            <param name="oneHotEncodeToMultipleColumns"></param>
            <param name="columnIndices">Column indices to vectorise</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.LoadVectoriser(BrightData.IDataTable,System.IO.BinaryReader)">
            <summary>
            Loads a previously created data table vectoriser
            </summary>
            <param name="dataTable"></param>
            <param name="reader">Reader to load parameters from</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertTable(BrightData.IColumnOrientedDataTable,BrightData.ColumnConversionType[])">
            <summary>
            Converts columns
            </summary>
            <param name="dataTable"></param>
            <param name="conversions"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertColumn(BrightData.ColumnConversionType,System.UInt32)">
            <summary>
            Creates a column conversion parameter
            </summary>
            <param name="type">Type of column conversion</param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ConvertColumn(BrightData.NormalizationType,System.UInt32)">
            <summary>
            Creates a column normalization parameter
            </summary>
            <param name="type"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReinterpretColumns(System.UInt32[],BrightData.ColumnType,System.String)">
            <summary>
            Creates a reinterpret columns parameter
            </summary>
            <param name="sourceColumnIndices"></param>
            <param name="newColumnType"></param>
            <param name="newColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToArray(BrightData.IDataTableSegment)">
            <summary>
            Converts the segment to an array
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumn``1(BrightData.IColumnOrientedDataTable,System.UInt32)">
            <summary>
            Returns a strongly typed column from the data table
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to retrieve</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Get``1(BrightData.IDataTableSegment,System.UInt32)">
            <summary>
            Casts the value at column index to type T
            </summary>
            <param name="segment"></param>
            <param name="columnIndex"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Sample(BrightData.IRowOrientedDataTable,System.UInt32)">
            <summary>
            Samples rows from the data table
            </summary>
            <param name="table"></param>
            <param name="sampleSize">Number of rows to sample</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCustomColumnConverter``2(BrightData.IColumnOrientedDataTable,System.UInt32,System.Func{``0,``1},System.Action{BrightData.IMetaData})">
            <summary>
            Creates a custom column converter
            </summary>
            <param name="table"></param>
            <param name="columnIndex">Column index to convert</param>
            <param name="converter">Column converter</param>
            <param name="columnFinaliser">Called after each row </param>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:BrightData.ExtensionMethods.NextRandomFloat(BrightData.IBrightDataContext)">
            <summary>
            Returns a randomly initialized float
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.IBrightDataContext,System.Int32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.RandomIndex(BrightData.IBrightDataContext,System.UInt32)">
            <summary>
            Returns a randomly initialized positive number
            </summary>
            <param name="context"></param>
            <param name="length">Exclusive upper bound</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBernoulliDistribution(BrightData.IBrightDataContext,System.Single)">
            <summary>
            Create a bernoulli distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateBinomialDistribution(BrightData.IBrightDataContext,System.Single,System.UInt32)">
            <summary>
            Create a binomial distribution
            </summary>
            <param name="context"></param>
            <param name="probability"></param>
            <param name="numTrials"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateCategoricalDistribution(BrightData.IBrightDataContext,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Create a categorical distribution
            </summary>
            <param name="context"></param>
            <param name="categoricalValues"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateContinuousDistribution(BrightData.IBrightDataContext,System.Single,System.Single)">
            <summary>
            Create a continuous distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiscreteUniformDistribution(BrightData.IBrightDataContext,System.Int32,System.Int32)">
            <summary>
            Create a discrete uniform distribution
            </summary>
            <param name="context"></param>
            <param name="inclusiveLowerBound"></param>
            <param name="exclusiveUpperBound"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateNormalDistribution(BrightData.IBrightDataContext,System.Single,System.Single)">
            <summary>
            Create a normal distribution
            </summary>
            <param name="context"></param>
            <param name="mean"></param>
            <param name="stdDev">Standard deviation</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector``1(BrightData.IBrightDataContext,System.UInt32,System.Func{System.UInt32,``0})">
            <summary>
            Creates a vector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector``1(BrightData.IBrightDataContext,System.UInt32,``0)">
            <summary>
            Creates a vector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="size">Size of vector</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector``1(BrightData.IBrightDataContext,``0[])">
            <summary>
            Creates a vector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="initialData">Initial data</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector``1(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a vector from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrix``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,``0})">
            <summary>
            Creates a matrix
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initializer">Callback to initialize each value (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrix``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32,``0)">
            <summary>
            Creates a matrix
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="initialValue">Initial value of each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrix``1(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a matrix from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromRows``1(BrightData.IBrightDataContext,BrightData.LinearAlgebra.Vector{``0}[])">
            <summary>
            Creates a matrix from vectors (each will become a row)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromRows``1(BrightData.IBrightDataContext,``0[][])">
            <summary>
            Creates a matrix from rows (each will become a row)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromColumns``1(BrightData.IBrightDataContext,BrightData.LinearAlgebra.Vector{``0}[])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromColumns``1(BrightData.IBrightDataContext,``0[][])">
            <summary>
            Creates a matrix from vectors (each will become a column)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor3D``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 3D tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor3D``1(BrightData.IBrightDataContext,BrightData.LinearAlgebra.Matrix{``0}[])">
            <summary>
            Creates a 3D tensor from matrices
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="slices"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor3D``1(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Create a 3D tensor from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor4D``1(BrightData.IBrightDataContext,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 4D tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices in each 3D tensor</param>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in each matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateTensor4D``1(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Creates a 4D tensor from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetColumnCount``1(BrightData.ITensor{``0})">
            <summary>
            Returns the number of columns in this tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetRowCount``1(BrightData.ITensor{``0})">
            <summary>
            Returns the number of rows in this tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetDepth``1(BrightData.ITensor{``0})">
            <summary>
            Returns the number of matrices in this tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.GetCount``1(BrightData.ITensor{``0})">
            <summary>
            Returns the number of 3D tensors in this tensor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector(BrightData.ILinearAlgebraProvider,System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Creates a vector from an enumerable of floats
            </summary>
            <param name="lap"></param>
            <param name="data">The initial values in the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector(BrightData.ILinearAlgebraProvider,BrightData.IIndexableFloatVector)">
            <summary>
            Creates a vector
            </summary>
            <param name="lap"></param>
            <param name="data">Indexable vector to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector(BrightData.ILinearAlgebraProvider,BrightData.IFloatVector)">
            <summary>
            Creates a vector
            </summary>
            <param name="lap"></param>
            <param name="data">Vector to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector(BrightData.ILinearAlgebraProvider,BrightData.LinearAlgebra.Vector{System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="lap"></param>
            <param name="data">Vector to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector(BrightData.ILinearAlgebraProvider,System.Single[])">
            <summary>
            Creates a vector
            </summary>
            <param name="lap"></param>
            <param name="data">List of values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateVector(BrightData.ILinearAlgebraProvider,System.UInt32,System.Single)">
            <summary>
            Creates a vector
            </summary>
            <param name="lap"></param>
            <param name="length">Vector size</param>
            <param name="value">Constant value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateZeroMatrix(BrightData.ILinearAlgebraProvider,System.UInt32,System.UInt32)">
            <summary>
            Creates a matrix with every element initialized to zero
            </summary>
            <param name="lap"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrix(BrightData.ILinearAlgebraProvider,BrightData.LinearAlgebra.Matrix{System.Single})">
            <summary>
            Creates a matrix from an existing matrix
            </summary>
            <param name="lap"></param>
            <param name="matrix">Matrix to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromRows(BrightData.ILinearAlgebraProvider,BrightData.LinearAlgebra.Vector{System.Single}[])">
            <summary>
            Creates a matrix from row vectors
            </summary>
            <param name="lap"></param>
            <param name="rowList">List of vectors (each vector becomes a row in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromRows(BrightData.ILinearAlgebraProvider,BrightData.IIndexableFloatVector[])">
            <summary>
            Creates a matrix from row vectors
            </summary>
            <param name="lap"></param>
            <param name="rowList">List of indexable vectors (each vector becomes a row in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromColumns(BrightData.ILinearAlgebraProvider,BrightData.LinearAlgebra.Vector{System.Single}[])">
            <summary>
            Creates a matrix from column vectors
            </summary>
            <param name="lap"></param>
            <param name="columnList">List of vectors (each vector becomes a column in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromColumns(BrightData.ILinearAlgebraProvider,BrightData.IIndexableFloatVector[])">
            <summary>
            Creates a matrix column vectors
            </summary>
            <param name="lap"></param>
            <param name="columnList">List of indexable vectors (each vector becomes a column in the new matrix)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrix(BrightData.ILinearAlgebraProvider,System.UInt32,System.UInt32,System.Single)">
            <summary>
            Creates a matrix
            </summary>
            <param name="lap"></param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="value">Constant value to initialize each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrix(BrightData.ILinearAlgebraProvider,BrightData.IIndexableFloatMatrix)">
            <summary>
            Creates a matrix
            </summary>
            <param name="lap"></param>
            <param name="matrix">Indexable matrix to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateIdentityMatrix(BrightData.ILinearAlgebraProvider,System.UInt32)">
            <summary>
            Creates an identity matrix (each diagonal element is 1, each other element is 0)
            </summary>
            <param name="lap"></param>
            <param name="size">Width and height of the new matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateDiagonalMatrix(BrightData.ILinearAlgebraProvider,System.Single[])">
            <summary>
            Creates a diagonal matrix
            </summary>
            <param name="lap"></param>
            <param name="values">Diagonal values</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Create3DTensor(BrightData.ILinearAlgebraProvider,BrightData.LinearAlgebra.Tensor3D{System.Single})">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="lap"></param>
            <param name="tensor">The tensor to copy from</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Create3DTensor(BrightData.ILinearAlgebraProvider,BrightData.LinearAlgebra.Matrix{System.Single}[])">
            <summary>
            Creates a 3D tensor from matrices
            </summary>
            <param name="lap"></param>
            <param name="matrices">Matrices to copy fropm</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Calculate(BrightData.DistanceMetric,BrightData.IFloatMatrix,BrightData.IFloatMatrix)">
            <summary>
            Calculates the distance between two matrices
            </summary>
            <param name="distance">Distance metric (either euclidean or square euclidean)</param>
            <param name="matrix1">First matrix</param>
            <param name="matrix2">Second matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Calculate(BrightData.DistanceMetric,BrightData.IFloatVector,BrightData.IFloatVector)">
            <summary>
            Calculates the distance between two vectors
            </summary>
            <param name="distance">Distance metric</param>
            <param name="vector1">First vector</param>
            <param name="vector2">Second vector</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromRows(BrightData.ILinearAlgebraProvider,System.Collections.Generic.IEnumerable{BrightData.LinearAlgebra.Vector{System.Single}})">
            <summary>
            Creates a matrix from row vectors
            </summary>
            <param name="lap"></param>
            <param name="rows">Row vectors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromRows(BrightData.ILinearAlgebraProvider,System.Collections.Generic.IEnumerable{BrightData.IFloatVector})">
            <summary>
            Creates a matrix from row vectors
            </summary>
            <param name="lap"></param>
            <param name="rows">Row vectors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromColumns(BrightData.ILinearAlgebraProvider,System.Collections.Generic.IEnumerable{BrightData.LinearAlgebra.Vector{System.Single}})">
            <summary>
            Creates a matrix from column vectors
            </summary>
            <param name="lap"></param>
            <param name="columns">Column vectors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateMatrixFromColumns(BrightData.ILinearAlgebraProvider,System.Collections.Generic.IEnumerable{BrightData.IFloatVector})">
            <summary>
            Creates a matrix from column vectors
            </summary>
            <param name="lap"></param>
            <param name="columns">Column vectors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.AsFloatVectors(System.Collections.Generic.IEnumerable{BrightData.LinearAlgebra.Vector{System.Single}})">
            <summary>
            Converts vectors to float vectors
            </summary>
            <param name="vectors"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Set``1(BrightData.ITensorSegment{``0},System.Func{System.UInt32,``0})">
            <summary>
            Sets each element in a tensor
            </summary>
            <param name="vector"></param>
            <param name="getValue"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateSegment``1(BrightData.IBrightDataContext,``0[])">
            <summary>
            Creates a tensor segment from an existing array
            </summary>
            <param name="context"></param>
            <param name="block">Array to copy values from</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.CreateSegment``1(BrightData.IBrightDataContext,System.UInt32)">
            <summary>
            Creates a tensor segment
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="size">Size of new segment</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.InitializeRandomly``1(BrightData.ITensor{``0})">
            <summary>
            Randomly initialize a tensor
            </summary>
            <param name="tensor"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize``1(BrightData.ITensor{``0},``0)">
            <summary>
            Initialize a tensor to a single value
            </summary>
            <param name="tensor"></param>
            <param name="value">Value to initialize each element of the tensor</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ExtensionMethods.Initialize``1(BrightData.ITensor{``0},System.Func{System.UInt32,``0})">
            <summary>
            Initialize a tensor using a callback
            </summary>
            <typeparam name="T"></typeparam>
            <param name="tensor"></param>
            <param name="initializer">Callback for each element</param>
        </member>
        <member name="M:BrightData.ExtensionMethods.CosineDistance(System.Single[],System.Single[])">
            <summary>
            Calculates the cosine distance between two vectors
            </summary>
            <param name="vector"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.EuclideanDistance(System.Single[],System.Single[])">
            <summary>
            Calculates euclidean distance between two vectors
            </summary>
            <param name="vector"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ManhattanDistance(System.Single[],System.Single[])">
            <summary>
            Calculates manhattan distance between two vectors
            </summary>
            <param name="vector"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.Mutate(BrightData.LinearAlgebra.Vector{System.Single},System.Func{System.Single,System.Single})">
            <summary>
            Mutates a vector via a callback
            </summary>
            <param name="vector">Vector to mutate</param>
            <param name="mutator">Callback that can mutate each value of the vector</param>
            <returns>New vector</returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.MutateWith(BrightData.LinearAlgebra.Vector{System.Single},BrightData.LinearAlgebra.Vector{System.Single},System.Func{System.Single,System.Single,System.Single})">
            <summary>
            Mutates a vector by combining it with another vector
            </summary>
            <param name="vector">Vector to mutate</param>
            <param name="other">Other vector</param>
            <param name="mutator">Callback that can mutate each value of the vector</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ToSparse(BrightData.ITensorSegment{System.Single})">
            <summary>
            Converts the tensor segment to a sparse format (only non zero entries are preserved)
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadVectorFrom(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a vector from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ExtensionMethods.ReadMatrixFrom(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Reads a matrix from a binary reader
            </summary>
            <param name="context"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ColumnTypeClassifier">
            <summary>
            Classifies data table column types
            </summary>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsDecimal(BrightData.ColumnType)">
            <summary>
            Checks for a decimal type (floating point)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsNumeric(BrightData.ColumnType)">
            <summary>
            Checks for a numeric type (floating point or integer)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsContinuous(BrightData.ColumnType)">
            <summary>
            Checks for a continuous type (non categorical)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsCategorical(BrightData.ColumnType)">
            <summary>
            Checks for a categorical type (non continuous)
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.IsBlittable(BrightData.ColumnType)">
            <summary>
            Checks if the type has an independent memory layout across managed and unmanaged code
            </summary>
            <param name="columnType">Column type to check</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.ColumnTypeClassifier.GetClass(BrightData.ColumnType,BrightData.IMetaData)">
            <summary>
            Returns the set of possible column classifications
            </summary>
            <param name="type">Column type to check</param>
            <param name="metaData">Column metadata</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper">
            <summary>
            Helper class to calculate convolutional indices
            </summary>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.LeftToRight(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from left to right
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="M:BrightData.Helper.ConvolutionHelper.TopToBottom(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Generates convolution indices from top to bottom
            </summary>
            <param name="width">Input width</param>
            <param name="height">Input height</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">X Stride</param>
            <param name="yStride">Y Stride</param>
            <returns>List of (x, y) indices</returns>
        </member>
        <member name="T:BrightData.Helper.ConvolutionHelper.ConvolutionalDelegate">
            <inheritdoc />
        </member>
        <member name="F:BrightData.Helper.ConvolutionHelper.Default">
            <summary>
            Default convolutional direction
            </summary>
        </member>
        <member name="T:BrightData.Helper.DataEncoder">
            <summary>
            Encodes types from/to bytes
            </summary>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Read``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read from a binary reader
            </summary>
            <typeparam name="T">Type to read</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Generic method to read an array from a binary reader
            </summary>
            <typeparam name="T">Type within the array</typeparam>
            <param name="reader">Source</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0)">
            <summary>
            Generic method to write to binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="val">Item to write</param>
        </member>
        <member name="M:BrightData.Helper.DataEncoder.Write``1(System.IO.BinaryWriter,``0[])">
            <summary>
            Generic method to write an array to a binary writer
            </summary>
            <typeparam name="T">Type to write</typeparam>
            <param name="writer">Destination</param>
            <param name="values">Array to write</param>
        </member>
        <member name="T:BrightData.Helper.DoubleMath">
            <summary>
            Helpers for double based math
            </summary>
        </member>
        <member name="F:BrightData.Helper.DoubleMath.AlmostZero">
            <summary>
            A number that is close to zero
            </summary>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Double,System.Double,System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.DoubleMath.AreApproximatelyEqual(System.Nullable{System.Double},System.Nullable{System.Double},System.Double)">
            <summary>
            True if the numbers are approximately equal
            </summary>
            <param name="value1">First value to compare</param>
            <param name="value2">Second value to compare</param>
            <param name="tolerance">How close to compare</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.FloatMath">
            <summary>
            Constrained float math helpers - if the value is too small or too big it will be capped. Also NaN values are replaced with zero.
            </summary>
        </member>
        <member name="T:BrightData.Helper.GenericActivator">
            <summary>
            Generic object creator
            </summary>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``2(System.Type,System.Object[])">
            <summary>
            Creates a new object
            </summary>
            <typeparam name="T1">Type to cast created object to</typeparam>
            <typeparam name="T2">Type to cast created object to</typeparam>
            <param name="type">Type of object to create</param>
            <param name="args">Arguments to pass to constructor</param>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.Create``1">
            <summary>
            Creates a new object (via default constructor)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1">
            <summary>
            Creates a new unitialized object (constructor is not invoked)
            </summary>
            <typeparam name="T">Type to create</typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.Helper.GenericActivator.CreateUninitialized``1(System.Type)">
            <summary>
            Creates a new unitialized object (constructor is not invoked)
            </summary>
            <param name="type">Type to create</param>
            <typeparam name="T">Type to return (created object cast to this type)</typeparam>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.ShapedBase">
            <summary>
            Tensor shape
            </summary>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Shape">
            <summary>
            Array of sizes
            </summary>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.#ctor(System.UInt32[])">
            <summary>
            Constructor
            </summary>
            <param name="shape">Array of sizes</param>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Size">
            <summary>
            Total size of the shape
            </summary>
        </member>
        <member name="P:BrightData.Helper.ShapedBase.Rank">
            <summary>
            Number of sizes within the shape
            </summary>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Helper.ShapedBase.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads the shape from a binary reader
            </summary>
            <param name="reader">Reader</param>
            <returns>Size of tensor</returns>
        </member>
        <member name="M:BrightData.Helper.ShapedBase.ResolveShape(System.UInt32,System.Nullable{System.UInt32}[])">
            <summary>
            Works out the shape from a possibly incomplete list of sizes
            </summary>
            <param name="total">Total size</param>
            <param name="shape">List of sizes that form the shape (one can be null)</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.Helper.StreamCloner">
            <summary>
            Clones streams
            </summary>
        </member>
        <member name="T:BrightData.Helper.StringIndexer">
            <summary>
            Builds a string table
            </summary>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.Create(System.String[])">
            <summary>
            Creates a string indexer
            </summary>
            <param name="strings">Initial strings in table</param>
        </member>
        <member name="M:BrightData.Helper.StringIndexer.GetIndex(System.String)">
            <summary>
            Returns the index of a string (creates it if not already in table)
            </summary>
            <param name="str">String to search</param>
            <returns>String index</returns>
        </member>
        <member name="P:BrightData.Helper.StringIndexer.OutputSize">
            <summary>
            Size of the string table
            </summary>
        </member>
        <member name="T:BrightData.Helper.TempStreamManager">
            <summary>
            Manages a collection of temp files
            </summary>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="basePath">Location on disk to write new temp files</param>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.Get(System.String)">
            <summary>
            Returns an existing (or creates a new) temp stream
            </summary>
            <param name="uniqueId">Unique identifier</param>
        </member>
        <member name="M:BrightData.Helper.TempStreamManager.HasStream(System.String)">
            <summary>
            Checks if the the stream has been created
            </summary>
            <param name="uniqueId">Unique identifier</param>
            <returns>True if the stream has been created</returns>
        </member>
        <member name="T:BrightData.IndexList">
            <summary>
            Contains a list of indices
            </summary>
        </member>
        <member name="P:BrightData.IndexList.Context">
            <inheritdoc />
        </member>
        <member name="P:BrightData.IndexList.Indices">
            <summary>
            The list of indices
            </summary>
        </member>
        <member name="P:BrightData.IndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.IndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.IndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.IndexList})">
            <summary>
            Merges a sequence of index lists into a single index list
            </summary>
            <param name="lists">Lists to merge</param>
        </member>
        <member name="M:BrightData.IndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.IndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.IndexList.Initialize(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.IndexList.ToXml">
            <summary>
            Converts the index list to XML
            </summary>
        </member>
        <member name="M:BrightData.IndexList.JaccardSimilarity(BrightData.IndexList)">
            <summary>
            Calculates the jaccard similarity between this and another index list
            </summary>
            <param name="other">Index list to compare to</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.ToDense(System.Nullable{System.UInt32})">
            <summary>
            Converts to a vector
            </summary>
            <param name="maxIndex">Maximum index to include</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IndexList.HasIndex(System.UInt32)">
            <summary>
            Checks if the specified index has been set
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHaveIndices">
            <summary>
            Indicates that the type has a list of indices
            </summary>
        </member>
        <member name="P:BrightData.IHaveIndices.Indices">
            <summary>
            Enumerates the indices
            </summary>
        </member>
        <member name="T:BrightData.ICanWriteToBinaryWriter">
            <summary>
            Indicates that the type can serialize to a binary writer
            </summary>
        </member>
        <member name="M:BrightData.ICanWriteToBinaryWriter.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Serialize to binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:BrightData.ICanInitializeFromBinaryReader">
            <summary>
            Indicates that the type can initialize from a binary reader
            </summary>
        </member>
        <member name="M:BrightData.ICanInitializeFromBinaryReader.Initialize(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Initialize from a binary reader
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">Reader to read from to initialize</param>
        </member>
        <member name="T:BrightData.ISerializable">
            <summary>
            Supports both writing and reading from binary
            </summary>
        </member>
        <member name="T:BrightData.IMetaData">
            <summary>
            Unstructured meta data store
            </summary>
        </member>
        <member name="M:BrightData.IMetaData.Get(System.String)">
            <summary>
            Returns a value
            </summary>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.GetNullable``1(System.String)">
            <summary>
            Returns a typed nullable value
            </summary>
            <param name="name">Name of the value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Get``1(System.String,``0)">
            <summary>
            Returns a typed value
            </summary>
            <param name="name">Name of the value</param>
            <param name="valueIfMissing">Value to return if the value has not been set</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Get``1(System.String)">
            <summary>
            Returns an existing value (throws if not found)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Set``1(System.String,``0)">
            <summary>
            Sets a named value
            </summary>
            <param name="name">Name of the value</param>
            <param name="value">Value</param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:BrightData.IMetaData.AsXml">
            <summary>
            XML representation of the meta data
            </summary>
        </member>
        <member name="M:BrightData.IMetaData.CopyTo(BrightData.IMetaData)">
            <summary>
            Copies this to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
        </member>
        <member name="M:BrightData.IMetaData.CopyTo(BrightData.IMetaData,System.String[])">
            <summary>
            Copies the specified values to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keys">Values to copy</param>
        </member>
        <member name="M:BrightData.IMetaData.CopyAllExcept(BrightData.IMetaData,System.String[])">
            <summary>
            Copies all except for the specified values to another meta data store
            </summary>
            <param name="metadata">Other meta data store</param>
            <param name="keys">Values NOT to copy (i.e. skip)</param>
        </member>
        <member name="M:BrightData.IMetaData.ReadFrom(System.IO.BinaryReader)">
            <summary>
            Reads values from a binary reader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:BrightData.IMetaData.GetStringsWithPrefix(System.String)">
            <summary>
            Returns all value names with the specified prefix
            </summary>
            <param name="prefix">Prefix to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Has(System.String)">
            <summary>
            Checks if a value has been set
            </summary>
            <param name="key">Name of the value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IMetaData.Remove(System.String)">
            <summary>
            Removes a value
            </summary>
            <param name="key">Name of the value</param>
        </member>
        <member name="T:BrightData.IHaveMetaData">
            <summary>
            Indicates that the type has a meta data store
            </summary>
        </member>
        <member name="P:BrightData.IHaveMetaData.MetaData">
            <summary>
            Meta data store
            </summary>
        </member>
        <member name="T:BrightData.IReferenceCountedMemory">
            <summary>
            Reference counted memory block
            </summary>
        </member>
        <member name="P:BrightData.IReferenceCountedMemory.Size">
            <summary>
            Size of the memory block
            </summary>
        </member>
        <member name="M:BrightData.IReferenceCountedMemory.AddRef">
            <summary>
            Adds a reference
            </summary>
            <returns>Current number of references</returns>
        </member>
        <member name="M:BrightData.IReferenceCountedMemory.Release">
            <summary>
            Removes a reference
            </summary>
            <returns>Current number of references</returns>
        </member>
        <member name="P:BrightData.IReferenceCountedMemory.AllocationIndex">
            <summary>
            Returns this block's allocation index
            </summary>
        </member>
        <member name="P:BrightData.IReferenceCountedMemory.IsValid">
            <summary>
            Checks if the block is valid
            </summary>
        </member>
        <member name="T:BrightData.ITensor">
            <summary>
            Tensor base interface
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Shape">
            <summary>
            The shape of the tensor (array of each dimension)
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Size">
            <summary>
            Total number of elements in tensor
            </summary>
        </member>
        <member name="P:BrightData.ITensor.Rank">
            <summary>
            Size of the Shape array
            </summary>
        </member>
        <member name="T:BrightData.ITensor`1">
            <summary>
            Typed tensor base interface
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.ITensor`1.GetDataCopy">
            <summary>
            Returns a copy of the underlying data segment
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensor`1.Segment">
            <summary>
            Underlying data segment
            </summary>
        </member>
        <member name="P:BrightData.ITensor`1.Computation">
            <summary>
            Typed computation interface
            </summary>
        </member>
        <member name="T:BrightData.IDataReader">
            <summary>
            Typed data reader
            </summary>
        </member>
        <member name="M:BrightData.IDataReader.Read``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed value from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataReader.ReadArray``1(System.IO.BinaryReader)">
            <summary>
            Reads a typed array from a binary reader
            </summary>
            <typeparam name="T"></typeparam>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITensorPool">
            <summary>
            A memory pool of tensors
            </summary>
        </member>
        <member name="M:BrightData.ITensorPool.Get``1(System.UInt32)">
            <summary>
            Returns an existing cached array if available or allocates a new array otherwise
            </summary>
            <typeparam name="T"></typeparam>
            <param name="size">Size of the tensor to allocate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorPool.Reuse``1(``0[])">
            <summary>
            Indicates that this array can be reused
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
        </member>
        <member name="P:BrightData.ITensorPool.MaxCacheSize">
            <summary>
            Maximum size to cache for reusable arrays
            </summary>
        </member>
        <member name="P:BrightData.ITensorPool.CacheSize">
            <summary>
            Current size of cached arrays
            </summary>
        </member>
        <member name="T:BrightData.IDisposableLayers">
            <summary>
            Collects a list of disposable objects that can all be disposed when the layer is disposed
            </summary>
        </member>
        <member name="M:BrightData.IDisposableLayers.Add(System.IDisposable)">
            <summary>
            Adds a new disposable object
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:BrightData.IDisposableLayers.Push">
            <summary>
            Creates a new layer to add disposable objects to
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDisposableLayers.Pop">
            <summary>
            Disposes all objects in the top layer and removes this layer
            </summary>
        </member>
        <member name="T:BrightData.ISetLinearAlgebraProvider">
            <summary>
            Indicates that the type can set a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.ISetLinearAlgebraProvider.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.IHaveLinearAlgebraProvider">
            <summary>
            Gives access to a linear algebra provider
            </summary>
        </member>
        <member name="P:BrightData.IHaveLinearAlgebraProvider.LinearAlgebraProvider">
            <summary>
            Linear algebra provider
            </summary>
        </member>
        <member name="T:BrightData.IBrightDataContext">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="P:BrightData.IBrightDataContext.Random">
            <summary>
            Random number generator
            </summary>
        </member>
        <member name="P:BrightData.IBrightDataContext.TensorPool">
            <summary>
            Tensor pool
            </summary>
        </member>
        <member name="P:BrightData.IBrightDataContext.MemoryLayer">
            <summary>
            Disposable memory layers
            </summary>
        </member>
        <member name="P:BrightData.IBrightDataContext.DataReader">
            <summary>
            Data reader
            </summary>
        </member>
        <member name="M:BrightData.IBrightDataContext.GetComputation``1">
            <summary>
            Typed computation
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:BrightData.IBrightDataContext.TempStreamProvider">
            <summary>
            Temp Stream Provider
            </summary>
        </member>
        <member name="M:BrightData.IBrightDataContext.Get``1(System.String,``0)">
            <summary>
            Returns transient, context specific meta data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of value</param>
            <param name="defaultValue">Default value if not already set</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBrightDataContext.Get``1(System.String)">
            <summary>
            Returns optional context specific meta data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBrightDataContext.Set``1(System.String,``0)">
            <summary>
            Sets transient, context specific meta data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of value</param>
            <param name="value">Value</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IBrightDataContext.Set``1(System.String,System.Func{``0})">
            <summary>
            Sets transient, context specific meta data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="name">Name of value</param>
            <param name="valueCreator">Function that will create value to set on demand if not already set</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IBrightDataContext.IsStochastic">
            <summary>
            True if random generator has been initialized with a random initial seed
            </summary>
        </member>
        <member name="M:BrightData.IBrightDataContext.ResetRandom(System.Nullable{System.Int32})">
            <summary>
            Resets the random number generator
            </summary>
            <param name="seed">Random seed (or null to randomly initialize)</param>
        </member>
        <member name="T:BrightData.IHaveDataContext">
            <summary>
            Indicates that the type has a data context
            </summary>
        </member>
        <member name="P:BrightData.IHaveDataContext.Context">
            <summary>
            Bright data context
            </summary>
        </member>
        <member name="T:BrightData.ITensorSegment`1">
            <summary>
            Typed indexable data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.ITensorSegment`1.IsContiguous">
            <summary>
            True if the data values are contiguous in memory
            </summary>
        </member>
        <member name="P:BrightData.ITensorSegment`1.Item(System.UInt32)">
            <summary>
            Returns a value at an index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment`1.Item(System.Int64)">
            <summary>
            Returns a value at an index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ITensorSegment`1.ToArray">
            <summary>
            Converts the segment to an array
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITensorSegment`1.Values">
            <summary>
            All values
            </summary>
        </member>
        <member name="M:BrightData.ITensorSegment`1.InitializeFrom(System.IO.Stream)">
            <summary>
            Initialize the segment from a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.InitializeFrom(System.Func{System.UInt32,`0})">
            <summary>
            Initialize the segment from a callback
            </summary>
            <param name="initializer">Functions that returns values for each indexed value</param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.InitializeTo(`0)">
            <summary>
            Initialize the segment to a single value
            </summary>
            <param name="initialValue">Initial value</param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.Initialize(`0[])">
            <summary>
            Initialize from an array
            </summary>
            <param name="initialData"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.WriteTo(System.IO.Stream)">
            <summary>
            Writes to a stream
            </summary>
            <param name="writerBaseStream"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.CopyTo(`0[])">
            <summary>
            Copies all values to an existing array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:BrightData.ITensorSegment`1.CopyTo(BrightData.ITensorSegment{`0})">
            <summary>
            Copies all values to another segment
            </summary>
            <param name="segment"></param>
        </member>
        <member name="T:BrightData.INumericComputation`1">
            <summary>
            Typed generic computation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.IWriteToMetaData">
            <summary>
            Indicates that the type can write values to meta data
            </summary>
        </member>
        <member name="M:BrightData.IWriteToMetaData.WriteTo(BrightData.IMetaData)">
            <summary>
            Writes values to meta data
            </summary>
            <param name="metadata">Meta data store</param>
        </member>
        <member name="T:BrightData.IDataAnalyser">
            <summary>
            Base data analyzer type
            </summary>
        </member>
        <member name="M:BrightData.IDataAnalyser.AddObject(System.Object)">
            <summary>
            Adds an object to analyze
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.IDataAnalyser`1">
            <summary>
            Typed data analyser
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDataAnalyser`1.Add(`0)">
            <summary>
            Adds a typed object to analyze
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:BrightData.NormalizationType">
            <summary>
            Types of data normalization
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Standard">
            <summary>
            Standard deviation
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Euclidean">
            <summary>
            Euclidean norm
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.Manhattan">
            <summary>
            Manhattan
            </summary>
        </member>
        <member name="F:BrightData.NormalizationType.FeatureScale">
            <summary>
            Between 0..1
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert">
            <summary>
            Indicates that the type can convert different types
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.From">
            <summary>
            Type that is converted from
            </summary>
        </member>
        <member name="P:BrightData.ICanConvert.To">
            <summary>
            Type that is converted to
            </summary>
        </member>
        <member name="T:BrightData.ICanConvert`2">
            <summary>
            Typed converter interface
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.ICanConvert`2.Convert(`0)">
            <summary>
            Converts a type from one to another
            </summary>
            <param name="data">Object to convert</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.INormalize">
            <summary>
            Data normalizer
            </summary>
        </member>
        <member name="P:BrightData.INormalize.NormalizationType">
            <summary>
            Type of data normalization
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Divide">
            <summary>
            Value to divide each value
            </summary>
        </member>
        <member name="P:BrightData.INormalize.Subtract">
            <summary>
            Value to subtract from each value
            </summary>
        </member>
        <member name="T:BrightData.AggregationType">
            <summary>
            Types of aggregations
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Sum">
            <summary>
            Sums values to a final value
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Average">
            <summary>
            Averages values
            </summary>
        </member>
        <member name="F:BrightData.AggregationType.Max">
            <summary>
            Finds the maximum value
            </summary>
        </member>
        <member name="T:BrightData.IDistribution`1">
            <summary>
            Data distribution
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IDistribution`1.Sample">
            <summary>
            Samples a value from the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDiscreteDistribution">
            <summary>
            Discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.INonNegativeDiscreteDistribution">
            <summary>
            Positive discrete data distribution
            </summary>
        </member>
        <member name="T:BrightData.IContinuousDistribution">
            <summary>
            Continuous data distribution
            </summary>
        </member>
        <member name="T:BrightData.IProvideTempStreams">
            <summary>
            Temp stream provider
            </summary>
        </member>
        <member name="M:BrightData.IProvideTempStreams.Get(System.String)">
            <summary>
            Returns an existing or creates a new temporary stream
            </summary>
            <param name="uniqueId">Id that uniquely identifies the context</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IProvideTempStreams.HasStream(System.String)">
            <summary>
            Checks if a stream has been created
            </summary>
            <param name="uniqueId">Id that uniquely identifies the context</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IHybridBuffer">
            <summary>
            Hybrid buffers write first to memory but then to disk once it's cache is exhausted
            </summary>
        </member>
        <member name="M:BrightData.IHybridBuffer.CopyTo(System.IO.Stream)">
            <summary>
            Copies the buffer to a stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:BrightData.IHybridBuffer.NumDistinct">
            <summary>
            Number of distinct items in the buffer (or null if not known)
            </summary>
        </member>
        <member name="M:BrightData.IHybridBuffer.Add(System.Object)">
            <summary>
            Adds an object to the buffer
            </summary>
            <param name="obj">Object to add</param>
        </member>
        <member name="T:BrightData.IAppendableBuffer`1">
            <summary>
            Append only buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:BrightData.IAppendableBuffer`1.Add(`0)">
            <summary>
            Adds a new item
            </summary>
            <param name="value">Item to add</param>
        </member>
        <member name="T:BrightData.IHybridBuffer`1">
            <summary>
            Typed hybrid buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.HybridBufferType">
            <summary>
            Type of hybrid buffer
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.Unknown">
            <summary>
            Unknown type
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.Struct">
            <summary>
            Buffer of structs
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.String">
            <summary>
            Buffer of strings
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.EncodedStruct">
            <summary>
            Buffer of encoded structs
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.EncodedString">
            <summary>
            Buffer of encoded strings
            </summary>
        </member>
        <member name="F:BrightData.HybridBufferType.Object">
            <summary>
            Buffer of objects
            </summary>
        </member>
        <member name="T:BrightData.IHaveSize">
            <summary>
            Indicates that the type has a size
            </summary>
        </member>
        <member name="P:BrightData.IHaveSize.Size">
            <summary>
            Number of items
            </summary>
        </member>
        <member name="T:BrightData.ICanEnumerate">
            <summary>
            Indicates that the type can enumerate items
            </summary>
        </member>
        <member name="M:BrightData.ICanEnumerate.Enumerate">
            <summary>
            Enumerates all items
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICanEnumerate`1">
            <summary>
            Indicates that the type can enumerate items of this type
            </summary>
            <typeparam name="T">Type to enumerate</typeparam>
        </member>
        <member name="M:BrightData.ICanEnumerate`1.EnumerateTyped">
            <summary>
            Enumerates all items
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IIndexStrings">
            <summary>
            Indicates that the type can convert string to string indices
            </summary>
        </member>
        <member name="M:BrightData.IIndexStrings.GetIndex(System.String)">
            <summary>
            Returns the index for a string
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IIndexStrings.OutputSize">
            <summary>
            Gets the total number of possible string indices
            </summary>
        </member>
        <member name="T:BrightData.IHaveIndexer">
            <summary>
            Indicates that the type has string indexer
            </summary>
        </member>
        <member name="P:BrightData.IHaveIndexer.Indexer">
            <summary>
            String indexer
            </summary>
        </member>
        <member name="T:BrightData.ICanComplete">
            <summary>
            Indicates that an operation can be completed
            </summary>
        </member>
        <member name="M:BrightData.ICanComplete.Complete">
            <summary>
            Complete the operation
            </summary>
        </member>
        <member name="T:BrightData.IHaveDictionary">
            <summary>
            Indicates that the type has a dictionary (string table)
            </summary>
        </member>
        <member name="P:BrightData.IHaveDictionary.Dictionary">
            <summary>
            Current dictionary (string table)
            </summary>
        </member>
        <member name="T:BrightData.ICanReadSection">
            <summary>
            Implemented by types that can repeatedly read the same section of a stream
            </summary>
        </member>
        <member name="M:BrightData.ICanReadSection.GetReader">
            <summary>
            Creates a new reader for the readable section of the stream
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.ICloneStreams">
            <summary>
            Clones streams
            </summary>
        </member>
        <member name="M:BrightData.ICloneStreams.Clone">
            <summary>
            Creates a new repeatable section reader
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.DataTableOrientation">
            <summary>
            Determines if the data table is oriented as either rows or columns
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.Unknown">
            <summary>
            Pathological case
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.RowOriented">
            <summary>
            Data table is a series of rows, optimised for per-row processing
            </summary>
        </member>
        <member name="F:BrightData.DataTableOrientation.ColumnOriented">
            <summary>
            Data table is a series of columns, optimised for column based processing
            </summary>
        </member>
        <member name="T:BrightData.ColumnType">
            <summary>
            Segment table column type
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Unknown">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Boolean">
            <summary>
            Boolean values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Byte">
            <summary>
            Byte values (-128 to 128)
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Short">
            <summary>
            Short values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Int">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Long">
            <summary>
            Long values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Float">
            <summary>
            Float values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Double">
            <summary>
            Double values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Decimal">
            <summary>
            Decimal values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.String">
            <summary>
            String values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Date">
            <summary>
            Date values
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.IndexList">
            <summary>
            List of indices
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.WeightedIndexList">
            <summary>
            Weighted list of indices
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Vector">
            <summary>
            Vector of floats
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Matrix">
            <summary>
            Matrix of floats
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Tensor3D">
            <summary>
            3D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.Tensor4D">
            <summary>
            4D tensor of floats
            </summary>
        </member>
        <member name="F:BrightData.ColumnType.BinaryData">
            <summary>
            Binary data
            </summary>
        </member>
        <member name="T:BrightData.ColumnClass">
            <summary>
            Column classifications
            </summary>
        </member>
        <member name="T:BrightData.ISingleTypeTableSegment">
            <summary>
            A segment (series of values) in a table of which each element has the same type
            </summary>
        </member>
        <member name="P:BrightData.ISingleTypeTableSegment.SingleType">
            <summary>
            The single type of the segment
            </summary>
        </member>
        <member name="M:BrightData.ISingleTypeTableSegment.Enumerate">
            <summary>
            Enumerate each item (casting to object)
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ISingleTypeTableSegment.Size">
            <summary>
            Number of values (size of segment)
            </summary>
        </member>
        <member name="T:BrightData.IDataTableSegment">
            <summary>
            A series of values from a data table
            </summary>
        </member>
        <member name="P:BrightData.IDataTableSegment.Size">
            <summary>
            Number of values (size of segment)
            </summary>
        </member>
        <member name="P:BrightData.IDataTableSegment.Types">
            <summary>
            The column type of each value
            </summary>
        </member>
        <member name="P:BrightData.IDataTableSegment.Item(System.UInt32)">
            <summary>
            The value at each index (cast to object)
            </summary>
            <param name="index">Index to retrieve</param>
        </member>
        <member name="T:BrightData.IDataTableSegment`1">
            <summary>
            Typed data table segment (all of the same type)
            </summary>
            <typeparam name="T">Data type of values within the segment</typeparam>
        </member>
        <member name="M:BrightData.IDataTableSegment`1.EnumerateTyped">
            <summary>
            Enumerates the values
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IDataTable">
            <summary>
            A data table is an immutable collection of data with columns and rows (in which the columns have the same type of data)
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.ColumnTypes">
            <summary>
            The type of each column
            </summary>
        </member>
        <member name="P:BrightData.IDataTable.Orientation">
            <summary>
            How the table is aligned (either row or column)
            </summary>
        </member>
        <member name="M:BrightData.IDataTable.ForEachRow(System.Action{System.Object[],System.UInt32},System.UInt32)">
            <summary>
            Invokes the callback on each row of the data table
            </summary>
            <param name="callback">Callback for each row</param>
            <param name="maxRows">Maximum number of rows to process</param>
        </member>
        <member name="M:BrightData.IDataTable.ForEachRow(System.Action{System.Object[]},System.UInt32)">
            <summary>
            Invokes the callback on each row of the data table
            </summary>
            <param name="callback">Callback for each row</param>
            <param name="maxRows">Maximum number of rows to process</param>
        </member>
        <member name="M:BrightData.IDataTable.Columns(System.UInt32[])">
            <summary>
            Enumerates the columns of the data table
            </summary>
            <param name="columnIndices">Column indices to retrieve</param>
        </member>
        <member name="M:BrightData.IDataTable.ReadTyped(System.Collections.Generic.IEnumerable{BrightData.IConsumeColumnData},System.UInt32)">
            <summary>
            Consumes data in the table via an array of consumers, which will each consume data for each row in the table
            </summary>
            <param name="consumers">Array of consumers, for each column in the table</param>
            <param name="maxRows">Maximum number of rows to process</param>
        </member>
        <member name="M:BrightData.IDataTable.Column(System.UInt32)">
            <summary>
            Returns a single column from the table
            </summary>
            <param name="columnIndex">Column index to retrieve</param>
        </member>
        <member name="M:BrightData.IDataTable.ColumnAnalysis(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns analysed metadata for the specified columns
            </summary>
            <param name="columnIndices">Column indices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTable.ColumnMetaData(System.UInt32)">
            <summary>
            Returns the metadata for a single column (without analysis)
            </summary>
            <param name="columnIndex">Column index to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTable.Project(System.Func{System.Object[],System.Object[]},System.String)">
            <summary>
            Applies a projection function to each row of this data table
            </summary>
            <param name="projector">Mutates the rows of each row by changing values, types, or both</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
        </member>
        <member name="M:BrightData.IDataTable.WriteTo(System.String)">
            <summary>
            Writes the data table to disk
            </summary>
            <param name="filePath">File path</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IColumnOrientedDataTable">
            <summary>
            Column oriented data table
            </summary>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.AsRowOriented(System.String)">
            <summary>
            Converts to a row oriented data table
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Convert(BrightData.IColumnTransformationParam[])">
            <summary>
            Creates a new table with columns that have been converted
            </summary>
            <param name="conversion">Column conversion parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Convert(System.String,BrightData.IColumnTransformationParam[])">
            <summary>
            Creates a new table with columns that have been converted
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="conversion">Column conversion parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Normalize(BrightData.NormalizationType,System.String)">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="type">Normalization type</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Normalize(BrightData.IColumnTransformationParam[])">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="conversion">Column normalization parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Normalize(System.String,BrightData.IColumnTransformationParam[])">
            <summary>
            Normalizes the data in all columns of the table
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="conversion">Column normalization parameters</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.CopyColumns(System.UInt32[])">
            <summary>
            Copies the selected columns to a new data table
            </summary>
            <param name="columnIndices">Column indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.CopyColumns(System.String,System.UInt32[])">
            <summary>
            Copies the selected columns to a new data table
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="columnIndices">Column indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ConcatColumns(BrightData.IColumnOrientedDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="others">Other tables to concatenate</param>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ConcatColumns(System.String,BrightData.IColumnOrientedDataTable[])">
            <summary>
            Creates a new data table with this concatenated with other column oriented data tables
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="others">Other tables to concatenate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.FilterRows(System.Predicate{System.Object[]},System.String)">
            <summary>
            Creates a new data table of the rows that match the predicate
            </summary>
            <param name="predicate">Predicate function to evaluate which rows to include in the new table</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ReinterpretColumns(BrightData.IReinterpretColumnsParam[])">
            <summary>
            Many to one or one to many style column transformations
            </summary>
            <param name="columns">Parameters to determine which columns are reinterpreted</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ReinterpretColumns(System.String,BrightData.IReinterpretColumnsParam[])">
            <summary>
            Many to one or one to many style column transformations
            </summary>
            <param name="filePath">File path to store new table on disk</param>
            <param name="columns">Parameters to determine which columns are reinterpreted</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.Clone(System.String)">
            <summary>
            Clones the current data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IColumnOrientedDataTable.ColumnAnalysis(System.UInt32,System.Boolean,System.UInt32,System.UInt32)">
            <summary>
            Returns the metadata for a single column after performing analysis on the column
            </summary>
            <param name="columnIndex">Column index to retrieve</param>
            <param name="force">True to force metadata analysis</param>
            <param name="writeCount">Maximum size of sequences to write in final meta data</param>
            <param name="maxCount">Maximum number of distinct items to track</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IRowOrientedDataTable">
            <summary>
            Row oriented data table
            </summary>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.AsColumnOriented(System.String)">
            <summary>
            Converts to a column oriented data table
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.ForEachRow(System.Collections.Generic.IEnumerable{System.UInt32},System.Action{System.Object[]})">
            <summary>
            Invokes the callback on each specified row of the table
            </summary>
            <param name="rowIndices">Row indices to select</param>
            <param name="callback">Callback to invoke on each selected row</param>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Bag(System.UInt32,System.String)">
            <summary>
            Samples (with replacement) from the data table
            </summary>
            <param name="sampleCount">Number of rows to sample</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Row(System.UInt32)">
            <summary>
            Returns the row at the specified index
            </summary>
            <param name="rowIndex">Row index to retrieve</param>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Rows(System.UInt32[])">
            <summary>
            Returns the rows at the specified indices
            </summary>
            <param name="rowIndices">Row indices to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Concat(BrightData.IRowOrientedDataTable[])">
            <summary>
            Creates a new table of this concatenated with other row oriented data tables
            </summary>
            <param name="others">Other row oriented data tables to concatenate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Concat(System.String,BrightData.IRowOrientedDataTable[])">
            <summary>
            Creates a new table of this concatenated with other row oriented data tables
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="others">Other row oriented data tables to concatenate</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.CopyRows(System.UInt32[])">
            <summary>
            Copy specified rows from this to a new data table
            </summary>
            <param name="rowIndices">Row indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.CopyRows(System.String,System.UInt32[])">
            <summary>
            Copy specified rows from this to a new data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <param name="rowIndices">Row indices to copy</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Shuffle(System.String)">
            <summary>
            Creates a new data table from the randomly shuffled rows of this data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Sort(System.UInt32,System.Boolean,System.String)">
            <summary>
            Creates a new sorted data table
            </summary>
            <param name="columnIndex">Column index to sort</param>
            <param name="ascending">True to sort ascending</param>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.GroupBy(System.UInt32)">
            <summary>
            Splits this table into many data tables based on the value from a column
            </summary>
            <param name="columnIndex">Column index to group on</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.FirstRow">
            <summary>
            Returns the first row as a string
            </summary>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.SecondRow">
            <summary>
            Returns the second row as a string
            </summary>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.ThirdRow">
            <summary>
            Returns the third row as a string
            </summary>
        </member>
        <member name="P:BrightData.IRowOrientedDataTable.LastRow">
            <summary>
            Returns the last row as a string
            </summary>
        </member>
        <member name="M:BrightData.IRowOrientedDataTable.Clone(System.String)">
            <summary>
            Clones the current data table
            </summary>
            <param name="filePath">File path to store new table on disk (optional)</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ColumnConversionType">
            <summary>
            Single column conversion options
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.Unchanged">
            <summary>
            Leave the column unchanged (nop)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToBoolean">
            <summary>
            Convert to boolean
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToDate">
            <summary>
            Convert to date
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToNumeric">
            <summary>
            Convert to numeric (best numeric size will be automatically determined)
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToString">
            <summary>
            Convert to string
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToIndexList">
            <summary>
            Convert to index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToWeightedIndexList">
            <summary>
            Convert to weighted index list
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToVector">
            <summary>
            Convert to vector
            </summary>
        </member>
        <member name="F:BrightData.ColumnConversionType.ToCategoricalIndex">
            <summary>
            Convert each value to an index within a dictionary
            </summary>
        </member>
        <member name="T:BrightData.ITransformColumn">
            <summary>
            Transforms columns
            </summary>
        </member>
        <member name="M:BrightData.ITransformColumn.Finalise(BrightData.IMetaData)">
            <summary>
            Complete the transformation
            </summary>
            <param name="metaData">Meta data store to receive transformation information</param>
        </member>
        <member name="T:BrightData.ITransformColumn`2">
            <summary>
            Typed column transformer
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="M:BrightData.ITransformColumn`2.Convert(`0,BrightData.IHybridBuffer{`1})">
            <summary>
            Writes the converted input to the buffer
            </summary>
            <param name="input"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ITransformationContext">
            <summary>
            Transforms a column
            </summary>
        </member>
        <member name="M:BrightData.ITransformationContext.Transform">
            <summary>
            Performs the transformation
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.ITransformationContext.Buffer">
            <summary>
            Buffer that is written to
            </summary>
        </member>
        <member name="T:BrightData.IColumnInfo">
            <summary>
            Table column information
            </summary>
        </member>
        <member name="P:BrightData.IColumnInfo.Index">
            <summary>
            Column index
            </summary>
        </member>
        <member name="P:BrightData.IColumnInfo.ColumnType">
            <summary>
            Column type
            </summary>
        </member>
        <member name="P:BrightData.IColumnInfo.Dictionary">
            <summary>
            Encoded dictionary
            </summary>
        </member>
        <member name="T:BrightData.IColumnTransformationParam">
            <summary>
            Informtion about a column transformation
            </summary>
        </member>
        <member name="P:BrightData.IColumnTransformationParam.ColumnIndex">
            <summary>
            Column index
            </summary>
        </member>
        <member name="M:BrightData.IColumnTransformationParam.GetTransformer(BrightData.ColumnType,BrightData.ISingleTypeTableSegment,System.Func{BrightData.IMetaData},BrightData.IProvideTempStreams,System.UInt32)">
            <summary>
            Gets a column transformer
            </summary>
            <param name="fromType">Convert from column type</param>
            <param name="column">Column to convert</param>
            <param name="analysedMetaData">Function to produce analysed column meta data if needed</param>
            <param name="tempStreams">Temp stream provider</param>
            <param name="inMemoryRowCount">Number of rows to cache in memory</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.IConvertibleTable">
            <summary>
            A table that is easily convertible to other types
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleTable.Row(System.UInt32)">
            <summary>
            Returns a row that can be easily converted
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IConvertibleTable.Rows(System.UInt32[])">
            <summary>
            Returns rows that can be easily converted
            </summary>
            <param name="rowIndices">Row indices to return</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IConvertibleTable.DataTable">
            <summary>
            The underlying data table
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleTable.Map``1(System.Func{BrightData.IConvertibleRow,``0})">
            <summary>
            Maps each row
            </summary>
            <typeparam name="T"></typeparam>
            <param name="rowMapper">Callback that will be invoked on each convertible row</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IConvertibleTable.ForEachRow(System.Action{BrightData.IConvertibleRow})">
            <summary>
            Invokes a callback on each convertible row
            </summary>
            <param name="action">Callback</param>
        </member>
        <member name="T:BrightData.IHaveDataTable">
            <summary>
            Indicates that the type has a data table
            </summary>
        </member>
        <member name="P:BrightData.IHaveDataTable.DataTable">
            <summary>
            Data table
            </summary>
        </member>
        <member name="T:BrightData.IConvertibleRow">
            <summary>
            A row that whose elements can be converted to other types
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleRow.Get(System.UInt32)">
            <summary>
            Gets an element
            </summary>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IConvertibleRow.Segment">
            <summary>
            Returns the row segment
            </summary>
        </member>
        <member name="M:BrightData.IConvertibleRow.GetTyped``1(System.UInt32)">
            <summary>
            Returns a value (dynamic conversion to type T)
            </summary>
            <typeparam name="T">Type to convert to</typeparam>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IConvertibleRow.RowIndex">
            <summary>
            Row index
            </summary>
        </member>
        <member name="T:BrightData.IConsumeColumnData">
            <summary>
            Interface that 
            </summary>
        </member>
        <member name="P:BrightData.IConsumeColumnData.ColumnIndex">
            <summary>
            Column index that will be consumed
            </summary>
        </member>
        <member name="P:BrightData.IConsumeColumnData.ColumnType">
            <summary>
            Column type of incoming data
            </summary>
        </member>
        <member name="T:BrightData.IConsumeColumnData`1">
            <summary>
            Typed column consumer that writes to a buffer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.IDataTableVectoriser">
            <summary>
            Data table vectoriser
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(System.Object[])">
            <summary>
            Vectorise a table row
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Vectorise(BrightData.IDataTableSegment)">
            <summary>
            Vectorise a data table segment
            </summary>
            <param name="segment"></param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IDataTableVectoriser.OutputSize">
            <summary>
            Size of the output vectors
            </summary>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.GetOutputLabel(System.UInt32,System.UInt32)">
            <summary>
            Returns the associated label from the one hot encoding dictionary
            </summary>
            <param name="vectorIndex">Index within one hot encoded vector</param>
            <param name="columnIndex">Data table column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IDataTableVectoriser.Enumerate">
            <summary>
            Returns a sequence of vectorised table rows
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IReinterpretColumnsParam">
            <summary>
            Reinterpret columns parameters
            </summary>
        </member>
        <member name="P:BrightData.IReinterpretColumnsParam.ColumnIndices">
            <summary>
            Source column indices
            </summary>
        </member>
        <member name="M:BrightData.IReinterpretColumnsParam.GetNewColumns(BrightData.IBrightDataContext,BrightData.IProvideTempStreams,System.UInt32,System.ValueTuple{BrightData.IColumnInfo,BrightData.ISingleTypeTableSegment}[])">
            <summary>
            Gets new columns
            </summary>
            <param name="context">Bright data context</param>
            <param name="tempStreams">Temp stream provider</param>
            <param name="initialColumnIndex">First column index in the sequence</param>
            <param name="columns">Source column data</param>
            <returns></returns>
        </member>
        <member name="T:BrightData.ILinearAlgebraProvider">
            <summary>
            Linear algebra adaptor interfaces
            </summary>
        </member>
        <member name="P:BrightData.ILinearAlgebraProvider.Name">
            <summary>
            Name of the linear algebra provider
            </summary>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateVector(System.UInt32,System.Boolean)">
            <summary>
            Creates a new vector
            </summary>
            <param name="length">Length of the vector</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateVector(System.UInt32,System.Func{System.UInt32,System.Single})">
            <summary>
            Creates a vector
            </summary>
            <param name="length">Size of the vector</param>
            <param name="init">Callback to initialise each element of the vector</param>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a matrix
            </summary>
            <param name="rows">The number of rows</param>
            <param name="columns">The number of columns</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateMatrix(System.UInt32,System.UInt32,System.Func{System.UInt32,System.UInt32,System.Single})">
            <summary>
            Creates a matrix
            </summary>
            <param name="rows">The number of rows</param>
            <param name="columns">The number of columns</param>
            <param name="init">Callback to initialise each element of the matrix</param>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateMatrixFromRows(BrightData.IFloatVector[])">
            <summary>
            Creates a matrix from a list of vectors. Each vector will become a row in the new matrix
            </summary>
            <param name="vectorRows">List of vectors for each row</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateMatrixFromColumns(BrightData.IFloatVector[])">
            <summary>
            Creates a matrix from a list of vectors. Each vector will become a column in the new matrix
            </summary>
            <param name="vectorColumns">List of vectors for each column</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.Create3DTensor(System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a 3D tensor
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="depth">Number of depth slices</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.Create3DTensor(BrightData.IFloatMatrix[])">
            <summary>
            Creates a 3D tensor from a list of matrices
            </summary>
            <param name="matrices">List of matrices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.Create4DTensor(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Creates a 4D tensor
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <param name="depth">Number of matrices</param>
            <param name="count">Number of 3D tensors</param>
            <param name="setToZero">True to initialise the data to zero (otherwise it might be anything)</param>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.Create4DTensor(BrightData.I3DFloatTensor[])">
            <summary>
            Creates a 4D tensor from a list of 3D tensors
            </summary>
            <param name="tensors">List of 3D tensors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.Create4DTensor(BrightData.LinearAlgebra.Tensor3D{System.Single}[])">
            <summary>
            Creates a 4D tensor from a list of 3D tensors
            </summary>
            <param name="tensors">List of 3D tensors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.PushLayer">
            <summary>
            Creates a save point in the allocation history
            </summary>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.PopLayer">
            <summary>
            Releases all allocated memory since the last save point
            </summary>
        </member>
        <member name="P:BrightData.ILinearAlgebraProvider.IsGpu">
            <summary>
            True if the provider uses the GPU
            </summary>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CalculateDistances(BrightData.IFloatVector[],System.Collections.Generic.IReadOnlyList{BrightData.IFloatVector},BrightData.DistanceMetric)">
            <summary>
            Calculates the distance of each vector against the comparison vectors - the size of all vectors should be the same
            </summary>
            <param name="vectors"></param>
            <param name="comparison"></param>
            <param name="distanceMetric"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.ILinearAlgebraProvider.CreateVector(BrightData.ITensorSegment{System.Single})">
            <summary>
            Creates a vector from a tensor segment
            </summary>
            <param name="data">Tensor segment</param>
        </member>
        <member name="T:BrightData.DistanceMetric">
            <summary>
            Distance metrics
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Euclidean">
            <summary>
            Euclidean Distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Cosine">
            <summary>
            Cosine Distance Metric
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.Manhattan">
            <summary>
            Manhattan Distance
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.MeanSquared">
            <summary>
            Means Square Error
            </summary>
        </member>
        <member name="F:BrightData.DistanceMetric.SquaredEuclidean">
            <summary>
            Square Euclidean
            </summary>
        </member>
        <member name="T:BrightData.IFloatVector">
            <summary>
            A vector
            </summary>
        </member>
        <member name="P:BrightData.IFloatVector.IsValid">
            <summary>
            Checks if the vector has not been disposed
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.ReshapeAsColumnMatrix">
            <summary>
            Converts the vector to a column matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.ReshapeAsRowMatrix">
            <summary>
            Converts the vector to a row matrix
            </summary>
        </member>
        <member name="P:BrightData.IFloatVector.Count">
            <summary>
            The number of elements in the vector
            </summary>
        </member>
        <member name="P:BrightData.IFloatVector.Data">
            <summary>
            Converts the vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.Add(BrightData.IFloatVector)">
            <summary>
            Adds a vector (without in place modification)
            </summary>
            <param name="vector">The vector to add</param>
        </member>
        <member name="M:BrightData.IFloatVector.Subtract(BrightData.IFloatVector)">
            <summary>
            Subtracts a vector (without in place modification)
            </summary>
            <param name="vector">The vector to subtract</param>
        </member>
        <member name="M:BrightData.IFloatVector.L1Norm">
            <summary>
            Calculates the absolute values (L1) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.L2Norm">
            <summary>
            Calculates the euclidean (L2) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.MaximumIndex">
            <summary>
            Returns the index of the vector with the greatest value
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.MinimumIndex">
            <summary>
            Returns the index of the vector with the smallest value
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.Multiply(System.Single)">
            <summary>
            Multiples (in place) by a scalar
            </summary>
            <param name="scalar">The value to multiple each element</param>
        </member>
        <member name="M:BrightData.IFloatVector.Add(System.Single)">
            <summary>
            Adds (in place) a scalar
            </summary>
            <param name="scalar">The value to add to each element</param>
        </member>
        <member name="M:BrightData.IFloatVector.AddInPlace(BrightData.IFloatVector,System.Single,System.Single)">
            <summary>
            Adds a vector in place
            </summary>
            <param name="vector">The target vector to add to the current vector</param>
            <param name="coefficient1">A value to multiply each element of the current vector</param>
            <param name="coefficient2">A value to multiply each element of the target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.SubtractInPlace(BrightData.IFloatVector,System.Single,System.Single)">
            <summary>
            Subtracts a vector in place
            </summary>
            <param name="vector">The target vector to subtract from the current vector</param>
            <param name="coefficient1">A value to multiply each element of the current vector</param>
            <param name="coefficient2">A value to multiply each element of the target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.AsIndexable">
            <summary>
            Converts the vector to an indexable vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.PointwiseMultiply(BrightData.IFloatVector)">
            <summary>
            Pointwise multiplication (without in place modification) with a vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.DotProduct(BrightData.IFloatVector)">
            <summary>
            The dot product of two vectors
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.GetNewVectorFromIndexes(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns a new vector from a subset of the vector indices
            </summary>
            <param name="indices">A list of indexes to use as the source of the new vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.Clone">
            <summary>
            Creates a new copy of the vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.Sqrt">
            <summary>
            Creates a new vector in which each element is the square root of the current vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.Abs">
            <summary>
            Creates a new vector in which each element is the absolute value of the current vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.CopyFrom(BrightData.IFloatVector)">
            <summary>
            Copies values from the target vector into the current vector
            </summary>
            <param name="vector"></param>
        </member>
        <member name="M:BrightData.IFloatVector.EuclideanDistance(BrightData.IFloatVector)">
            <summary>
            Calculates the euclidean distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.CosineDistance(BrightData.IFloatVector)">
            <summary>
            Calculates the cosine distance between the current and the target vector
            </summary>
            <param name="vector">The target vector></param>
        </member>
        <member name="M:BrightData.IFloatVector.ManhattanDistance(BrightData.IFloatVector)">
            <summary>
            Calculates the manhattan distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.MeanSquaredDistance(BrightData.IFloatVector)">
            <summary>
            Calculates the mean squared distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.SquaredEuclidean(BrightData.IFloatVector)">
            <summary>
            Calculates the squared euclidean distance between the current and the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatVector.GetMinMax">
            <summary>
            Finds the minimum and maximum values in the current vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.Average">
            <summary>
            Calculates the average value from the elements of the current vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.StdDev(System.Nullable{System.Single})">
            <summary>
            Calculates the standard deviation from the elements of the current vector
            </summary>
            <param name="mean">(optional) pre calculated mean</param>
        </member>
        <member name="M:BrightData.IFloatVector.Normalize(BrightData.NormalizationType)">
            <summary>
            Normalizes (in place) the values of the current vector
            </summary>
            <param name="type">The type of normalisation</param>
        </member>
        <member name="M:BrightData.IFloatVector.Softmax">
            <summary>
            Returns the softmax function (without in place modification) applied to the current vector
            https://en.wikipedia.org/wiki/Softmax_function
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.SoftmaxDerivative">
            <summary>
            Returns the jacobian matrix of the softmax derivative
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatVector.FindDistances(BrightData.IFloatVector[],BrightData.DistanceMetric)">
            <summary>
            Returns a vector of distances between the current and target vectors
            </summary>
            <param name="data">The list of target vectors</param>
            <param name="distance">The distance metric</param>
            <returns>A vector in which each element n is the distance between the current and the nth target vector</returns>
        </member>
        <member name="M:BrightData.IFloatVector.FindDistance(BrightData.IFloatVector,BrightData.DistanceMetric)">
            <summary>
            Returns the distance between the current and the target vector
            </summary>
            <param name="other">The target vector</param>
            <param name="distance">The distance metric</param>
        </member>
        <member name="M:BrightData.IFloatVector.CosineDistance(BrightData.IFloatVector[],System.Single[]@)">
            <summary>
            Returns a vector of the cosine distance between the current and target vectors
            </summary>
            <param name="data">The list of target vectors</param>
            <param name="dataNorm">A buffer to hold the norms of the target vectors</param>
            <returns>A vector in which each element n is the cosine distance between the current and the nth target vector</returns>
        </member>
        <member name="M:BrightData.IFloatVector.Log">
            <summary>
            Returns a vector (without in place modification) in which each element is the natural log of each element in the current vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.Sigmoid">
            <summary>
            Returns the sigmoid function (without in place modification) applied to the current vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatVector.ReshapeAsMatrix(System.UInt32,System.UInt32)">
            <summary>
            Fast conversion to matrix (internal buffer is used directly)
            </summary>
            <param name="rows">The number of rows in the matrix</param>
            <param name="columns">The number of columns in the matrix</param>
        </member>
        <member name="M:BrightData.IFloatVector.ReshapeAs3DTensor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Converts the vector to a 3D tensor
            </summary>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in matrix</param>
            <param name="depth">Number of matrices</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatVector.ReshapeAs4DTensor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Converts the vector to a 4D tensor
            </summary>
            <param name="rows">Number of rows in each matrix</param>
            <param name="columns">Number of columns in matrix</param>
            <param name="depth">Number of matrices</param>
            <param name="count">Number of 3D tensors</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatVector.Split(System.UInt32)">
            <summary>
            Splits the vector into a list of vectors
            </summary>
            <param name="blockCount">The number of sub vectors to split into</param>
        </member>
        <member name="M:BrightData.IFloatVector.RotateInPlace(System.UInt32)">
            <summary>
            Rotates values in the vector (both horizontally and vertically within blocks)
            </summary>
            <param name="blockCount"></param>
        </member>
        <member name="M:BrightData.IFloatVector.Reverse">
            <summary>
            Returns a reversed copy of the vector's values
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatVector.GetAt(System.UInt32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="index">The index of the vector to return</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatVector.SetAt(System.UInt32,System.Single)">
            <summary>
            Updates the value at the specified index
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:BrightData.IFloatVector.IsEntirelyFinite">
            <summary>
            Checks if every value in the vector is finite (not NaN or positive/negative infinity)
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IIndexableFloatVector">
            <summary>
            Returns an indexable vector (in which elements can be directly indexed)
            </summary>
        </member>
        <member name="P:BrightData.IIndexableFloatVector.Item(System.UInt32)">
            <summary>
            Returns an element at the specified index
            </summary>
            <param name="index">The index to retrieve</param>
        </member>
        <member name="P:BrightData.IIndexableFloatVector.Values">
            <summary>
            Gets the values as an enumerable
            </summary>
        </member>
        <member name="M:BrightData.IIndexableFloatVector.ToArray">
            <summary>
            Converts the vector to an array
            </summary>
        </member>
        <member name="M:BrightData.IIndexableFloatVector.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the vector as well)
            </summary>
        </member>
        <member name="M:BrightData.IIndexableFloatVector.Append(System.Single[])">
            <summary>
            Creates a new vector (without in place modification) in which new values are appended onto the end of the current vector
            </summary>
            <param name="data">The values to append</param>
        </member>
        <member name="T:BrightData.IFloatMatrix">
            <summary>
            A matrix
            </summary>
        </member>
        <member name="P:BrightData.IFloatMatrix.IsValid">
            <summary>
            Checks if the matrix has not been disposed
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Multiply(BrightData.IFloatMatrix)">
            <summary>
            Multiplies the current vector (without in place modification) with the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="P:BrightData.IFloatMatrix.ColumnCount">
            <summary>
            The number of columns
            </summary>
        </member>
        <member name="P:BrightData.IFloatMatrix.RowCount">
            <summary>
            The number of rows
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Column(System.UInt32)">
            <summary>
            Returns a column as a vector
            </summary>
            <param name="index">The column index</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.Diagonal">
            <summary>
            Returns the matrix diagonal as a vector
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Row(System.UInt32)">
            <summary>
            Returns a row as a vector
            </summary>
            <param name="index">The row index</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.Add(BrightData.IFloatMatrix)">
            <summary>
            Returns the current matrix (without in place modification) added to the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.Subtract(BrightData.IFloatMatrix)">
            <summary>
            Returns the current matrix  (without in place modification) minus the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.PointwiseMultiply(BrightData.IFloatMatrix)">
            <summary>
            Returns the pointwise product of the current matrix (without in place modification) with the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.TransposeAndMultiply(BrightData.IFloatMatrix)">
            <summary>
            Returns the current matrix (without in place modification) and multipled with the transposed target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.TransposeThisAndMultiply(BrightData.IFloatMatrix)">
            <summary>
            Returns the transpose of the current matrix (without in place modification) multipled with the target matrix
            </summary>
            <param name="matrix"></param>
        </member>
        <member name="M:BrightData.IFloatMatrix.RowSums">
            <summary>
            Returns a vector that contains the sum of the elements in each row of the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.ColumnSums">
            <summary>
            Returns a vector that contains the sum of the elements in each column of the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Transpose">
            <summary>
            Returns the transpose of the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Multiply(System.Single)">
            <summary>
            Multiplies (in place) each element of the matrix by a scalar
            </summary>
            <param name="scalar">The scalar to multiply each element</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.Multiply(BrightData.IFloatVector)">
            <summary>
            Returns the product of the current matrix (without in place modification) with the target vector
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.AddInPlace(BrightData.IFloatMatrix,System.Single,System.Single)">
            <summary>
            Adds the target matrix to the current matrix (in place)
            </summary>
            <param name="matrix">The target matrix</param>
            <param name="coefficient1">A coefficient to multiply each element of the current matrix</param>
            <param name="coefficient2">A coefficient to multipy each element of the target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.SubtractInPlace(BrightData.IFloatMatrix,System.Single,System.Single)">
            <summary>
            Subtracts the target matrix from the current matrix (in place)
            </summary>
            <param name="matrix">The target matrix</param>
            <param name="coefficient1">A coefficient to multiply each element of the current matrix</param>
            <param name="coefficient2">A coefficient to multipy each element of the target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.SigmoidActivation">
            <summary>
            Returns a new matrix with the sigmoid function applied to each element
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.SigmoidDerivative">
            <summary>
            Returns a new matrix with the sigmoid derivative of each element
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.TanhActivation">
            <summary>
            Returns a new matrix with the tanh function applied to each element
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.TanhDerivative">
            <summary>
            Returns a new matrix with the tanh derivative of each element
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.SoftmaxActivation">
            <summary>
            Returns a new matrix with the softmax function applied to each row of the matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.AddToEachRow(BrightData.IFloatVector)">
            <summary>
            Adds the target vector to each row of the current matrix (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.AddToEachColumn(BrightData.IFloatVector)">
            <summary>
            Adds the target vector to each column of the current matrix (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="P:BrightData.IFloatMatrix.Data">
            <summary>
            Converts the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.AsIndexable">
            <summary>
            Converts the matrix to an indexable matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.GetNewMatrixFromRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns a new matrix from a subset of the current matrix's rows
            </summary>
            <param name="rowIndexes">The list of row indices</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.GetNewMatrixFromColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Returns a new matrix from a subset of the current matrix's columns
            </summary>
            <param name="columnIndexes">The list of column indices</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ClearRows(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Set to zero the specified rows in the current matrix
            </summary>
            <param name="indexes">The list of row indices</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ClearColumns(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Set to zero the specified columns in the current matrix
            </summary>
            <param name="indexes">The list of column indices</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ReluActivation">
            <summary>
            Returns the RELU function applied to each element of the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.ReluDerivative">
            <summary>
            Returns the RELU derivative of each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.LeakyReluActivation">
            <summary>
            Returns the leaky RELU function applied to each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.LeakyReluDerivative">
            <summary>
            Returns the leaky RELU derivative of each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Clone">
            <summary>
            Creates a copy of the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Clear">
            <summary>
            Sets each element to zero
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Sqrt">
            <summary>
            Returns the square root of each element in the current matrix
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.Pow(System.Single)">
            <summary>
            Returns each element raised to specified power
            </summary>
            <param name="power">The power to apply to each element</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.PointwiseDivide(BrightData.IFloatMatrix)">
            <summary>
            Returns the current matrix (not modified in place) divided by the target matrix
            </summary>
            <param name="matrix">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.L1Regularisation(System.Single)">
            <summary>
            L1 Regularisation applied to each element of the current matrix (in place)
            </summary>
            <param name="coefficient">The L1 coefficient</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ColumnL2Norm">
            <summary>
            Returns a vector of the L2 norms of each column
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.RowL2Norm">
            <summary>
            Returns a vector of the L2 norms of each row
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.PointwiseDivideRows(BrightData.IFloatVector)">
            <summary>
            Pointwise divide each row by the target vector (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.PointwiseDivideColumns(BrightData.IFloatVector)">
            <summary>
            Pointwise divide each column by the target vector (in place)
            </summary>
            <param name="vector">The target vector</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.Constrain(System.Single,System.Single)">
            <summary>
            Constrain each value within the specified min and max values (in place)
            </summary>
            <param name="min">The minimum allowed value</param>
            <param name="max">The maximum allowed value</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.GetRowSegment(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a segment from a row of the current matrix
            </summary>
            <param name="rowIndex">The row index</param>
            <param name="columnIndex">The start index to return</param>
            <param name="length">The number of elements to return</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.GetColumnSegment(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a segment from a column of the current matrix
            </summary>
            <param name="columnIndex">The column index</param>
            <param name="rowIndex">The start index to return</param>
            <param name="length">The number of elements to return</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ConcatColumns(BrightData.IFloatMatrix)">
            <summary>
            Returns a new matrix with the columns of the target matrix appended to each column of the current matrix
            </summary>
            <param name="bottom">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ConcatRows(BrightData.IFloatMatrix)">
            <summary>
            Returns a new matrix with the rows of the target matrix appended to each row of the current matrix
            </summary>
            <param name="right">The target matrix</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.SplitAtColumn(System.UInt32)">
            <summary>
            Splits the rows of the current matrix into two matrices
            </summary>
            <param name="columnIndex">The column index at which to split</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.SplitAtRow(System.UInt32)">
            <summary>
            Splits the columns of the current matrix into two matrices
            </summary>
            <param name="rowIndex">The row index at which to split</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.Svd">
            <summary>
            Singular value decomposition
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.ReshapeAsVector">
            <summary>
            Fast conversion to vector (the internal buffer is not modified)
            </summary>
        </member>
        <member name="M:BrightData.IFloatMatrix.ReshapeAs3DTensor(System.UInt32,System.UInt32)">
            <summary>
            Reshapes the matrix to a 3D tensor, treating each column as a depth slice in the new 3D tensor
            </summary>
            <param name="rows">Row count of each sub matrix</param>
            <param name="columns">Column count of each sub matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatMatrix.ReshapeAs4DTensor(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Converts the matrix to a 4D tensor, treating each column as a 3D tensor
            </summary>
            <param name="rows">Row count of each sub matrix</param>
            <param name="columns">Column count of each sub matrix</param>
            <param name="depth">Depth of each 3D tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatMatrix.GetAt(System.UInt32,System.UInt32)">
            <summary>
            Returns the value at the specified row and column index
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatMatrix.SetAt(System.UInt32,System.UInt32,System.Single)">
            <summary>
            Updates the value at the specified row and column index
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:BrightData.IFloatMatrix.ColumnVectors">
            <summary>
            Returns the columns of the matrix as vectors
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.IFloatMatrix.RowVectors">
            <summary>
            Returns the rows of the matrix as vectors
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.IIndexableFloatMatrix">
            <summary>
            A matrix whose elements can be indexed directly
            </summary>
        </member>
        <member name="P:BrightData.IIndexableFloatMatrix.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns an element from the current matrix
            </summary>
            <param name="row">Row index</param>
            <param name="column">Column index</param>
        </member>
        <member name="P:BrightData.IIndexableFloatMatrix.Rows">
            <summary>
            Returns the rows of the current matrix as vectors
            </summary>
        </member>
        <member name="P:BrightData.IIndexableFloatMatrix.Columns">
            <summary>
            Returns the columns of the current matrix as vectors
            </summary>
        </member>
        <member name="P:BrightData.IIndexableFloatMatrix.Values">
            <summary>
            Returns each element in the current matrix as enumerable
            </summary>
        </member>
        <member name="M:BrightData.IIndexableFloatMatrix.Map(System.Func{System.Single,System.Single})">
            <summary>
            Mutates each element of the current matrix
            </summary>
            <param name="mutator">The function to apply to each element</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.IIndexableFloatMatrix.MapIndexed(System.Func{System.UInt32,System.UInt32,System.Single,System.Single})">
            <summary>
            Mutates each element of the current matrix
            </summary>
            <param name="mutator">The function to apply to each element (rowIndex: uint, columnIndex: uint, value: float) => float</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.IIndexableFloatMatrix.AsXml">
            <summary>
            Returns the matrix as xml
            </summary>
        </member>
        <member name="M:BrightData.IIndexableFloatMatrix.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the matrix as well)
            </summary>
        </member>
        <member name="T:BrightData.I3DFloatTensor">
            <summary>
            A list of matrices
            </summary>
        </member>
        <member name="P:BrightData.I3DFloatTensor.RowCount">
            <summary>
            The number of rows in each matrix
            </summary>
        </member>
        <member name="P:BrightData.I3DFloatTensor.ColumnCount">
            <summary>
            The number of columns in each matrix
            </summary>
        </member>
        <member name="P:BrightData.I3DFloatTensor.Depth">
            <summary>
            The number of matrices
            </summary>
        </member>
        <member name="P:BrightData.I3DFloatTensor.Data">
            <summary>
            Converts the current tensor
            </summary>
        </member>
        <member name="M:BrightData.I3DFloatTensor.GetMatrixAt(System.UInt32)">
            <summary>
            Returns a matrix at the specified depth
            </summary>
            <param name="depth">The depth to query</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.AsIndexable">
            <summary>
            Returns an indexable 3D tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.AddPadding(System.UInt32)">
            <summary>
            Adds padding to each matrix
            </summary>
            <param name="padding">The padding (both vertical and horizontal)</param>
            <returns>A new tensor</returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.RemovePadding(System.UInt32)">
            <summary>
            Removes padding from each matrix
            </summary>
            <param name="padding">The padding to remove</param>
            <returns>A new tensor</returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Performs a convolution on each source matrix
            </summary>
            <param name="filterWidth">The filter width</param>
            <param name="filterHeight">The filter height</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.ReshapeAsVector">
            <summary>
            Converts the tensor to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.ReshapeAsMatrix">
            <summary>
            Converts the tensor to a matrix (each depth slice becomes a column in the new matrix)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.ReshapeAs4DTensor(System.UInt32,System.UInt32)">
            <summary>
            Reshapes the 3D tensor into a 4D tensor (the current depth becomes the count of 3D tensors and columns becomes the new depth)
            </summary>
            <param name="rows">Rows in each 4D tensor</param>
            <param name="columns">Columns in each 4D tensor</param>
        </member>
        <member name="M:BrightData.I3DFloatTensor.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Performs a max pooling operation on the tensor
            </summary>
            <param name="filterWidth">The pooling filter width</param>
            <param name="filterHeight">The pooling filter height</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <param name="saveIndices">True to save the indices for a future reverse max pool operation</param>
            <returns>A max pooled tensor</returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.ReverseMaxPool(BrightData.I3DFloatTensor,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a max pooling operation
            </summary>
            <param name="outputRows">Input rows</param>
            <param name="outputColumns">Input columns</param>
            <param name="indices">A tensor that contains the indices of each maximum value that was found per filter</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
        </member>
        <member name="M:BrightData.I3DFloatTensor.ReverseIm2Col(BrightData.IFloatMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a im2col operation
            </summary>
            <param name="filter">The rotated filters</param>
            <param name="outputRows">Rows of the input tensor</param>
            <param name="outputColumns">Columns of the input tensor</param>
            <param name="outputDepth">Depth of the input tensor</param>
            <param name="filterHeight">Height of each filter</param>
            <param name="filterWidth">Width of each filter</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.CombineDepthSlices">
            <summary>
            Adds each depth slice into a single matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.AddInPlace(BrightData.I3DFloatTensor)">
            <summary>
            Adds the other tensor to the current tensor
            </summary>
            <param name="tensor">Tensor to add</param>
        </member>
        <member name="M:BrightData.I3DFloatTensor.Multiply(BrightData.IFloatMatrix)">
            <summary>
            Multiplies the tensor with the other matrix
            </summary>
            <param name="matrix">Matrix to multiply with</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I3DFloatTensor.AddToEachRow(BrightData.IFloatVector)">
            <summary>
            Adds the vector to each row of the tensor
            </summary>
            <param name="vector">Vector to add to each row</param>
        </member>
        <member name="M:BrightData.I3DFloatTensor.TransposeThisAndMultiply(BrightData.I4DFloatTensor)">
            <summary>
            Transpose each sub matrix in the current tensor before multiplying it with each each sub tensor (converted to a matrix)
            </summary>
            <param name="tensor">Tensor to multiply with</param>
        </member>
        <member name="T:BrightData.IIndexable3DFloatTensor">
            <summary>
            A 3D tensor that can be directly indexed
            </summary>
        </member>
        <member name="P:BrightData.IIndexable3DFloatTensor.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="row">The row to query</param>
            <param name="column">The column to query</param>
            <param name="depth">The depth to query</param>
        </member>
        <member name="P:BrightData.IIndexable3DFloatTensor.Matrix">
            <summary>
            Gets a list of the indexable matrices
            </summary>
        </member>
        <member name="P:BrightData.IIndexable3DFloatTensor.AsXml">
            <summary>
            Returns the matrix as xml
            </summary>
        </member>
        <member name="M:BrightData.IIndexable3DFloatTensor.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the tensor as well)
            </summary>
        </member>
        <member name="T:BrightData.I4DFloatTensor">
            <summary>
            A list of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.I4DFloatTensor.RowCount">
            <summary>
            The number of rows in each 3D tensor
            </summary>
        </member>
        <member name="P:BrightData.I4DFloatTensor.ColumnCount">
            <summary>
            The number of columns in each 3D tensor
            </summary>
        </member>
        <member name="P:BrightData.I4DFloatTensor.Depth">
            <summary>
            The depth of each 3D tensor
            </summary>
        </member>
        <member name="P:BrightData.I4DFloatTensor.Count">
            <summary>
            The count of 3D tensors
            </summary>
        </member>
        <member name="M:BrightData.I4DFloatTensor.GetTensorAt(System.UInt32)">
            <summary>
            Returns the tensor at the specified index
            </summary>
            <param name="index">The index to query</param>
        </member>
        <member name="M:BrightData.I4DFloatTensor.AsIndexable">
            <summary>
            Returns an indexable list of 3D tensors
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.AddPadding(System.UInt32)">
            <summary>
            Adds padding to the 4D tensor
            </summary>
            <param name="padding">Padding to add to the left, top, right and bottom edges of the tensor</param>
            <returns>A new tensor with the padding added</returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.RemovePadding(System.UInt32)">
            <summary>
            Removes padding from the 4D tensor
            </summary>
            <param name="padding">Padding to remove from the left, top, right and bottom edges of the tensor</param>
            <returns>A new tensor with the padding removed</returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.MaxPool(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Applies a max pooling operation to the current tensor
            </summary>
            <param name="filterWidth">Max pool filter width</param>
            <param name="filterHeight">Max pool filter height</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <param name="saveIndices">True to save the indices for a future reverse pool operation</param>
        </member>
        <member name="M:BrightData.I4DFloatTensor.ReverseMaxPool(BrightData.I4DFloatTensor,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverses a max pool operation
            </summary>
            <param name="outputRows">Input tensor rows</param>
            <param name="outputColumns">Input tensor columns</param>
            <param name="indices">Tensor of indices from MaxPool operation</param>
            <param name="filterWidth">Max pool filter width</param>
            <param name="filterHeight">Max pool filter height</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.Im2Col(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Applies the convolutional filter to each 3D tensor, producing a 3D tensor which can be multipled by the filter matrix
            </summary>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.ReverseIm2Col(BrightData.IFloatMatrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reverse a previously applied im2Col
            </summary>
            <param name="filter">List of filters that have been rotated 180 degrees</param>
            <param name="outputRows">Rows of the input 4D tensor</param>
            <param name="outputColumns">Columns of the input 4D tensor</param>
            <param name="outputDepth">Depth of the input 4D tensor</param>
            <param name="filterWidth">Filter width</param>
            <param name="filterHeight">Filter height</param>
            <param name="xStride">Filter x stride</param>
            <param name="yStride">Filter y stride</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.ColumnSums">
            <summary>
            Sums the columns of each sub-tensor's sub matrix
            </summary>
        </member>
        <member name="M:BrightData.I4DFloatTensor.ReshapeAsVector">
            <summary>
            Converts the tensor to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.I4DFloatTensor.ReshapeAsMatrix">
            <summary>
            Converts the tensor to a matrix (each 3D tensor becomes a column in the new matrix)
            </summary>
            <returns></returns>
        </member>
        <member name="P:BrightData.I4DFloatTensor.Data">
            <summary>
            Converts the current tensor
            </summary>
        </member>
        <member name="T:BrightData.IIndexable4DFloatTensor">
            <summary>
            A 4D tensor that can be directly indexed
            </summary>
        </member>
        <member name="P:BrightData.IIndexable4DFloatTensor.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns a value from the tensor
            </summary>
            <param name="row">The row to query</param>
            <param name="column">The column to query</param>
            <param name="depth">The depth to query</param>
            <param name="index">The tensor index to query</param>
        </member>
        <member name="P:BrightData.IIndexable4DFloatTensor.Tensors">
            <summary>
            Gets a list of the indexable matrices
            </summary>
        </member>
        <member name="P:BrightData.IIndexable4DFloatTensor.AsXml">
            <summary>
            Returns the matrix as xml
            </summary>
        </member>
        <member name="M:BrightData.IIndexable4DFloatTensor.GetInternalArray">
            <summary>
            Returns the underlying array used as storage (changes to this array will affect the tensor as well)
            </summary>
        </member>
        <member name="T:BrightData.LinearAlgebra.Matrix`1">
            <summary>
            Matrix type
            </summary>
            <typeparam name="T">Data type within the matrix</typeparam>
        </member>
        <member name="P:BrightData.LinearAlgebra.Matrix`1.RowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Matrix`1.ColumnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.Row(System.UInt32)">
            <summary>
            Returns a row as a vector
            </summary>
            <param name="index">Row index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.Column(System.UInt32)">
            <summary>
            Returns a column as a vector
            </summary>
            <param name="index">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.Matrix`1.Rows">
            <summary>
            All rows
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Matrix`1.Columns">
            <summary>
            All columns
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.Matrix`1.Item(System.UInt32,System.UInt32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="rowY">Row index</param>
            <param name="columnX">Column index</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.ToColumnMajor">
            <summary>
            Converts to a column major array format (default is row major)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.Transpose">
            <summary>
            Transpose the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.Multiply(BrightData.LinearAlgebra.Matrix{`0})">
            <summary>
            Multiply the matrix with another matrix
            </summary>
            <param name="other">Other matrix to multiply</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.GetDiagonal">
            <summary>
            Returns the diagonal of the matrix as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.RowSums">
            <summary>
            Returns the sum of each row as a vector
            </summary>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.ColumnSums">
            <summary>
            Returns the sum of each column as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.Multiply(BrightData.LinearAlgebra.Vector{`0})">
            <summary>
            Multiplies the matrix with a vector
            </summary>
            <param name="vector">Vector to multiply</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Matrix`1.Create(BrightData.ITensorSegment{`0})">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.Tensor3D`1">
            <summary>
            3D tensor type
            </summary>
            <typeparam name="T">Data type within the tensor</typeparam>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.Depth">
            <summary>
            Number of matrices
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.RowCount">
            <summary>
            Number of rows within each matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.ColumnCount">
            <summary>
            Number of columns within each matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.MatrixSize">
            <summary>
            Size of each matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="depth">Index of the matrix</param>
            <param name="rowY">Row within the matrix</param>
            <param name="columnX">Column within the matrix</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.Item(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="depth">Index of the matrix</param>
            <param name="rowY">Row within the matrix</param>
            <param name="columnX">Column within the matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor3D`1.Matrix(System.UInt32)">
            <summary>
            Returns a matrix at the specified index
            </summary>
            <param name="index">Matrix index</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor3D`1.Matrices">
            <summary>
            All matrices
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor3D`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor3D`1.Create(BrightData.ITensorSegment{`0})">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor3D`1.GetAsRaw">
            <summary>
            Converts the segment to a column major vector (default is row major)
            </summary>
        </member>
        <member name="T:BrightData.LinearAlgebra.Tensor4D`1">
            <summary>
            4D tensor type
            </summary>
            <typeparam name="T">Data type within the tensor</typeparam>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.Count">
            <summary>
            Number of 3D tensors
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.Depth">
            <summary>
            Number of matrices within each 3D tensor
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.RowCount">
            <summary>
            Number of rows within each matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.ColumnCount">
            <summary>
            Number of columns within each matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.MatrixSize">
            <summary>
            Size of each matrix
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.TensorSize">
            <summary>
            Size of each 3D tensor
            </summary>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix depth within the 3D tensor</param>
            <param name="rowY">Row within the matrix</param>
            <param name="columnX">Column within the matrix</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.Item(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="count">3D tensor index</param>
            <param name="depth">Matrix depth within the 3D tensor</param>
            <param name="rowY">Row within the matrix</param>
            <param name="columnX">Column within the matrix</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor4D`1.Tensor(System.UInt32)">
            <summary>
            Returns a nested 3D tensor
            </summary>
            <param name="index">Tensor index</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.Tensor4D`1.Tensors">
            <summary>
            All 3D tensors
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor4D`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Tensor4D`1.Create(BrightData.ITensorSegment{`0})">
            <inheritdoc />
        </member>
        <member name="T:BrightData.LinearAlgebra.TensorBase`2">
            <summary>
            Base class for tensors
            </summary>
            <typeparam name="T">Data type within the tensor</typeparam>
            <typeparam name="DT">Underlying type (vector, matrix etc)</typeparam>
        </member>
        <member name="F:BrightData.LinearAlgebra.TensorBase`2._segment">
            <summary>
            Data segment
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.#ctor(BrightData.ITensorSegment{`0},System.UInt32[])">
            <summary>
            Constructor
            </summary>
            <param name="segment">Data segment</param>
            <param name="shape">Shape of tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.#ctor(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <summary>
            Initialize from binary reader
            </summary>
            <param name="context">Bright data context</param>
            <param name="reader">Reader to initialize from</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Initialize(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Dispose">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Create(BrightData.ITensorSegment{`0})">
            <summary>
            Creates a derived type
            </summary>
            <param name="segment">Data segment</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorBase`2.Computation">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.GetDataCopy">
            <inheritdoc />
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorBase`2.Context">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.ToArray">
            <summary>
            Converts the data to an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Add(`1)">
            <summary>
            Adds this to another tensor (new tensor returned - this tensor is not changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <returns>New tensor</returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Add(`1,`0,`0)">
            <summary>
            Adds this to another tensor (new tensor returned - this tensor is not changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
            <returns>New tensor</returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Add(`0)">
            <summary>
            Adds a scalar to this tensor (new tensor returned - this tensor is not changed)
            </summary>
            <param name="scalar">Value to add to each element</param>
            <returns>New tensor</returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.AddInPlace(`1)">
            <summary>
            Adds another tensor to this in place (this tensor is changed)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.AddInPlace(`1,`0,`0)">
            <summary>
            Adds another tensor to this in place (this tensor is changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.AddInPlace(`0)">
            <summary>
            Adds a scalar to this in place (this tensor is changed)
            </summary>
            <param name="scalar">Value to add to each element</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Subtract(`1)">
            <summary>
            Subtracts another tensor from this (new tensor returned - this tensor is not changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Subtract(`1,`0,`0)">
            <summary>
            Subtracts another tensor from this (new tensor returned - this tensor is not changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.SubtractInPlace(`1)">
            <summary>
            Subtracts another tensor from this in place (this tensor is changed)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.SubtractInPlace(`1,`0,`0)">
            <summary>
            Subtracts another tensor from this in place (this tensor is changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <param name="coefficient1">Value to multiply each element of this tensor</param>
            <param name="coefficient2">Value to multiply each element of the other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.PointwiseMultiply(`1)">
            <summary>
            Multiplies each element with the corresponding element from the other tensor (new tensor returned - this tensor is not changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.PointwiseMultiplyInPlace(`1)">
            <summary>
            Multiplies each element with the corresponding element from the other tensor (this tensor is changed)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Multiply(`0)">
            <summary>
            Multiplies each element with a value  (new tensor returned - this tensor is not changed)
            </summary>
            <param name="scalar">Value to multiply</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.MultiplyInPlace(`0)">
            <summary>
            Multiplies each element with a value (this tensor is changed)
            </summary>
            <param name="scalar">Value to multiply</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.PointwiseDivide(`1)">
            <summary>
            Divides each element with the corresponding element from the other tensor (new tensor returned - this tensor is not changed)
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.PointwiseDivideInPlace(`1)">
            <summary>
            Divides each element with the corresponding element from the other tensor (this tensor is changed)
            </summary>
            <param name="tensor">Other tensor</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Log">
            <summary>
            Creates a new tensor with each value set to the log of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Abs">
            <summary>
            Creates a new tensor with each value set to the absolute value of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Sqrt">
            <summary>
            Creates a new tensor with each value set to the square root of value of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Squared">
            <summary>
            Creates a new tensor with each value set to the squared value of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Pow(`0)">
            <summary>
            Creates a new tensor with each value set to pow(n) of element in this tensor
            </summary>
            <param name="power">Power</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.DotProduct(`1)">
            <summary>
            Computes the dot product of this tensor and another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Sum">
            <summary>
            Sums all elements of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Search(`0)">
            <summary>
            Finds the index of an element of this tensor
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.ConstrainInPlace(System.Nullable{`0},System.Nullable{`0})">
            <summary>
            Mutates this tensor so that any value outside the range will be modified to fit within
            </summary>
            <param name="minValue">Minimum allowed value</param>
            <param name="maxValue">Maximum allowed value</param>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Average">
            <summary>
            Finds the average of all elements within this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.L1Norm">
            <summary>
            Computes the L1 norm of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.L2Norm">
            <summary>
            Computes the L2 norm of this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.CosineDistance(`1)">
            <summary>
            Calculates the cosine distance between this and another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.EuclideanDistance(`1)">
            <summary>
            Computes the euclidean distance between this and another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.ManhattanDistance(`1)">
            <summary>
            Computes the manhattan distance between this and another tensor
            </summary>
            <param name="tensor">Other tensor</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Mean">
            <summary>
            Computes the average of the elements in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.StdDev(System.Nullable{`0})">
            <summary>
            Computes the standard deviation of the elements in this tensor
            </summary>
            <param name="mean"></param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Softmax">
            <summary>
            Computes the softmax
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.SoftmaxDerivative">
            <summary>
            Computes the softmax derivative
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Sigmoid">
            <summary>
            Computes the sigmoid function of each element
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.SigmoidDerivative">
            <summary>
            Computes the sigmoid derivative of each element
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Tanh">
            <summary>
            Computes tanh of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.TanhDerivative">
            <summary>
            Computes tanh derivative of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Relu">
            <summary>
            Computes the relu of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.ReluDerivative">
            <summary>
            Computes the relu derivative of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.LeakyRelu">
            <summary>
            Computes the leaky relu of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.LeakyReluDerivative">
            <summary>
            Computes the leaky relu derivative of each element in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.GetMinAndMaxValues">
            <summary>
            Finds the min and max values and indices from this tensnor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.IsEntirelyFinite">
            <summary>
            Checks if each element is entirely finite (not infinity, NaN etc)
            </summary>
            <returns>True if all elements are finite</returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Reverse">
            <summary>
            Reverse the order of the elements in this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Split(System.UInt32)">
            <summary>
            Splits this tensor into segments
            </summary>
            <param name="blockCount">Number of blocks to split into</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.TensorBase`2.Segment">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Clone">
            <summary>
            Clones this tensor
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Reshape">
            <summary>
            Reshapes to a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a matrix
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 3D tensor
            </summary>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.Reshape(System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32},System.Nullable{System.UInt32})">
            <summary>
            Reshapes to a 4D tensor
            </summary>
            <param name="count">Number of 3D tensors</param>
            <param name="depth">Number of matrices</param>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.MaximumIndex">
            <summary>
            Returns the index with the highest value
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.TensorBase`2.MinimumIndex">
            <summary>
            Returns the index with the lowest value
            </summary>
            <returns></returns>
        </member>
        <member name="T:BrightData.LinearAlgebra.Vector`1">
            <summary>
            Generic vector
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:BrightData.LinearAlgebra.Vector`1.Size">
            <summary>
            Number of elements in the vector
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Vector`1.Create(BrightData.ITensorSegment{`0})">
            <summary>
            Creates a vector from a tensor segment
            </summary>
            <param name="segment">Tensor segment that will be used</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.Vector`1.Item(System.Int32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="index">Index to retrieve</param>
            <returns></returns>
        </member>
        <member name="P:BrightData.LinearAlgebra.Vector`1.Item(System.UInt32)">
            <summary>
            Returns the value at the specified index
            </summary>
            <param name="index">Index to retrieve</param>
        </member>
        <member name="P:BrightData.LinearAlgebra.Vector`1.Values">
            <summary>
            The values in the vector
            </summary>
        </member>
        <member name="M:BrightData.LinearAlgebra.Vector`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.LinearAlgebra.Vector`1.CopyFrom(`0[])">
            <summary>
            Copies from an array into this vector
            </summary>
            <param name="array">Array to copy from</param>
        </member>
        <member name="T:BrightData.Memory.DisposableLayers">
            <summary>
            Collects allocations within a "layer" that can all be released at once
            </summary>
        </member>
        <member name="T:BrightData.Memory.MemoryLayer">
            <summary>
            A section of memory blocks that will be released when the layer is disposed
            </summary>
        </member>
        <member name="T:BrightData.Memory.ReferenceCountedBlock`1">
            <summary>
            Reference counted memory block
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Memory.TensorPool">
            <summary>
            Tensor memory pool
            </summary>
        </member>
        <member name="T:BrightData.Memory.TensorSegment`1">
            <summary>
            "Pointer" to a tensor block that manages reference counting
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.Memory.TensorSegmentWrapper`1">
            <summary>
            Tensor segment that uses offsets and strides to form a translated segment from a wrapped tensor segment
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:BrightData.MetaData">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.#ctor(BrightData.IMetaData,System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="metaData">Existing meta data to copy from</param>
            <param name="keys">Keys to copy (or all if none specified)</param>
        </member>
        <member name="M:BrightData.MetaData.#ctor(BrightData.IHaveMetaData,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.#ctor(System.IO.BinaryReader)">
            <summary>
            Creates meta data from a binary reader
            </summary>
            <param name="reader">Reader</param>
        </member>
        <member name="M:BrightData.MetaData.CopyTo(BrightData.IMetaData)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.CopyTo(BrightData.IMetaData,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.CopyAllExcept(BrightData.IMetaData,System.String[])">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Get(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.GetNullable``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Get``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Get``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Set``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="P:BrightData.MetaData.AsXml">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.WriteTo(System.IO.BinaryWriter)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.ReadFrom(System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.GetStringsWithPrefix(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Has(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.MetaData.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Serialisation.SerialisationHelper">
            <summary>
            Serialisation helpers
            </summary>
        </member>
        <member name="M:BrightData.Serialisation.SerialisationHelper.WriteTo(System.String,System.IO.BinaryWriter)">
            <summary>
            Writes a string
            </summary>
            <param name="str"></param>
            <param name="writer"></param>
        </member>
        <member name="T:BrightData.Transformation.ColumnConversion">
            <summary>
            Parameters that define a column conversion from one type to another
            </summary>
        </member>
        <member name="P:BrightData.Transformation.ColumnConversion.ColumnIndex">
            <inheritdoc />
        </member>
        <member name="M:BrightData.Transformation.ColumnConversion.GetTransformer(BrightData.ColumnType,BrightData.ISingleTypeTableSegment,System.Func{BrightData.IMetaData},BrightData.IProvideTempStreams,System.UInt32)">
            <inheritdoc />
        </member>
        <member name="T:BrightData.Transformation.ColumnNormalization">
            <summary>
            Parameters that define how to normalize a column of a data table
            </summary>
        </member>
        <member name="T:BrightData.Transformation.NormalizeTransformation">
            <summary>
            Normalization parameters
            </summary>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.#ctor(BrightData.NormalizationType,BrightData.IMetaData)">
            <summary>
            Creates a new set of parameters based on supplied the numeric analysis
            </summary>
            <param name="type">Type of normalization</param>
            <param name="analysedMetaData">Numeric analysis</param>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.WriteTo(BrightData.IMetaData)">
            <summary>
            Writes the normalization parameters to a meta data store
            </summary>
            <param name="metaData"></param>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.NormalizationType">
            <summary>
            Type of normalization
            </summary>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.Divide">
            <summary>
            Value that will be divided (after subtraction)
            </summary>
        </member>
        <member name="P:BrightData.Transformation.NormalizeTransformation.Subtract">
            <summary>
            Value that will be subtracted
            </summary>
        </member>
        <member name="M:BrightData.Transformation.NormalizeTransformation.Normalize(System.Double)">
            <summary>
            Normalizes a value with the parameters
            </summary>
            <param name="val">Value to normalize</param>
            <returns>Normalized result</returns>
        </member>
        <member name="T:BrightData.Transformation.ReinterpretColumns">
            <summary>
            Parameters that define how to reinterpret the columns in a data table
            </summary>
        </member>
        <member name="T:BrightData.Transformation.TransformationContext`2">
            <summary>
            A transformation context reads values from a column and writes transformed values to a buffer
            </summary>
            <typeparam name="TF"></typeparam>
            <typeparam name="TT"></typeparam>
        </member>
        <member name="T:BrightData.WeightedIndexList">
            <summary>
            A list of weighted indices is a sparse vector
            </summary>
        </member>
        <member name="T:BrightData.WeightedIndexList.Item">
            <summary>
            An item within a weighted index list
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Item.Index">
            <summary>
            Index of item
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Item.Weight">
            <summary>
            Weight of item
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.#ctor(System.UInt32,System.Single)">
            <summary>
            Constructor
            </summary>
            <param name="index">Index of item</param>
            <param name="weight">Weight of item</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.Equals(BrightData.WeightedIndexList.Item)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Item.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:BrightData.WeightedIndexList.Context">
            <inheritdoc />
        </member>
        <member name="P:BrightData.WeightedIndexList.Indices">
            <summary>
            The list of indices
            </summary>
        </member>
        <member name="P:BrightData.WeightedIndexList.Count">
            <summary>
            The number of items in the list
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.ToString">
            <summary>
            ToString override
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.Initialize(BrightData.IBrightDataContext,System.IO.BinaryReader)">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Merge(System.Collections.Generic.IEnumerable{BrightData.WeightedIndexList},BrightData.AggregationType)">
            <summary>
            Merges a sequence of weighted index lists into one list
            </summary>
            <param name="lists">Lists to merge</param>
            <param name="mergeOperation">How to merge item weights</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.WriteTo(System.String,System.Xml.XmlWriter)">
            <summary>
            Writes the data to an XML writer
            </summary>
            <param name="name">The name to give the data</param>
            <param name="writer">The writer to write to</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.WriteTo(System.IO.BinaryWriter)">
            <summary>
            Writes the data to a binary writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:BrightData.WeightedIndexList.ToXml">
            <summary>
            Converts the weighted index list to XML
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsIndexList">
            <summary>
            Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)
            </summary>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.Dot(BrightData.WeightedIndexList)">
            <summary>
            Dot product of this combined with the other weighted index list
            </summary>
            <param name="other">Other weighted index list</param>
        </member>
        <member name="P:BrightData.WeightedIndexList.Magnitude">
            <summary>
            Magnitude of weights
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.CosineSimilarity(BrightData.WeightedIndexList)">
            <summary>
            Cosine similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.GetMaxWeight">
            <summary>
            Returns the index with the highest weight
            </summary>
        </member>
        <member name="M:BrightData.WeightedIndexList.JaccardSimilarity(BrightData.WeightedIndexList)">
            <summary>
            Computes the jaccard similarity between this and another weighted index list
            </summary>
            <param name="other">Other list to compare</param>
        </member>
        <member name="M:BrightData.WeightedIndexList.AsDense(System.Nullable{System.UInt32})">
            <summary>
            Converts to a vector
            </summary>
            <param name="maxIndex">Inclusive highest index to copy (optional)</param>
            <returns></returns>
        </member>
        <member name="M:BrightData.WeightedIndexList.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BrightData.WeightedIndexList.Equals(System.Object)">
            <inheritdoc />
        </member>
    </members>
</doc>
