<assembly>
<enum name="BrightData.BufferType">
	<summary>
		
	</summary>
	<value name="Unknown" value="0" summary="" />
	<value name="Struct" value="1" summary="" />
	<value name="String" value="2" summary="" />
	<value name="EncodedStruct" value="3" summary="" />
	<value name="EncodedString" value="4" summary="" />
	<value name="Object" value="5" summary="" />
</enum>
<enum name="BrightTable.ColumnClass">
	<summary>
		
	</summary>
	<value name="Unknown" value="0" summary="" />
	<value name="Categorical" value="1" summary="" />
	<value name="Numeric" value="2" summary="" />
	<value name="Decimal" value="4" summary="" />
	<value name="Structable" value="8" summary="" />
	<value name="Tensor" value="16" summary="" />
	<value name="IndexBased" value="32" summary="" />
	<value name="Continuous" value="64" summary="" />
	<value name="Integer" value="128" summary="" />
</enum>
<enum name="BrightTable.ColumnConversionType">
	<summary>
		
	</summary>
	<value name="Unchanged" value="0" summary="" />
	<value name="ToBoolean" value="1" summary="" />
	<value name="ToDate" value="2" summary="" />
	<value name="ToNumeric" value="3" summary="" />
	<value name="ToString" value="4" summary="" />
	<value name="ToIndexList" value="5" summary="" />
	<value name="ToWeightedIndexList" value="6" summary="" />
	<value name="ToVector" value="7" summary="" />
	<value name="ToCategoricalIndex" value="8" summary="" />
</enum>
<enum name="BrightTable.ColumnType">
	<summary>
		Segment table column type
	</summary>
	<value name="Unknown" value="0" summary="Nothing" />
	<value name="Boolean" value="1" summary="Boolean values" />
	<value name="Byte" value="2" summary="Byte values (-128 to 128)" />
	<value name="Short" value="3" summary="Short values" />
	<value name="Int" value="4" summary="Integer values" />
	<value name="Long" value="5" summary="Long values" />
	<value name="Float" value="6" summary="Float values" />
	<value name="Double" value="7" summary="Double values" />
	<value name="Decimal" value="8" summary="Decimal values" />
	<value name="String" value="9" summary="String values" />
	<value name="Date" value="10" summary="Date values" />
	<value name="IndexList" value="11" summary="List of indices" />
	<value name="WeightedIndexList" value="12" summary="Weighted list of indices" />
	<value name="Vector" value="13" summary="Vector of floats" />
	<value name="Matrix" value="14" summary="Matrix of floats" />
	<value name="Tensor3D" value="15" summary="3D tensor of floats" />
	<value name="Tensor4D" value="16" summary="4D tensor of floats" />
	<value name="BinaryData" value="17" summary="Binary data" />
</enum>
<enum name="BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
	<summary>
		The type of data within the column
	</summary>
	<value name="ContinuousGaussian" value="0" summary="Continuous values" />
	<value name="Categorical" value="1" summary="Categorical values" />
</enum>
<enum name="BrightTable.DataTableOrientation">
	<summary>
		
	</summary>
	<value name="Unknown" value="0" summary="" />
	<value name="RowOriented" value="1" summary="" />
	<value name="ColumnOriented" value="2" summary="" />
</enum>
<enum name="BrightData.DistanceMetric">
	<summary>
		Distance metrics
	</summary>
	<value name="Euclidean" value="0" summary="Euclidean Distance" />
	<value name="Cosine" value="1" summary="Cosine Distance Metric" />
	<value name="Manhattan" value="2" summary="Manhattan Distance" />
	<value name="MeanSquared" value="3" summary="Means Square Error" />
	<value name="SquaredEuclidean" value="4" summary="Square Euclidean" />
</enum>
<enum name="BrightWire.GaussianVarianceCalibration">
	<summary>
		Gaussian weight initialisation type
	</summary>
	<value name="SquareRootN" value="0" summary="Variances are calibrated by dividing by the square root of the connection count" />
	<value name="SquareRoot2N" value="1" summary="Variances are calibrated by multiplying by twice the square root of the connection count" />
</enum>
<enum name="BrightWire.GaussianVarianceCount">
	<summary>
		Gaussian variance count
	</summary>
	<value name="None" value="0" summary="No variance calibration is applied" />
	<value name="FanIn" value="1" summary="The count of incoming connections is used" />
	<value name="FanOut" value="2" summary="The count of outgoing connections is used" />
	<value name="FanInFanOut" value="3" summary="The count incoming and outgoing connections is used" />
</enum>
<enum name="BrightWire.MiniBatchSequenceType">
	<summary>
		Mini batch type
	</summary>
	<value name="Standard" value="0" summary="Standard batch type (non sequential batches have a single standard sequence item)" />
	<value name="SequenceStart" value="1" summary="Start of a sequence" />
	<value name="SequenceEnd" value="2" summary="End of a sequence" />
</enum>
<enum name="BrightData.NormalizationType">
	<summary>
		
	</summary>
	<value name="None" value="0" summary="" />
	<value name="Standard" value="1" summary="" />
	<value name="Euclidean" value="2" summary="" />
	<value name="Manhattan" value="3" summary="" />
	<value name="FeatureScale" value="4" summary="" />
</enum>
<enum name="BrightData.OperationType">
	<summary>
		
	</summary>
	<value name="Add" value="0" summary="" />
	<value name="Average" value="1" summary="" />
	<value name="Max" value="2" summary="" />
</enum>
<enum name="BrightWire.TrainingErrorCalculation">
	<summary>
		Describes how to calculate the training error
	</summary>
	<value name="None" value="0" summary="Do not calculate the training error" />
	<value name="Fast" value="1" summary="Compare the output against the target output and calculate the euclidean distance" />
	<value name="TrainingData" value="2" summary="Execute the model against the training data" />
</enum>

<interface name="BrightData.I3DFloatTensor" base="System.IDisposable">
	<summary>
		A list of matrices
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows in each matrix</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns in each matrix</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>The number of matrices</summary>
	</property>
	<property type="BrightData.Tensor3D&lt;System.Single&gt;" name="Data">
		<summary>Converts the current tensor to protobuf format</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrixAt">
		<summary>Returns a matrix at the specified depth</summary>
				<param type="System.UInt32" name="depth" summary="The depth to query" />
			</method>
	<method type="BrightData.IIndexable3DFloatTensor" name="AsIndexable">
		<summary>Returns an indexable 3D tensor</summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="AddPadding">
		<summary>Adds padding to each matrix</summary>
				<param type="System.UInt32" name="padding" summary="The padding (both vertical and horizontal)" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="RemovePadding">
		<summary>Removes padding from each matrix</summary>
				<param type="System.UInt32" name="padding" summary="The padding to remove" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Im2Col">
		<summary>Performs a convolution on each source matrix</summary>
				<param type="System.UInt32" name="filterWidth" summary="The filter width" />
				<param type="System.UInt32" name="filterHeight" summary="The filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Converts the tensor to a vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Converts the tensor to a matrix (each depth slice becomes a column in the new matrix)</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Reshapes the 3D tensor into a 4D tensor (the current depth becomes the count of 3D tensors and columns becomes the new depth)</summary>
				<param type="System.UInt32" name="rows" summary="Rows in each 4D tensor" />
				<param type="System.UInt32" name="columns" summary="Columns in each 4D tensor" />
			</method>
	<method type="(BrightData.I3DFloatTensor Result, BrightData.I3DFloatTensor Indices)" name="MaxPool">
		<summary>Performs a max pooling operation on the tensor</summary>
				<param type="System.UInt32" name="filterWidth" summary="The pooling filter width" />
				<param type="System.UInt32" name="filterHeight" summary="The pooling filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="saveIndices" summary="True to save the indices for a future reverse max pool operation" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseMaxPool">
		<summary>Reverses a max pooling operation</summary>
				<param type="BrightData.I3DFloatTensor" name="indices" summary="A tensor that contains the indices of each maximum value that was found per filter" />
				<param type="System.UInt32" name="outputRows" summary="Input rows" />
				<param type="System.UInt32" name="outputColumns" summary="Input columns" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseIm2Col">
		<summary>Reverses a im2col operation</summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="The rotated filters" />
				<param type="System.UInt32" name="outputRows" summary="Rows of the input tensor" />
				<param type="System.UInt32" name="outputColumns" summary="Columns of the input tensor" />
				<param type="System.UInt32" name="outputDepth" summary="Depth of the input tensor" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CombineDepthSlices">
		<summary>Adds each depth slice into a single matrix</summary>
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the other tensor to the current tensor</summary>
				<param type="BrightData.I3DFloatTensor" name="tensor" summary="Tensor to add" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Multiply">
		<summary>Multiplies the tensor with the other matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="Matrix to multiply with" />
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the vector to each row of the tensor</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="Vector to add to each row" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="TransposeThisAndMultiply">
		<summary>Transpose each sub matrix in the current tensor before multiplying it with each each sub tensor (converted to a matrix)</summary>
				<param type="BrightData.I4DFloatTensor" name="tensor" summary="Tensor to multiply with" />
			</method>
</interface>
<interface name="BrightData.I4DFloatTensor" base="System.IDisposable">
	<summary>
		A list of 3D tensors
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows in each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns in each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>The depth of each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>The count of 3D tensors</summary>
	</property>
	<method type="BrightData.I3DFloatTensor" name="GetTensorAt">
		<summary>Returns the tensor at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The index to query" />
			</method>
	<method type="BrightData.IIndexable4DFloatTensor" name="AsIndexable">
		<summary>Returns an indexable list of 3D tensors</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="AddPadding">
		<summary>Adds padding to the 4D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Padding to add to the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="RemovePadding">
		<summary>Removes padding from the 4D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Padding to remove from the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="(BrightData.I4DFloatTensor Result, BrightData.I4DFloatTensor Indices)" name="MaxPool">
		<summary>Applies a max pooling operation to the current tensor</summary>
				<param type="System.UInt32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="saveIndices" summary="True to save the indices for a future reverse pool operation" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReverseMaxPool">
		<summary>Reverses a max pool operation</summary>
				<param type="BrightData.I4DFloatTensor" name="indices" summary="Tensor of indices from MaxPool operation" />
				<param type="System.UInt32" name="outputRows" summary="Input tensor rows" />
				<param type="System.UInt32" name="outputColumns" summary="Input tensor columns" />
				<param type="System.UInt32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Im2Col">
		<summary>Applies the convolutional filter to each 3D tensor, producing a 3D tensor which can be multipled by the filter matrix</summary>
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReverseIm2Col">
		<summary>Reverse a previously applied im2Col</summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="List of filters that have been rotated 180 degrees" />
				<param type="System.UInt32" name="outputRows" summary="Rows of the input 4D tensor" />
				<param type="System.UInt32" name="outputColumns" summary="Columns of the input 4D tensor" />
				<param type="System.UInt32" name="outputDepth" summary="Depth of the input 4D tensor" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums">
		<summary>Sums the columns of each sub-tensor's sub matrix</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Converts the tensor to a vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Converts the tensor to a matrix (each 3D tensor becomes a column in the new matrix)</summary>
			</method>
	<property type="BrightData.Tensor3D&lt;System.Single&gt;[]" name="Data">
		<summary>Converts the current tensor to protobuf format</summary>
	</property>
</interface>
<interface name="BrightWire.IAction" base="">
	<summary>
		An action to perform when a signal reaches a node
	</summary>
		<method type="BrightWire.IGraphData" name="Execute">
		<summary>Executes the action</summary>
				<param type="BrightWire.IGraphData" name="input" summary="Current graph signal" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
			</method>
	<method type="System.String" name="Serialise">
		<summary>Serialises the action to a string</summary>
			</method>
	<method type="System.Void" name="Initialise">
		<summary>Initialises the action</summary>
				<param type="System.String" name="data" summary="Previously serialised data" />
			</method>
</interface>
<interface name="BrightWire.IAdaptiveDataSource" base="">
	<summary>
		Adaptive data sources apply the output from a preliminary graph
	</summary>
		<property type="BrightWire.INode" name="AdaptiveInput">
		<summary>The input node of the preliminary graph</summary>
	</property>
	<method type="BrightWire.Models.DataSourceModel" name="GetModel">
		<summary>Gets the serialised preliminary graph</summary>
				<param type="System.String" name="name" summary="Optional name to give the data source" />
			</method>
</interface>
<interface name="BrightWire.IBackpropagation" base="System.IDisposable">
	<summary>
		Backpropagation handler
	</summary>
		<method type="System.Void" name="Backward">
		<summary>Backpropagate</summary>
				<param type="BrightWire.INode" name="fromNode" summary="Node that sent the signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="The current node's parents" />
			</method>
</interface>
<interface name="BrightData.IBrightDataContext" base="System.IDisposable">
	<summary>
		
	</summary>
		<property type="System.Random" name="Random">
		<summary></summary>
	</property>
	<property type="BrightData.ITensorPool" name="TensorPool">
		<summary></summary>
	</property>
	<property type="BrightData.IDisposableLayers" name="MemoryLayer">
		<summary></summary>
	</property>
	<property type="BrightData.IDataReader" name="DataReader">
		<summary></summary>
	</property>
	<method type="BrightData.INumericComputation&lt;T&gt;" name="GetComputation">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="BrightData.IProvideTempStreams" name="TempStreamProvider">
		<summary></summary>
	</property>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Set">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="T" name="Set">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="System.Func&lt;T&gt;" name="valueCreator" summary="" />
			</method>
</interface>
<interface name="BrightData.ICanConvert" base="">
	<summary>
		
	</summary>
		<property type="System.Type" name="From">
		<summary></summary>
	</property>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ICanConvert&lt;TF, TT&gt;" base="BrightData.ICanConvert">
	<summary>
		
	</summary>
		<method type="TT" name="Convert">
		<summary></summary>
				<param type="TF" name="data" summary="" />
			</method>
</interface>
<interface name="BrightData.ICanEnumerate&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.ICanInitialiseNode" base="">
	<summary>
		Interface that allows the node to be initialised
	</summary>
		<method type="System.Void" name="Initialise">
		<summary>Initialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Node unique id" />
				<param type="System.String" name="name" summary="Friendly name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
</interface>
<interface name="BrightData.ICanInitializeFromBinaryReader" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialise" base="">
	<summary>
		Serialisation interface for graph components
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes the node state to the binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads the node state</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader that holds the node's state" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialiseToStream" base="">
	<summary>
		Standard serialisation interface
	</summary>
		<method type="System.Void" name="SerialiseTo">
		<summary>Writes the current object state to the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to write to" />
			</method>
	<method type="System.Void" name="DeserialiseFrom">
		<summary>Reads the current object state from the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="System.Boolean" name="clear" summary="True to clear the existing state" />
			</method>
</interface>
<interface name="BrightData.ICanWriteToBinaryWriter" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</interface>
<interface name="BrightTable.IColumnInfo" base="BrightData.IHaveMetaData">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="Index">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType" name="ColumnType">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IColumnOrientedDataTable" base="BrightTable.IDataTable">
	<summary>
		
	</summary>
		<method type="BrightTable.IRowOrientedDataTable" name="AsRowOriented">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Convert">
		<summary></summary>
				<param type="BrightTable.Transformations.ColumnConversion[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Convert">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.Transformations.ColumnConversion[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Normalize">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Normalize">
		<summary></summary>
				<param type="BrightTable.Transformations.ColumnNormalization[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Normalize">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.Transformations.ColumnNormalization[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="SelectColumns">
		<summary></summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="SelectColumns">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ConcatColumns">
		<summary></summary>
				<param type="BrightTable.IColumnOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ConcatColumns">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.IColumnOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="FilterRows">
		<summary></summary>
				<param type="System.Predicate&lt;System.Object[]&gt;" name="predicate" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ReinterpretColumns">
		<summary></summary>
				<param type="BrightTable.Transformations.ReinterpretColumns[]" name="columns" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ReinterpretColumns">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.Transformations.ReinterpretColumns[]" name="columns" summary="" />
			</method>
</interface>
<interface name="BrightTable.IColumnTransformation" base="">
	<summary>
		
	</summary>
		<method type="System.UInt32" name="Transform">
		<summary></summary>
			</method>
	<property type="BrightData.IHybridBuffer" name="Buffer">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IColumnTransformationParam" base="">
	<summary>
		
	</summary>
		<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary></summary>
	</property>
	<method type="BrightData.ICanConvert" name="GetConverter">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="fromType" summary="" />
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
			</method>
</interface>
<interface name="BrightData.IContinuousDistribution" base="BrightData.IDistribution&lt;System.Single&gt;">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightTable.IConvert&lt;TF, TT&gt;" base="BrightData.ICanConvert">
	<summary>
		
	</summary>
		<method type="System.Boolean" name="Convert">
		<summary></summary>
				<param type="TF" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;TT&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Void" name="Finalise">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
</interface>
<interface name="BrightTable.IConvertibleRow" base="BrightTable.IHaveDataTable">
	<summary>
		
	</summary>
		<method type="System.Object" name="Get">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<property type="BrightTable.IDataTableSegment" name="Segment">
		<summary></summary>
	</property>
	<method type="T" name="GetTyped">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<property type="System.UInt32" name="RowIndex">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="NumColumns">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IConvertibleTable" base="">
	<summary>
		
	</summary>
		<method type="BrightTable.IConvertibleRow" name="Row">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.IConvertibleRow&gt;" name="Rows">
		<summary></summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<property type="BrightTable.IRowOrientedDataTable" name="DataTable">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Map">
		<summary></summary>
				<param type="System.Func&lt;BrightTable.IConvertibleRow, T&gt;" name="rowMapper" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Action&lt;BrightTable.IConvertibleRow&gt;" name="action" summary="" />
			</method>
</interface>
<interface name="BrightWire.ICreateGradientDescent" base="">
	<summary>
		Creates a gradient descent optimisation
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation</summary>
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightWire.ICreateTemplateBasedGradientDescent" base="">
	<summary>
		Creates gradient descent optimisations based on a matrix
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation for a particular target matrix</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="prev" summary="Any other previously created gradient descent optimisation in this context" />
				<param type="BrightData.IFloatMatrix" name="template" summary="The instance of the matrix that will be updated" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser" base="BrightData.IWriteToMetaData">
	<summary>
		
	</summary>
		<method type="System.Void" name="AddObject">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser&lt;T&gt;" base="BrightData.IDataAnalyser">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataReader" base="">
	<summary>
		
	</summary>
		<method type="T" name="Read">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.IDataSource" base="">
	<summary>
		Segment sources feed data into a graph
	</summary>
		<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>The size of the input data</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary>The size of the output data</summary>
	</property>
	<property type="System.UInt32" name="InputCount">
		<summary>The number of inputs that can feed into the graph</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get">
		<summary>Gets a mini batch with the specified rows</summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.UInt32[]" name="rows" summary="List of rows" />
			</method>
	<method type="System.UInt32[][]" name="GetBuckets">
		<summary>For sequential data, returns the row indexes grouped by sequence length</summary>
			</method>
	<method type="System.Void" name="OnBatchProcessed">
		<summary>Called when the current batch has completed</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith">
		<summary>Creates a new data source, using the current as a template but replacing the data table</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="The new data table" />
			</method>
	<property type="BrightTable.IVectorise" name="InputVectoriser">
		<summary></summary>
	</property>
	<property type="BrightTable.IVectorise" name="OutputVectoriser">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IDataTable" base="BrightData.IHaveMetaData">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType[]" name="ColumnTypes">
		<summary></summary>
	</property>
	<property type="BrightTable.DataTableOrientation" name="Orientation">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IMetaData&gt;" name="ColumnMetaData">
		<summary></summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Action&lt;System.Object[], System.UInt32&gt;" name="callback" summary="" />
				<param type="System.UInt32" name="maxRows" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.ISingleTypeTableSegment&gt;" name="Columns">
		<summary></summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="ReadTyped">
		<summary></summary>
				<param type="BrightTable.ITypedRowConsumer[]" name="consumers" summary="" />
				<param type="System.UInt32" name="maxRows" summary="" />
			</method>
	<method type="BrightTable.ISingleTypeTableSegment" name="Column">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
</interface>
<interface name="BrightTable.IDataTableSegment" base="">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType[]" name="Types">
		<summary></summary>
	</property>
	<property type="System.Object" name="this">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IDataTableSegment&lt;T&gt;" base="BrightTable.ISingleTypeTableSegment">
	<summary>
		
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary></summary>
			</method>
</interface>
<interface name="BrightData.IDiscreteDistribution" base="BrightData.IDistribution&lt;System.Int32&gt;">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightData.IDisposableLayers" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="System.IDisposable" name="disposable" summary="" />
			</method>
	<method type="System.IDisposable" name="Push">
		<summary></summary>
			</method>
	<method type="System.Void" name="Pop">
		<summary></summary>
			</method>
</interface>
<interface name="BrightData.IDistribution&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="T" name="Sample">
		<summary></summary>
			</method>
</interface>
<interface name="BrightTable.IEditableBuffer" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Set">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Object" name="value" summary="" />
			</method>
	<method type="System.Void" name="Finalise">
		<summary></summary>
			</method>
</interface>
<interface name="BrightTable.IEditableBuffer&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="T" name="value" summary="" />
			</method>
</interface>
<interface name="BrightWire.IErrorMetric" base="">
	<summary>
		Error metrics used to quantify machine learning
	</summary>
		<property type="System.Boolean" name="DisplayAsPercentage">
		<summary>True if the result should be formatted as a percentage</summary>
	</property>
	<method type="System.Single" name="Compute">
		<summary>Computes the error between the output vector and target vector</summary>
				<param type="BrightData.Vector&lt;System.Single&gt;" name="output" summary="The vector that was the output of the model" />
				<param type="BrightData.Vector&lt;System.Single&gt;" name="targetOutput" summary="The vector that the model was expected to output" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CalculateGradient">
		<summary>Calculates the gradient of the error function</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="The graph context" />
				<param type="BrightData.IFloatMatrix" name="output" summary="The mini batch of output vectors" />
				<param type="BrightData.IFloatMatrix" name="targetOutput" summary="The mini batch of expected target vectors" />
			</method>
</interface>
<interface name="BrightWire.IExecutionHistory" base="">
	<summary>
		Record of node execution
	</summary>
		<property type="BrightWire.INode" name="Source">
		<summary>Node that was executed</summary>
	</property>
	<property type="BrightWire.INode[]" name="Parents">
		<summary>The node's parents</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Node output signal</summary>
	</property>
	<property type="BrightWire.IBackpropagation" name="Backpropagation">
		<summary>Optional backpropagation</summary>
	</property>
</interface>
<interface name="BrightWire.IFeedForward" base="BrightWire.INode">
	<summary>
		Feed forward layer
	</summary>
		<property type="System.UInt32" name="InputSize">
		<summary>Size of incoming connections</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of outgoing connections</summary>
	</property>
	<property type="BrightData.IFloatVector" name="Bias">
		<summary>Bias vector</summary>
	</property>
	<property type="BrightData.IFloatMatrix" name="Weight">
		<summary>Weight matrix</summary>
	</property>
	<method type="System.Void" name="UpdateWeights">
		<summary>Updates the weights</summary>
				<param type="BrightData.IFloatMatrix" name="delta" summary="Weight delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="Graph learning context" />
			</method>
</interface>
<interface name="BrightData.IFloatMatrix" base="System.IDisposable">
	<summary>
		A matrix
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary>Checks if the matrix has not been disposed</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="Multiply">
		<summary>Multiplies the current vector (without in place modification) with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Column">
		<summary>Returns a column as a vector</summary>
				<param type="System.UInt32" name="index" summary="The column index" />
			</method>
	<method type="BrightData.IFloatVector" name="Diagonal">
		<summary>Returns the matrix diagonal as a vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Row">
		<summary>Returns a row as a vector</summary>
				<param type="System.UInt32" name="index" summary="The row index" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Add">
		<summary>Returns the current matrix (without in place modification) added to the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Subtract">
		<summary>Returns the current matrix  (without in place modification) minus the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseMultiply">
		<summary>Returns the pointwise product of the current matrix (without in place modification) with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeAndMultiply">
		<summary>Returns the current matrix (without in place modification) and multipled with the transposed target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeThisAndMultiply">
		<summary>Returns the transpose of the current matrix (without in place modification) multipled with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="RowSums">
		<summary>Returns a vector that contains the sum of the elements in each row of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums">
		<summary>Returns a vector that contains the sum of the elements in each column of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Transpose">
		<summary>Returns the transpose of the current matrix</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiplies (in place) each element of the matrix by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The scalar to multiply each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Multiply">
		<summary>Returns the product of the current matrix (without in place modification) with the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the target matrix to the current matrix (in place)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts the target matrix from the current matrix (in place)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidActivation">
		<summary>Returns a new matrix with the sigmoid function applied to each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidDerivative">
		<summary>Returns a new matrix with the sigmoid derivative of each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhActivation">
		<summary>Returns a new matrix with the tanh function applied to each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhDerivative">
		<summary>Returns a new matrix with the tanh derivative of each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxActivation">
		<summary>Returns a new matrix with the softmax function applied to each row of the matrix</summary>
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the target vector to each row of the current matrix (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddToEachColumn">
		<summary>Adds the target vector to each column of the current matrix (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<property type="BrightData.Matrix&lt;System.Single&gt;" name="Data">
		<summary>Converts the current matrix</summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="AsIndexable">
		<summary>Converts the matrix to an indexable matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromRows">
		<summary>Returns a new matrix from a subset of the current matrix's rows</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndexes" summary="The list of row indices" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromColumns">
		<summary>Returns a new matrix from a subset of the current matrix's columns</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndexes" summary="The list of column indices" />
			</method>
	<method type="System.Void" name="ClearRows">
		<summary>Set to zero the specified rows in the current matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="The list of row indices" />
			</method>
	<method type="System.Void" name="ClearColumns">
		<summary>Set to zero the specified columns in the current matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="The list of column indices" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluActivation">
		<summary>Returns the RELU function applied to each element of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluDerivative">
		<summary>Returns the RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluActivation">
		<summary>Returns the leaky RELU function applied to each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluDerivative">
		<summary>Returns the leaky RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Clone">
		<summary>Creates a copy of the current matrix</summary>
			</method>
	<method type="System.Void" name="Clear">
		<summary>Sets each element to zero</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Sqrt">
		<summary>Returns the square root of each element in the current matrix</summary>
				<param type="System.Single" name="valueAdjustment" summary="Term to add to each element in the result matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Pow">
		<summary>Returns each element raised to specified power</summary>
				<param type="System.Single" name="power" summary="The power to apply to each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseDivide">
		<summary>Returns the current matrix (not modified in place) divided by the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="System.Void" name="L1Regularisation">
		<summary>L1 Regularisation applied to each element of the current matrix (in place)</summary>
				<param type="System.Single" name="coefficient" summary="The L1 coefficient" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnL2Norm">
		<summary>Returns a vector of the L2 norms of each column</summary>
			</method>
	<method type="BrightData.IFloatVector" name="RowL2Norm">
		<summary>Returns a vector of the L2 norms of each row</summary>
			</method>
	<method type="System.Void" name="PointwiseDivideRows">
		<summary>Pointwise divide each row by the target vector (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="PointwiseDivideColumns">
		<summary>Pointwise divide each column by the target vector (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="Constrain">
		<summary>Constrain each value within the specified min and max values (in place)</summary>
				<param type="System.Single" name="min" summary="The minimum allowed value" />
				<param type="System.Single" name="max" summary="The maximum allowed value" />
			</method>
	<method type="BrightData.IFloatVector" name="GetRowSegment">
		<summary>Returns a segment from a row of the current matrix</summary>
				<param type="System.UInt32" name="rowIndex" summary="The row index" />
				<param type="System.UInt32" name="columnIndex" summary="The start index to return" />
				<param type="System.UInt32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightData.IFloatVector" name="GetColumnSegment">
		<summary>Returns a segment from a column of the current matrix</summary>
				<param type="System.UInt32" name="columnIndex" summary="The column index" />
				<param type="System.UInt32" name="rowIndex" summary="The start index to return" />
				<param type="System.UInt32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatColumns">
		<summary>Returns a new matrix with the columns of the target matrix appended to each column of the current matrix</summary>
				<param type="BrightData.IFloatMatrix" name="bottom" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatRows">
		<summary>Returns a new matrix with the rows of the target matrix appended to each row of the current matrix</summary>
				<param type="BrightData.IFloatMatrix" name="right" summary="The target matrix" />
			</method>
	<method type="(BrightData.IFloatMatrix Left, BrightData.IFloatMatrix Right)" name="SplitAtColumn">
		<summary>Splits the rows of the current matrix into two matrices</summary>
				<param type="System.UInt32" name="columnIndex" summary="The column index at which to split" />
			</method>
	<method type="(BrightData.IFloatMatrix Top, BrightData.IFloatMatrix Bottom)" name="SplitAtRow">
		<summary>Splits the columns of the current matrix into two matrices</summary>
				<param type="System.UInt32" name="rowIndex" summary="The row index at which to split" />
			</method>
	<method type="(BrightData.IFloatMatrix U, BrightData.IFloatVector S, BrightData.IFloatMatrix VT)" name="Svd">
		<summary>Singular value decomposition</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Fast conversion to vector (the internal buffer is not modified)</summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor">
		<summary>Reshapes the matrix to a 3D tensor, treating each column as a depth slice in the new 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each sub matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each sub matrix" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Converts the matrix to a 4D tensor, treating each column as a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each sub matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each sub matrix" />
				<param type="System.UInt32" name="depth" summary="Depth of each 3D tensor" />
			</method>
	<method type="System.Single" name="GetAt">
		<summary>Returns the value at the specified row and column index</summary>
				<param type="System.UInt32" name="row" summary="Row index" />
				<param type="System.UInt32" name="column" summary="Column index" />
			</method>
	<method type="System.Void" name="SetAt">
		<summary>Updates the value at the specified row and column index</summary>
				<param type="System.UInt32" name="row" summary="Row index" />
				<param type="System.UInt32" name="column" summary="Column index" />
				<param type="System.Single" name="value" summary="Value to set" />
			</method>
	<method type="BrightData.IFloatVector[]" name="ColumnVectors">
		<summary>Returns the columns of the matrix as vectors</summary>
			</method>
	<method type="BrightData.IFloatVector[]" name="RowVectors">
		<summary>Returns the rows of the matrix as vectors</summary>
			</method>
</interface>
<interface name="BrightData.IFloatVector" base="System.IDisposable">
	<summary>
		A vector
	</summary>
		<property type="System.Boolean" name="IsValid">
		<summary>Checks if the vector has not been disposed</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsColumnMatrix">
		<summary>Converts the vector to a column matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsRowMatrix">
		<summary>Converts the vector to a row matrix</summary>
			</method>
	<property type="System.UInt32" name="Count">
		<summary>The number of elements in the vector</summary>
	</property>
	<property type="BrightData.Vector&lt;System.Single&gt;" name="Data">
		<summary>Converts the vector</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Add">
		<summary>Adds a vector (without in place modification)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The vector to add" />
			</method>
	<method type="BrightData.IFloatVector" name="Subtract">
		<summary>Subtracts a vector (without in place modification)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The vector to subtract" />
			</method>
	<method type="System.Single" name="L1Norm">
		<summary>Calculates the absolute values (L1) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.Single" name="L2Norm">
		<summary>Calculates the euclidean (L2) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.UInt32" name="MaximumIndex">
		<summary>Returns the index of the vector with the greatest value</summary>
			</method>
	<method type="System.UInt32" name="MinimumIndex">
		<summary>Returns the index of the vector with the smallest value</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiples (in place) by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to multiple each element" />
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds (in place) a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to add to each element" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a vector in place</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector to add to the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts a vector in place</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector to subtract from the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="BrightData.IIndexableFloatVector" name="AsIndexable">
		<summary>Converts the vector to an indexable vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="PointwiseMultiply">
		<summary>Pointwise multiplication (without in place modification) with a vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="DotProduct">
		<summary>The dot product of two vectors</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="BrightData.IFloatVector" name="GetNewVectorFromIndexes">
		<summary>Returns a new vector from a subset of the vector indices</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="A list of indexes to use as the source of the new vector" />
			</method>
	<method type="BrightData.IFloatVector" name="Clone">
		<summary>Creates a new copy of the vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sqrt">
		<summary>Creates a new vector in which each element is the square root of the current vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Abs">
		<summary>Creates a new vector in which each element is the absolute value of the current vector</summary>
			</method>
	<method type="System.Void" name="CopyFrom">
		<summary>Copies values from the target vector into the current vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance">
		<summary>Calculates the euclidean distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="CosineDistance">
		<summary>Calculates the cosine distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector>" />
			</method>
	<method type="System.Single" name="ManhattanDistance">
		<summary>Calculates the manhattan distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance">
		<summary>Calculates the mean squared distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="SquaredEuclidean">
		<summary>Calculates the squared euclidean distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="(System.Single Min, System.Single Max)" name="GetMinMax">
		<summary>Finds the minimum and maximum values in the current vector</summary>
			</method>
	<method type="System.Single" name="Average">
		<summary>Calculates the average value from the elements of the current vector</summary>
			</method>
	<method type="System.Single" name="StdDev">
		<summary>Calculates the standard deviation from the elements of the current vector</summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="(optional) pre calculated mean" />
			</method>
	<method type="System.Void" name="Normalise">
		<summary>Normalises (in place) the values of the current vector</summary>
				<param type="BrightData.NormalizationType" name="type" summary="The type of normalisation" />
			</method>
	<method type="BrightData.IFloatVector" name="Softmax">
		<summary>Returns the softmax function (without in place modification) applied to the current vector
https://en.wikipedia.org/wiki/Softmax_function</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxDerivative">
		<summary>Returns the jacobian matrix of the softmax derivative</summary>
			</method>
	<method type="BrightData.IFloatVector" name="FindDistances">
		<summary>Returns a vector of distances between the current and target vectors</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="The list of target vectors" />
				<param type="BrightData.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="System.Single" name="FindDistance">
		<summary>Returns the distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="other" summary="The target vector" />
				<param type="BrightData.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="BrightData.IFloatVector" name="CosineDistance">
		<summary>Returns a vector of the cosine distance between the current and target vectors</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="The list of target vectors" />
				<param type="System.Single[]" name="dataNorm" summary="A buffer to hold the norms of the target vectors" />
			</method>
	<method type="BrightData.IFloatVector" name="Log">
		<summary>Returns a vector (without in place modification) in which each element is the natural log of each element in the current vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sigmoid">
		<summary>Returns the sigmoid function (without in place modification) applied to the current vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Fast conversion to matrix (internal buffer is used directly)</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows in the matrix" />
				<param type="System.UInt32" name="columns" summary="The number of columns in the matrix" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor">
		<summary>Converts the vector to a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Converts the vector to a 4D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
			</method>
	<method type="BrightData.IFloatVector[]" name="Split">
		<summary>Splits the vector into a list of vectors</summary>
				<param type="System.UInt32" name="blockCount" summary="The number of sub vectors to split into" />
			</method>
	<method type="System.Void" name="RotateInPlace">
		<summary>Rotates values in the vector (both horizontally and vertically within blocks)</summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Reverse">
		<summary>Returns a reversed copy of the vector's values</summary>
			</method>
	<method type="System.Single" name="GetAt">
		<summary>Returns the value at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The index of the vector to return" />
			</method>
	<method type="System.Void" name="SetAt">
		<summary>Updates the value at the specified index</summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary>Checks if every value in the vector is finite (not NaN or positive/negative infinity)</summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.IGradientDescentOptimisation" base="System.IDisposable">
	<summary>
		Gradient descent optimisation
	</summary>
		<method type="System.Void" name="Update">
		<summary>Updates the matrix with the delta</summary>
				<param type="BrightData.IFloatMatrix" name="source" summary="The matrix to update" />
				<param type="BrightData.IFloatMatrix" name="delta" summary="The delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="The graph learning context" />
			</method>
</interface>
<interface name="BrightWire.IGraphContext" base="System.IDisposable">
	<summary>
		Graph context
	</summary>
		<property type="System.Boolean" name="IsTraining">
		<summary>True if the graph is currently training</summary>
	</property>
	<property type="BrightWire.INode" name="Source">
		<summary>Node that sent the current signal</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Current signal</summary>
	</property>
	<property type="BrightWire.IGraphExecutionContext" name="ExecutionContext">
		<summary>Current execution context</summary>
	</property>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Current learning context (optional)</summary>
	</property>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="BatchSequence">
		<summary>Current mini batch sequence</summary>
	</property>
	<method type="System.Void" name="AddForward">
		<summary>Records node execution</summary>
				<param type="BrightWire.IExecutionHistory" name="action" summary="Record of node execution" />
				<param type="System.Func&lt;BrightWire.IBackpropagation&gt;" name="callback" summary="Optional callback to add backpropagation" />
			</method>
	<method type="System.Void" name="AddBackward">
		<summary>Sends a backward error signal</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.INode" name="target" summary="Node to send to" />
				<param type="BrightWire.INode" name="source" summary="Node that sent the error" />
			</method>
	<method type="System.Void" name="AppendErrorSignal">
		<summary>Records an error signal against a node</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.INode" name="forNode" summary="Node to record against" />
			</method>
	<method type="System.Void" name="Backpropagate">
		<summary>Backpropagates the signal</summary>
				<param type="BrightWire.IGraphData" name="delta" summary="Error signal" />
			</method>
	<property type="BrightWire.IGraphData" name="ErrorSignal">
		<summary>Current error signal</summary>
	</property>
	<property type="System.Boolean" name="HasNext">
		<summary>Checks if there is a pending forward graph operation</summary>
	</property>
	<method type="System.Boolean" name="ExecuteNext">
		<summary>Executes the next pending forward graph operation</summary>
			</method>
	<method type="System.Void" name="SetOutput">
		<summary>Saves the data as an output of the graph</summary>
				<param type="BrightWire.IGraphData" name="data" summary="Segment to save" />
				<param type="System.Int32" name="channel" summary="Channel to save against (optional)" />
			</method>
	<method type="BrightWire.IGraphData" name="GetOutput">
		<summary>Returns a saved output</summary>
				<param type="System.Int32" name="channel" summary="Output channel (optional)" />
			</method>
	<property type="BrightWire.IGraphData[]" name="Output">
		<summary>Returns all stored output</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphData" base="">
	<summary>
		Wrapper around the data that is used as a signal between nodes in the graph
	</summary>
		<property type="System.UInt32" name="Rows">
		<summary>Row count</summary>
	</property>
	<property type="System.UInt32" name="Columns">
		<summary>Column count</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>3D Tensor depth (1 if the signal is a matrix)</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>Count of 3D tensors (1 of the signal is a matrix or 3D tensor)</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrix">
		<summary>Gets the signal as a matrix</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="Get4DTensor">
		<summary>Gets the signal as a 4D tensor</summary>
			</method>
	<method type="BrightWire.IGraphData" name="ReplaceWith">
		<summary>Replaces the data with the specified matrix (but preserves any tensor meta data)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The matrix to use as a replacement" />
			</method>
	<method type="BrightData.IFloatMatrix[]" name="GetSubMatrices">
		<summary>Returns the list of matrices that compose the signal (single item if the signal is a matrix)</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphEngine" base="">
	<summary>
		Graph engines drive execution within a graph
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>Serialised version of the current graph and its parameters</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source that feeds into the graph</summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Execute">
		<summary>Executes a data source on the current graph</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source to process" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="Execute">
		<summary>Executes a single vector on the current graph</summary>
				<param type="System.Single[]" name="input" summary="Vector to execute" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="ExecuteSequential">
		<summary>Executes a sequential input on the current graph</summary>
				<param type="System.UInt32" name="sequenceIndex" summary="Index of the current sequence (starting from 0)" />
				<param type="System.Single[]" name="input" summary="Input vector" />
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="BrightWire.MiniBatchSequenceType" name="sequenceType" summary="The sequence type (start, standard, end)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="ExecuteSequential">
		<summary>Executes a sequence of inputs on the current graph</summary>
				<param type="System.Single[][]" name="input" summary="List of vector inputs" />
			</method>
	<property type="BrightWire.INode" name="Start">
		<summary>The graph's single start node</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphExecutionContext" base="System.IDisposable">
	<summary>
		Graph execution context
	</summary>
		<method type="System.Void" name="SetMemory">
		<summary>Writes to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
				<param type="BrightData.IFloatMatrix" name="memory" summary="Segment" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetMemory">
		<summary>Reads from a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
			</method>
	<method type="BrightWire.IGraphOperation" name="GetNextOperation">
		<summary>Gets the next queued graph operation (if any)</summary>
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds a list of graph operations to the queue</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphOperation&gt;" name="operationList" summary="List of operations" />
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="System.Int32" name="RemainingOperationCount">
		<summary>How many operations remain queued</summary>
	</property>
	<method type="System.Void" name="RegisterContinuation">
		<summary>Registers a continuation that will be executed after the current sequence has been processed in full</summary>
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="Sequence index" />
				<param type="System.Action&lt;BrightWire.IGraphContext&gt;" name="callback" summary="Continuation" />
			</method>
	<property type="System.Boolean" name="HasContinuations">
		<summary>True if there are registered continuations</summary>
	</property>
	<method type="System.Void" name="Continue">
		<summary>Execute any registered continuation for this context</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="Context with an associated IMiniBatchSequence" />
			</method>
</interface>
<interface name="BrightWire.IGraphOperation" base="">
	<summary>
		A pending graph operation (mini batch)
	</summary>
		<method type="System.Void" name="Execute">
		<summary>Executes the operation</summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Graph execution context" />
			</method>
</interface>
<interface name="BrightWire.IGraphTrainingEngine" base="BrightWire.IGraphEngine">
	<summary>
		A graph engine that also trains the graph's parameters against training data
	</summary>
		<method type="BrightWire.INode" name="GetInput">
		<summary>Returns the specified input node</summary>
				<param type="System.UInt32" name="index" summary="Index of the input node to retrieve" />
			</method>
	<method type="System.Double" name="Train">
		<summary>Executes a training epoch on the graph</summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="System.Boolean" name="Test">
		<summary>Executes test data on the current graph</summary>
				<param type="BrightWire.IDataSource" name="testDataSource" summary="Segment source with test data" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to use to evaluate the test score" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
				<param type="System.Action&lt;System.Single, System.Double, System.Boolean, System.Boolean&gt;" name="values" summary="Optional callback to get the (testError, trainingRate, isPercentage, isImprovedScore) data" />
			</method>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Graph learning context</summary>
	</property>
	<method type="System.Void" name="LoadParametersFrom">
		<summary>Loads model parameters into the existing graph</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Model to load parameters from" />
			</method>
</interface>
<interface name="BrightWire.IHaveAction" base="">
	<summary>
		Node that exposes an action
	</summary>
		<property type="BrightWire.IAction" name="Action">
		<summary>The node's action</summary>
	</property>
</interface>
<interface name="BrightTable.IHaveDataContext" base="">
	<summary>
		
	</summary>
		<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IHaveDataTable" base="">
	<summary>
		
	</summary>
		<property type="BrightTable.IDataTable" name="DataTable">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHaveEncodedData" base="">
	<summary>
		
	</summary>
		<property type="System.Boolean" name="IsEncoded">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHaveIndexer" base="">
	<summary>
		
	</summary>
		<property type="BrightData.IIndexStrings" name="Indexer">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHaveIndices" base="">
	<summary>
		Interface
	</summary>
		<property type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="Indices">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.IHaveMemoryNode" base="">
	<summary>
		Nodes that have a memory feeder sub-node
	</summary>
		<property type="BrightWire.INode" name="Memory">
		<summary>The memory feed sub node</summary>
	</property>
</interface>
<interface name="BrightData.IHaveMetaData" base="">
	<summary>
		
	</summary>
		<property type="BrightData.IMetaData" name="MetaData">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHybridBuffer" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Length">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IHybridBuffer&lt;T&gt;" base="BrightData.IHybridBuffer">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="T" name="item" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary></summary>
			</method>
</interface>
<interface name="BrightData.IIndexable3DFloatTensor" base="BrightData.I3DFloatTensor">
	<summary>
		A 3D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="BrightData.IIndexableFloatMatrix[]" name="Matrix">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the tensor as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexable4DFloatTensor" base="BrightData.I4DFloatTensor">
	<summary>
		A 4D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="BrightData.IIndexable3DFloatTensor[]" name="Tensors">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the tensor as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexableFloatMatrix" base="BrightData.IFloatMatrix">
	<summary>
		A matrix whose elements can be indexed directly
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element from the current matrix</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Rows">
		<summary>Returns the rows of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Columns">
		<summary>Returns the columns of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Returns each element in the current matrix as enumerable</summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="Map">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element" />
			</method>
	<method type="BrightData.IIndexableFloatMatrix" name="MapIndexed">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element (rowIndex: uint, columnIndex: uint, value: float) => float" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the matrix as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexableFloatVector" base="BrightData.IFloatVector">
	<summary>
		Returns an indexable vector (in which elements can be directly indexed)
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element at the specified index</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Gets the values as an enumerable</summary>
	</property>
	<method type="System.Single[]" name="ToArray">
		<summary>Converts the vector to an array</summary>
			</method>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the vector as well)</summary>
			</method>
	<method type="BrightData.IIndexableFloatVector" name="Append">
		<summary>Creates a new vector (without in place modification) in which new values are appended onto the end of the current vector</summary>
				<param type="System.Single[]" name="data" summary="The values to append" />
			</method>
</interface>
<interface name="BrightWire.IIndexListClassifier" base="">
	<summary>
		A classifier that classifies index lists
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary>Classifies the input data and returns the classifications with their weights</summary>
				<param type="BrightData.IndexList" name="indexList" summary="The index list to classify" />
			</method>
</interface>
<interface name="BrightWire.IIndexListEncoder" base="">
	<summary>
		Encodes index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the index lists to a dense vector</summary>
				<param type="BrightData.IndexList" name="indexList" summary="The index list to encode" />
			</method>
</interface>
<interface name="BrightData.IIndexStrings" base="">
	<summary>
		
	</summary>
		<method type="System.UInt32" name="GetIndex">
		<summary></summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.ILearningContext" base="">
	<summary>
		Graph learning context
	</summary>
		<property type="System.Double" name="EpochSeconds">
		<summary>The duration in seconds of the last epoch</summary>
	</property>
	<property type="System.Int64" name="EpochMilliseconds">
		<summary>The duration in milliseconds of the last epoch</summary>
	</property>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider</summary>
	</property>
	<property type="System.UInt32" name="CurrentEpoch">
		<summary>The index of the current epoch (starting from one)</summary>
	</property>
	<property type="System.Single" name="LearningRate">
		<summary>The current learning/training rate</summary>
	</property>
	<property type="System.Single" name="BatchLearningRate">
		<summary>The learning rate adjusted with the current batch size</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>The current mini batch size</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The total number of rows per epoch</summary>
	</property>
	<method type="System.Void" name="StoreUpdate">
		<summary>Stores an update to the model parameters</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that is affected by this update" />
				<param type="T" name="update" summary="The update" />
				<param type="System.Action&lt;T&gt;" name="updater" summary="Callback to execute the update" />
			</method>
	<property type="BrightWire.TrainingErrorCalculation" name="TrainingErrorCalculation">
		<summary>True if the graph should calculate training error</summary>
	</property>
	<property type="System.Boolean" name="DeferUpdates">
		<summary>True if updates are deferred until the mini batch is complete</summary>
	</property>
	<method type="System.Void" name="ApplyUpdates">
		<summary>Apply any deferred updates</summary>
			</method>
	<method type="System.Void" name="StartEpoch">
		<summary>Start a new epoch</summary>
			</method>
	<method type="System.Void" name="EndEpoch">
		<summary>End the current epoch</summary>
			</method>
	<method type="System.Void" name="SetRowCount">
		<summary>Sets the number of rows</summary>
				<param type="System.UInt32" name="rowCount" summary="The number of rows per epoch" />
			</method>
	<method type="System.Void" name="DeferBackpropagation">
		<summary>Register the backpropagation to be deferred</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The error signal associated with this backpropagation (optional, can be null)" />
				<param type="System.Action&lt;BrightWire.IGraphData&gt;" name="update" summary="The callback to execute the backpropagation" />
			</method>
	<method type="System.Void" name="BackpropagateThroughTime">
		<summary>Backpropagates the error signal across all deferred backpropagations</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="The backpropagation signal" />
				<param type="System.Int32" name="maxDepth" summary="The maximum depth to backpropagate the signal" />
			</method>
	<method type="System.Void" name="ScheduleLearningRate">
		<summary>Schedules a change in the learning rate the specified epoch</summary>
				<param type="System.UInt32" name="atEpoch" summary="The epoch to change the learning rate" />
				<param type="System.Single" name="newLearningRate" summary="The learning rate to use at that epoch" />
			</method>
	<method type="System.Void" name="EnableNodeUpdates">
		<summary>Enable or disable node parameter updates</summary>
				<param type="BrightWire.INode" name="node" summary="The node to modify" />
				<param type="System.Boolean" name="enableUpdates" summary="True if the node can make updates via backpropagation" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Resets the learning context</summary>
			</method>
	<property type="System.Action&lt;System.String&gt;" name="MessageLog">
		<summary>Sends the message to some output</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="ErrorMetric">
		<summary>Error metric to use when evaluating trainging progress</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory" name="GraphFactory">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ILinearAlgebraProvider" base="System.IDisposable">
	<summary>
		Linear algebra adaptor interfaces
	</summary>
		<property type="System.String" name="Name">
		<summary></summary>
	</property>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a new vector</summary>
				<param type="System.UInt32" name="length" summary="Length of the vector" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a vector</summary>
				<param type="System.UInt32" name="length" summary="Size of the vector" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="init" summary="Callback to initialise each element of the vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows" />
				<param type="System.UInt32" name="columns" summary="The number of columns" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows" />
				<param type="System.UInt32" name="columns" summary="The number of columns" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single&gt;" name="init" summary="Callback to initialise each element of the matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows">
		<summary>Creates a matrix from a list of vectors. Each vector will become a row in the new matrix</summary>
				<param type="BrightData.IFloatVector[]" name="vectorRows" summary="List of vectors for each row" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns">
		<summary>Creates a matrix from a list of vectors. Each vector will become a column in the new matrix</summary>
				<param type="BrightData.IFloatVector[]" name="vectorColumns" summary="List of vectors for each column" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.UInt32" name="depth" summary="Number of depth slices" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor from a list of matrices</summary>
				<param type="BrightData.IFloatMatrix[]" name="matrices" summary="List of matrices" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor from a list of 3D tensors</summary>
				<param type="BrightData.I3DFloatTensor[]" name="tensors" summary="List of 3D tensors" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor from a list of 3D tensors</summary>
				<param type="BrightData.Tensor3D&lt;System.Single&gt;[]" name="tensors" summary="List of 3D tensors" />
			</method>
	<method type="System.Void" name="PushLayer">
		<summary>Creates a save point in the allocation history</summary>
			</method>
	<method type="System.Void" name="PopLayer">
		<summary>Releases all allocated memory since the last save point</summary>
			</method>
	<property type="System.Boolean" name="IsGpu">
		<summary>True if the provider uses the GPU</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="CalculateDistances">
		<summary>Calculates the distance of each vector against the comparison vectors - the size of all vectors should be the same</summary>
				<param type="BrightData.IFloatVector[]" name="vectors" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IFloatVector&gt;" name="comparison" summary="" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="data" summary="" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionPredictor" base="System.IDisposable">
	<summary>
		Linear regression predictor
	</summary>
		<method type="System.Single" name="Predict">
		<summary>Predicts a value from input data</summary>
				<param type="System.Single[]" name="input" summary="The input data" />
			</method>
	<method type="System.Single[]" name="Predict">
		<summary>Bulk value prediction</summary>
				<param type="System.Single[][]" name="input" summary="List of data to predict" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionTrainer" base="">
	<summary>
		Trainer for linear regression models
	</summary>
		<method type="BrightWire.Models.Linear.LinearRegression" name="GradientDescent">
		<summary>Solves the model using gradient descent</summary>
				<param type="System.Int32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightData.IFloatVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionClassifier" base="System.IDisposable">
	<summary>
		Logistic regression classifier
	</summary>
		<method type="BrightData.Vector&lt;System.Single&gt;" name="Predict">
		<summary>Outputs a list of values from 0 to 1 for each input data</summary>
				<param type="BrightData.Matrix&lt;System.Single&gt;" name="input" summary="Input data" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionTrainer" base="">
	<summary>
		A logistic regression trainer
	</summary>
		<method type="BrightWire.Models.Linear.LogisticRegression" name="GradientDescent">
		<summary>Trains a model using gradient descent</summary>
				<param type="System.UInt32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightData.IFloatVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer&lt;T&gt;" base="BrightWire.ICanSerialiseToStream">
	<summary>
		Markov model trainer
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a sequence of items to the trainer</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer2&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 2)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer3&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 3)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMemoryNode" base="">
	<summary>
		Recurrent neural networks memory node
	</summary>
		<property type="BrightData.Vector&lt;System.Single&gt;" name="Data">
		<summary>The current state of the memory node</summary>
	</property>
</interface>
<interface name="BrightData.IMetaData" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		
	</summary>
		<method type="System.Object" name="Get">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="GetNullable">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="valueIfMissing" summary="" />
			</method>
	<method type="T" name="Set">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="CopyAllExcept">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetStringsWithPrefix">
		<summary></summary>
				<param type="System.String" name="prefix" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMiniBatch" base="">
	<summary>
		Information about the current mini batch
	</summary>
		<property type="System.UInt32[]" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence">
		<summary>Gets the next item in the sequence</summary>
			</method>
	<property type="System.UInt32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex">
		<summary>Gets a sequence item</summary>
				<param type="System.UInt32" name="index" summary="The index to retrieve" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the sequence iterator</summary>
			</method>
</interface>
<interface name="BrightWire.IMiniBatchSequence" base="">
	<summary>
		A sequence within a mini batch
	</summary>
		<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary>Mini batch</summary>
	</property>
	<property type="System.UInt32" name="SequenceIndex">
		<summary>Index of the sequence</summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary>Sequence type</summary>
	</property>
	<property type="BrightWire.IGraphData[]" name="Input">
		<summary>Input data</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary>Training target data</summary>
	</property>
</interface>
<interface name="BrightWire.INode" base="BrightWire.ICanInitialiseNode">
	<summary>
		Graph node
	</summary>
		<property type="System.String" name="Id">
		<summary>Unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Friendly name</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.IWire&gt;" name="Output">
		<summary>List of outgoing wires</summary>
	</property>
	<method type="System.Void" name="ExecuteForward">
		<summary>Executes the node forward</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="System.UInt32" name="channel" summary="Channel the signal was received on" />
			</method>
	<method type="BrightWire.INode" name="FindByName">
		<summary>Searches for a node by friendly name</summary>
				<param type="System.String" name="name" summary="Friendly name of the node to find" />
			</method>
	<method type="BrightWire.INode" name="FindById">
		<summary>Searches for a node by id</summary>
				<param type="System.String" name="id" summary="Unique id of the node" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.INode&gt;" name="SubNodes">
		<summary>Sub-nodes of the current node</summary>
	</property>
	<method type="BrightWire.Models.ExecutionGraphModel.Node" name="SerialiseTo">
		<summary>Serialise the node</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.INode&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraphModel.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraphModel.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.INode&gt;" name="graph" summary="Dictionary of nodes with their associated unique ids" />
			</method>
	<method type="System.Void" name="LoadParameters">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
</interface>
<interface name="BrightData.INonNegativeDiscreteDistribution" base="BrightData.IDistribution&lt;System.UInt32&gt;">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightData.INormalize" base="">
	<summary>
		
	</summary>
		<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary></summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary></summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.INumericComputation&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="BrightData.ITensorSegment&lt;T&gt;" name="Abs">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Add">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="ConstrainInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="maxValue" summary="" />
			</method>
	<method type="T" name="Average">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="T" name="CosineDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="T" name="DotProduct">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="T" name="EuclideanDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Exp">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="L1Norm">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="T" name="L2Norm">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Log">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="ManhattanDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Multiply">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="T" name="NextRandom">
		<summary></summary>
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="PointwiseDivide">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="PointwiseMultiply">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="Search">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Sqrt">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Squared">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="StdDev">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="mean" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Subtract">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="T" name="Sum">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="(T Min, T Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Reverse">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;BrightData.ITensorSegment&lt;T&gt;&gt;" name="Split">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Sigmoid">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="SigmoidDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Tanh">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="TanhDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Relu">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="ReluDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="LeakyRelu">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="LeakyReluDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Softmax">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="SoftmaxDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Pow">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="power" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.UInt32" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Decimal" name="val" summary="" />
			</method>
</interface>
<interface name="BrightWire.IPropertySet" base="">
	<summary>
		The current set of graph initialisation parameters
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider to use</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="WeightInitialisation">
		<summary>The weight initialiser to use</summary>
	</property>
	<property type="BrightWire.IGradientDescentOptimisation" name="GradientDescent">
		<summary>The gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="TemplateGradientDescentDescriptor">
		<summary>The template based gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="GradientDescentDescriptor">
		<summary>The descriptor to create new gradient descent optimisations</summary>
	</property>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified template based gradient descent optimisation</summary>
				<param type="BrightWire.ICreateTemplateBasedGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.ICreateGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="optimisation" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified weight initialiser</summary>
				<param type="BrightWire.IWeightInitialisation" name="weightInit" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Clone">
		<summary>Clones the current property set</summary>
			</method>
	<method type="T" name="Get">
		<summary>Gets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="defaultValue" summary="The value to use if the property has not been supplied" />
			</method>
	<method type="BrightWire.IPropertySet" name="Set">
		<summary>Sets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="obj" summary="The property value" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Clears the named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
</interface>
<interface name="BrightData.IProvideTempStreams" base="System.IDisposable">
	<summary>
		
	</summary>
		<method type="System.IO.Stream" name="Get">
		<summary></summary>
				<param type="System.String" name="uniqueId" summary="" />
			</method>
	<method type="System.Boolean" name="HasStream">
		<summary></summary>
				<param type="System.String" name="uniqueId" summary="" />
			</method>
</interface>
<interface name="BrightWire.IRandomProjection" base="System.IDisposable">
	<summary>
		Random projection
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>The size to reduce to</summary>
	</property>
	<property type="BrightData.IFloatMatrix" name="Matrix">
		<summary>The transformation matrix</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Compute">
		<summary>Reduces a vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Compute">
		<summary>Reduces a matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
</interface>
<interface name="BrightData.IReferenceCountedMemory" base="">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Int32" name="AddRef">
		<summary></summary>
			</method>
	<method type="System.Int32" name="Release">
		<summary></summary>
			</method>
	<property type="System.Int64" name="AllocationIndex">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.IRowClassifier" base="">
	<summary>
		
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary></summary>
				<param type="BrightTable.IConvertibleRow" name="row" summary="" />
			</method>
</interface>
<interface name="BrightTable.IRowOrientedDataTable" base="BrightTable.IDataTable">
	<summary>
		
	</summary>
		<method type="BrightTable.IColumnOrientedDataTable" name="AsColumnOriented">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndices" summary="" />
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Bag">
		<summary></summary>
				<param type="System.UInt32" name="sampleCount" summary="" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IDataTableSegment" name="Row">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.IDataTableSegment&gt;" name="Rows">
		<summary></summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Concat">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Concat">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.IRowOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Project">
		<summary></summary>
				<param type="System.Func&lt;System.Object[], System.Object[]&gt;" name="projector" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="SelectRows">
		<summary></summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="SelectRows">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Shuffle">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Sort">
		<summary></summary>
				<param type="System.Boolean" name="ascending" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.String Label, BrightTable.IRowOrientedDataTable Table)&gt;" name="GroupBy">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<property type="System.String" name="FirstRow">
		<summary></summary>
	</property>
	<property type="System.String" name="SecondRow">
		<summary></summary>
	</property>
	<property type="System.String" name="ThirdRow">
		<summary></summary>
	</property>
	<property type="System.String" name="LastRow">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ISerializable" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightData.ISetLinearAlgebraProvider" base="">
	<summary>
		
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.ISingleTypeTableSegment" base="BrightData.IHaveMetaData">
	<summary>
		
	</summary>
		<property type="BrightTable.ColumnType" name="SingleType">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.ITableClassifier" base="">
	<summary>
		
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, (System.String Classification, System.Single Weight)[] Predictions)&gt;" name="Classify">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
			</method>
</interface>
<interface name="BrightData.ITensor" base="System.IDisposable">
	<summary>
		
	</summary>
		<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Rank">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ITensor&lt;T&gt;" base="BrightData.ITensor">
	<summary>
		
	</summary>
		<method type="BrightData.ITensorSegment&lt;T&gt;" name="GetDataCopy">
		<summary></summary>
			</method>
	<property type="BrightData.ITensorSegment&lt;T&gt;" name="Segment">
		<summary></summary>
	</property>
	<property type="BrightData.INumericComputation&lt;T&gt;" name="Computation">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ITensorComputation&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="BrightData.Matrix&lt;T&gt;" name="Transpose">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="Multiply">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="m2" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="TransposeAndMultiply">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="m2" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="TransposeThisAndMultiply">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="m2" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="RowSums">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="ColumnSums">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRowInPlace">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
				<param type="BrightData.Vector&lt;T&gt;" name="v" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumnInPlace">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
				<param type="BrightData.Vector&lt;T&gt;" name="v" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="ConcatRows">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="left" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="right" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="ConcatColumns">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="top" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="bottom" summary="" />
			</method>
</interface>
<interface name="BrightData.ITensorPool" base="">
	<summary>
		
	</summary>
		<method type="T[]" name="Get">
		<summary></summary>
				<param type="System.UInt32" name="size" summary="" />
			</method>
	<method type="System.Void" name="Reuse">
		<summary></summary>
				<param type="T[]" name="block" summary="" />
			</method>
	<property type="System.Int64" name="MaxCacheSize">
		<summary></summary>
	</property>
	<property type="System.Int64" name="CacheSize">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ITensorSegment&lt;T&gt;" base="BrightData.IReferenceCountedMemory">
	<summary>
		
	</summary>
		<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsContiguous">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<method type="T[]" name="ToArray">
		<summary></summary>
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Void" name="InitializeFrom">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="T" name="initializer" summary="" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="T[]" name="initialData" summary="" />
			</method>
	<method type="System.Void" name="WriteTo">
		<summary></summary>
				<param type="System.IO.Stream" name="writerBaseStream" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="T[]" name="array" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
</interface>
<interface name="BrightTable.ITransformColumnOrientedDataTable" base="">
	<summary>
		
	</summary>
		<method type="BrightTable.IColumnOrientedDataTable" name="Transform">
		<summary></summary>
				<param type="BrightTable.IColumnOrientedDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
</interface>
<interface name="BrightTable.ITransformRowOrientedDataTable" base="">
	<summary>
		
	</summary>
		<method type="BrightTable.IRowOrientedDataTable" name="Transform">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
</interface>
<interface name="BrightTable.ITypedRowConsumer" base="">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="ColumnIndex">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType" name="ColumnType">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.ITypedRowConsumer&lt;T&gt;" base="BrightTable.ITypedRowConsumer">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightTable.IVectorise" base="">
	<summary>
		
	</summary>
		<method type="System.Single[]" name="Vectorise">
		<summary></summary>
				<param type="System.Object[]" name="row" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary></summary>
	</property>
	<method type="System.String" name="GetOutputLabel">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.UInt32" name="vectorIndex" summary="" />
			</method>
</interface>
<interface name="BrightWire.IVolumeDataSource" base="">
	<summary>
		Volume (3D tensor) based data sources
	</summary>
		<property type="System.UInt32" name="Width">
		<summary>Width of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Height">
		<summary>Height of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>Depth of each input volume</summary>
	</property>
</interface>
<interface name="BrightWire.IWeightedIndexListEncoder" base="">
	<summary>
		Encodes weighted index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the weighted index list to a dense vector</summary>
				<param type="BrightData.WeightedIndexList" name="indexList" summary="" />
			</method>
</interface>
<interface name="BrightWire.IWeightInitialisation" base="">
	<summary>
		Neural network weight initialiser
	</summary>
		<method type="BrightData.IFloatVector" name="CreateBias">
		<summary>Creates the bias vector</summary>
				<param type="System.UInt32" name="size" summary="The size of the vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateWeight">
		<summary>Creates the weight matrix</summary>
				<param type="System.UInt32" name="rows" summary="Row count" />
				<param type="System.UInt32" name="columns" summary="Column count" />
			</method>
</interface>
<interface name="BrightWire.IWire" base="">
	<summary>
		Wires connect nodes in the graph
	</summary>
		<property type="BrightWire.INode" name="SendTo">
		<summary>The node to send a signal to</summary>
	</property>
	<property type="System.UInt32" name="Channel">
		<summary>The channel</summary>
	</property>
</interface>
<interface name="BrightData.IWriteToMetaData" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</interface>

<class name="BrightWire.Models.ConfusionMatrix.ActualClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.And" base="" is-static="true" is-abstract="false">
	<summary>
		Simple AND training data
	</summary>
	<method type="BrightTable.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing AND training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for node backpropagation
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Dispose</summary>
			</method>
	<method type="System.Void" name="Backward" is-static="false">
		<summary>Called when backpropagating</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="Parents of the current node" />
			</method>
	<method type="System.Void" name="_Backward" is-static="false">
		<summary>Called when a valid error signal has been received</summary>
				<param type="BrightWire.INode" name="fromNode" summary=">The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="Parents of the current node" />
			</method>
</class>
<class name="BrightData.Distributions.BernoulliDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BernoulliDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
			</method>
	<property type="System.Single" name="Probability">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A bernoulli naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class[]" name="ClassData">
		<summary>Classification data</summary>
	</property>
	<property type="System.UInt32[]" name="Vocabulary">
		<summary>The list of string indexes that were in the training set</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.BigEndianBinaryReader" base="System.IO.BinaryReader" is-static="false" is-abstract="false">
	<summary>
		Binary reader for big endian streams
	</summary>
	<method type="System.Void" name="BigEndianBinaryReader" is-static="false">
		<summary>Creates a new big endian binary reader</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Int32" name="ReadInt32" is-static="false">
		<summary>Reads an int</summary>
			</method>
	<method type="System.Int16" name="ReadInt16" is-static="false">
		<summary>Reads a short</summary>
			</method>
	<method type="System.Int64" name="ReadInt64" is-static="false">
		<summary>Reads a long</summary>
			</method>
	<method type="System.UInt32" name="ReadUInt32" is-static="false">
		<summary>Reads a ulong</summary>
			</method>
</class>
<class name="BrightData.BinaryData" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BinaryData" is-static="false">
		<summary></summary>
				<param type="System.Byte[]" name="data" summary="" />
			</method>
	<method type="System.Void" name="BinaryData" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="System.Byte[]" name="Data">
		<summary></summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept two input signals and output one signal
	</summary>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Executes on the primary channel</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="The graph context" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.BinaryIntegers" base="" is-static="false" is-abstract="false">
	<summary>
		Creates random integers and returns feature vectors against binary mathematical logic
	</summary>
	<method type="BrightTable.IRowOrientedDataTable" name="Addition" is-static="true">
		<summary>Creates random integers added together as feature vectors
The input feature contains two features, one for each bit at that position
The output feature contains a single feature: 1 or 0 if that bit is set in the result</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="sampleCount" summary="How many samples to generate" />
			</method>
</class>
<class name="BrightData.Distributions.BinomialDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BinomialDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
				<param type="System.UInt32" name="numTrials" summary="" />
			</method>
	<property type="BrightData.Distributions.BernoulliDistribution" name="BaseDistribution">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="NumTrials">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.BrightDataContext" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BrightDataContext" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="" />
				<param type="System.Int64" name="maxCacheSize" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Random" name="Random">
		<summary></summary>
	</property>
	<property type="BrightData.ITensorPool" name="TensorPool">
		<summary></summary>
	</property>
	<property type="BrightData.IDisposableLayers" name="MemoryLayer">
		<summary></summary>
	</property>
	<property type="BrightData.IDataReader" name="DataReader">
		<summary></summary>
	</property>
	<method type="BrightData.INumericComputation&lt;T&gt;" name="GetComputation" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="BrightData.IProvideTempStreams" name="TempStreamProvider">
		<summary></summary>
	</property>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="System.Func&lt;T&gt;" name="valueCreator" summary="" />
			</method>
	<property type="System.Boolean" name="IsStochastic">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Buffers.BufferedStreamReader" base="" is-static="true" is-abstract="false">
	<summary>
		Buffered stream reader helper
	</summary>
	<method type="BrightData.ICanEnumerate&lt;T&gt;" name="GetReader" is-static="true">
		<summary>Returns a reader that buffers items in memory</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="System.UInt32" name="inMemorySize" summary="Number of bytes to use as an in memory buffer" />
			</method>
</class>
<class name="BrightData.Buffers.BufferWriter" base="" is-static="true" is-abstract="false">
	<summary>
		Buffered stream writer helper
	</summary>
	<method type="System.Void" name="CopyTo" is-static="true">
		<summary>Writes the hybrid buffer to a stream</summary>
				<param type="BrightData.IHybridBuffer&lt;T&gt;" name="buffer" summary="Buffer to write" />
				<param type="System.IO.Stream" name="stream" summary="Stream to write to" />
			</method>
</class>
<class name="BrightData.Analysis.CastToDoubleNumericAnalysis&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CastToDoubleNumericAnalysis" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<property type="BrightData.Analysis.NumericAnalyser" name="Analysis">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability" base="" is-static="false" is-abstract="false">
	<summary>
		A category and its associated log probability
	</summary>
	<property type="System.String" name="Category">
		<summary>The category label</summary>
	</property>
	<property type="System.Double" name="LogProbability">
		<summary>The natural log of the category's probability</summary>
	</property>
	<property type="System.Double" name="Probability">
		<summary>The category's probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.Distributions.CategoricalDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CategoricalDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="categoricalValues" summary="" />
			</method>
	<property type="System.Single[]" name="CumulativeValues">
		<summary></summary>
	</property>
	<property type="System.Single" name="CumulativeTotal">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		A classification
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The log of the prior probablilty for this classification</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The log of the missing probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of probabilities for each string index</summary>
	</property>
	<property type="System.Double" name="InverseMissingProbability">
		<summary>The log of the inverse missing probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		Classification data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification's prior log probability</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The classifications missing log probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of string indexes and their probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary" base="" is-static="false" is-abstract="false">
	<summary>
		A classification and its associated data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="LogPrior">
		<summary>The natural log of the prior</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.Column[]" name="ColumnSummary">
		<summary>The column data associated with this classification</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification prior probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.Column" base="" is-static="false" is-abstract="false">
	<summary>
		A column within the naive bayes model
	</summary>
	<property type="System.UInt32" name="ColumnIndex">
		<summary>Index within the data set</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>Type of column (categorical or continuous)</summary>
	</property>
	<property type="System.Double" name="Variance">
		<summary>The variance of the column values (continuous only)</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>The mean of the column values (continuous only)</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability[]" name="Probability">
		<summary>The list of categories within the column and their probability (categorical only)</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightTable.Transformations.ColumnConversion" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ColumnConversion" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="" />
				<param type="BrightTable.ColumnConversionType" name="type" summary="" />
			</method>
	<method type="System.Void" name="ColumnConversion" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="" />
				<param type="BrightData.ICanConvert" name="converter" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary></summary>
	</property>
	<method type="BrightData.ICanConvert" name="GetConverter" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="fromType" summary="" />
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="implicit operator ColumnConversion" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnConversionType" name="type" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="implicit operator ColumnConversion" is-static="true">
		<summary></summary>
				<param type="(System.UInt32 Index, BrightTable.ColumnConversionType Type)" name="column" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="implicit operator ColumnConversion" is-static="true">
		<summary></summary>
				<param type="(System.UInt32 Index, BrightData.ICanConvert Converter)" name="column" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="Create" is-static="true">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Func&lt;TF, TT&gt;" name="converter" summary="" />
			</method>
</class>
<class name="BrightTable.Transformations.ColumnNormalization" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.ICanConvert" name="GetConverter" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="fromType" summary="" />
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary></summary>
	</property>
	<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary></summary>
	</property>
	<method type="System.Void" name="ColumnNormalization" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="index" summary="" />
				<param type="BrightData.NormalizationType" name="type" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnNormalization" name="implicit operator ColumnNormalization" is-static="true">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnNormalization" name="implicit operator ColumnNormalization" is-static="true">
		<summary></summary>
				<param type="(System.UInt32 Index, BrightData.NormalizationType Type)" name="column" summary="" />
			</method>
</class>
<class name="BrightTable.Helper.ColumnTypeClassifier" base="" is-static="true" is-abstract="false">
	<summary>
		Classifies data table column types
	</summary>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsStructable" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="BrightTable.ColumnClass" name="GetClass" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="FeatureBagCount">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MinDataPerNode">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MaxDepth">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="MinInformationGain">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxAttributes">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.ConfusionMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.String[]" name="ClassificationLabels">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ExpectedClassification[]" name="Classifications">
		<summary></summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="GetCount" is-static="false">
		<summary>Returns the count of the expected vs actual classifications</summary>
				<param type="System.String" name="expected" summary="Expected classification label" />
				<param type="System.String" name="actual" summary="Actual classification label" />
			</method>
</class>
<class name="BrightData.Consts" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
</class>
<class name="BrightData.Distributions.ContinuousDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ContinuousDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="inclusiveLowerBound" summary="" />
				<param type="System.Single" name="exclusiveUpperBound" summary="" />
			</method>
	<property type="System.Single" name="From">
		<summary></summary>
	</property>
	<property type="System.Single" name="Size">
		<summary></summary>
	</property>
	<method type="System.Single" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightTable.Transformations.ColumnConversion.Converter&lt;TF, TT&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Converter" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;TF, TT&gt;" name="converter" summary="" />
			</method>
	<method type="System.Boolean" name="Convert" is-static="false">
		<summary></summary>
				<param type="TF" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;TT&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Void" name="Finalise" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.Type" name="From">
		<summary></summary>
	</property>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Converters.ConverterBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		
	</summary>
	<property type="System.Type" name="From">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Converters.ConvertToFloat&lt;T&gt;" base="BrightData.Converters.ConverterBase&lt;T&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ConvertToFloat" is-static="false">
		<summary></summary>
				<param type="System.Boolean" name="throwOnFailure" summary="" />
			</method>
	<method type="System.Single" name="Convert" is-static="false">
		<summary></summary>
				<param type="T" name="data" summary="" />
			</method>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Analysis.ConvertToStringFrequencyAnalysis&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ConvertToStringFrequencyAnalysis" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<property type="BrightData.Analysis.StringAnalyser" name="Analysis">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightData.Helper.ConvolutionHelper" base="" is-static="true" is-abstract="false">
	<summary>
		Helper class to calculate convolutional indices
	</summary>
	<method type="System.Collections.Generic.List&lt;(System.UInt32 X, System.UInt32 Y)&gt;" name="LeftToRight" is-static="true">
		<summary>Generates convolution indices from left to right</summary>
				<param type="System.UInt32" name="width" summary="Input width" />
				<param type="System.UInt32" name="height" summary="Input height" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="X Stride" />
				<param type="System.UInt32" name="yStride" summary="Y Stride" />
			</method>
	<method type="System.Collections.Generic.List&lt;(System.UInt32 X, System.UInt32 Y)&gt;" name="TopToBottom" is-static="true">
		<summary>Generates convolution indices from top to bottom</summary>
				<param type="System.UInt32" name="width" summary="Input width" />
				<param type="System.UInt32" name="height" summary="Input height" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="X Stride" />
				<param type="System.UInt32" name="yStride" summary="Y Stride" />
			</method>
</class>
<class name="BrightTable.Input.CsvParser" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CsvParser" is-static="false">
		<summary></summary>
				<param type="System.IO.StreamReader" name="stream" summary="" />
				<param type="System.Char" name="delimiter" summary="" />
				<param type="System.Char" name="quote" summary="" />
			</method>
	<property type="System.Action&lt;System.Int32&gt;" name="OnProgress">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String[]&gt;" name="Parse" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.Helper.DataEncoder" base="" is-static="false" is-abstract="false">
	<summary>
		Encodes types from/to bytes
	</summary>
	<method type="System.Void" name="DataEncoder" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="T" name="Read" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="Write" is-static="true">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
				<param type="T" name="val" summary="" />
			</method>
	<method type="System.Void" name="Write" is-static="true">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
				<param type="T[]" name="values" summary="" />
			</method>
</class>
<class name="BrightWire.Models.DataSourceModel" base="" is-static="false" is-abstract="false">
	<summary>
		Serialises an adaptive data source - that is, a data source that takes the output from a preliminary output graph and sends it to the primary graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the data source</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>The size of each input training data item</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>The size of each training item output (classification label)</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>The preliminary graph</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for data table based data adaptors
	</summary>
	<property type="System.UInt32" name="InputCount">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphExecutionContext" name="executionContext" summary="" />
				<param type="System.UInt32[]" name="rows" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith" is-static="false">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
			</method>
	<property type="BrightTable.IVectorise" name="InputVectoriser">
		<summary></summary>
	</property>
	<property type="BrightTable.IVectorise" name="OutputVectoriser">
		<summary></summary>
	</property>
	<method type="System.UInt32[][]" name="GetBuckets" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="OnBatchProcessed" is-static="false">
		<summary></summary>
				<param type="BrightWire.IGraphContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.DataTableBuilder" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightTable.Builders.TableBuilder" name="CreateTwoColumnMatrixTableBuilder" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightTable.Builders.TableBuilder" name="CreateTwoColumnVectorTableBuilder" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightTable.Builders.TableBuilder" name="Create3DTensorToVectorTableBuilder" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightTable.Transformations.DataTableVectoriser" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.UInt32" name="OutputSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="Vectorise" is-static="false">
		<summary></summary>
				<param type="System.Object[]" name="row" summary="" />
			</method>
	<method type="System.Void" name="DataTableVectoriser" is-static="false">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;System.Single&gt;&gt;" name="Enumerate" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="GetOutputLabel" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.UInt32" name="vectorIndex" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.DateAnalyser" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.DateTime" name="date" summary="" />
			</method>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MinDate">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MaxDate">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DateAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="DateAnalysis" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MinDate">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.DateTime&gt;" name="MaxDate">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Helper.DebugHelpers" base="" is-static="true" is-abstract="false">
	<summary>
		Helper classes useful when debugging BW
	</summary>
	<method type="System.String" name="WriteComparison" is-static="true">
		<summary>Zips two tensors and writes the values side by side</summary>
				<param type="BrightData.IIndexable3DFloatTensor" name="t1" summary="First tensor" />
				<param type="BrightData.IIndexable3DFloatTensor" name="t2" summary="Second tensor" />
			</method>
	<method type="System.String" name="WriteComparison" is-static="true">
		<summary>Zips two tensors and writes the values side by side</summary>
				<param type="BrightData.IIndexable4DFloatTensor" name="t1" summary="First tensor" />
				<param type="BrightData.IIndexable4DFloatTensor" name="t2" summary="Second tensor" />
			</method>
	<method type="System.String" name="WriteComparison" is-static="true">
		<summary>Zips two matrices and writes the values side by side</summary>
				<param type="BrightData.IIndexableFloatMatrix" name="m1" summary="First matrix" />
				<param type="BrightData.IIndexableFloatMatrix" name="m2" summary="Second matrix" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.DecisionTree" base="" is-static="false" is-abstract="false">
	<summary>
		A decision tree model
	</summary>
	<property type="System.UInt32" name="ClassColumnIndex">
		<summary>The classification label column index</summary>
	</property>
	<property type="BrightWire.Models.TreeBased.DecisionTree.Node" name="Root">
		<summary>The root of the tree</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Converts the tree to XML</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer" base="" is-static="true" is-abstract="false">
	<summary>
		Decision tree classifier
https://en.wikipedia.org/wiki/Decision_tree_learning
	</summary>
	<method type="BrightWire.Models.TreeBased.DecisionTree" name="Train" is-static="true">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.DimensionAnalyser" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="XDimension">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="YDimension">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ZDimension">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensor&lt;System.Single&gt;" name="obj" summary="" />
			</method>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.DimensionAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="DimensionAnalysis" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="XDimension">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="YDimension">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ZDimension">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Error metrics
	</summary>
	<property type="BrightWire.IErrorMetric" name="BinaryClassification">
		<summary>Binary classification error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="CrossEntropy">
		<summary>Cross entropy error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="OneHotEncoding">
		<summary>One hot encoding error metric</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="Quadratic">
		<summary>Quadratic error metric</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised execution graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Node" name="InputNode">
		<summary>The primary input node</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Node[]" name="OtherNodes">
		<summary>Other connected nodes</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel.Wire[]" name="Wires">
		<summary>A list of the wires that connect the nodes in the graph</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.ExecutionResult" base="" is-static="false" is-abstract="false">
	<summary>
		The output from a mini batch
	</summary>
	<method type="System.Void" name="ExecutionResult" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.IMiniBatchSequence" name="miniBatch" summary="The mini batch sequence" />
				<param type="BrightData.Vector&lt;System.Single&gt;[]" name="output" summary="The mini batch output" />
				<param type="System.UInt32" name="index" summary="Output index" />
			</method>
	<property type="System.UInt32" name="Index">
		<summary>Output index</summary>
	</property>
	<property type="BrightData.Vector&lt;System.Single&gt;[]" name="Output">
		<summary>The list of output rows</summary>
	</property>
	<property type="BrightData.Vector&lt;System.Single&gt;[]" name="Target">
		<summary>The list of target rows</summary>
	</property>
	<property type="BrightData.Vector&lt;System.Single&gt;[][]" name="Input">
		<summary>The list of input rows</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="MiniBatchSequence">
		<summary>The mini batch</summary>
	</property>
	<method type="System.Single" name="CalculateError" is-static="false">
		<summary>Calculates the error of the output against the target</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="The error metric to calculate with" />
			</method>
</class>
<class name="BrightWire.Models.ConfusionMatrix.ExpectedClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ActualClassification[]" name="ActualClassifications">
		<summary></summary>
	</property>
</class>
<class name="BrightTable.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="GetDataType" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
			</method>
	<method type="BrightTable.ColumnType" name="GetColumnType" is-static="true">
		<summary></summary>
				<param type="System.Type" name="dataType" summary="" />
			</method>
	<method type="System.Boolean" name="IsStructable" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsInteger" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Boolean" name="IsIndexed" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Boolean" name="IsTensor" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Type" name="DataType" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTableSegment" name="segment" summary="" />
			</method>
	<method type="System.Type" name="GetDataType" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTableSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="RowIndices" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="ColumnIndices" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IMetaData&gt;" name="AllMetaData" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0, T1&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0, T1, T2&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Action&lt;T0, T1, T2, T3&gt;" name="callback" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;T&gt;" name="MapRows" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Func&lt;System.Object[], System.UInt32, T&gt;" name="callback" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;T&gt;" name="MapRows" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Func&lt;T0, T&gt;" name="callback" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;T&gt;" name="MapRows" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.Func&lt;T0, T1, T&gt;" name="callback" summary="" />
			</method>
	<method type="BrightData.IMetaData[]" name="AllColumnsMetaData" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightData.IDataAnalyser" name="GetColumnAnalyser" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="System.Int32" name="distinctValueCount" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="Analyse" is-static="true">
		<summary></summary>
				<param type="BrightTable.ISingleTypeTableSegment" name="segment" summary="" />
				<param type="System.Boolean" name="force" summary="" />
				<param type="System.Int32" name="distinctValueCount" summary="" />
			</method>
	<method type="BrightData.IMetaData[]" name="GetColumnAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
				<param type="System.Boolean" name="force" summary="" />
				<param type="System.Int32" name="distinctValueCount" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ParseCsv" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.StreamReader" name="reader" summary="" />
				<param type="System.Boolean" name="hasHeader" summary="" />
				<param type="System.Char" name="delimiter" summary="" />
				<param type="System.String" name="fileOutputPath" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
				<param type="System.Boolean" name="writeProgress" summary="" />
				<param type="System.String" name="tempBasePath" summary="" />
			</method>
	<method type="System.Void" name="WriteProgress" is-static="true">
		<summary></summary>
				<param type="System.Int32" name="newProgress" summary="" />
				<param type="System.Int32" name="oldProgress" summary="" />
				<param type="System.Int32" name="max" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;System.Object[]&gt;" name="Head" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="size" summary="" />
			</method>
	<method type="BrightTable.IDataTable" name="LoadTable" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.UInt32" name="CopyToFloatSegment" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTableSegment&lt;T&gt;" name="column" summary="" />
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="vector" summary="" />
			</method>
	<method type="System.UInt32" name="CopyTo" is-static="true">
		<summary></summary>
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="vector" summary="" />
			</method>
	<method type="System.Void" name="SetTargetColumn" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="" />
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="GetTargetColumn" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
			</method>
	<method type="System.UInt32" name="GetTargetColumnOrThrow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="ColumnIndicesOfFeatures" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="SetType" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="BrightTable.ColumnType" name="type" summary="" />
			</method>
	<method type="System.Void" name="SetSequentialColumn" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightData.IHybridBuffer" name="GetGrowableSegment" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="BrightTable.ColumnType" name="type" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="bufferSize" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="BuildColumnOrientedTable" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.List&lt;BrightTable.ISingleTypeTableSegment&gt;" name="segments" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rowCount" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="BuildColumnOrientedTable" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.List&lt;BrightData.IHybridBuffer&gt;" name="buffers" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rowCount" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="BuildColumnOrientedTable" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.List&lt;BrightTable.Segments.GrowableSegment&lt;T&gt;&gt;" name="buffers" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rowCount" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="BuildRowOrientedTable" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.List&lt;BrightData.IHybridBuffer&gt;" name="buffers" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rowCount" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnInfo" name="ChangeColumnType" is-static="true">
		<summary></summary>
				<param type="BrightTable.IColumnInfo" name="column" summary="" />
				<param type="BrightTable.ColumnType" name="newType" summary="" />
			</method>
	<method type="BrightTable.IConvertibleTable" name="AsConvertible" is-static="true">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.Vector&lt;System.Single&gt; Numeric, System.String Label)&gt;" name="GetVectorisedFeatures" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightTable.ColumnType" name="GetColumnType" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.UInt32" name="GetNumDistinct" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="BrightTable.Builders.TableBuilder" name="BuildTable" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="ToRowOriented" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ToColumnOriented" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="(BrightTable.IRowOrientedDataTable Training, BrightTable.IRowOrientedDataTable Test)" name="Split" is-static="true">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="" />
				<param type="System.Double" name="trainingPercentage" summary="" />
				<param type="System.String" name="trainingFilePath" summary="" />
				<param type="System.String" name="testFilePath" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;System.Single&gt;&gt;" name="GetColumnsAsVectors" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="true">
		<summary></summary>
				<param type="BrightTable.ISingleTypeTableSegment" name="segment" summary="" />
			</method>
	<method type="T[]" name="ToArray" is-static="true">
		<summary></summary>
				<param type="BrightTable.ISingleTypeTableSegment" name="segment" summary="" />
			</method>
	<method type="(BrightData.Matrix&lt;System.Single&gt; Features, BrightData.Matrix&lt;System.Single&gt; Target)" name="AsMatrices" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;System.Single&gt;" name="AsMatrix" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Vectorise" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IDataTableSegment&lt;T&gt;" name="Column" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="T[]" name="ToArray" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTableSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightTable.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts indexed classifications to a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts weighted index classifications to a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightTable.IDataTable" name="ConvertToTable" is-static="true">
		<summary>Converts the vector classifications into a data table</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.Vector&lt;System.Single&gt; Data)&gt;" name="data" summary="" />
				<param type="System.Boolean" name="preserveVectors" summary="True to create a data table with a vector column type, false to to convert to columns of floats" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Classification, BrightData.Vector&lt;System.Single&gt; Data)&gt;" name="Vectorise" is-static="true">
		<summary>Converts the weighted index classification list to a list of dense vectors</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Object" name="GetDefaultValue" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Type" name="ToType" is-static="true">
		<summary></summary>
				<param type="System.TypeCode" name="code" summary="" />
			</method>
	<method type="BrightData.IndexList" name="CreateIndexList" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
	<method type="BrightData.WeightedIndexList" name="CreateWeightedIndexList" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="(System.UInt32 Index, System.Single Weight)[]" name="indexList" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="size" summary="" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="size" summary="" />
				<param type="T" name="initializer" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="CreateVector" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[]" name="initialData" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="CreateMatrix" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, T&gt;" name="initializer" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="CreateMatrix" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
				<param type="T" name="initializer" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="CreateMatrixFromRows" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.Vector&lt;T&gt;[]" name="rows" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="CreateMatrixFromRows" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[][]" name="rows" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="CreateMatrixFromColumns" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.Vector&lt;T&gt;[]" name="columns" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="CreateMatrixFromColumns" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[][]" name="columns" summary="" />
			</method>
	<method type="BrightData.Tensor3D&lt;T&gt;" name="CreateTensor3D" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="BrightData.Tensor3D&lt;T&gt;" name="CreateTensor3D" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;[]" name="slices" summary="" />
			</method>
	<method type="BrightData.Tensor4D&lt;T&gt;" name="CreateTensor4D" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.UInt32" name="GetColumnCount" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetRowCount" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetDepth" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.UInt32" name="GetCount" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.WeightedIndexList" name="ToSparse" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="segment" summary="" />
			</method>
	<method type="System.Boolean" name="SetIfNotNull" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="SetIfNotNull" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="HasConversionOperator" is-static="true">
		<summary></summary>
				<param type="System.Type" name="from" summary="" />
				<param type="System.Type" name="to" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Shuffle" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="seq" summary="" />
				<param type="System.Random" name="rnd" summary="" />
			</method>
	<method type="(T[] Training, T[] Test)" name="Split" is-static="true">
		<summary></summary>
				<param type="T[]" name="seq" summary="" />
				<param type="System.Double" name="trainPercentage" summary="" />
			</method>
	<method type="T[]" name="Bag" is-static="true">
		<summary></summary>
				<param type="T[]" name="list" summary="" />
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="" />
			</method>
	<method type="System.String" name="Name" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.UInt32" name="Index" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsTarget" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Boolean" name="IsSequential" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.String" name="Name" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metadataProvider" summary="" />
			</method>
	<method type="System.UInt32" name="Index" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metadataProvider" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metadataProvider" summary="" />
			</method>
	<method type="System.Boolean" name="IsTarget" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metadataProvider" summary="" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metadataProvider" summary="" />
			</method>
	<method type="System.Boolean" name="IsSequential" is-static="true">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metadataProvider" summary="" />
			</method>
	<method type="System.Single" name="CosineDistance" is-static="true">
		<summary></summary>
				<param type="System.Single[]" name="vector" summary="" />
				<param type="System.Single[]" name="other" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance" is-static="true">
		<summary></summary>
				<param type="System.Single[]" name="vector" summary="" />
				<param type="System.Single[]" name="other" summary="" />
			</method>
	<method type="System.Single" name="ManhattanDistance" is-static="true">
		<summary></summary>
				<param type="System.Single[]" name="vector" summary="" />
				<param type="System.Single[]" name="other" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="Mutate" is-static="true">
		<summary></summary>
				<param type="BrightData.Vector&lt;System.Single&gt;" name="vector" summary="" />
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="MutateWith" is-static="true">
		<summary></summary>
				<param type="BrightData.Vector&lt;System.Single&gt;" name="vector" summary="" />
				<param type="BrightData.Vector&lt;System.Single&gt;" name="other" summary="" />
				<param type="System.Func&lt;System.Single, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="GetMetaData" is-static="true">
		<summary></summary>
				<param type="BrightData.IWriteToMetaData" name="writer" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DateAnalysis" name="GetDateAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DimensionAnalysis" name="GetDimensionAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.FrequencyAnalysis" name="GetFrequencyAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.IndexAnalysis" name="GetIndexAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.NumericAnalysis" name="GetNumericAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.StringAnalysis" name="GetStringAnalysis" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.NumericAnalysis" name="Analyze" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DateAnalysis" name="Analyze" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.DateTime&gt;" name="dates" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.DimensionAnalysis" name="Analyze" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.ITensor&lt;System.Single&gt;&gt;" name="tensors" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.IndexAnalysis" name="Analyze" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IHaveIndices&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.StringAnalysis" name="Analyze" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="items" summary="" />
			</method>
	<method type="BrightData.Analysis.Readers.FrequencyAnalysis" name="AnalyzeFrequency" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
	<method type="System.Void" name="InitializeRandomly" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensor&lt;T&gt;" name="tensor" summary="" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="" />
			</method>
	<method type="BrightData.Converters.ConvertToFloat&lt;T&gt;" name="GetFloatConverter" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Void" name="Set" is-static="true">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="vector" summary="" />
				<param type="System.Func&lt;System.UInt32, T&gt;" name="getValue" summary="" />
			</method>
	<method type="BrightData.ICanConvert" name="GetConverter" is-static="true">
		<summary></summary>
				<param type="System.Type" name="toType" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary></summary>
				<param type="System.UInt32" name="count" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary></summary>
				<param type="System.Int32" name="count" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary></summary>
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.UInt32" name="start" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="AsRange" is-static="true">
		<summary></summary>
				<param type="System.Int32" name="count" summary="" />
				<param type="System.Int32" name="start" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="AsFloatVectors" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;System.Single&gt;&gt;" name="vectors" summary="" />
			</method>
	<method type="System.Single" name="Execute" is-static="true">
		<summary></summary>
				<param type="BrightData.OperationType" name="operation" summary="" />
				<param type="System.Collections.Generic.List&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="CreateSegment" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="T[]" name="block" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="CreateSegment" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="size" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="SetTargetColumn" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="isTarget" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="SetCategorical" is-static="true">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="System.Boolean" name="isCategorical" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="ConvertToWeightedIndexList" is-static="true">
		<summary>Converts the indexed classifications to weighted indexed classifications</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Boolean" name="groupByClassification" summary="True to group by classification (i.e convert the bag to a set)" />
			</method>
	<method type="System.Single" name="GetMaxWeight" is-static="true">
		<summary>Finds the greatest weight within the weighted index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the weighted index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.UInt32" name="GetMaxIndex" is-static="true">
		<summary>Find the greatest index within the index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="TFIDF" is-static="true">
		<summary>Modifies the weights in the classification set based on relative corpus statistics to increase the weight of important words relative to each document
https://en.wikipedia.org/wiki/Tf%E2%80%93idf</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="Normalise" is-static="true">
		<summary>Normalises the weighted index classification list to fit between 0 and 1</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.WeightedIndexList Data)&gt;" name="data" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(T Item, System.UInt32 Count)&gt;" name="GroupAndCount" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
	<method type="System.String" name="Format" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(T Item, System.UInt32 Count)&gt;" name="items" summary="" />
			</method>
	<method type="System.Void" name="UseLegacySerialisationInput" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Boolean" name="use" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Single" name="NextFloat" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.UInt32" name="RandomIndex" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="length" summary="" />
			</method>
	<method type="System.UInt32" name="RandomIndex" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="length" summary="" />
			</method>
</class>
<class name="BrightData.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Creates a vector based on an enumerable of floats</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="data" summary="The initial values in the vector" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatVector" name="data" summary="Indexable vector to copy" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IFloatVector" name="data" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.Vector&lt;System.Single&gt;" name="data" summary="Vector to copy" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Single[]" name="data" summary="List of values" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector" is-static="true">
		<summary>Create a vector</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="length" summary="Vector size" />
				<param type="System.Single" name="value" summary="Constant value" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateZeroMatrix" is-static="true">
		<summary>Creates a matrix with every value initialised to zero</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Numer of columns" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.Matrix&lt;System.Single&gt;" name="matrix" summary="Matrix to copy" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary>Create a matrix from a list of row vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.Vector&lt;System.Single&gt;[]" name="rowList" summary="List of vectors (each vector becomes a row in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary>Create a matrix from a list of row vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatVector[]" name="rowList" summary="List of indexable vectors (each vector becomes a row in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary>Create a matrix from a list of column vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.Vector&lt;System.Single&gt;[]" name="columnList" summary="List of vectors (each vector becomes a column in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary>Create a matrix from a list of column vectors</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatVector[]" name="columnList" summary="List of indexable vectors (each vector becomes a column in the new matrix)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="rows" summary="Matrix rows" />
				<param type="System.UInt32" name="columns" summary="Matrix columns" />
				<param type="System.Single" name="value" summary="Constant value" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix" is-static="true">
		<summary>Create a matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.IIndexableFloatMatrix" name="matrix" summary="Indexable matrix to copy" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateIdentityMatrix" is-static="true">
		<summary>Create an identity matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="size" summary="Width and height of the new matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateDiagonalMatrix" is-static="true">
		<summary>Create a diagonal matrix</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Single[]" name="values" summary="List of diagonal values" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor" is-static="true">
		<summary>Create a 3D tensor</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.Tensor3D&lt;System.Single&gt;" name="tensor" summary="The serialised representation of the 3D tensor" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor" is-static="true">
		<summary>Creates a 3D tensor from a list of matrices</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightData.Matrix&lt;System.Single&gt;[]" name="matrices" summary="List of matrices" />
			</method>
	<method type="BrightData.IFloatVector" name="Calculate" is-static="true">
		<summary>Calculates the distance between two matrices</summary>
				<param type="BrightData.DistanceMetric" name="distance" summary="" />
				<param type="BrightData.IFloatMatrix" name="matrix1" summary="" />
				<param type="BrightData.IFloatMatrix" name="matrix2" summary="" />
			</method>
	<method type="System.Single" name="Calculate" is-static="true">
		<summary>Calculates the distance between two vectors</summary>
				<param type="BrightData.DistanceMetric" name="distance" summary="" />
				<param type="BrightData.IFloatVector" name="vector1" summary="" />
				<param type="BrightData.IFloatVector" name="vector2" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;System.Single&gt;&gt;" name="rows" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows" is-static="true">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="rows" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;System.Single&gt;&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns" is-static="true">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="columns" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		Static extension methods
	</summary>
	<method type="BrightWire.IMarkovModelTrainer2&lt;T&gt;" name="CreateMarkovTrainer2" is-static="true">
		<summary>Create a markov model trainer of window size 2</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="BrightWire.IMarkovModelTrainer3&lt;T&gt;" name="CreateMarkovTrainer3" is-static="true">
		<summary>Create a markov model trainer of window size 3</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="minObservations" summary="Minimum number of data points to record an observation" />
			</method>
	<method type="T[]" name="GetFields" is-static="true">
		<summary></summary>
				<param type="BrightTable.IConvertibleRow" name="row" summary="" />
				<param type="System.UInt32[]" name="indices" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightTable.IConvertibleRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classify" is-static="true">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightTable.IConvertibleRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classify" is-static="true">
		<summary></summary>
				<param type="BrightTable.IConvertibleTable" name="convertible" summary="" />
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightData.IFloatVector Vector, System.UInt32 RowIndex, System.String Label)&gt;" name="GetRowsAsLabeledFeatures" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="HierachicalCluster" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="KMeans" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="" />
				<param type="System.UInt32" name="maxIterations" summary="" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, System.String Label)[]&gt;" name="NonNegativeMatrixFactorisation" is-static="true">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="k" summary="" />
				<param type="System.UInt32" name="maxIterations" summary="" />
			</method>
	<method type="System.UInt32" name="GetOutputSizeOrThrow" is-static="true">
		<summary></summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.GraphFactory" name="CreateGraphFactory" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.GraphFactory" name="CreateGraphFactory" is-static="true">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="CreateSequentialWindow" is-static="true">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="System.UInt32" name="windowSize" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightWire.Models.ConfusionMatrix" name="CreateConfusionMatrix" is-static="true">
		<summary>Creates a confusion matrix from two columns of a data table</summary>
				<param type="BrightTable.IConvertibleTable" name="dataTable" summary="Data table" />
				<param type="System.UInt32" name="actualClassificationColumnIndex" summary="The column index of the actual classifications" />
				<param type="System.UInt32" name="expectedClassificationColumnIndex" summary="The column index of the expected classifications" />
			</method>
	<method type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, System.String Classification, System.Single Score)&gt;" name="Classify" is-static="true">
		<summary>Classifies each row of the index classification list</summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;(System.String Label, BrightData.IndexList Data)&gt;" name="data" summary="" />
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="The classifier to classify each item in the list" />
			</method>
	<method type="BrightWire.IRowClassifier" name="AsRowClassifier" is-static="true">
		<summary></summary>
				<param type="BrightWire.IIndexListClassifier" name="classifier" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="BrightData.IIndexStrings" name="indexer" summary="" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Train" is-static="true">
		<summary>Trains a graph for a fixed number of iterations</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="The graph training engine" />
				<param type="System.UInt32" name="numIterations" summary="The number of iterations to train for" />
				<param type="BrightWire.IDataSource" name="testData" summary="The test data source to use" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="The error metric to evaluate the test data against" />
				<param type="System.Action&lt;BrightWire.Models.GraphModel&gt;" name="onImprovement" summary="Optional callback for when the test data score has improved against the error metric" />
				<param type="System.Int32" name="testCadence" summary="Determines how many epochs elapse before the test data is evaluated" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(BrightTable.IConvertibleRow Row, (System.String Label, System.Single Weight)[] Classification)&gt;" name="Classifiy" is-static="true">
		<summary>Classifies each row of the data table</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel" name="GetGraph" is-static="true">
		<summary>Serialises the node and any other connected nodes to an execution graph</summary>
				<param type="BrightWire.INode" name="input" summary="" />
				<param type="System.String" name="name" summary="Name of the graph (optional)" />
			</method>
	<method type="BrightWire.INode" name="CreateFrom" is-static="true">
		<summary>Creates a node and any other connected nodes from a serialised execution graph</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Serialised graph" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;[][]" name="OrderSequentialOutput" is-static="true">
		<summary>Aligns the output of sequential graph execution into an ordered list of results</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="results" summary="Output from sequential graph execution" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the matrix to a generic IGraphData</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="Matrix to convert" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the 3D tensor to a generic IGraphData</summary>
				<param type="BrightData.I3DFloatTensor" name="tensor" summary="Tensor to convert" />
			</method>
	<method type="BrightWire.IGraphData" name="AsGraphData" is-static="true">
		<summary>Converts the 4D tensor to a generic IGraphData</summary>
				<param type="BrightData.I4DFloatTensor" name="tensor" summary="Tensor to convert" />
			</method>
</class>
<class name="BrightWire.ExtensionMethods" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.IRandomProjection" name="CreateRandomProjection" is-static="true">
		<summary>Random projections allow you to reduce the dimensions of a matrix while still preserving significant information</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
				<param type="System.UInt32" name="fixedSize" summary="The vector size to reduce from" />
				<param type="System.UInt32" name="reducedSize" summary="The vector size to reduce to" />
				<param type="System.Int32" name="s" summary="" />
			</method>
	<method type="BrightWire.Models.Linear.LogisticRegression" name="TrainLogisticRegression" is-static="true">
		<summary>Trains a logistic regression model on a data table</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="The training data" />
				<param type="System.UInt32" name="iterations" summary="Number of iterations to train for" />
				<param type="System.Single" name="learningRate" summary="The learning rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Optional callback that is called after each iteration with the current cost" />
			</method>
	<method type="BrightWire.ILogisticRegressionTrainer" name="CreateLogisticRegressionTrainer" is-static="true">
		<summary>Logistic regression learns a sigmoid function over a set of data that learns to classify future values into positive or negative samples</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="The training data provider" />
			</method>
	<method type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a pair of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
			</method>
	<method type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="GetTransitions" is-static="true">
		<summary>Find the next set of state transitions from a tuple of observations</summary>
				<param type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="model" summary="A markov model saved to a dictionary" />
				<param type="T" name="item1" summary="The first observation" />
				<param type="T" name="item2" summary="The second observation" />
				<param type="T" name="item3" summary="The third observation" />
			</method>
	<method type="BrightData.IFloatVector[][]" name="NNMF" is-static="true">
		<summary>Non negative matrix factorisation - clustering based on matrix factorisation. Only applicable for training data that is non-negative.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="data" summary="The training data" />
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear alegbra provider" />
				<param type="System.UInt32" name="k" summary="The number of clusters" />
				<param type="System.UInt32" name="maxIterations" summary="The maximum number of iterations" />
			</method>
	<method type="BrightData.IFloatVector[][]" name="HierachicalCluster" is-static="true">
		<summary>Hierachical clustering successively finds the closest distance between pairs of centroids until k is reached</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="data" summary="The list of vectors to cluster" />
				<param type="System.UInt32" name="k" summary="The number of clusters to find" />
			</method>
	<method type="BrightData.IFloatVector[][]" name="KMeans" is-static="true">
		<summary>K Means uses coordinate descent and a distance metric between randomly selected centroids to cluster the data</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="data" summary="The list of vectors to cluster" />
				<param type="BrightData.IBrightDataContext" name="context" summary="Bright data context" />
				<param type="System.UInt32" name="k" summary="The number of clusters to find" />
				<param type="System.UInt32" name="maxIterations" summary="The maximum number of iterations" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric to use to compare centroids" />
			</method>
	<method type="BrightWire.Models.InstanceBased.KNearestNeighbours" name="TrainKNearestNeighbours" is-static="true">
		<summary>K Nearest Neighbours is an instance based classification method that uses examples from training data to predict classifications</summary>
				<param type="BrightTable.IDataTable" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.Linear.MultinomialLogisticRegression" name="TrainMultinomialLogisticRegression" is-static="true">
		<summary>Multinomial Logistic Regression generalises Logistic Regression to multi-class classification</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="data" summary="The training data" />
				<param type="System.UInt32" name="trainingIterations" summary="Number of training iterations" />
				<param type="System.Single" name="trainingRate" summary="Training rate" />
				<param type="System.Single" name="lambda" summary="L2 regularisation" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Optional callback that is called after each iteration with the current cost" />
			</method>
	<method type="BrightWire.Models.TreeBased.RandomForest" name="TrainRandomForest" is-static="true">
		<summary>Random forests are built on a bagged collection of features to try to capture the most salient points of the training data without overfitting</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="data" summary="The training data" />
				<param type="System.UInt32" name="b" summary="The number of trees in the forest" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="baggedRowCount" summary="" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
	<method type="BrightWire.Models.TreeBased.DecisionTree" name="TrainDecisionTree" is-static="true">
		<summary>Decision trees build a logical tree to classify data. Various measures can be specified to prevent overfitting.</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="data" summary="The training data" />
				<param type="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" name="config" summary="" />
			</method>
	<method type="BrightWire.Models.Bayesian.MultinomialNaiveBayes" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Classification, BrightData.IndexList Data)&gt;" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.Bayesian.MultinomialNaiveBayes" name="TrainMultinomialNaiveBayes" is-static="true">
		<summary>Multinomial naive bayes preserves the count of each feature within the model. Useful for long documents.</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="The training data table that must have a index-list based column to classify against" />
			</method>
	<method type="BrightWire.Models.Bayesian.BernoulliNaiveBayes" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Classification, BrightData.IndexList Data)&gt;" name="data" summary="The training data" />
			</method>
	<method type="BrightWire.Models.Bayesian.BernoulliNaiveBayes" name="TrainBernoulliNaiveBayes" is-static="true">
		<summary>Bernoulli naive bayes treats each feature as either 1 or 0 - all feature counts are discarded. Useful for short documents.</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="The training data table that must have an index-list based column" />
			</method>
	<method type="BrightWire.Models.Bayesian.NaiveBayes" name="TrainNaiveBayes" is-static="true">
		<summary>Naive bayes is a classifier that assumes conditional independence between all features</summary>
				<param type="BrightTable.IDataTable" name="table" summary="The training data provider" />
			</method>
	<method type="BrightWire.ILinearRegressionTrainer" name="CreateLinearRegressionTrainer" is-static="true">
		<summary>Linear regression fits a line to a set of data that allows you predict future values</summary>
				<param type="BrightTable.IDataTable" name="table" summary="The training data table" />
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.String" name="GetBestClassification" is-static="true">
		<summary>Finds the classification with the highest weight</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.String Label, System.Single Weight)&gt;" name="classifications" summary="List of weighted classifications" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel" name="TrainSimpleNeuralNetwork" is-static="true">
		<summary></summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="graph" summary="" />
				<param type="BrightTable.IRowOrientedDataTable" name="trainingTable" summary="" />
				<param type="BrightTable.IRowOrientedDataTable" name="testTable" summary="" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="" />
				<param type="System.Single" name="learningRate" summary="" />
				<param type="System.UInt32" name="batchSize" summary="" />
				<param type="System.UInt32" name="hiddenLayerSize" summary="" />
				<param type="System.UInt32" name="numIterations" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory, BrightWire.INode&gt;" name="activation" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider, BrightWire.ICreateTemplateBasedGradientDescent&gt;" name="gradientDescent" summary="" />
				<param type="System.Func&lt;BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider, BrightWire.IWeightInitialisation&gt;" name="weightInitialisation" summary="" />
			</method>
</class>
<class name="BrightData.FloatTensors.Float3DTensor" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Float3DTensor" is-static="false">
		<summary></summary>
				<param type="BrightData.Tensor3D&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Tensor3D&lt;System.Single&gt;" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.Matrix&lt;System.Single&gt;[]" name="matrices" summary="" />
			</method>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="BrightData.Tensor3D&lt;System.Single&gt;" name="Data">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrixAt" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="depth" summary="" />
			</method>
	<method type="BrightData.IIndexable3DFloatTensor" name="AsIndexable" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="AddPadding" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="RemovePadding" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="padding" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Im2Col" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="(BrightData.I3DFloatTensor Result, BrightData.I3DFloatTensor Indices)" name="MaxPool" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
				<param type="System.Boolean" name="saveIndices" summary="" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseMaxPool" is-static="false">
		<summary></summary>
				<param type="BrightData.I3DFloatTensor" name="indices" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseIm2Col" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="" />
				<param type="System.UInt32" name="outputRows" summary="" />
				<param type="System.UInt32" name="outputColumns" summary="" />
				<param type="System.UInt32" name="outputDepth" summary="" />
				<param type="System.UInt32" name="filterWidth" summary="" />
				<param type="System.UInt32" name="filterHeight" summary="" />
				<param type="System.UInt32" name="xStride" summary="" />
				<param type="System.UInt32" name="yStride" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CombineDepthSlices" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.I3DFloatTensor" name="tensor" summary="" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRow" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="TransposeThisAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.I4DFloatTensor" name="tensor" summary="" />
			</method>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="BrightData.IIndexableFloatMatrix[]" name="Matrix">
		<summary></summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Helper.FloatMath" base="" is-static="true" is-abstract="false">
	<summary>
		Constrained float math helpers - if the value is too small or too big it will be capped. Also NaN values are replaced with zero.
	</summary>
	<method type="System.Single" name="Log" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Exp" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Sqrt" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
				<param type="System.Single" name="adjustment" summary="" />
			</method>
	<method type="System.Single" name="Pow" is-static="true">
		<summary></summary>
				<param type="System.Single" name="x" summary="" />
				<param type="System.Single" name="y" summary="" />
			</method>
	<method type="System.Boolean" name="IsZero" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsNotZero" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="AreEqual" is-static="true">
		<summary></summary>
				<param type="System.Single" name="value1" summary="" />
				<param type="System.Single" name="value2" summary="" />
				<param type="System.Single" name="tolerance" summary="" />
			</method>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<method type="System.Single" name="Constrain" is-static="true">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="System.Single" name="Next" is-static="true">
		<summary></summary>
				<param type="System.Random" name="rand" summary="" />
			</method>
	<method type="System.Collections.Generic.IEqualityComparer&lt;System.Single&gt;" name="GetEqualityComparer" is-static="true">
		<summary></summary>
				<param type="System.Single" name="tolerance" summary="" />
			</method>
	<method type="System.Int32" name="FloatToInt32Bits" is-static="true">
		<summary></summary>
				<param type="System.Single" name="f" summary="" />
			</method>
	<method type="System.Boolean" name="AlmostEqual2SComplement" is-static="true">
		<summary></summary>
				<param type="System.Single" name="a" summary="" />
				<param type="System.Single" name="b" summary="" />
				<param type="System.Int32" name="maxDeltaBits" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="System.Single" name="v1" summary="" />
				<param type="System.Single" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexable4DFloatTensor" name="t1" summary="" />
				<param type="BrightData.IIndexable4DFloatTensor" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexable3DFloatTensor" name="t1" summary="" />
				<param type="BrightData.IIndexable3DFloatTensor" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexableFloatMatrix" name="m1" summary="" />
				<param type="BrightData.IIndexableFloatMatrix" name="m2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.IIndexableFloatVector" name="v1" summary="" />
				<param type="BrightData.IIndexableFloatVector" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.Tensor4D&lt;System.Single&gt;" name="t1" summary="" />
				<param type="BrightData.Tensor4D&lt;System.Single&gt;" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.Tensor3D&lt;System.Single&gt;" name="t1" summary="" />
				<param type="BrightData.Tensor3D&lt;System.Single&gt;" name="t2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.Matrix&lt;System.Single&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;System.Single&gt;" name="m2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
	<method type="System.Boolean" name="AreApproximatelyEqual" is-static="true">
		<summary></summary>
				<param type="BrightData.Vector&lt;System.Single&gt;" name="v1" summary="" />
				<param type="BrightData.Vector&lt;System.Single&gt;" name="v2" summary="" />
				<param type="System.Int32" name="maxDifference" summary="" />
			</method>
</class>
<class name="BrightData.FloatTensors.FloatMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="FloatMatrix" is-static="false">
		<summary></summary>
				<param type="BrightData.Matrix&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Matrix&lt;System.Single&gt;" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.Vector&lt;System.Single&gt;[]" name="rows" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;System.Single&gt;" name="ReadFrom" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatVector" name="Column" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Diagonal" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="Row" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Add" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Subtract" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeThisAndMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="RowSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Transpose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Multiply" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidActivation" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhActivation" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxActivation" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="AddToEachRow" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumn" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<property type="BrightData.Matrix&lt;System.Single&gt;" name="Data">
		<summary></summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="AsIndexable" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromRows" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndexes" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromColumns" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndexes" summary="" />
			</method>
	<method type="System.Void" name="ClearRows" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="" />
			</method>
	<method type="System.Void" name="ClearColumns" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluActivation" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluActivation" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Clone" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Clear" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Sqrt" is-static="false">
		<summary></summary>
				<param type="System.Single" name="valueAdjustment" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Pow" is-static="false">
		<summary></summary>
				<param type="System.Single" name="power" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseDivide" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="System.Void" name="L1Regularisation" is-static="false">
		<summary></summary>
				<param type="System.Single" name="coefficient" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnL2Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="RowL2Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="PointwiseDivideRows" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="PointwiseDivideColumns" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Void" name="Constrain" is-static="false">
		<summary></summary>
				<param type="System.Single" name="min" summary="" />
				<param type="System.Single" name="max" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="GetRowSegment" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.UInt32" name="length" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="GetColumnSegment" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.UInt32" name="rowIndex" summary="" />
				<param type="System.UInt32" name="length" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatColumns" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="bottom" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatRows" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatMatrix" name="right" summary="" />
			</method>
	<method type="(BrightData.IFloatMatrix Left, BrightData.IFloatMatrix Right)" name="SplitAtColumn" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<method type="(BrightData.IFloatMatrix Top, BrightData.IFloatMatrix Bottom)" name="SplitAtRow" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="(BrightData.IFloatMatrix U, BrightData.IFloatVector S, BrightData.IFloatMatrix VT)" name="Svd" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
			</method>
	<method type="System.Single" name="GetAt" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="row" summary="" />
				<param type="System.UInt32" name="column" summary="" />
			</method>
	<method type="System.Void" name="SetAt" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="row" summary="" />
				<param type="System.UInt32" name="column" summary="" />
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="BrightData.IFloatVector[]" name="ColumnVectors" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector[]" name="RowVectors" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Rows">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Columns">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="Map" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<method type="BrightData.IIndexableFloatMatrix" name="MapIndexed" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</class>
<class name="BrightData.FloatTensors.FloatVector" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="FloatVector" is-static="false">
		<summary></summary>
				<param type="BrightData.Vector&lt;System.Single&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single[]" name="ret" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="ReadFrom" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsColumnMatrix" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsRowMatrix" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
	<property type="BrightData.Vector&lt;System.Single&gt;" name="Data">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatVector" name="Add" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Subtract" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="L1Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="L2Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="System.UInt32" name="MaximumIndex" is-static="false">
		<summary></summary>
			</method>
	<method type="System.UInt32" name="MinimumIndex" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Multiply" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.Single" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
				<param type="System.Single" name="coefficient1" summary="" />
				<param type="System.Single" name="coefficient2" summary="" />
			</method>
	<method type="BrightData.IIndexableFloatVector" name="AsIndexable" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="PointwiseMultiply" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="DotProduct" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="GetNewVectorFromIndexes" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Clone" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sqrt" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="Abs" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="CosineDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="ManhattanDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="SquaredEuclidean" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="(System.Single Min, System.Single Max)" name="GetMinMax" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="Average" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="StdDev" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="" />
			</method>
	<method type="System.Void" name="Normalise" is-static="false">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Softmax" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="FindDistances" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="" />
				<param type="BrightData.DistanceMetric" name="distance" summary="" />
			</method>
	<method type="System.Single" name="FindDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="other" summary="" />
				<param type="BrightData.DistanceMetric" name="distance" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="CosineDistance" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="" />
				<param type="System.Single[]" name="dataNorm" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Log" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sigmoid" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="count" summary="" />
			</method>
	<method type="BrightData.IFloatVector[]" name="Split" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="System.Void" name="RotateInPlace" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Reverse" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="GetAt" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Void" name="SetAt" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Single" name="this">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Single[]" name="ToArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single[]" name="GetInternalArray" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IIndexableFloatVector" name="Append" is-static="false">
		<summary></summary>
				<param type="System.Single[]" name="data" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Analysis.FrequencyAnalyser&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="FrequencyAnalyser" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="System.String" name="MostFrequent">
		<summary></summary>
	</property>
	<property type="System.UInt64" name="Total">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String, System.UInt64&gt;&gt;" name="ItemFrequency">
		<summary></summary>
	</property>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.FrequencyAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="FrequencyAnalysis" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.String" name="MostFrequent">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Converters.GenericConverter&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="GenericConverter" is-static="false">
		<summary></summary>
				<param type="T" name="fallback" summary="" />
			</method>
	<method type="(System.Object ConvertedValue, System.Boolean WasSuccessful)" name="ConvertValue" is-static="false">
		<summary></summary>
				<param type="System.Object" name="value" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt gradient descent optimisers
	</summary>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad">
		<summary>Adagrad gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam">
		<summary>Adam gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum">
		<summary>Momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum">
		<summary>Nesterov momentum gradient descent</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp">
		<summary>Rms prop gradient descent</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Provides standard graph actions
	</summary>
	<method type="BrightWire.IAction" name="Constrain" is-static="false">
		<summary>Constrains the signal through the graph (either forward or backward)</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory" base="" is-static="false" is-abstract="false">
	<summary>
		Creates graph nodes
	</summary>
	<method type="System.Void" name="GraphFactory" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider to use" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="A property set with initialisation data (optional)" />
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="BrightWire.IPropertySet" name="CurrentPropertySet">
		<summary>The current property set</summary>
	</property>
	<method type="System.Void" name="PushPropertySet" is-static="false">
		<summary>Clones the current property set with an optional mutator and then pushes it onto the stack</summary>
				<param type="System.Action&lt;BrightWire.IPropertySet&gt;" name="mutator" summary="Callback that can modify the cloned property set" />
			</method>
	<method type="System.Void" name="PopPropertyStack" is-static="false">
		<summary>Pops the last property set from the stack</summary>
			</method>
	<method type="BrightWire.IGradientDescentOptimisation" name="CreateWeightUpdater" is-static="false">
		<summary>Creates a gradient descent optimiser for the given matrix</summary>
				<param type="BrightData.IFloatMatrix" name="weight" summary="" />
			</method>
	<method type="BrightWire.IGraphExecutionContext" name="CreateExecutionContext" is-static="false">
		<summary>Creates a graph execution context</summary>
			</method>
	<method type="BrightWire.ILearningContext" name="CreateLearningContext" is-static="false">
		<summary>Creates a graph learning context</summary>
				<param type="System.Single" name="learningRate" summary="Initial learning rate" />
				<param type="System.UInt32" name="batchSize" summary="Mini batch size" />
				<param type="BrightWire.TrainingErrorCalculation" name="trainingErrorCalculation" summary="How to calculate the training error" />
				<param type="System.Boolean" name="deferUpdates" summary="True to defer updates (used when training recurrent neural networks)" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source with training data" />
				<param type="System.Single" name="learningRate" summary="Initial learning rate" />
				<param type="System.UInt32" name="batchSize" summary="Mini batch size" />
				<param type="BrightWire.TrainingErrorCalculation" name="trainingErrorCalculation" summary="How to calculate the training error" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source with training data" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="The serialised graph to execute" />
				<param type="System.Single" name="trainingRate" summary="Initial learning rate" />
				<param type="System.UInt32" name="batchSize" summary="Mini batch size" />
				<param type="BrightWire.TrainingErrorCalculation" name="trainingErrorCalculation" summary="How to calculate the training error" />
			</method>
	<method type="BrightWire.IGraphTrainingEngine" name="CreateTrainingEngine" is-static="false">
		<summary>Creates a graph training engine</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source with training data" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Previously created training context" />
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="The serialised graph to execute (optional)" />
			</method>
	<method type="BrightWire.IGraphEngine" name="CreateEngine" is-static="false">
		<summary>Creates a graph execution engine</summary>
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="The serialised graph to execute" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of vectors</summary>
				<param type="BrightData.Vector&lt;System.Single&gt;[]" name="vectorList" summary="The list of vectors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of matrices (sequential vectors)</summary>
				<param type="BrightData.Matrix&lt;System.Single&gt;[]" name="sequenceList" summary="The list of matrices that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a list of tensors</summary>
				<param type="BrightData.Tensor3D&lt;System.Single&gt;[]" name="tensorList" summary="The list of tensors that will be the rows in the data source" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates a data source from a data table</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="The data table to convert" />
				<param type="System.UInt32[]" name="featureColumns" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates an adaptive data source (that uses the output from a preliminary graph)</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="Segment that will be sent to the preliminary graph" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context to use while training the preliminary graph" />
				<param type="System.Action&lt;BrightWire.ExecutionGraph.WireBuilder&gt;" name="dataConversionBuilder" summary="Callback to build the preliminary graph" />
			</method>
	<method type="BrightWire.IDataSource" name="CreateDataSource" is-static="false">
		<summary>Creates an adaptive data source from a serialised model</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="Segment that will be sent to the preliminary graph" />
				<param type="BrightWire.Models.DataSourceModel" name="dataSource" summary="The serialised preliminary graph" />
				<param type="BrightWire.ILearningContext" name="learningContext" summary="Learning context to use while training the preliminary graph" />
			</method>
	<method type="(BrightWire.INode RowClassifier, System.UInt32 OutputSize)" name="CreateClassifier" is-static="false">
		<summary>Create a row classifier node</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="The classifier for each row" />
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="The data table that contains the rows to classify (linked by mini batch index)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateFeedForward" is-static="false">
		<summary>Creates a feed forward layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateDropConnect" is-static="false">
		<summary>Creates a new drop connect layer (a feed forward layer with drop out applied to the weights)</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage of connections to drop (0..1)" />
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateTiedFeedForward" is-static="false">
		<summary>Creates a layer whose weights are shared with another layer (but transposed)</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer that shares weights" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateConvolutional" is-static="false">
		<summary>Creates a convolutional layer</summary>
				<param type="System.UInt32" name="inputDepth" summary="Input depth" />
				<param type="System.UInt32" name="filterCount" summary="Number of convolutional filters" />
				<param type="System.UInt32" name="padding" summary="Padding to apply before convolutions" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate the backpropagation error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateMaxPool" is-static="false">
		<summary>Creates a max pooling convolutional layer</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateSimpleRecurrent" is-static="false">
		<summary>Creates a simple recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="BrightWire.INode" name="activation" summary="Activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateElman" is-static="false">
		<summary>Creates an Elman recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateJordan" is-static="false">
		<summary>Creates a Jordan recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateOneMinusInput" is-static="false">
		<summary>Creates a node that subtracts each input from 1 (1-x)</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateSequenceReverser" is-static="false">
		<summary>Creates a node that outputs the reversed index of the current sequence (for bidirectional recurrent networks)</summary>
				<param type="System.Int32" name="index" summary="Input index to reverse" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateBatchNormalisation" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="inputSize" summary="" />
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.INode" name="CreateGru" is-static="false">
		<summary>Creates a GRU recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateRan" is-static="false">
		<summary>Creates a Recurrent Additive Layer (recurrent)</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateLstm" is-static="false">
		<summary>Creates a LSTM recurrent layer</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of incoming connections" />
				<param type="System.Single[]" name="memory" summary="Size of the layer memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateDropOut" is-static="false">
		<summary>Creates a layer that drops random connections</summary>
				<param type="System.Single" name="dropoutPercentage" summary="Percentage to drop (0..1)" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateOutputNode" is-static="false">
		<summary>Creates a node that writes the current forward signal as an output of the graph</summary>
				<param type="System.Int32" name="channel" summary="Output channel" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the engine's input node</summary>
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine to build with" />
				<param type="System.Int32" name="inputIndex" summary="Input index to connect to" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the selected node</summary>
				<param type="System.UInt32" name="inputSize" summary="Number of outgoing connections" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Connect" is-static="false">
		<summary>Builds a new wire from the selected node</summary>
				<param type="System.UInt32" name="width" summary="Volume width" />
				<param type="System.UInt32" name="height" summary="Volume height" />
				<param type="System.UInt32" name="depth" summary="Volume depth" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="Wire to subtract from" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Wire to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Subtract" is-static="false">
		<summary>Subtracts the second input from the first input and sends the result to a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.INode" name="input1" summary="The node to subtract from" />
				<param type="BrightWire.INode" name="input2" summary="The node to subtract" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds the output of two nodes together into a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.INode" name="input1" summary="First node" />
				<param type="BrightWire.INode" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two wires into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Multiply" is-static="false">
		<summary>Multiplies the output of two nodes together into a new wire</summary>
				<param type="System.UInt32" name="inputSize" summary="The number of connections" />
				<param type="BrightWire.INode" name="input1" summary="First node" />
				<param type="BrightWire.INode" name="input2" summary="Second node" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Join" is-static="false">
		<summary>Concatenates two wires together into a new wire</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input1" summary="First wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="input2" summary="Second wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ReverseTemporalJoin" is-static="false">
		<summary>Concatenates two wires together into a new wire, but reverses the temporal index of the second input to realign with reversed sequences</summary>
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="forwardInput" summary="Forward wire to join" />
				<param type="BrightWire.ExecutionGraph.WireBuilder" name="backwardInput" summary="Backward wire to join" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="CreateWrapper" is-static="false">
		<summary>Wraps an existing node, enabling that node to be used at multiple locations in the same graph</summary>
				<param type="BrightWire.INode" name="nodeToWrap" summary="Node to wrap" />
				<param type="System.String" name="name" summary="Optional name to give the wrapping node" />
			</method>
	<method type="BrightWire.INode" name="Create" is-static="false">
		<summary>Creates a node from it's serialised model</summary>
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="node" summary="The node model" />
			</method>
	<method type="BrightWire.INode" name="LeakyReluActivation" is-static="false">
		<summary>Creates a new leaky relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="ReluActivation" is-static="false">
		<summary>Creates a new relu activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="SigmoidActivation" is-static="false">
		<summary>Creates a new sigmoid activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="TanhActivation" is-static="false">
		<summary>Creates a new tanh activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="SoftMaxActivation" is-static="false">
		<summary>Creates a new softmax activation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="ConstantWeightInitialisation" is-static="false">
		<summary>Creates a constant weight initialiser</summary>
				<param type="System.Single" name="biasValue" summary="Single bias value" />
				<param type="System.Single" name="weightValue" summary="Single weight value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="GaussianWeightInitialisation" is-static="false">
		<summary>Creates a gaussian weight initialiser</summary>
				<param type="System.Boolean" name="zeroBias" summary="True to set bias values to zero, otherwise bias initialisation is treated the same as weight initialisation" />
				<param type="System.Single" name="stdDev" summary="Standard deviation of gaussian distribution" />
				<param type="BrightWire.GaussianVarianceCalibration" name="varianceCalibration" summary="How to calibrate the variance" />
				<param type="BrightWire.GaussianVarianceCount" name="varianceCount" summary="How to count connections while calibrating connections" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="IdentityWeightInitialisation" is-static="false">
		<summary>Creates an identity weight initialiser</summary>
				<param type="System.Single" name="identityValue" summary="The value to give to each diagonal value" />
			</method>
	<method type="BrightWire.IWeightInitialisation" name="XavierWeightInitialisation" is-static="false">
		<summary>Creates a xavier weight initialiser</summary>
				<param type="System.Single" name="parameter" summary="Xavier parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="AdaGrad" is-static="false">
		<summary>Creates an AdaGrad gradient descent optimiser</summary>
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Adam" is-static="false">
		<summary>Creates an Adam gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Decay parameter" />
				<param type="System.Single" name="decay2" summary="Second decay parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L1" is-static="false">
		<summary>Creates a L1 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L1 parameter" />
			</method>
	<method type="BrightWire.ICreateGradientDescent" name="L2" is-static="false">
		<summary>Creates a L2 regularisation gradient descent optimiser</summary>
				<param type="System.Single" name="lambda" summary="L2 parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="Momentum" is-static="false">
		<summary>Creats a momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="NesterovMomentum" is-static="false">
		<summary>Creates a nesterov momentum gradient descent optimiser</summary>
				<param type="System.Single" name="momentum" summary="Nesterov momentum parameter" />
			</method>
	<method type="BrightWire.ICreateTemplateBasedGradientDescent" name="RmsProp" is-static="false">
		<summary>Creates a rms prop gradient descent optimiser</summary>
				<param type="System.Single" name="decay" summary="Rms decay" />
			</method>
	<property type="BrightWire.IGradientDescentOptimisation" name="SimpleGradientDescent">
		<summary>Uses vanilla stochastic gradient descent</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" name="Regularisation">
		<summary>Prebuilt regularisation</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GradientDescentProvider" name="GradientDescent">
		<summary>Prebuilt gradient descent optimisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.ErrorMetricProvider" name="ErrorMetric">
		<summary>Error metrics</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" name="WeightInitialisation">
		<summary>Prebuilt weight initialisers</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider" name="GraphOperation">
		<summary>Standard graph operations</summary>
	</property>
	<property type="BrightWire.ExecutionGraph.GraphFactory.GraphActionProvider" name="GraphAction">
		<summary>Standard graph actions</summary>
	</property>
</class>
<class name="BrightWire.Models.GraphModel" base="" is-static="false" is-abstract="false">
	<summary>
		A serialised graph
	</summary>
	<property type="System.String" name="Version">
		<summary>Segment contract version number</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The name of the graph</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>The primary execution graph</summary>
	</property>
	<property type="BrightWire.Models.DataSourceModel" name="DataSource">
		<summary>Optional data source associated with the model</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.GraphOperationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Provides standard graph operations
	</summary>
	<method type="BrightWire.INode" name="OneDividedBy" is-static="false">
		<summary>Calculates inverse (1/x) of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.INode" name="InputSquared" is-static="false">
		<summary>Calculates square (x^2) of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.INode" name="SquareRootOf" is-static="false">
		<summary>Calculates square root of graph input</summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="BrightWire.INode" name="OneMinusInput" is-static="false">
		<summary>Caclculates one minus graph input (1-x)</summary>
				<param type="System.String" name="name" summary="" />
			</method>
</class>
<class name="BrightTable.Segments.GrowableSegment&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="GrowableSegment" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="BrightData.IHybridBuffer&lt;T&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.IMetaData" name="MetaData">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType" name="SingleType">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Length">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsEncoded">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.Buffers.HybridBufferBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		
	</summary>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="T" name="item" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Length">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.IndexAnalyser" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="IndexAnalyser" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="BrightData.IHaveIndices" name="obj" summary="" />
			</method>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.IndexAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="IndexAnalysis" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.UInt32" name="MinIndex">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MaxIndex">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary></summary>
	</property>
</class>
<class name="BrightData.IndexList" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="IndexList" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="Indices">
		<summary>The list of indices</summary>
	</property>
	<method type="BrightData.IndexList" name="Create" is-static="true">
		<summary>Create a new index list with the specified indices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32[]" name="indices" summary="Sparse list of indices" />
			</method>
	<method type="BrightData.IndexList" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="" />
			</method>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the list</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="BrightData.IndexList" name="Merge" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IndexList&gt;" name="lists" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.IndexList" name="ReadFrom" is-static="true">
		<summary>Creates an index list from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<method type="System.String" name="ToXml" is-static="false">
		<summary>Converts the index list to XML</summary>
			</method>
	<method type="System.Single" name="JaccardSimilarity" is-static="false">
		<summary></summary>
				<param type="BrightData.IndexList" name="other" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="ToDense" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxIndex" summary="" />
			</method>
	<method type="System.Boolean" name="HasIndex" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
</class>
<class name="BrightData.Iterators.Iterator&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		Simple iterator with context stack
	</summary>
	<method type="System.Void" name="Iterator" is-static="false">
		<summary></summary>
				<param type="System.Collections.Generic.IReadOnlyList&lt;T&gt;" name="list" summary="" />
			</method>
	<method type="BrightData.Iterators.Iterator&lt;T&gt;" name="Clone" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="First" is-static="false">
		<summary>Get the first element in the collection</summary>
			</method>
	<method type="System.Void" name="Push" is-static="false">
		<summary>Push the context stack</summary>
			</method>
	<method type="System.Int32" name="Pop" is-static="false">
		<summary>Pop the context stack</summary>
				<param type="System.Boolean" name="restore" summary="True to reset the position" />
			</method>
	<property type="System.Boolean" name="HasData">
		<summary>True if the iterator can advance</summary>
	</property>
	<method type="T" name="GetNext" is-static="false">
		<summary>Read and advance the iterator</summary>
			</method>
	<method type="System.Boolean" name="CanPeek" is-static="false">
		<summary>Checks if the specified look ahead is within the array</summary>
				<param type="System.Int32" name="length" summary="How far away to peek" />
			</method>
	<method type="T" name="Peek" is-static="false">
		<summary>Read but does not advance the iterator</summary>
				<param type="System.Int32" name="offset" summary="How far ahead to peek" />
			</method>
	<method type="System.Void" name="Move" is-static="false">
		<summary>Advance the iterator</summary>
				<param type="System.Int32" name="offset" summary="How far to advance" />
			</method>
	<property type="System.Int32" name="Position">
		<summary></summary>
	</property>
	<property type="System.Int32" name="PrevPosition">
		<summary>Position minus 1</summary>
	</property>
	<property type="System.Int32" name="Length">
		<summary></summary>
	</property>
	<method type="System.Void" name="MoveTo" is-static="false">
		<summary>Move to an indexed position</summary>
				<param type="System.Int32" name="position" summary="" />
			</method>
	<method type="BrightData.Iterators.Iterator&lt;T&gt;" name="GetRange" is-static="false">
		<summary>Creates a new iterator with the specified sub range of data</summary>
				<param type="System.Int32" name="start" summary="" />
				<param type="System.Int32" name="end" summary="" />
			</method>
</class>
<class name="BrightWire.Models.InstanceBased.KNearestNeighbours" base="" is-static="false" is-abstract="false">
	<summary>
		K Nearest Neighbour Model
	</summary>
	<property type="BrightData.Vector&lt;System.Single&gt;[]" name="Instance">
		<summary>The list of vectors to match against</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The corresponding list of classifications</summary>
	</property>
	<property type="System.UInt32[]" name="DataColumns">
		<summary>The vector indexes to use to encode a data table row as a vector</summary>
	</property>
	<property type="System.UInt32" name="TargetColumn">
		<summary>The vector indexes to use to encode the other column(s) as a classification target</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
				<param type="System.UInt32" name="k" summary="The number of instances to consider" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="The distance metric to compare each row with each instance" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Linear.LegacyMultinomialLogisticRegressionClassifier" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="LegacyMultinomialLogisticRegressionClassifier" is-static="false">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="BrightWire.Models.Linear.MultinomialLogisticRegression" name="model" summary="" />
			</method>
	<method type="(System.String Label, System.Single Weight)[]" name="Classify" is-static="false">
		<summary></summary>
				<param type="BrightTable.IConvertibleRow" name="row" summary="" />
			</method>
</class>
<class name="BrightWire.Linear.Training.LegacyMultinomialLogisticRegressionTrainner" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightWire.Models.Linear.MultinomialLogisticRegression" name="Train" is-static="true">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="table" summary="" />
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="trainingIterations" summary="" />
				<param type="System.Single" name="trainingRate" summary="" />
				<param type="System.Single" name="lambda" summary="" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.LinearBinnedFrequencyAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="LinearBinnedFrequencyAnalysis" is-static="false">
		<summary></summary>
				<param type="System.Double" name="min" summary="" />
				<param type="System.Double" name="max" summary="" />
				<param type="System.UInt32" name="numBins" summary="" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;(System.Double Start, System.Double End, System.UInt64 Count)&gt;" name="ContinuousFrequency">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.Linear.LinearRegression" base="" is-static="false" is-abstract="false">
	<summary>
		A linear regression model
	</summary>
	<property type="BrightData.Vector&lt;System.Single&gt;" name="Theta">
		<summary>The model parameters</summary>
	</property>
	<method type="BrightWire.ILinearRegressionPredictor" name="CreatePredictor" is-static="false">
		<summary>Creates a predictor from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="The linear algebra provider" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Linear.LogisticRegression" base="" is-static="false" is-abstract="false">
	<summary>
		A logistic regression model
	</summary>
	<property type="BrightData.Vector&lt;System.Single&gt;" name="Theta">
		<summary>The model parameters</summary>
	</property>
	<method type="BrightWire.ILogisticRegressionClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightTable.Transformations.ReinterpretColumns.ManyToOne&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ManyToOne" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="System.UInt32" name="newColumnIndex" summary="" />
				<param type="(BrightTable.IColumnInfo Info, BrightTable.ISingleTypeTableSegment Segment)[]" name="sourceColumns" summary="" />
				<param type="System.Func&lt;BrightData.IBrightDataContext, System.Object[], T&gt;" name="converter" summary="" />
			</method>
	<property type="BrightData.IMetaData" name="MetaData">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Index">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightTable.ColumnType" name="SingleType">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate" is-static="false">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing two items at a time
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;[]" name="Observation">
		<summary>The list of observations</summary>
	</property>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model based on observing the last three observations
	</summary>
	<property type="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;[]" name="Observation">
		<summary>The list of observations</summary>
	</property>
	<property type="System.Collections.Generic.Dictionary&lt;BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;, BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]&gt;" name="AsDictionary">
		<summary>Converts the model to a dictionary</summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation2&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding two items
	</summary>
	<property type="T" name="Item1">
		<summary>The second last preceding item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The last preceding item</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="Transition">
		<summary>The list of possible transitions from this state</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals overide</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hash code override</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelObservation3&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model observation based on the preceding three instances
	</summary>
	<property type="T" name="Item1">
		<summary>The third last item</summary>
	</property>
	<property type="T" name="Item2">
		<summary>The second last item</summary>
	</property>
	<property type="T" name="Item3">
		<summary>The third last item</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;[]" name="Transition">
		<summary>The list of associated transitions</summary>
	</property>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary>Equals override</summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary>Hashcode override</summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MarkovModelStateTransition&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		A markov model state transition
	</summary>
	<property type="T" name="NextState">
		<summary>The next state</summary>
	</property>
	<property type="System.Single" name="Probability">
		<summary>The probability of this next state</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.Matrix&lt;T&gt;" base="BrightData.TensorBase&lt;T, BrightData.Matrix&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Matrix" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="Matrix" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="BrightData.Vector&lt;T&gt;" name="Row" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="Column" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;T&gt;&gt;" name="Rows">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.Vector&lt;T&gt;&gt;" name="Columns">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="T[]" name="ToColumnMajor" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="Transpose" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="GetDiagonal" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="RowSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="ColumnSums" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="Multiply" is-static="false">
		<summary></summary>
				<param type="BrightData.Vector&lt;T&gt;" name="vector" summary="" />
			</method>
</class>
<class name="BrightData.MetaData" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary></summary>
				<param type="BrightData.IHaveMetaData" name="metaData" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="MetaData" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Void" name="CopyTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keysToCopy" summary="" />
			</method>
	<method type="System.Void" name="CopyAllExcept" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Object" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="GetNullable" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="valueIfMissing" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetStringsWithPrefix" is-static="false">
		<summary></summary>
				<param type="System.String" name="prefix" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Helper.MiniBatch" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="MiniBatch" is-static="false">
		<summary>Creates a non sequential mini batch</summary>
				<param type="System.UInt32[]" name="rows" summary="The indices of the rows in this mini batch" />
				<param type="BrightWire.IDataSource" name="dataSource" summary="Associated data source" />
				<param type="BrightWire.IGraphData[]" name="input" summary="Mini batch input data" />
				<param type="BrightWire.IGraphData" name="output" summary="Expected output data (when training, otherwise null)" />
			</method>
	<method type="System.Void" name="MiniBatch" is-static="false">
		<summary>Creates a sequential mini batch</summary>
				<param type="System.UInt32[]" name="rows" summary="The indices of the rows in this mini batch" />
				<param type="BrightWire.IDataSource" name="dataSource" summary="Associated data source" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary>Adds another item to the sequential mini batch</summary>
				<param type="BrightWire.MiniBatchSequenceType" name="type" summary="Type of the sequential item" />
				<param type="BrightWire.IGraphData[]" name="input" summary="Mini batch input data" />
				<param type="BrightWire.IGraphData" name="output" summary="Expected output data (when training, otherwise null)" />
			</method>
	<property type="System.UInt32[]" name="Rows">
		<summary></summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary></summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="SequenceCount">
		<summary></summary>
	</property>
	<method type="System.Void" name="Reset" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.MultiGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept input on an arbitary number of channels and output a single signal
	</summary>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Executes on the primary channel</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="The graph context" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Linear.MultinomialLogisticRegression" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial logistic regression model
	</summary>
	<property type="BrightWire.Models.Linear.LogisticRegression[]" name="Model">
		<summary>The list of logistic regression models</summary>
	</property>
	<property type="System.String[]" name="Classification">
		<summary>The associated classification labels</summary>
	</property>
	<property type="System.UInt32[]" name="FeatureColumn">
		<summary>The columns used to build the dense input vectors</summary>
	</property>
	<method type="BrightWire.ITableClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="Linear algebra provider" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		Multinomial naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class[]" name="ClassData">
		<summary>The list of possible classifications</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary[]" name="Class">
		<summary>A list of possible classifications and their data</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.DecisionTree.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node in the decision tree
	</summary>
	<property type="BrightWire.Models.TreeBased.DecisionTree.Node[]" name="Children">
		<summary>The nodes children</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="ColumnIndex">
		<summary>The column index that is being split on</summary>
	</property>
	<property type="System.String" name="MatchLabel">
		<summary>The value to match this node</summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Split">
		<summary>The value to split on</summary>
	</property>
	<property type="System.String" name="Classification">
		<summary>This node's classification label</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the node as XML</summary>
				<param type="System.Xml.XmlWriter" name="writer" summary="The XML writer" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.ExecutionGraphModel.Node" base="" is-static="false" is-abstract="false">
	<summary>
		A node within the graph
	</summary>
	<method type="System.Void" name="Node" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Node" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.String" name="TypeName">
		<summary>The .NET type name of the node type</summary>
	</property>
	<property type="System.String" name="Id">
		<summary>The unique id within the graph</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Node friendly name</summary>
	</property>
	<property type="System.String" name="Description">
		<summary>A short description of the node</summary>
	</property>
	<property type="System.Byte[]" name="Data">
		<summary>The node's parameters</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.NodeBase" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for graph nodes
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Disposal</summary>
			</method>
	<property type="System.String" name="Id">
		<summary>The node's unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>The node's name in the graph</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.IWire&gt;" name="Output">
		<summary>The list of outgoing wires along which the output signal will be sent</summary>
	</property>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Called when executing forward on the primary channel</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="" />
			</method>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Called when executing forward</summary>
				<param type="BrightWire.IGraphContext" name="context" summary="" />
				<param type="System.UInt32" name="channel" summary="" />
			</method>
	<method type="BrightWire.Models.ExecutionGraphModel.Node" name="SerialiseTo" is-static="false">
		<summary>Serialise this node and any connected nodes</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.INode&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraphModel.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraphModel.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise" is-static="false">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.INode&gt;" name="graph" summary="The complete graph" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Serialise the node</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="Binary writer" />
			</method>
	<method type="System.Void" name="ReadFrom" is-static="false">
		<summary>Deserialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader" />
			</method>
	<method type="BrightWire.INode" name="FindByName" is-static="false">
		<summary>Finds a connected node by friendly name</summary>
				<param type="System.String" name="name" summary="The node's name to search for" />
			</method>
	<method type="BrightWire.INode" name="FindById" is-static="false">
		<summary>Finds a connected node by id</summary>
				<param type="System.String" name="id" summary="Unique id to find" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.INode&gt;" name="SubNodes">
		<summary>The list of sub-nodes</summary>
	</property>
	<method type="System.Void" name="LoadParameters" is-static="false">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="" />
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
</class>
<class name="BrightData.Distributions.NormalDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="NormalDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="mean" summary="" />
				<param type="System.Single" name="stdDev" summary="" />
			</method>
	<property type="System.Single" name="Mean">
		<summary></summary>
	</property>
	<property type="System.Single" name="StdDev">
		<summary></summary>
	</property>
	<method type="System.Single" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightTable.Transformations.ColumnNormalization.Normalizer&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Normalizer" is-static="false">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
				<param type="BrightData.IMetaData" name="analysedMetaData" summary="" />
			</method>
	<method type="System.Boolean" name="Convert" is-static="false">
		<summary></summary>
				<param type="T" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;T&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Void" name="Finalise" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.Type" name="From">
		<summary></summary>
	</property>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
	<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary></summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary></summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Transformation.NormalizeTransformation" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="NormalizeTransformation" is-static="false">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
				<param type="BrightData.IMetaData" name="analysedMetaData" summary="" />
			</method>
	<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary></summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary></summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary></summary>
	</property>
	<method type="System.Double" name="Normalize" is-static="false">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.NumericAnalyser" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="NumericAnalyser" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<property type="System.Double" name="L1Norm">
		<summary></summary>
	</property>
	<property type="System.Double" name="L2Norm">
		<summary></summary>
	</property>
	<property type="System.Double" name="Min">
		<summary></summary>
	</property>
	<property type="System.Double" name="Max">
		<summary></summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Variance">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="StdDev">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Median">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Mode">
		<summary></summary>
	</property>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.NumericAnalysis" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="NumericAnalysis" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.Double" name="L1Norm">
		<summary></summary>
	</property>
	<property type="System.Double" name="L2Norm">
		<summary></summary>
	</property>
	<property type="System.Double" name="Min">
		<summary></summary>
	</property>
	<property type="System.Double" name="Max">
		<summary></summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Variance">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="StdDev">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Median">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="Mode">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="Frequency">
		<summary></summary>
	</property>
	<property type="(System.String Label, System.Double value)[]" name="FrequencyRange">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Buffers.ObjectHybridBuffer&lt;T&gt;" base="BrightData.Buffers.HybridBufferBase&lt;T&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ObjectHybridBuffer" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="maxCount" summary="" />
			</method>
</class>
<class name="BrightTable.Helper.OneHotEncodings" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="OneHotEncodings" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.String[]" name="categories" summary="" />
			</method>
	<property type="System.UInt32" name="ColumnIndex">
		<summary></summary>
	</property>
	<property type="System.String[]" name="Categories">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.Or" base="" is-static="true" is-abstract="false">
	<summary>
		Simple OR training data
	</summary>
	<method type="BrightTable.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing OR training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.Models.TreeBased.RandomForest" base="" is-static="false" is-abstract="false">
	<summary>
		A random forest model
	</summary>
	<property type="BrightWire.Models.TreeBased.DecisionTree[]" name="Forest">
		<summary>The list of trees in the forest</summary>
	</property>
	<method type="BrightWire.IRowClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from the model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.ReberGrammar" base="" is-static="false" is-abstract="false">
	<summary>
		Generates Reber grammar sequences: https://www.willamette.edu/~gorr/classes/cs449/reber.html
	</summary>
	<method type="System.Char" name="GetChar" is-static="true">
		<summary>Gets the character at the specified index</summary>
				<param type="System.Int32" name="index" summary="Index to query" />
			</method>
	<method type="System.Int32" name="GetIndex" is-static="true">
		<summary>Gets the index for the specified character</summary>
				<param type="System.Char" name="ch" summary="The character to query" />
			</method>
	<method type="BrightData.Matrix&lt;System.Single&gt;" name="Encode" is-static="true">
		<summary>Encodes a reber sequence as a sequence of one hot encoded vectors</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.String" name="sequence" summary="The reber sequence to encode" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="GetOneHot" is-static="true">
		<summary>One hot encodes the REBER strings</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="strList" summary="A list of REBER sequences" />
			</method>
	<property type="System.Int32" name="Size">
		<summary>The number of REBER characters</summary>
	</property>
	<method type="System.Void" name="ReberGrammar" is-static="false">
		<summary>Creates a reber grammar builder</summary>
				<param type="System.Random" name="random" summary="Random number provider" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Get" is-static="false">
		<summary>Generates an unlimited number of reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="minlength" summary="Minimum length of the sequences (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxLength" summary="Mimimum length of the sequences (optional)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GetExtended" is-static="false">
		<summary>Generates an unlimited number of extended reber sequences</summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="minlength" summary="Minimum length of the sequences (optional)" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="maxLength" summary="Mimimum length of the sequences (optional)" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.RegularisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt regularisation
	</summary>
	<property type="BrightWire.ICreateGradientDescent" name="L1">
		<summary>L1 regularisation</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="L2">
		<summary>L2 regularisation</summary>
	</property>
</class>
<class name="BrightTable.Transformations.ReinterpretColumns" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ReinterpretColumns" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="newType" summary="" />
				<param type="System.String" name="name" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<property type="BrightTable.ColumnType" name="NewType">
		<summary></summary>
	</property>
	<property type="System.String" name="Name">
		<summary></summary>
	</property>
	<property type="System.UInt32[]" name="ColumnIndices">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.ISingleTypeTableSegment&gt;" name="GetNewColumns" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.IProvideTempStreams" name="tempStreams" summary="" />
				<param type="System.UInt32" name="initialColumnIndex" summary="" />
				<param type="(BrightTable.IColumnInfo Info, BrightTable.ISingleTypeTableSegment Segment)[]" name="columns" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.DataTableAdaptor.RowBasedDataTableAdaptorBase" base="BrightWire.ExecutionGraph.DataTableAdaptor.DataTableAdaptorBase&lt;System.Object[]&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for data tables that work with data table rows
	</summary>
</class>
<class name="BrightWire.ExecutionGraph.Helper.MiniBatch.Sequence" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="SequenceIndex">
		<summary></summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary></summary>
	</property>
	<property type="BrightWire.IGraphData[]" name="Input">
		<summary></summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.SequenceGenerator" base="" is-static="false" is-abstract="false">
	<summary>
		Generates random alphabetical sequences
	</summary>
	<method type="System.Void" name="SequenceGenerator" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="dictionarySize" summary="The number of letters to use" />
				<param type="System.UInt32" name="minSize" summary="The minimum size of each sequence" />
				<param type="System.UInt32" name="maxSize" summary="The maximum size of each sequence" />
				<param type="System.Boolean" name="noRepeat" summary="True to avoid repeating any previous character within each sequence" />
			</method>
	<property type="System.UInt32" name="DictionarySize">
		<summary>The number of letters to use</summary>
	</property>
	<method type="System.String" name="NextSequence" is-static="false">
		<summary>Generates a new sequence</summary>
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="Encode" is-static="false">
		<summary>Converts the character to a one hot encoded vector</summary>
				<param type="System.Char" name="ch" summary="" />
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="Encode" is-static="false">
		<summary>Encodes the characters as a dense vector</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;(System.Char, System.Single)&gt;" name="data" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;System.Single&gt;" name="Encode" is-static="false">
		<summary>Encodes the string as a list of dense vectors within a matrix (each character becomes a row in the matrix)</summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="GenerateSequences" is-static="false">
		<summary>Generator function to generate new sequences</summary>
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SequenceWindowBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Creates a new training feature vector using a window of surrounding features at each point in the input sequence
	</summary>
	<method type="System.Void" name="SequenceWindowBuilder" is-static="false">
		<summary>Creates a new sequence window builder</summary>
				<param type="System.Int32" name="before" summary="The number of previous items to include before each item" />
				<param type="System.Int32" name="after" summary="The number of following items to include after each item" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Single[]&gt;" name="Get" is-static="false">
		<summary>Augments a single sequence</summary>
				<param type="System.Single[][]" name="data" summary="The sequence to analyse" />
			</method>
	<property type="System.Int32" name="OutputSize">
		<summary>The size of the generated training data</summary>
	</property>
</class>
<class name="BrightData.Serialisation.SerialisationHelper" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.String" name="str" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.Int32" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.UInt32" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.Nullable&lt;T&gt;" name="val" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
				<param type="System.Action&lt;T&gt;" name="onWrite" summary="" />
			</method>
	<method type="System.Nullable&lt;T&gt;" name="ReadNullable" is-static="true">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="System.Func&lt;T&gt;" name="onRead" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IReadOnlyCollection&lt;BrightData.ICanWriteToBinaryWriter&gt;" name="list" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="T[]" name="array" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="true">
		<summary></summary>
				<param type="System.String[]" name="array" summary="" />
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="T" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray" is-static="true">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="T[]" name="ReadStructArray" is-static="true">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.String[]" name="ReadStringArray" is-static="true">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightData.Helper.ShapedBase" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<method type="System.Void" name="ShapedBase" is-static="false">
		<summary></summary>
				<param type="System.UInt32[]" name="shape" summary="" />
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Rank">
		<summary></summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.UInt32" name="ReadFrom" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.SimpleTokeniser" base="" is-static="true" is-abstract="false">
	<summary>
		Finds strings of words and numbers in a larger string
	</summary>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Tokenise" is-static="true">
		<summary>Splits the text into smaller word and number strings. Punctuation characters become single character strings.</summary>
				<param type="System.String" name="text" summary="The text to tokenise" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="JoinNegations" is-static="true">
		<summary>Simple token modification following "not".
Double not or punctuation stops the not mode</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="tokenList" summary="The list of tokens" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.String[]&gt;" name="FindSentences" is-static="true">
		<summary>Finds sentences from a list of strings</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="stringList" summary="The list of strings" />
			</method>
	<method type="System.Boolean" name="IsEndOfSentence" is-static="true">
		<summary>Checks if the string is an end of sentence token</summary>
				<param type="System.String" name="str" summary="The string to check" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.SingleBackpropagationBase&lt;T&gt;" base="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that back propagate to a single parent
	</summary>
	<method type="System.Void" name="_Backward" is-static="false">
		<summary>Called when a valid error signal has been received</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IGraphContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="Parents of the current node" />
			</method>
</class>
<class name="BrightData.Analysis.StringAnalyser" base="BrightData.Analysis.FrequencyAnalyser&lt;System.String&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StringAnalyser" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.Readers.StringAnalysis" base="BrightData.Analysis.Readers.FrequencyAnalysis" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StringAnalysis" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<property type="System.UInt32" name="MinLength">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MaxLength">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Buffers.StringHybridBuffer" base="BrightData.Buffers.HybridBufferBase&lt;System.String&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StringHybridBuffer" is-static="false">
		<summary></summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
			</method>
</class>
<class name="BrightData.Helper.StringIndexer" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.Helper.StringIndexer" name="Create" is-static="true">
		<summary></summary>
				<param type="System.String[]" name="strings" summary="" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary></summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<property type="System.UInt32" name="OutputSize">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The probabilities associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The log of the conditional probability</summary>
	</property>
	<property type="System.Double" name="InverseProbability">
		<summary>The log of the inverse conditional probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability" base="" is-static="false" is-abstract="false">
	<summary>
		The conditional probability associated with a string index
	</summary>
	<property type="System.UInt32" name="StringIndex">
		<summary>The string index</summary>
	</property>
	<property type="System.Double" name="ConditionalProbability">
		<summary>The conditional probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.Iterators.StringIterator" base="BrightData.Iterators.Iterator&lt;System.Char&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StringIterator" is-static="false">
		<summary></summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Iterators.StringIterator" name="Clone" is-static="false">
		<summary></summary>
			</method>
	<property type="System.String" name="Data">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" name="Lines">
		<summary></summary>
	</property>
	<method type="System.Boolean" name="IsMatch" is-static="false">
		<summary></summary>
				<param type="System.Char[]" name="list" summary="" />
			</method>
	<method type="System.Boolean" name="Matches" is-static="false">
		<summary></summary>
				<param type="System.String" name="str" summary="" />
			</method>
	<method type="BrightData.Iterators.StringIterator" name="GetRange" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="start" summary="" />
				<param type="System.Int32" name="end" summary="" />
			</method>
</class>
<class name="BrightWire.Models.StringTable" base="" is-static="false" is-abstract="false">
	<summary>
		An array of indexed strings
	</summary>
	<property type="System.String[]" name="Data">
		<summary>The array of indexed strings</summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Helper.StringTableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Assigns string indices to strings
	</summary>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates an empty string table builder</summary>
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="BrightWire.Models.StringTable" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Void" name="StringTableBuilder" is-static="false">
		<summary>Creates a string table builder pre populated with an existing string table</summary>
				<param type="System.String[]" name="stringTable" summary="The string table to pre populate" />
			</method>
	<method type="System.Boolean" name="TryGetIndex" is-static="false">
		<summary>Returns true if the string has already been added</summary>
				<param type="System.String" name="str" summary="The string to check" />
				<param type="System.UInt32" name="ret" summary="The string index" />
			</method>
	<method type="System.UInt32" name="GetIndex" is-static="false">
		<summary>Gets a string index for a string (creates a new index if not found)</summary>
				<param type="System.String" name="str" summary="The string to look up" />
			</method>
	<property type="BrightWire.Models.StringTable" name="StringTable">
		<summary>Serialises the string table</summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary>Returns the size of the string table</summary>
	</property>
	<method type="System.String" name="GetString" is-static="false">
		<summary>Returns the string at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The string index" />
			</method>
</class>
<class name="BrightData.Buffers.StructHybridBuffer&lt;T&gt;" base="BrightData.Buffers.HybridBufferBase&lt;T&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="StructHybridBuffer" is-static="false">
		<summary></summary>
				<param type="BrightData.IProvideTempStreams" name="tempStream" summary="" />
				<param type="System.UInt32" name="maxCount" summary="" />
				<param type="System.UInt16" name="maxDistinct" summary="" />
			</method>
</class>
<class name="BrightTable.Builders.TableBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="System.Void" name="TableBuilder" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<method type="System.Void" name="CopyColumnsFrom" is-static="false">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightData.IMetaData" name="AddColumn" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="type" summary="" />
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="System.Void" name="AddRow" is-static="false">
		<summary></summary>
				<param type="System.Object[]" name="data" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="BuildRowOriented" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="BuildColumnOriented" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.Helper.TempStreamManager" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="TempStreamManager" is-static="false">
		<summary></summary>
				<param type="System.String" name="basePath" summary="" />
			</method>
	<method type="System.IO.Stream" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="uniqueId" summary="" />
			</method>
	<method type="System.Boolean" name="HasStream" is-static="false">
		<summary></summary>
				<param type="System.String" name="uniqueId" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.Tensor3D&lt;T&gt;" base="BrightData.TensorBase&lt;T, BrightData.Tensor3D&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Tensor3D" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="Tensor3D" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.Matrix&lt;T&gt;" name="Matrix" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.Matrix&lt;T&gt;&gt;" name="Matrices">
		<summary></summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="T[]" name="GetAsRaw" is-static="false">
		<summary>Converts the segment to a column major vector</summary>
			</method>
</class>
<class name="BrightData.Tensor4D&lt;T&gt;" base="BrightData.TensorBase&lt;T, BrightData.Tensor4D&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Tensor4D" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="count" summary="" />
				<param type="System.UInt32" name="depth" summary="" />
				<param type="System.UInt32" name="rows" summary="" />
				<param type="System.UInt32" name="columns" summary="" />
			</method>
	<method type="System.Void" name="Tensor4D" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="MatrixSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="TensorSize">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<method type="BrightData.Tensor3D&lt;T&gt;" name="Tensor" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.TensorBase&lt;T, DT&gt;" base="BrightData.Helper.ShapedBase" is-static="false" is-abstract="true">
	<summary>
		
	</summary>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="BrightData.INumericComputation&lt;T&gt;" name="Computation">
		<summary></summary>
	</property>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="GetDataCopy" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="T[]" name="ToArray" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="InitializeFrom" is-static="false">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="DT" name="Add" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace" is-static="false">
		<summary></summary>
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="DT" name="Subtract" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="DT" name="PointwiseMultiply" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace" is-static="false">
		<summary></summary>
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="DT" name="PointwiseDivide" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="DT" name="Multiply" is-static="false">
		<summary></summary>
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="DT" name="Log" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Abs" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Sqrt" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Squared" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Pow" is-static="false">
		<summary></summary>
				<param type="T" name="power" summary="" />
			</method>
	<method type="T" name="DotProduct" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="T" name="Sum" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="Search" is-static="false">
		<summary></summary>
				<param type="T" name="value" summary="" />
			</method>
	<method type="System.Void" name="ConstrainInPlace" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;T&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="maxValue" summary="" />
			</method>
	<method type="T" name="Average" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="L1Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="L2Norm" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="CosineDistance" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="T" name="EuclideanDistance" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="T" name="ManhattanDistance" is-static="false">
		<summary></summary>
				<param type="DT" name="tensor" summary="" />
			</method>
	<method type="T" name="Mean" is-static="false">
		<summary></summary>
			</method>
	<method type="T" name="StdDev" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;T&gt;" name="mean" summary="" />
			</method>
	<method type="DT" name="Softmax" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="SoftmaxDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Sigmoid" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="SigmoidDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Tanh" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="TanhDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Relu" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="ReluDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="LeakyRelu" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="LeakyReluDerivative" is-static="false">
		<summary></summary>
			</method>
	<method type="(T Min, T Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite" is-static="false">
		<summary></summary>
			</method>
	<method type="DT" name="Reverse" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Collections.Generic.List&lt;BrightData.ITensorSegment&lt;T&gt;&gt;" name="Split" is-static="false">
		<summary></summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<property type="BrightData.ITensorSegment&lt;T&gt;" name="Segment">
		<summary></summary>
	</property>
	<method type="DT" name="Clone" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="Reshape" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="Reshape" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.Tensor3D&lt;T&gt;" name="Reshape" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="" />
			</method>
	<method type="BrightData.Tensor4D&lt;T&gt;" name="Reshape" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="count" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="depth" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="rows" summary="" />
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columns" summary="" />
			</method>
	<method type="System.UInt32" name="MaximumIndex" is-static="false">
		<summary>Finds the index with the highest value</summary>
			</method>
	<method type="System.UInt32" name="MinimumIndex" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Helper.TrainingAction" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="TrainingAction" is-static="false">
		<summary>Creates a training action history from a single optional parent</summary>
				<param type="BrightWire.INode" name="source" summary="The node that executed" />
				<param type="BrightWire.IGraphData" name="data" summary="The output of the node" />
				<param type="BrightWire.INode" name="parent" summary="The single parent that contributed to the output (optional)" />
			</method>
	<method type="System.Void" name="TrainingAction" is-static="false">
		<summary>Creates a training action history from multiple parents</summary>
				<param type="BrightWire.INode" name="source" summary="The node that executed" />
				<param type="BrightWire.IGraphData" name="data" summary="The output of the node" />
				<param type="BrightWire.INode[]" name="parents" summary="The parent nodes that contributed to the output" />
			</method>
	<property type="BrightWire.INode" name="Source">
		<summary></summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary></summary>
	</property>
	<property type="BrightWire.IBackpropagation" name="Backpropagation">
		<summary></summary>
	</property>
	<property type="BrightWire.INode[]" name="Parents">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Vector&lt;T&gt;" base="BrightData.TensorBase&lt;T, BrightData.Vector&lt;T&gt;&gt;" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Vector" is-static="false">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Void" name="Vector" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="CopyFrom" is-static="false">
		<summary></summary>
				<param type="T[]" name="array" summary="" />
			</method>
</class>
<class name="BrightWire.Helper.VectorBasedStatistics" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="VectorBasedStatistics" is-static="false">
		<summary></summary>
				<param type="BrightData.ILinearAlgebraProvider" name="lap" summary="" />
				<param type="System.UInt32" name="size" summary="" />
				<param type="System.Single[]" name="mean" summary="" />
				<param type="System.Single[]" name="m2" summary="" />
				<param type="System.UInt32" name="count" summary="" />
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
	<property type="BrightData.IFloatVector" name="Mean">
		<summary></summary>
	</property>
	<property type="BrightData.IFloatVector" name="M2">
		<summary></summary>
	</property>
	<method type="System.Void" name="Update" is-static="false">
		<summary></summary>
				<param type="BrightData.IFloatVector" name="data" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="GetVariance" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.IFloatVector" name="GetSampleVariance" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Helper.VectorDistanceHelper" base="" is-static="false" is-abstract="false">
	<summary>
		Calculates the distance between a list of vectors and a list of vectors to compare against
	</summary>
	<method type="System.Void" name="VectorDistanceHelper" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="List of vectors to compare" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="Distance metric for comparison" />
			</method>
	<property type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IFloatVector&gt;" name="CompareTo">
		<summary>The list of vectors to compare against</summary>
	</property>
	<property type="BrightData.DistanceMetric" name="Metric">
		<summary>Distance metric</summary>
	</property>
	<method type="System.Int32" name="AddComparison" is-static="false">
		<summary>Adds a comparison vector (will be owned and disposed by the helper class)</summary>
				<param type="BrightData.IFloatVector" name="comparison" summary="Vector to compare against" />
			</method>
	<method type="System.Void" name="UpdateComparisonVector" is-static="false">
		<summary>Updates the comparison vector at this index (disposes the old vector)</summary>
				<param type="System.Int32" name="index" summary="Index to update" />
				<param type="BrightData.IFloatVector" name="newVector" summary="Vector to replace with" />
			</method>
	<method type="System.Void" name="SetComparisonVectors" is-static="false">
		<summary>Updates the entire list of comparison vectors</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.IFloatVector&gt;" name="comparisonVectors" summary="List of vectors to compare against" />
			</method>
	<method type="System.UInt32[]" name="GetClosest" is-static="false">
		<summary>Returns the index of the closest comparison vector for each vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="GetAverageFromData" is-static="false">
		<summary>Returns a vector averaged from the data vectors</summary>
				<param type="System.UInt32[]" name="indices" summary="Indices of the data vectors to use in the averaged vector" />
			</method>
</class>
<class name="BrightData.WeightedIndexList" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="WeightedIndexList" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<property type="BrightData.WeightedIndexList.Item[]" name="Indices">
		<summary>The list of indices</summary>
	</property>
	<method type="BrightData.WeightedIndexList" name="Create" is-static="true">
		<summary>Create a new weighted index list with the specified weighted indices</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="BrightData.WeightedIndexList.Item[]" name="indexList" summary="Sparse list of weighted indices" />
			</method>
	<method type="BrightData.WeightedIndexList" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="(System.UInt32 Index, System.Single Weight)[]" name="indexList" summary="" />
			</method>
	<method type="BrightData.WeightedIndexList" name="Create" is-static="true">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.WeightedIndexList.Item&gt;" name="indexList" summary="" />
			</method>
	<property type="System.Int32" name="Count">
		<summary>The number of items in the list</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary>ToString override</summary>
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="BrightData.WeightedIndexList" name="Merge" is-static="true">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightData.WeightedIndexList&gt;" name="lists" summary="" />
				<param type="BrightData.OperationType" name="mergeOperation" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to an XML writer</summary>
				<param type="System.String" name="name" summary="The name to give the data" />
				<param type="System.Xml.XmlWriter" name="writer" summary="The writer to write to" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary>Writes the data to a binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="BrightData.WeightedIndexList" name="ReadFrom" is-static="true">
		<summary>Creates a weighted index list from a binary reader</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="The binary reader" />
			</method>
	<method type="System.String" name="ToXml" is-static="false">
		<summary>Converts the weighted index list to XML</summary>
			</method>
	<method type="BrightData.IndexList" name="AsIndexList" is-static="false">
		<summary>Converts the weighted index-list to an unweighted index-list (only those indices whose weight is not zero)</summary>
			</method>
	<method type="System.Single" name="Dot" is-static="false">
		<summary></summary>
				<param type="BrightData.WeightedIndexList" name="other" summary="" />
			</method>
	<property type="System.Single" name="Magnitude">
		<summary></summary>
	</property>
	<method type="System.Single" name="CosineSimilarity" is-static="false">
		<summary></summary>
				<param type="BrightData.WeightedIndexList" name="other" summary="" />
			</method>
	<method type="System.Single" name="GetMaxWeight" is-static="false">
		<summary></summary>
			</method>
	<method type="BrightData.WeightedIndexList" name="Normalise" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Single" name="JaccardSimilarity" is-static="false">
		<summary></summary>
				<param type="BrightData.WeightedIndexList" name="other" summary="" />
			</method>
	<method type="BrightData.Vector&lt;System.Single&gt;" name="AsDense" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="maxIndex" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.GraphFactory.WeightInitialisationProvider" base="" is-static="false" is-abstract="false">
	<summary>
		Prebuilt weight initialisers
	</summary>
	<property type="BrightWire.IWeightInitialisation" name="Ones">
		<summary>All weights are initialised to 1</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Zeroes">
		<summary>All weights are initialised to 0</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Gaussian">
		<summary>Weights are randomly initialised using a gaussian distribution</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Xavier">
		<summary>Weights are randomly initialised using the xavier algorithm</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity">
		<summary>Weights are initialised to the identity matrix</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="Identity01">
		<summary>Weights are initialised to the identity matrix / 10</summary>
	</property>
</class>
<class name="BrightWire.Models.ExecutionGraphModel.Wire" base="" is-static="false" is-abstract="false">
	<summary>
		Wires connect nodes (aka edges)
	</summary>
	<property type="System.String" name="FromId">
		<summary>The source node id</summary>
	</property>
	<property type="System.String" name="ToId">
		<summary>The target node id</summary>
	</property>
	<property type="System.UInt32" name="InputChannel">
		<summary>The channel on the target node to send the source node's output</summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.WireBuilder" base="" is-static="false" is-abstract="false">
	<summary>
		Wires nodes together to build strands of a graph
	</summary>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.UInt32" name="size" summary="Initial wire size" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes starting from the specified node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.UInt32" name="width" summary="Initial input width" />
				<param type="System.UInt32" name="height" summary="Initial input height" />
				<param type="System.UInt32" name="depth" summary="Initial input depth" />
				<param type="BrightWire.INode" name="node" summary="The node to build from" />
			</method>
	<method type="System.Void" name="WireBuilder" is-static="false">
		<summary>Connects new nodes to the engine output node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="BrightWire.IGraphTrainingEngine" name="engine" summary="Graph engine" />
				<param type="System.UInt32" name="inputIndex" summary="Input index to connect" />
			</method>
	<property type="System.UInt32" name="CurrentSize">
		<summary>The current wire size</summary>
	</property>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="SetNewSize" is-static="false">
		<summary>Changes the current size of the builder</summary>
				<param type="System.UInt32" name="newSize" summary="New wire builder size" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddClassifier" is-static="false">
		<summary>Connects a row classifier</summary>
				<param type="BrightWire.IRowClassifier" name="classifier" summary="" />
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddFeedForward" is-static="false">
		<summary>Adds a feed forward layer</summary>
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddTiedFeedForward" is-static="false">
		<summary>Adds a feed forward layer whose weights are tied to a previous layer</summary>
				<param type="BrightWire.IFeedForward" name="layer" summary="The layer whose weights are tied" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropOut" is-static="false">
		<summary>Adds a drop out layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddDropConnect" is-static="false">
		<summary>Adds a drop connect layer</summary>
				<param type="System.Single" name="dropOutPercentage" summary="Percentage of connections to drop" />
				<param type="System.UInt32" name="outputSize" summary="Number of outgoing connections" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddOutput" is-static="false">
		<summary>Creates a node that writes the current forward signal as an output of the graph</summary>
				<param type="System.Int32" name="channel" summary="Output channel" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Add" is-static="false">
		<summary>Adds a node</summary>
				<param type="BrightWire.INode" name="node" summary="" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddForwardAction" is-static="false">
		<summary>Adds an action that will be executed in the forward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackwardAction" is-static="false">
		<summary>Adds an action that will be executed in the backward pass</summary>
				<param type="BrightWire.IAction" name="action" summary="Action to execute" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBatchNormalisation" is-static="false">
		<summary>Adds a batch normalisation layer</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSimpleRecurrent" is-static="false">
		<summary>Adds a simple recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="Activation layer" />
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddSimpleRecurrent" is-static="false">
		<summary>Adds a simple recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="Activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddElman" is-static="false">
		<summary>Adds an Elman recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddElman" is-static="false">
		<summary>Adds an Elman recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddJordan" is-static="false">
		<summary>Adds a Jordan recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddJordan" is-static="false">
		<summary>Adds a Jordan recurrent neural network layer</summary>
				<param type="BrightWire.INode" name="activation" summary="First activation layer" />
				<param type="BrightWire.INode" name="activation2" summary="Second activation layer" />
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddGru" is-static="false">
		<summary>Adds a gated recurrent unit recurrent neural network layer</summary>
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddGru" is-static="false">
		<summary>Adds a gated recurrent unit recurrent neural network layer</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRan" is-static="false">
		<summary>Adds a recurrent additive layer (recurrent)</summary>
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddRan" is-static="false">
		<summary>Adds a recurrent additive layer (recurrent)</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddLstm" is-static="false">
		<summary>Adds a long short term memory recurrent neural network layer</summary>
				<param type="System.Single[]" name="initialMemory" summary="Initial memory" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddLstm" is-static="false">
		<summary>Adds a long short term memory recurrent neural network layer</summary>
				<param type="System.UInt32" name="memorySize" summary="Size of the memory buffer" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ReverseSequence" is-static="false">
		<summary>Adds a node that will reverse the sequence (for bidirectional recurrent neural networks)</summary>
				<param type="System.Int32" name="index" summary="Input index to reverse" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddMaxPooling" is-static="false">
		<summary>Adds a max pooling convolutional layer</summary>
				<param type="System.UInt32" name="filterWidth" summary="Width of max pooliing filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of max pooling filter" />
				<param type="System.UInt32" name="xStride" summary="X stride" />
				<param type="System.UInt32" name="yStride" summary="Y stride" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddConvolutional" is-static="false">
		<summary>Adds a convolutional layer</summary>
				<param type="System.UInt32" name="filterCount" summary="Number of filters in the layer" />
				<param type="System.UInt32" name="padding" summary="Padding to add before applying the convolutions" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="shouldBackpropagate" summary="True to calculate a backpropagation signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="Transpose" is-static="false">
		<summary>Transposes the graph signal to move between convolutional and non-convolutional layers</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="TransposeAndCombine" is-static="false">
		<summary>Transposes the graph signal and merges each depth slice</summary>
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagation" is-static="false">
		<summary>Adds backpropagation - when executed an error signal will be calculated and flow backwards to previous nodes</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to calculate the error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="AddBackpropagationThroughTime" is-static="false">
		<summary>Adds backpropagation through time</summary>
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to calculate the error signal" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainForwardSignal" is-static="false">
		<summary>Constrains the error signal in the forward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="ConstrainBackwardSignal" is-static="false">
		<summary>Constrains the error signal in the backward direction</summary>
				<param type="System.Single" name="min" summary="Minimum allowed value" />
				<param type="System.Single" name="max" summary="Maximum allowed value" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="WriteNodeMemoryToSlot" is-static="false">
		<summary>Writes node memory to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="BrightWire.IHaveMemoryNode" name="node" summary="The node to read" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.ExecutionGraph.WireBuilder" name="JoinInputWithMemory" is-static="false">
		<summary>Concatenates the named memory slot with the input signal</summary>
				<param type="System.String" name="slotName" summary="Memory slot name" />
				<param type="System.String" name="name" summary="Optional name to give the node" />
			</method>
	<method type="BrightWire.INode" name="Find" is-static="false">
		<summary>Tries to find the specified node</summary>
				<param type="System.String" name="name" summary="The friendly name of the node" />
			</method>
	<property type="BrightWire.INode" name="LastNode">
		<summary>The last added node</summary>
	</property>
</class>
<class name="BrightWire.ExecutionGraph.Helper.WireToNode" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="WireToNode" is-static="false">
		<summary>Constructor</summary>
				<param type="BrightWire.INode" name="node" summary="The destination node" />
				<param type="System.UInt32" name="channel" summary="The input channel on the node" />
			</method>
	<property type="BrightWire.INode" name="SendTo">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Channel">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.Xor" base="" is-static="true" is-abstract="false">
	<summary>
		Simple XOR training data
	</summary>
	<method type="BrightTable.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing XOR training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
</assembly>
