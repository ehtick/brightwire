<assembly>
<enum name="BrightData.BufferType">
	<summary>
		
	</summary>
	<value name="Unknown" value="0" summary="" />
	<value name="Struct" value="1" summary="" />
	<value name="String" value="2" summary="" />
	<value name="EncodedStruct" value="3" summary="" />
	<value name="EncodedString" value="4" summary="" />
	<value name="Object" value="5" summary="" />
</enum>
<enum name="BrightTable.ColumnConversionType">
	<summary>
		
	</summary>
	<value name="Unchanged" value="0" summary="" />
	<value name="ToBoolean" value="1" summary="" />
	<value name="ToDate" value="2" summary="" />
	<value name="ToNumeric" value="3" summary="" />
	<value name="ToString" value="4" summary="" />
	<value name="ToIndexList" value="5" summary="" />
	<value name="ToWeightedIndexList" value="6" summary="" />
	<value name="ToVector" value="7" summary="" />
	<value name="ToCategoricalIndex" value="8" summary="" />
</enum>
<enum name="BrightTable.ColumnType">
	<summary>
		Segment table column type
	</summary>
	<value name="Unknown" value="0" summary="Nothing" />
	<value name="Boolean" value="1" summary="Boolean values" />
	<value name="Byte" value="2" summary="Byte values (-128 to 128)" />
	<value name="Short" value="3" summary="Short values" />
	<value name="Int" value="4" summary="Integer values" />
	<value name="Long" value="5" summary="Long values" />
	<value name="Float" value="6" summary="Float values" />
	<value name="Double" value="7" summary="Double values" />
	<value name="Decimal" value="8" summary="Decimal values" />
	<value name="String" value="9" summary="String values" />
	<value name="Date" value="10" summary="Date values" />
	<value name="IndexList" value="11" summary="List of indices" />
	<value name="WeightedIndexList" value="12" summary="Weighted list of indices" />
	<value name="Vector" value="13" summary="Vector of floats" />
	<value name="Matrix" value="14" summary="Matrix of floats" />
	<value name="Tensor3D" value="15" summary="3D tensor of floats" />
	<value name="Tensor4D" value="16" summary="4D tensor of floats" />
	<value name="BinaryData" value="17" summary="Binary data" />
</enum>
<enum name="BrightWire.Models.Bayesian.NaiveBayes.ColumnType">
	<summary>
		The type of data within the column
	</summary>
	<value name="ContinuousGaussian" value="0" summary="Continuous values" />
	<value name="Categorical" value="1" summary="Categorical values" />
</enum>
<enum name="BrightTable.DataTableOrientation">
	<summary>
		
	</summary>
	<value name="Unknown" value="0" summary="" />
	<value name="RowOriented" value="1" summary="" />
	<value name="ColumnOriented" value="2" summary="" />
</enum>
<enum name="BrightData.DistanceMetric">
	<summary>
		Distance metrics
	</summary>
	<value name="Euclidean" value="0" summary="Euclidean Distance" />
	<value name="Cosine" value="1" summary="Cosine Distance Metric" />
	<value name="Manhattan" value="2" summary="Manhattan Distance" />
	<value name="MeanSquared" value="3" summary="Means Square Error" />
	<value name="SquaredEuclidean" value="4" summary="Square Euclidean" />
</enum>
<enum name="BrightWire.GaussianVarianceCalibration">
	<summary>
		Gaussian weight initialisation type
	</summary>
	<value name="SquareRootN" value="0" summary="Variances are calibrated by dividing by the square root of the connection count" />
	<value name="SquareRoot2N" value="1" summary="Variances are calibrated by multiplying by twice the square root of the connection count" />
</enum>
<enum name="BrightWire.GaussianVarianceCount">
	<summary>
		Gaussian variance count
	</summary>
	<value name="None" value="0" summary="No variance calibration is applied" />
	<value name="FanIn" value="1" summary="The count of incoming connections is used" />
	<value name="FanOut" value="2" summary="The count of outgoing connections is used" />
	<value name="FanInFanOut" value="3" summary="The count incoming and outgoing connections is used" />
</enum>
<enum name="BrightWire.MiniBatchSequenceType">
	<summary>
		Mini batch type
	</summary>
	<value name="Standard" value="0" summary="Standard batch type (non sequential batches have a single standard sequence item)" />
	<value name="SequenceStart" value="1" summary="Start of a sequence" />
	<value name="SequenceEnd" value="2" summary="End of a sequence" />
</enum>
<enum name="BrightData.NormalizationType">
	<summary>
		
	</summary>
	<value name="None" value="0" summary="" />
	<value name="Standard" value="1" summary="" />
	<value name="Euclidean" value="2" summary="" />
	<value name="Manhattan" value="3" summary="" />
	<value name="FeatureScale" value="4" summary="" />
</enum>
<enum name="BrightData.OperationType">
	<summary>
		
	</summary>
	<value name="Add" value="0" summary="" />
	<value name="Average" value="1" summary="" />
	<value name="Max" value="2" summary="" />
</enum>
<enum name="BrightWire.TrainingErrorCalculation">
	<summary>
		Describes how to calculate the training error
	</summary>
	<value name="None" value="0" summary="Do not calculate the training error" />
	<value name="Fast" value="1" summary="Compare the output against the target output and calculate the euclidean distance" />
	<value name="TrainingData" value="2" summary="Execute the model against the training data" />
</enum>

<interface name="BrightData.I3DFloatTensor" base="System.IDisposable">
	<summary>
		A list of matrices
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows in each matrix</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns in each matrix</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>The number of matrices</summary>
	</property>
	<property type="BrightData.Tensor3D&lt;System.Single&gt;" name="Data">
		<summary>Converts the current tensor to protobuf format</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrixAt">
		<summary>Returns a matrix at the specified depth</summary>
				<param type="System.UInt32" name="depth" summary="The depth to query" />
			</method>
	<method type="BrightData.IIndexable3DFloatTensor" name="AsIndexable">
		<summary>Returns an indexable 3D tensor</summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="AddPadding">
		<summary>Adds padding to each matrix</summary>
				<param type="System.UInt32" name="padding" summary="The padding (both vertical and horizontal)" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="RemovePadding">
		<summary>Removes padding from each matrix</summary>
				<param type="System.UInt32" name="padding" summary="The padding to remove" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Im2Col">
		<summary>Performs a convolution on each source matrix</summary>
				<param type="System.UInt32" name="filterWidth" summary="The filter width" />
				<param type="System.UInt32" name="filterHeight" summary="The filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Converts the tensor to a vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Converts the tensor to a matrix (each depth slice becomes a column in the new matrix)</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Reshapes the 3D tensor into a 4D tensor (the current depth becomes the count of 3D tensors and columns becomes the new depth)</summary>
				<param type="System.UInt32" name="rows" summary="Rows in each 4D tensor" />
				<param type="System.UInt32" name="columns" summary="Columns in each 4D tensor" />
			</method>
	<method type="(BrightData.I3DFloatTensor Result, BrightData.I3DFloatTensor Indices)" name="MaxPool">
		<summary>Performs a max pooling operation on the tensor</summary>
				<param type="System.UInt32" name="filterWidth" summary="The pooling filter width" />
				<param type="System.UInt32" name="filterHeight" summary="The pooling filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="saveIndices" summary="True to save the indices for a future reverse max pool operation" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseMaxPool">
		<summary>Reverses a max pooling operation</summary>
				<param type="BrightData.I3DFloatTensor" name="indices" summary="A tensor that contains the indices of each maximum value that was found per filter" />
				<param type="System.UInt32" name="outputRows" summary="Input rows" />
				<param type="System.UInt32" name="outputColumns" summary="Input columns" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReverseIm2Col">
		<summary>Reverses a im2col operation</summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="The rotated filters" />
				<param type="System.UInt32" name="outputRows" summary="Rows of the input tensor" />
				<param type="System.UInt32" name="outputColumns" summary="Columns of the input tensor" />
				<param type="System.UInt32" name="outputDepth" summary="Depth of the input tensor" />
				<param type="System.UInt32" name="filterWidth" summary="Width of each filter" />
				<param type="System.UInt32" name="filterHeight" summary="Height of each filter" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CombineDepthSlices">
		<summary>Adds each depth slice into a single matrix</summary>
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the other tensor to the current tensor</summary>
				<param type="BrightData.I3DFloatTensor" name="tensor" summary="Tensor to add" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Multiply">
		<summary>Multiplies the tensor with the other matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="Matrix to multiply with" />
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the vector to each row of the tensor</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="Vector to add to each row" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="TransposeThisAndMultiply">
		<summary>Transpose each sub matrix in the current tensor before multiplying it with each each sub tensor (converted to a matrix)</summary>
				<param type="BrightData.I4DFloatTensor" name="tensor" summary="Tensor to multiply with" />
			</method>
</interface>
<interface name="BrightData.I4DFloatTensor" base="System.IDisposable">
	<summary>
		A list of 3D tensors
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows in each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns in each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>The depth of each 3D tensor</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>The count of 3D tensors</summary>
	</property>
	<method type="BrightData.I3DFloatTensor" name="GetTensorAt">
		<summary>Returns the tensor at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The index to query" />
			</method>
	<method type="BrightData.IIndexable4DFloatTensor" name="AsIndexable">
		<summary>Returns an indexable list of 3D tensors</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="AddPadding">
		<summary>Adds padding to the 4D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Padding to add to the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="RemovePadding">
		<summary>Removes padding from the 4D tensor</summary>
				<param type="System.UInt32" name="padding" summary="Padding to remove from the left, top, right and bottom edges of the tensor" />
			</method>
	<method type="(BrightData.I4DFloatTensor Result, BrightData.I4DFloatTensor Indices)" name="MaxPool">
		<summary>Applies a max pooling operation to the current tensor</summary>
				<param type="System.UInt32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
				<param type="System.Boolean" name="saveIndices" summary="True to save the indices for a future reverse pool operation" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReverseMaxPool">
		<summary>Reverses a max pool operation</summary>
				<param type="BrightData.I4DFloatTensor" name="indices" summary="Tensor of indices from MaxPool operation" />
				<param type="System.UInt32" name="outputRows" summary="Input tensor rows" />
				<param type="System.UInt32" name="outputColumns" summary="Input tensor columns" />
				<param type="System.UInt32" name="filterWidth" summary="Max pool filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Max pool filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Im2Col">
		<summary>Applies the convolutional filter to each 3D tensor, producing a 3D tensor which can be multipled by the filter matrix</summary>
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReverseIm2Col">
		<summary>Reverse a previously applied im2Col</summary>
				<param type="BrightData.IFloatMatrix" name="filter" summary="List of filters that have been rotated 180 degrees" />
				<param type="System.UInt32" name="outputRows" summary="Rows of the input 4D tensor" />
				<param type="System.UInt32" name="outputColumns" summary="Columns of the input 4D tensor" />
				<param type="System.UInt32" name="outputDepth" summary="Depth of the input 4D tensor" />
				<param type="System.UInt32" name="filterWidth" summary="Filter width" />
				<param type="System.UInt32" name="filterHeight" summary="Filter height" />
				<param type="System.UInt32" name="xStride" summary="Filter x stride" />
				<param type="System.UInt32" name="yStride" summary="Filter y stride" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums">
		<summary>Sums the columns of each sub-tensor's sub matrix</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Converts the tensor to a vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Converts the tensor to a matrix (each 3D tensor becomes a column in the new matrix)</summary>
			</method>
	<property type="BrightData.Tensor3D&lt;System.Single&gt;[]" name="Data">
		<summary>Converts the current tensor to protobuf format</summary>
	</property>
</interface>
<interface name="BrightWire.IAction" base="">
	<summary>
		An action to perform when a signal reaches a node
	</summary>
		<method type="BrightWire.IGraphData" name="Execute">
		<summary>Executes the action</summary>
				<param type="BrightWire.IGraphData" name="input" summary="Current graph signal" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
			</method>
	<method type="System.String" name="Serialise">
		<summary>Serialises the action to a string</summary>
			</method>
	<method type="System.Void" name="Initialise">
		<summary>Initialises the action</summary>
				<param type="System.String" name="data" summary="Previously serialised data" />
			</method>
</interface>
<interface name="BrightWire.IAdaptiveDataSource" base="">
	<summary>
		Adaptive data sources apply the output from a preliminary graph
	</summary>
		<property type="BrightWire.INode" name="AdaptiveInput">
		<summary>The input node of the preliminary graph</summary>
	</property>
	<method type="BrightWire.Models.DataSourceModel" name="GetModel">
		<summary>Gets the serialised preliminary graph</summary>
				<param type="System.String" name="name" summary="Optional name to give the data source" />
			</method>
</interface>
<interface name="BrightWire.IBackpropagation" base="System.IDisposable">
	<summary>
		Backpropagation handler
	</summary>
		<method type="System.Void" name="Backward">
		<summary>Backpropagate</summary>
				<param type="BrightWire.INode" name="fromNode" summary="Node that sent the signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="The current node's parents" />
			</method>
</interface>
<interface name="BrightData.IBrightDataContext" base="System.IDisposable">
	<summary>
		
	</summary>
		<property type="System.Random" name="Random">
		<summary></summary>
	</property>
	<property type="BrightData.ITensorPool" name="TensorPool">
		<summary></summary>
	</property>
	<property type="BrightData.IDisposableLayers" name="MemoryLayer">
		<summary></summary>
	</property>
	<property type="BrightData.IDataReader" name="DataReader">
		<summary></summary>
	</property>
	<method type="BrightData.INumericComputation&lt;T&gt;" name="GetComputation">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="BrightData.IProvideTempStreams" name="TempStreamProvider">
		<summary></summary>
	</property>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Set">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="T" name="Set">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="System.Func&lt;T&gt;" name="valueCreator" summary="" />
			</method>
</interface>
<interface name="BrightData.ICanConvert" base="">
	<summary>
		
	</summary>
		<property type="System.Type" name="From">
		<summary></summary>
	</property>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ICanConvert&lt;TF, TT&gt;" base="BrightData.ICanConvert">
	<summary>
		
	</summary>
		<method type="TT" name="Convert">
		<summary></summary>
				<param type="TF" name="data" summary="" />
			</method>
</interface>
<interface name="BrightData.ICanEnumerate&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.ICanInitialiseNode" base="">
	<summary>
		Interface that allows the node to be initialised
	</summary>
		<method type="System.Void" name="Initialise">
		<summary>Initialise the node</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.String" name="id" summary="Node unique id" />
				<param type="System.String" name="name" summary="Friendly name" />
				<param type="System.String" name="description" summary="Node description" />
				<param type="System.Byte[]" name="data" summary="Serialisation data" />
			</method>
</interface>
<interface name="BrightData.ICanInitializeFromBinaryReader" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialise" base="">
	<summary>
		Serialisation interface for graph components
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary>Writes the node state to the binary writer</summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary>Reads the node state</summary>
				<param type="BrightWire.ExecutionGraph.GraphFactory" name="factory" summary="Graph factory" />
				<param type="System.IO.BinaryReader" name="reader" summary="Binary reader that holds the node's state" />
			</method>
</interface>
<interface name="BrightWire.ICanSerialiseToStream" base="">
	<summary>
		Standard serialisation interface
	</summary>
		<method type="System.Void" name="SerialiseTo">
		<summary>Writes the current object state to the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to write to" />
			</method>
	<method type="System.Void" name="DeserialiseFrom">
		<summary>Reads the current object state from the stream</summary>
				<param type="System.IO.Stream" name="stream" summary="Stream to read from" />
				<param type="System.Boolean" name="clear" summary="True to clear the existing state" />
			</method>
</interface>
<interface name="BrightData.ICanWriteToBinaryWriter" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
</interface>
<interface name="BrightTable.IColumnInfo" base="BrightData.IHaveMetaData">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="Index">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType" name="ColumnType">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IColumnOrientedDataTable" base="BrightTable.IDataTable">
	<summary>
		
	</summary>
		<method type="BrightTable.IRowOrientedDataTable" name="AsRowOriented">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Convert">
		<summary></summary>
				<param type="BrightTable.Transformations.ColumnConversion[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Convert">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.Transformations.ColumnConversion[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Normalize">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Normalize">
		<summary></summary>
				<param type="BrightTable.Transformations.ColumnNormalization[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="Normalize">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.Transformations.ColumnNormalization[]" name="conversion" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="SelectColumns">
		<summary></summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="SelectColumns">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ConcatColumns">
		<summary></summary>
				<param type="BrightTable.IColumnOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="ConcatColumns">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.IColumnOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IColumnOrientedDataTable" name="FilterRows">
		<summary></summary>
				<param type="System.Predicate&lt;System.Object[]&gt;" name="predicate" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
</interface>
<interface name="BrightTable.IColumnTransformation" base="">
	<summary>
		
	</summary>
		<method type="System.UInt32" name="Transform">
		<summary></summary>
			</method>
	<property type="BrightData.IHybridBuffer" name="Buffer">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IColumnTransformationParam" base="">
	<summary>
		
	</summary>
		<property type="System.Nullable&lt;System.UInt32&gt;" name="Index">
		<summary></summary>
	</property>
	<method type="BrightData.ICanConvert" name="GetConverter">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="fromType" summary="" />
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.Helper.TempStreamManager" name="tempStreams" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
			</method>
</interface>
<interface name="BrightWire.IContext" base="System.IDisposable">
	<summary>
		Graph context
	</summary>
		<property type="System.Boolean" name="IsTraining">
		<summary>True if the graph is currently training</summary>
	</property>
	<property type="BrightWire.INode" name="Source">
		<summary>Node that sent the current signal</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Current signal</summary>
	</property>
	<property type="BrightWire.IExecutionContext" name="ExecutionContext">
		<summary>Current execution context</summary>
	</property>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Current learning context (optional)</summary>
	</property>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="BatchSequence">
		<summary>Current mini batch sequence</summary>
	</property>
	<method type="System.Void" name="AddForward">
		<summary>Records node execution</summary>
				<param type="BrightWire.IExecutionHistory" name="action" summary="Record of node execution" />
				<param type="System.Func&lt;BrightWire.IBackpropagation&gt;" name="callback" summary="Optional callback to add backpropagation" />
			</method>
	<method type="System.Void" name="AddBackward">
		<summary>Sends a backward error signal</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.INode" name="target" summary="Node to send to" />
				<param type="BrightWire.INode" name="source" summary="Node that sent the error" />
			</method>
	<method type="System.Void" name="AppendErrorSignal">
		<summary>Records an error signal against a node</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="Error signal" />
				<param type="BrightWire.INode" name="forNode" summary="Node to record against" />
			</method>
	<method type="System.Void" name="Backpropagate">
		<summary>Backpropagates the signal</summary>
				<param type="BrightWire.IGraphData" name="delta" summary="Error signal" />
			</method>
	<property type="BrightWire.IGraphData" name="ErrorSignal">
		<summary>Current error signal</summary>
	</property>
	<property type="System.Boolean" name="HasNext">
		<summary>Checks if there is a pending forward graph operation</summary>
	</property>
	<method type="System.Boolean" name="ExecuteNext">
		<summary>Executes the next pending forward graph operation</summary>
			</method>
	<method type="System.Void" name="SetOutput">
		<summary>Saves the data as an output of the graph</summary>
				<param type="BrightWire.IGraphData" name="data" summary="Segment to save" />
				<param type="System.Int32" name="channel" summary="Channel to save against (optional)" />
			</method>
	<method type="BrightWire.IGraphData" name="GetOutput">
		<summary>Returns a saved output</summary>
				<param type="System.Int32" name="channel" summary="Output channel (optional)" />
			</method>
	<property type="BrightWire.IGraphData[]" name="Output">
		<summary>Returns all stored output</summary>
	</property>
</interface>
<interface name="BrightData.IContinuousDistribution" base="BrightData.IDistribution&lt;System.Single&gt;">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightTable.IConvert&lt;TF, TT&gt;" base="BrightData.ICanConvert">
	<summary>
		
	</summary>
		<method type="System.Boolean" name="Convert">
		<summary></summary>
				<param type="TF" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;TT&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Void" name="Finalise">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
</interface>
<interface name="BrightTable.IConvertibleRow" base="BrightTable.IHaveDataTable">
	<summary>
		
	</summary>
		<property type="BrightTable.IDataTableSegment" name="Segment">
		<summary></summary>
	</property>
	<method type="T" name="GetField">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<property type="System.UInt32" name="RowIndex">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IConvertibleTable" base="">
	<summary>
		
	</summary>
		<method type="BrightTable.IConvertibleRow" name="GetRow">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.IConvertibleRow&gt;" name="Rows">
		<summary></summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<property type="BrightTable.IRowOrientedDataTable" name="DataTable">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Map">
		<summary></summary>
				<param type="System.Func&lt;BrightTable.IConvertibleRow, T&gt;" name="rowMapper" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Action&lt;BrightTable.IConvertibleRow&gt;" name="action" summary="" />
			</method>
</interface>
<interface name="BrightWire.ICreateGradientDescent" base="">
	<summary>
		Creates a gradient descent optimisation
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation</summary>
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightWire.ICreateTemplateBasedGradientDescent" base="">
	<summary>
		Creates gradient descent optimisations based on a matrix
	</summary>
		<method type="BrightWire.IGradientDescentOptimisation" name="Create">
		<summary>Creates the gradient descent optimisation for a particular target matrix</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="prev" summary="Any other previously created gradient descent optimisation in this context" />
				<param type="BrightData.IFloatMatrix" name="template" summary="The instance of the matrix that will be updated" />
				<param type="BrightWire.IPropertySet" name="propertySet" summary="The property set that contains initialisation parameters" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser" base="BrightData.IWriteToMetaData">
	<summary>
		
	</summary>
		<method type="System.Void" name="AddObject">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataAnalyser&lt;T&gt;" base="BrightData.IDataAnalyser">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IDataReader" base="">
	<summary>
		
	</summary>
		<method type="T" name="Read">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="T[]" name="ReadArray">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.IDataSource" base="">
	<summary>
		Segment sources feed data into a graph
	</summary>
		<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="InputSize">
		<summary>The size of the input data</summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="OutputSize">
		<summary>The size of the output data</summary>
	</property>
	<property type="System.UInt32" name="InputCount">
		<summary>The number of inputs that can feed into the graph</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>Number of rows</summary>
	</property>
	<method type="BrightWire.IMiniBatch" name="Get">
		<summary>Gets a mini batch with the specified rows</summary>
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.UInt32[]" name="rows" summary="List of rows" />
			</method>
	<method type="System.UInt32[][]" name="GetBuckets">
		<summary>For sequential data, returns the row indexes grouped by sequence length</summary>
			</method>
	<method type="System.Void" name="OnBatchProcessed">
		<summary>Called when the current batch has completed</summary>
				<param type="BrightWire.IContext" name="context" summary="" />
			</method>
	<method type="BrightWire.IDataSource" name="CloneWith">
		<summary>Creates a new data source, using the current as a template but replacing the data table</summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="The new data table" />
			</method>
</interface>
<interface name="BrightTable.IDataTable" base="BrightData.IHaveMetaData">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="RowCount">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="ColumnCount">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType[]" name="ColumnTypes">
		<summary></summary>
	</property>
	<property type="BrightTable.DataTableOrientation" name="Orientation">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightData.IMetaData&gt;" name="ColumnMetaData">
		<summary></summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Action&lt;System.Object[], System.UInt32&gt;" name="callback" summary="" />
				<param type="System.UInt32" name="maxRows" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.ISingleTypeTableSegment&gt;" name="Columns">
		<summary></summary>
				<param type="System.UInt32[]" name="columnIndices" summary="" />
			</method>
	<method type="System.Void" name="ReadTyped">
		<summary></summary>
				<param type="BrightTable.ITypedRowConsumer[]" name="consumers" summary="" />
				<param type="System.UInt32" name="maxRows" summary="" />
			</method>
	<method type="BrightTable.ISingleTypeTableSegment" name="Column">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
</interface>
<interface name="BrightTable.IDataTableSegment" base="">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType[]" name="Types">
		<summary></summary>
	</property>
	<property type="System.Object" name="this">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IDataTableSegment&lt;T&gt;" base="BrightTable.ISingleTypeTableSegment">
	<summary>
		
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary></summary>
			</method>
</interface>
<interface name="BrightData.IDiscreteDistribution" base="BrightData.IDistribution&lt;System.Int32&gt;">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightData.IDisposableLayers" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="System.IDisposable" name="disposable" summary="" />
			</method>
	<method type="System.IDisposable" name="Push">
		<summary></summary>
			</method>
	<method type="System.Void" name="Pop">
		<summary></summary>
			</method>
</interface>
<interface name="BrightData.IDistribution&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="T" name="Sample">
		<summary></summary>
			</method>
</interface>
<interface name="BrightTable.IEditableBuffer" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Set">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Object" name="value" summary="" />
			</method>
	<method type="System.Void" name="Finalise">
		<summary></summary>
			</method>
</interface>
<interface name="BrightTable.IEditableBuffer&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="Set">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="T" name="value" summary="" />
			</method>
</interface>
<interface name="BrightWire.IErrorMetric" base="">
	<summary>
		Error metrics used to quantify machine learning
	</summary>
		<property type="System.Boolean" name="DisplayAsPercentage">
		<summary>True if the result should be formatted as a percentage</summary>
	</property>
	<method type="System.Single" name="Compute">
		<summary>Computes the error between the output vector and target vector</summary>
				<param type="BrightData.Vector&lt;System.Single&gt;" name="output" summary="The vector that was the output of the model" />
				<param type="BrightData.Vector&lt;System.Single&gt;" name="targetOutput" summary="The vector that the model was expected to output" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CalculateGradient">
		<summary>Calculates the gradient of the error function</summary>
				<param type="BrightWire.IContext" name="context" summary="The graph context" />
				<param type="BrightData.IFloatMatrix" name="output" summary="The mini batch of output vectors" />
				<param type="BrightData.IFloatMatrix" name="targetOutput" summary="The mini batch of expected target vectors" />
			</method>
</interface>
<interface name="BrightWire.IExecutionContext" base="System.IDisposable">
	<summary>
		Graph execution context
	</summary>
		<method type="System.Void" name="SetMemory">
		<summary>Writes to a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
				<param type="BrightData.IFloatMatrix" name="memory" summary="Segment" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetMemory">
		<summary>Reads from a named memory slot</summary>
				<param type="System.String" name="slotName" summary="Slot name" />
			</method>
	<method type="BrightWire.IGraphOperation" name="GetNextOperation">
		<summary>Gets the next queued graph operation (if any)</summary>
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds a list of graph operations to the queue</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;BrightWire.IGraphOperation&gt;" name="operationList" summary="List of operations" />
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="System.Int32" name="RemainingOperationCount">
		<summary>How many operations remain queued</summary>
	</property>
	<method type="System.Void" name="RegisterContinuation">
		<summary>Registers a continuation that will be executed after the current sequence has been processed in full</summary>
				<param type="BrightWire.IMiniBatchSequence" name="sequence" summary="Sequence index" />
				<param type="System.Action&lt;BrightWire.IContext&gt;" name="callback" summary="Continuation" />
			</method>
	<property type="System.Boolean" name="HasContinuations">
		<summary>True if there are registered continuations</summary>
	</property>
	<method type="System.Void" name="Continue">
		<summary>Execute any registered continuation for this context</summary>
				<param type="BrightWire.IContext" name="context" summary="Context with an associated IMiniBatchSequence" />
			</method>
</interface>
<interface name="BrightWire.IExecutionHistory" base="">
	<summary>
		Record of node execution
	</summary>
		<property type="BrightWire.INode" name="Source">
		<summary>Node that was executed</summary>
	</property>
	<property type="BrightWire.INode[]" name="Parents">
		<summary>The node's parents</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Data">
		<summary>Node output signal</summary>
	</property>
	<property type="BrightWire.IBackpropagation" name="Backpropagation">
		<summary>Optional backpropagation</summary>
	</property>
</interface>
<interface name="BrightWire.IFeedForward" base="BrightWire.INode">
	<summary>
		Feed forward layer
	</summary>
		<property type="System.UInt32" name="InputSize">
		<summary>Size of incoming connections</summary>
	</property>
	<property type="System.UInt32" name="OutputSize">
		<summary>Size of outgoing connections</summary>
	</property>
	<property type="BrightData.IFloatVector" name="Bias">
		<summary>Bias vector</summary>
	</property>
	<property type="BrightData.IFloatMatrix" name="Weight">
		<summary>Weight matrix</summary>
	</property>
	<method type="System.Void" name="UpdateWeights">
		<summary>Updates the weights</summary>
				<param type="BrightData.IFloatMatrix" name="delta" summary="Weight delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="Graph learning context" />
			</method>
</interface>
<interface name="BrightData.IFloatMatrix" base="System.IDisposable">
	<summary>
		A matrix
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary>Checks if the matrix has not been disposed</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="Multiply">
		<summary>Multiplies the current vector (without in place modification) with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<property type="System.UInt32" name="ColumnCount">
		<summary>The number of columns</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The number of rows</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Column">
		<summary>Returns a column as a vector</summary>
				<param type="System.UInt32" name="index" summary="The column index" />
			</method>
	<method type="BrightData.IFloatVector" name="Diagonal">
		<summary>Returns the matrix diagonal as a vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Row">
		<summary>Returns a row as a vector</summary>
				<param type="System.UInt32" name="index" summary="The row index" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Add">
		<summary>Returns the current matrix (without in place modification) added to the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Subtract">
		<summary>Returns the current matrix  (without in place modification) minus the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseMultiply">
		<summary>Returns the pointwise product of the current matrix (without in place modification) with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeAndMultiply">
		<summary>Returns the current matrix (without in place modification) and multipled with the transposed target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="TransposeThisAndMultiply">
		<summary>Returns the transpose of the current matrix (without in place modification) multipled with the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="RowSums">
		<summary>Returns a vector that contains the sum of the elements in each row of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ColumnSums">
		<summary>Returns a vector that contains the sum of the elements in each column of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Transpose">
		<summary>Returns the transpose of the current matrix</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiplies (in place) each element of the matrix by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The scalar to multiply each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Multiply">
		<summary>Returns the product of the current matrix (without in place modification) with the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds the target matrix to the current matrix (in place)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts the target matrix from the current matrix (in place)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
				<param type="System.Single" name="coefficient1" summary="A coefficient to multiply each element of the current matrix" />
				<param type="System.Single" name="coefficient2" summary="A coefficient to multipy each element of the target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidActivation">
		<summary>Returns a new matrix with the sigmoid function applied to each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SigmoidDerivative">
		<summary>Returns a new matrix with the sigmoid derivative of each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhActivation">
		<summary>Returns a new matrix with the tanh function applied to each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="TanhDerivative">
		<summary>Returns a new matrix with the tanh derivative of each element</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxActivation">
		<summary>Returns a new matrix with the softmax function applied to each row of the matrix</summary>
			</method>
	<method type="System.Void" name="AddToEachRow">
		<summary>Adds the target vector to each row of the current matrix (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="AddToEachColumn">
		<summary>Adds the target vector to each column of the current matrix (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<property type="BrightData.Matrix&lt;System.Single&gt;" name="Data">
		<summary>Converts the current matrix</summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="AsIndexable">
		<summary>Converts the matrix to an indexable matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromRows">
		<summary>Returns a new matrix from a subset of the current matrix's rows</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndexes" summary="The list of row indices" />
			</method>
	<method type="BrightData.IFloatMatrix" name="GetNewMatrixFromColumns">
		<summary>Returns a new matrix from a subset of the current matrix's columns</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="columnIndexes" summary="The list of column indices" />
			</method>
	<method type="System.Void" name="ClearRows">
		<summary>Set to zero the specified rows in the current matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="The list of row indices" />
			</method>
	<method type="System.Void" name="ClearColumns">
		<summary>Set to zero the specified columns in the current matrix</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indexes" summary="The list of column indices" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluActivation">
		<summary>Returns the RELU function applied to each element of the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReluDerivative">
		<summary>Returns the RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluActivation">
		<summary>Returns the leaky RELU function applied to each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="LeakyReluDerivative">
		<summary>Returns the leaky RELU derivative of each element in the current matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Clone">
		<summary>Creates a copy of the current matrix</summary>
			</method>
	<method type="System.Void" name="Clear">
		<summary>Sets each element to zero</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="Sqrt">
		<summary>Returns the square root of each element in the current matrix</summary>
				<param type="System.Single" name="valueAdjustment" summary="Term to add to each element in the result matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Pow">
		<summary>Returns each element raised to specified power</summary>
				<param type="System.Single" name="power" summary="The power to apply to each element" />
			</method>
	<method type="BrightData.IFloatMatrix" name="PointwiseDivide">
		<summary>Returns the current matrix (not modified in place) divided by the target matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The target matrix" />
			</method>
	<method type="System.Void" name="L1Regularisation">
		<summary>L1 Regularisation applied to each element of the current matrix (in place)</summary>
				<param type="System.Single" name="coefficient" summary="The L1 coefficient" />
			</method>
	<method type="BrightData.IFloatVector" name="ColumnL2Norm">
		<summary>Returns a vector of the L2 norms of each column</summary>
			</method>
	<method type="BrightData.IFloatVector" name="RowL2Norm">
		<summary>Returns a vector of the L2 norms of each row</summary>
			</method>
	<method type="System.Void" name="PointwiseDivideRows">
		<summary>Pointwise divide each row by the target vector (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="PointwiseDivideColumns">
		<summary>Pointwise divide each column by the target vector (in place)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Void" name="Constrain">
		<summary>Constrain each value within the specified min and max values (in place)</summary>
				<param type="System.Single" name="min" summary="The minimum allowed value" />
				<param type="System.Single" name="max" summary="The maximum allowed value" />
			</method>
	<method type="BrightData.IFloatVector" name="GetRowSegment">
		<summary>Returns a segment from a row of the current matrix</summary>
				<param type="System.UInt32" name="rowIndex" summary="The row index" />
				<param type="System.UInt32" name="columnIndex" summary="The start index to return" />
				<param type="System.UInt32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightData.IFloatVector" name="GetColumnSegment">
		<summary>Returns a segment from a column of the current matrix</summary>
				<param type="System.UInt32" name="columnIndex" summary="The column index" />
				<param type="System.UInt32" name="rowIndex" summary="The start index to return" />
				<param type="System.UInt32" name="length" summary="The number of elements to return" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatColumns">
		<summary>Returns a new matrix with the columns of the target matrix appended to each column of the current matrix</summary>
				<param type="BrightData.IFloatMatrix" name="bottom" summary="The target matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="ConcatRows">
		<summary>Returns a new matrix with the rows of the target matrix appended to each row of the current matrix</summary>
				<param type="BrightData.IFloatMatrix" name="right" summary="The target matrix" />
			</method>
	<method type="(BrightData.IFloatMatrix Left, BrightData.IFloatMatrix Right)" name="SplitAtColumn">
		<summary>Splits the rows of the current matrix into two matrices</summary>
				<param type="System.UInt32" name="columnIndex" summary="The column index at which to split" />
			</method>
	<method type="(BrightData.IFloatMatrix Top, BrightData.IFloatMatrix Bottom)" name="SplitAtRow">
		<summary>Splits the columns of the current matrix into two matrices</summary>
				<param type="System.UInt32" name="rowIndex" summary="The row index at which to split" />
			</method>
	<method type="(BrightData.IFloatMatrix U, BrightData.IFloatVector S, BrightData.IFloatMatrix VT)" name="Svd">
		<summary>Singular value decomposition</summary>
			</method>
	<method type="BrightData.IFloatVector" name="ReshapeAsVector">
		<summary>Fast conversion to vector (the internal buffer is not modified)</summary>
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor">
		<summary>Reshapes the matrix to a 3D tensor, treating each column as a depth slice in the new 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each sub matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each sub matrix" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Converts the matrix to a 4D tensor, treating each column as a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Row count of each sub matrix" />
				<param type="System.UInt32" name="columns" summary="Column count of each sub matrix" />
				<param type="System.UInt32" name="depth" summary="Depth of each 3D tensor" />
			</method>
	<method type="System.Single" name="GetAt">
		<summary>Returns the value at the specified row and column index</summary>
				<param type="System.UInt32" name="row" summary="Row index" />
				<param type="System.UInt32" name="column" summary="Column index" />
			</method>
	<method type="System.Void" name="SetAt">
		<summary>Updates the value at the specified row and column index</summary>
				<param type="System.UInt32" name="row" summary="Row index" />
				<param type="System.UInt32" name="column" summary="Column index" />
				<param type="System.Single" name="value" summary="Value to set" />
			</method>
	<method type="BrightData.IFloatVector[]" name="ColumnVectors">
		<summary>Returns the columns of the matrix as vectors</summary>
			</method>
	<method type="BrightData.IFloatVector[]" name="RowVectors">
		<summary>Returns the rows of the matrix as vectors</summary>
			</method>
</interface>
<interface name="BrightData.IFloatVector" base="System.IDisposable">
	<summary>
		A vector
	</summary>
		<property type="System.Boolean" name="IsValid">
		<summary>Checks if the vector has not been disposed</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsColumnMatrix">
		<summary>Converts the vector to a column matrix</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsRowMatrix">
		<summary>Converts the vector to a row matrix</summary>
			</method>
	<property type="System.UInt32" name="Count">
		<summary>The number of elements in the vector</summary>
	</property>
	<property type="BrightData.Vector&lt;System.Single&gt;" name="Data">
		<summary>Converts the vector</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Add">
		<summary>Adds a vector (without in place modification)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The vector to add" />
			</method>
	<method type="BrightData.IFloatVector" name="Subtract">
		<summary>Subtracts a vector (without in place modification)</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The vector to subtract" />
			</method>
	<method type="System.Single" name="L1Norm">
		<summary>Calculates the absolute values (L1) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.Single" name="L2Norm">
		<summary>Calculates the euclidean (L2) norm: https://en.wikipedia.org/wiki/Norm_(mathematics)</summary>
			</method>
	<method type="System.UInt32" name="MaximumIndex">
		<summary>Returns the index of the vector with the greatest value</summary>
			</method>
	<method type="System.UInt32" name="MinimumIndex">
		<summary>Returns the index of the vector with the smallest value</summary>
			</method>
	<method type="System.Void" name="Multiply">
		<summary>Multiples (in place) by a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to multiple each element" />
			</method>
	<method type="System.Void" name="Add">
		<summary>Adds (in place) a scalar</summary>
				<param type="System.Single" name="scalar" summary="The value to add to each element" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary>Adds a vector in place</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector to add to the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary>Subtracts a vector in place</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector to subtract from the current vector" />
				<param type="System.Single" name="coefficient1" summary="A value to multiply each element of the current vector" />
				<param type="System.Single" name="coefficient2" summary="A value to multiply each element of the target vector" />
			</method>
	<method type="BrightData.IIndexableFloatVector" name="AsIndexable">
		<summary>Converts the vector to an indexable vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="PointwiseMultiply">
		<summary>Pointwise multiplication (without in place modification) with a vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="DotProduct">
		<summary>The dot product of two vectors</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="BrightData.IFloatVector" name="GetNewVectorFromIndexes">
		<summary>Returns a new vector from a subset of the vector indices</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="indices" summary="A list of indexes to use as the source of the new vector" />
			</method>
	<method type="BrightData.IFloatVector" name="Clone">
		<summary>Creates a new copy of the vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sqrt">
		<summary>Creates a new vector in which each element is the square root of the current vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Abs">
		<summary>Creates a new vector in which each element is the absolute value of the current vector</summary>
			</method>
	<method type="System.Void" name="CopyFrom">
		<summary>Copies values from the target vector into the current vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="System.Single" name="EuclideanDistance">
		<summary>Calculates the euclidean distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="CosineDistance">
		<summary>Calculates the cosine distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector>" />
			</method>
	<method type="System.Single" name="ManhattanDistance">
		<summary>Calculates the manhattan distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="MeanSquaredDistance">
		<summary>Calculates the mean squared distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="System.Single" name="SquaredEuclidean">
		<summary>Calculates the squared euclidean distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="The target vector" />
			</method>
	<method type="(System.Single Min, System.Single Max)" name="GetMinMax">
		<summary>Finds the minimum and maximum values in the current vector</summary>
			</method>
	<method type="System.Single" name="Average">
		<summary>Calculates the average value from the elements of the current vector</summary>
			</method>
	<method type="System.Single" name="StdDev">
		<summary>Calculates the standard deviation from the elements of the current vector</summary>
				<param type="System.Nullable&lt;System.Single&gt;" name="mean" summary="(optional) pre calculated mean" />
			</method>
	<method type="System.Void" name="Normalise">
		<summary>Normalises (in place) the values of the current vector</summary>
				<param type="BrightData.NormalizationType" name="type" summary="The type of normalisation" />
			</method>
	<method type="BrightData.IFloatVector" name="Softmax">
		<summary>Returns the softmax function (without in place modification) applied to the current vector
https://en.wikipedia.org/wiki/Softmax_function</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="SoftmaxDerivative">
		<summary>Returns the jacobian matrix of the softmax derivative</summary>
			</method>
	<method type="BrightData.IFloatVector" name="FindDistances">
		<summary>Returns a vector of distances between the current and target vectors</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="The list of target vectors" />
				<param type="BrightData.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="System.Single" name="FindDistance">
		<summary>Returns the distance between the current and the target vector</summary>
				<param type="BrightData.IFloatVector" name="other" summary="The target vector" />
				<param type="BrightData.DistanceMetric" name="distance" summary="The distance metric" />
			</method>
	<method type="BrightData.IFloatVector" name="CosineDistance">
		<summary>Returns a vector of the cosine distance between the current and target vectors</summary>
				<param type="BrightData.IFloatVector[]" name="data" summary="The list of target vectors" />
				<param type="System.Single[]" name="dataNorm" summary="A buffer to hold the norms of the target vectors" />
			</method>
	<method type="BrightData.IFloatVector" name="Log">
		<summary>Returns a vector (without in place modification) in which each element is the natural log of each element in the current vector</summary>
			</method>
	<method type="BrightData.IFloatVector" name="Sigmoid">
		<summary>Returns the sigmoid function (without in place modification) applied to the current vector</summary>
			</method>
	<method type="BrightData.IFloatMatrix" name="ReshapeAsMatrix">
		<summary>Fast conversion to matrix (internal buffer is used directly)</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows in the matrix" />
				<param type="System.UInt32" name="columns" summary="The number of columns in the matrix" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="ReshapeAs3DTensor">
		<summary>Converts the vector to a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="ReshapeAs4DTensor">
		<summary>Converts the vector to a 4D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows in each matrix" />
				<param type="System.UInt32" name="columns" summary="Number of columns in matrix" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
			</method>
	<method type="BrightData.IFloatVector[]" name="Split">
		<summary>Splits the vector into a list of vectors</summary>
				<param type="System.UInt32" name="blockCount" summary="The number of sub vectors to split into" />
			</method>
	<method type="System.Void" name="RotateInPlace">
		<summary>Rotates values in the vector (both horizontally and vertically within blocks)</summary>
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="Reverse">
		<summary>Returns a reversed copy of the vector's values</summary>
			</method>
	<method type="System.Single" name="GetAt">
		<summary>Returns the value at the specified index</summary>
				<param type="System.UInt32" name="index" summary="The index of the vector to return" />
			</method>
	<method type="System.Void" name="SetAt">
		<summary>Updates the value at the specified index</summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Single" name="value" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary>Checks if every value in the vector is finite (not NaN or positive/negative infinity)</summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.IGradientDescentOptimisation" base="System.IDisposable">
	<summary>
		Gradient descent optimisation
	</summary>
		<method type="System.Void" name="Update">
		<summary>Updates the matrix with the delta</summary>
				<param type="BrightData.IFloatMatrix" name="source" summary="The matrix to update" />
				<param type="BrightData.IFloatMatrix" name="delta" summary="The delta matrix" />
				<param type="BrightWire.ILearningContext" name="context" summary="The graph learning context" />
			</method>
</interface>
<interface name="BrightWire.IGraphData" base="">
	<summary>
		Wrapper around the data that is used as a signal between nodes in the graph
	</summary>
		<property type="System.UInt32" name="Rows">
		<summary>Row count</summary>
	</property>
	<property type="System.UInt32" name="Columns">
		<summary>Column count</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>3D Tensor depth (1 if the signal is a matrix)</summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary>Count of 3D tensors (1 of the signal is a matrix or 3D tensor)</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="GetMatrix">
		<summary>Gets the signal as a matrix</summary>
			</method>
	<method type="BrightData.I4DFloatTensor" name="Get4DTensor">
		<summary>Gets the signal as a 4D tensor</summary>
			</method>
	<method type="BrightWire.IGraphData" name="ReplaceWith">
		<summary>Replaces the data with the specified matrix (but preserves any tensor meta data)</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="The matrix to use as a replacement" />
			</method>
	<method type="BrightData.IFloatMatrix[]" name="GetSubMatrices">
		<summary>Returns the list of matrices that compose the signal (single item if the signal is a matrix)</summary>
			</method>
</interface>
<interface name="BrightWire.IGraphEngine" base="">
	<summary>
		Graph engines drive execution within a graph
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>Linear algebra provider</summary>
	</property>
	<property type="BrightWire.Models.ExecutionGraphModel" name="Graph">
		<summary>Serialised version of the current graph and its parameters</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source that feeds into the graph</summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="Execute">
		<summary>Executes a data source on the current graph</summary>
				<param type="BrightWire.IDataSource" name="dataSource" summary="Segment source to process" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="Execute">
		<summary>Executes a single vector on the current graph</summary>
				<param type="System.Single[]" name="input" summary="Vector to execute" />
			</method>
	<method type="BrightWire.Models.ExecutionResult" name="ExecuteSequential">
		<summary>Executes a sequential input on the current graph</summary>
				<param type="System.UInt32" name="sequenceIndex" summary="Index of the current sequence (starting from 0)" />
				<param type="System.Single[]" name="input" summary="Input vector" />
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="BrightWire.MiniBatchSequenceType" name="sequenceType" summary="The sequence type (start, standard, end)" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightWire.Models.ExecutionResult&gt;" name="ExecuteSequential">
		<summary>Executes a sequence of inputs on the current graph</summary>
				<param type="System.Single[][]" name="input" summary="List of vector inputs" />
			</method>
	<property type="BrightWire.INode" name="Start">
		<summary>The graph's single start node</summary>
	</property>
</interface>
<interface name="BrightWire.IGraphOperation" base="">
	<summary>
		A pending graph operation (mini batch)
	</summary>
		<method type="System.Void" name="Execute">
		<summary>Executes the operation</summary>
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
			</method>
</interface>
<interface name="BrightWire.IGraphTrainingEngine" base="BrightWire.IGraphEngine">
	<summary>
		A graph engine that also trains the graph's parameters against training data
	</summary>
		<method type="BrightWire.INode" name="GetInput">
		<summary>Returns the specified input node</summary>
				<param type="System.UInt32" name="index" summary="Index of the input node to retrieve" />
			</method>
	<method type="System.Double" name="Train">
		<summary>Executes a training epoch on the graph</summary>
				<param type="BrightWire.IExecutionContext" name="executionContext" summary="Graph execution context" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
			</method>
	<method type="System.Boolean" name="Test">
		<summary>Executes test data on the current graph</summary>
				<param type="BrightWire.IDataSource" name="testDataSource" summary="Segment source with test data" />
				<param type="BrightWire.IErrorMetric" name="errorMetric" summary="Error metric to use to evaluate the test score" />
				<param type="System.UInt32" name="batchSize" summary="Initial size of each mini batch" />
				<param type="System.Action&lt;System.Single&gt;" name="batchCompleteCallback" summary="Optional callback to be notifiied after each mini batch has completed" />
				<param type="System.Action&lt;System.Single, System.Double, System.Boolean, System.Boolean&gt;" name="values" summary="Optional callback to get the (testError, trainingRate, isPercentage, isImprovedScore) data" />
			</method>
	<property type="BrightWire.ILearningContext" name="LearningContext">
		<summary>Graph learning context</summary>
	</property>
	<method type="System.Void" name="LoadParametersFrom">
		<summary>Loads model parameters into the existing graph</summary>
				<param type="BrightWire.Models.ExecutionGraphModel" name="graph" summary="Model to load parameters from" />
			</method>
</interface>
<interface name="BrightWire.IHaveAction" base="">
	<summary>
		Node that exposes an action
	</summary>
		<property type="BrightWire.IAction" name="Action">
		<summary>The node's action</summary>
	</property>
</interface>
<interface name="BrightTable.IHaveDataContext" base="">
	<summary>
		
	</summary>
		<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.IHaveDataTable" base="">
	<summary>
		
	</summary>
		<property type="BrightTable.IDataTable" name="DataTable">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHaveEncodedData" base="">
	<summary>
		
	</summary>
		<property type="System.Boolean" name="IsEncoded">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHaveIndices" base="">
	<summary>
		Interface
	</summary>
		<property type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="Indices">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.IHaveMemoryNode" base="">
	<summary>
		Nodes that have a memory feeder sub-node
	</summary>
		<property type="BrightWire.INode" name="Memory">
		<summary>The memory feed sub node</summary>
	</property>
</interface>
<interface name="BrightData.IHaveMetaData" base="">
	<summary>
		
	</summary>
		<property type="BrightData.IMetaData" name="MetaData">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.IHybridBuffer" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Length">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="NumDistinct">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
</interface>
<interface name="BrightData.IHybridBuffer&lt;T&gt;" base="BrightData.IHybridBuffer">
	<summary>
		
	</summary>
		<method type="System.Void" name="Add">
		<summary></summary>
				<param type="T" name="item" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="EnumerateTyped">
		<summary></summary>
			</method>
</interface>
<interface name="BrightData.IIndexable3DFloatTensor" base="BrightData.I3DFloatTensor">
	<summary>
		A 3D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="BrightData.IIndexableFloatMatrix[]" name="Matrix">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the tensor as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexable4DFloatTensor" base="BrightData.I4DFloatTensor">
	<summary>
		A 4D tensor that can be directly indexed
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns a value from the tensor</summary>
	</property>
	<property type="BrightData.IIndexable3DFloatTensor[]" name="Tensors">
		<summary>Gets a list of the indexable matrices</summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the tensor as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexableFloatMatrix" base="BrightData.IFloatMatrix">
	<summary>
		A matrix whose elements can be indexed directly
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element from the current matrix</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Rows">
		<summary>Returns the rows of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightData.IIndexableFloatVector&gt;" name="Columns">
		<summary>Returns the columns of the current matrix as vectors</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Returns each element in the current matrix as enumerable</summary>
	</property>
	<method type="BrightData.IIndexableFloatMatrix" name="Map">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element" />
			</method>
	<method type="BrightData.IIndexableFloatMatrix" name="MapIndexed">
		<summary>Mutates each element of the current matrix</summary>
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single, System.Single&gt;" name="mutator" summary="The function to apply to each element (rowIndex: uint, columnIndex: uint, value: float) => float" />
			</method>
	<property type="System.String" name="AsXml">
		<summary>Returns the matrix as xml</summary>
	</property>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the matrix as well)</summary>
			</method>
</interface>
<interface name="BrightData.IIndexableFloatVector" base="BrightData.IFloatVector">
	<summary>
		Returns an indexable vector (in which elements can be directly indexed)
	</summary>
		<property type="System.Single" name="this">
		<summary>Returns an element at the specified index</summary>
	</property>
	<property type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="Values">
		<summary>Gets the values as an enumerable</summary>
	</property>
	<method type="System.Single[]" name="ToArray">
		<summary>Converts the vector to an array</summary>
			</method>
	<method type="System.Single[]" name="GetInternalArray">
		<summary>Returns the underlying array used as storage (changes to this array will affect the vector as well)</summary>
			</method>
	<method type="BrightData.IIndexableFloatVector" name="Append">
		<summary>Creates a new vector (without in place modification) in which new values are appended onto the end of the current vector</summary>
				<param type="System.Single[]" name="data" summary="The values to append" />
			</method>
</interface>
<interface name="BrightWire.IIndexListClassifier" base="">
	<summary>
		A classifier that classifies index lists
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary>Classifies the input data and returns the classifications with their weights</summary>
				<param type="BrightData.IndexList" name="indexList" summary="The index list to classify" />
			</method>
</interface>
<interface name="BrightWire.IIndexListEncoder" base="">
	<summary>
		Encodes index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the index lists to a dense vector</summary>
				<param type="BrightData.IndexList" name="indexList" summary="The index list to encode" />
			</method>
</interface>
<interface name="BrightWire.ILearningContext" base="">
	<summary>
		Graph learning context
	</summary>
		<property type="System.Double" name="EpochSeconds">
		<summary>The duration in seconds of the last epoch</summary>
	</property>
	<property type="System.Int64" name="EpochMilliseconds">
		<summary>The duration in milliseconds of the last epoch</summary>
	</property>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider</summary>
	</property>
	<property type="System.UInt32" name="CurrentEpoch">
		<summary>The index of the current epoch (starting from one)</summary>
	</property>
	<property type="System.Single" name="LearningRate">
		<summary>The current learning/training rate</summary>
	</property>
	<property type="System.Single" name="BatchLearningRate">
		<summary>The learning rate adjusted with the current batch size</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>The current mini batch size</summary>
	</property>
	<property type="System.UInt32" name="RowCount">
		<summary>The total number of rows per epoch</summary>
	</property>
	<method type="System.Void" name="StoreUpdate">
		<summary>Stores an update to the model parameters</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that is affected by this update" />
				<param type="T" name="update" summary="The update" />
				<param type="System.Action&lt;T&gt;" name="updater" summary="Callback to execute the update" />
			</method>
	<property type="BrightWire.TrainingErrorCalculation" name="TrainingErrorCalculation">
		<summary>True if the graph should calculate training error</summary>
	</property>
	<property type="System.Boolean" name="DeferUpdates">
		<summary>True if updates are deferred until the mini batch is complete</summary>
	</property>
	<method type="System.Void" name="ApplyUpdates">
		<summary>Apply any deferred updates</summary>
			</method>
	<method type="System.Void" name="StartEpoch">
		<summary>Start a new epoch</summary>
			</method>
	<method type="System.Void" name="EndEpoch">
		<summary>End the current epoch</summary>
			</method>
	<method type="System.Void" name="SetRowCount">
		<summary>Sets the number of rows</summary>
				<param type="System.UInt32" name="rowCount" summary="The number of rows per epoch" />
			</method>
	<method type="System.Void" name="DeferBackpropagation">
		<summary>Register the backpropagation to be deferred</summary>
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The error signal associated with this backpropagation (optional, can be null)" />
				<param type="System.Action&lt;BrightWire.IGraphData&gt;" name="update" summary="The callback to execute the backpropagation" />
			</method>
	<method type="System.Void" name="BackpropagateThroughTime">
		<summary>Backpropagates the error signal across all deferred backpropagations</summary>
				<param type="BrightWire.IGraphData" name="signal" summary="The backpropagation signal" />
				<param type="System.Int32" name="maxDepth" summary="The maximum depth to backpropagate the signal" />
			</method>
	<method type="System.Void" name="ScheduleLearningRate">
		<summary>Schedules a change in the learning rate the specified epoch</summary>
				<param type="System.UInt32" name="atEpoch" summary="The epoch to change the learning rate" />
				<param type="System.Single" name="newLearningRate" summary="The learning rate to use at that epoch" />
			</method>
	<method type="System.Void" name="EnableNodeUpdates">
		<summary>Enable or disable node parameter updates</summary>
				<param type="BrightWire.INode" name="node" summary="The node to modify" />
				<param type="System.Boolean" name="enableUpdates" summary="True if the node can make updates via backpropagation" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Resets the learning context</summary>
			</method>
	<property type="System.Action&lt;System.String&gt;" name="MessageLog">
		<summary>Sends the message to some output</summary>
	</property>
	<property type="BrightWire.IErrorMetric" name="ErrorMetric">
		<summary>Error metric to use when evaluating trainging progress</summary>
	</property>
</interface>
<interface name="BrightData.ILinearAlgebraProvider" base="System.IDisposable">
	<summary>
		Linear algebra adaptor interfaces
	</summary>
		<property type="System.String" name="Name">
		<summary></summary>
	</property>
	<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a new vector</summary>
				<param type="System.UInt32" name="length" summary="Length of the vector" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary>Creates a vector</summary>
				<param type="System.UInt32" name="length" summary="Size of the vector" />
				<param type="System.Func&lt;System.UInt32, System.Single&gt;" name="init" summary="Callback to initialise each element of the vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows" />
				<param type="System.UInt32" name="columns" summary="The number of columns" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrix">
		<summary>Creates a matrix</summary>
				<param type="System.UInt32" name="rows" summary="The number of rows" />
				<param type="System.UInt32" name="columns" summary="The number of columns" />
				<param type="System.Func&lt;System.UInt32, System.UInt32, System.Single&gt;" name="init" summary="Callback to initialise each element of the matrix" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromRows">
		<summary>Creates a matrix from a list of vectors. Each vector will become a row in the new matrix</summary>
				<param type="BrightData.IFloatVector[]" name="vectorRows" summary="List of vectors for each row" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateMatrixFromColumns">
		<summary>Creates a matrix from a list of vectors. Each vector will become a column in the new matrix</summary>
				<param type="BrightData.IFloatVector[]" name="vectorColumns" summary="List of vectors for each column" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.UInt32" name="depth" summary="Number of depth slices" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.I3DFloatTensor" name="Create3DTensor">
		<summary>Creates a 3D tensor from a list of matrices</summary>
				<param type="BrightData.IFloatMatrix[]" name="matrices" summary="List of matrices" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor</summary>
				<param type="System.UInt32" name="rows" summary="Number of rows" />
				<param type="System.UInt32" name="columns" summary="Number of columns" />
				<param type="System.UInt32" name="depth" summary="Number of matrices" />
				<param type="System.UInt32" name="count" summary="Number of 3D tensors" />
				<param type="System.Boolean" name="setToZero" summary="True to initialise the data to zero (otherwise it might be anything)" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor from a list of 3D tensors</summary>
				<param type="BrightData.I3DFloatTensor[]" name="tensors" summary="List of 3D tensors" />
			</method>
	<method type="BrightData.I4DFloatTensor" name="Create4DTensor">
		<summary>Creates a 4D tensor from a list of 3D tensors</summary>
				<param type="BrightData.Tensor3D&lt;System.Single&gt;[]" name="tensors" summary="List of 3D tensors" />
			</method>
	<method type="System.Void" name="PushLayer">
		<summary>Creates a save point in the allocation history</summary>
			</method>
	<method type="System.Void" name="PopLayer">
		<summary>Releases all allocated memory since the last save point</summary>
			</method>
	<property type="System.Boolean" name="IsGpu">
		<summary>True if the provider uses the GPU</summary>
	</property>
	<method type="BrightData.IFloatMatrix" name="CalculateDistances">
		<summary>Calculates the distance of each vector against the comparison vectors - the size of all vectors should be the same</summary>
				<param type="BrightData.IFloatVector[]" name="vectors" summary="" />
				<param type="System.Collections.Generic.IReadOnlyList&lt;BrightData.IFloatVector&gt;" name="comparison" summary="" />
				<param type="BrightData.DistanceMetric" name="distanceMetric" summary="" />
			</method>
	<method type="BrightData.IFloatVector" name="CreateVector">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;System.Single&gt;" name="data" summary="" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionPredictor" base="System.IDisposable">
	<summary>
		Linear regression predictor
	</summary>
		<method type="System.Single" name="Predict">
		<summary>Predicts a value from input data</summary>
				<param type="System.Single[]" name="input" summary="The input data" />
			</method>
	<method type="System.Single[]" name="Predict">
		<summary>Bulk value prediction</summary>
				<param type="System.Single[][]" name="input" summary="List of data to predict" />
			</method>
</interface>
<interface name="BrightWire.ILinearRegressionTrainer" base="">
	<summary>
		Trainer for linear regression models
	</summary>
		<method type="BrightWire.Models.Linear.LinearRegression" name="GradientDescent">
		<summary>Solves the model using gradient descent</summary>
				<param type="System.Int32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightData.IFloatVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionClassifier" base="System.IDisposable">
	<summary>
		Logistic regression classifier
	</summary>
		<method type="BrightData.Vector&lt;System.Single&gt;" name="Predict">
		<summary>Outputs a list of values from 0 to 1 for each input data</summary>
				<param type="BrightData.Matrix&lt;System.Single&gt;" name="input" summary="Input data" />
			</method>
</interface>
<interface name="BrightWire.ILogisticRegressionTrainer" base="">
	<summary>
		A logistic regression trainer
	</summary>
		<method type="BrightWire.Models.Linear.LogisticRegression" name="GradientDescent">
		<summary>Trains a model using gradient descent</summary>
				<param type="System.UInt32" name="iterations" summary="Number of training epochs" />
				<param type="System.Single" name="learningRate" summary="The training rate" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
				<param type="System.Func&lt;System.Single, System.Boolean&gt;" name="costCallback" summary="Callback with current cost - False to stop training" />
			</method>
	<method type="System.Single" name="ComputeCost">
		<summary>Computes the cost of the specified parameters</summary>
				<param type="BrightData.IFloatVector" name="theta" summary="The model parameters" />
				<param type="System.Single" name="lambda" summary="Regularisation lambda" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer&lt;T&gt;" base="BrightWire.ICanSerialiseToStream">
	<summary>
		Markov model trainer
	</summary>
		<method type="System.Void" name="Add">
		<summary>Adds a sequence of items to the trainer</summary>
				<param type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="items" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer2&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 2)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel2&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMarkovModelTrainer3&lt;T&gt;" base="BrightWire.IMarkovModelTrainer&lt;T&gt;">
	<summary>
		Markov model trainer (window size 3)
	</summary>
		<method type="BrightWire.Models.Bayesian.MarkovModel3&lt;T&gt;" name="Build">
		<summary>Gets all current observations</summary>
			</method>
</interface>
<interface name="BrightWire.IMemoryNode" base="">
	<summary>
		Recurrent neural networks memory node
	</summary>
		<property type="BrightData.Vector&lt;System.Single&gt;" name="Data">
		<summary>The current state of the memory node</summary>
	</property>
</interface>
<interface name="BrightData.IMetaData" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		
	</summary>
		<method type="System.Object" name="Get">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="valueIfMissing" summary="" />
			</method>
	<method type="T" name="Set">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="CopyAllExcept">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
				<param type="System.String[]" name="keys" summary="" />
			</method>
	<method type="System.Void" name="ReadFrom">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</interface>
<interface name="BrightWire.IMiniBatch" base="">
	<summary>
		Information about the current mini batch
	</summary>
		<property type="System.UInt32[]" name="Rows">
		<summary>Row indexes of the current batch</summary>
	</property>
	<property type="BrightWire.IDataSource" name="DataSource">
		<summary>Segment source</summary>
	</property>
	<property type="System.Boolean" name="IsSequential">
		<summary>True if the data is sequential</summary>
	</property>
	<property type="System.UInt32" name="BatchSize">
		<summary>Number of items in the batch</summary>
	</property>
	<property type="BrightWire.IMiniBatchSequence" name="CurrentSequence">
		<summary>Current sequence (non sequential batches have a single sequence)</summary>
	</property>
	<property type="System.Boolean" name="HasNextSequence">
		<summary>True if there is another item in the sequence after the current item</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetNextSequence">
		<summary>Gets the next item in the sequence</summary>
			</method>
	<property type="System.UInt32" name="SequenceCount">
		<summary>Gets the length of the sequence</summary>
	</property>
	<method type="BrightWire.IMiniBatchSequence" name="GetSequenceAtIndex">
		<summary>Gets a sequence item</summary>
				<param type="System.UInt32" name="index" summary="The index to retrieve" />
			</method>
	<method type="System.Void" name="Reset">
		<summary>Resets the sequence iterator</summary>
			</method>
</interface>
<interface name="BrightWire.IMiniBatchSequence" base="">
	<summary>
		A sequence within a mini batch
	</summary>
		<property type="BrightWire.IMiniBatch" name="MiniBatch">
		<summary>Mini batch</summary>
	</property>
	<property type="System.UInt32" name="SequenceIndex">
		<summary>Index of the sequence</summary>
	</property>
	<property type="BrightWire.MiniBatchSequenceType" name="Type">
		<summary>Sequence type</summary>
	</property>
	<property type="BrightWire.IGraphData[]" name="Input">
		<summary>Input data</summary>
	</property>
	<property type="BrightWire.IGraphData" name="Target">
		<summary>Training target data</summary>
	</property>
</interface>
<interface name="BrightWire.INode" base="BrightWire.ICanInitialiseNode">
	<summary>
		Graph node
	</summary>
		<property type="System.String" name="Id">
		<summary>Unique id</summary>
	</property>
	<property type="System.String" name="Name">
		<summary>Friendly name</summary>
	</property>
	<property type="System.Collections.Generic.List&lt;BrightWire.IWire&gt;" name="Output">
		<summary>List of outgoing wires</summary>
	</property>
	<method type="System.Void" name="ExecuteForward">
		<summary>Executes the node forward</summary>
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="System.UInt32" name="channel" summary="Channel the signal was received on" />
			</method>
	<method type="BrightWire.INode" name="FindByName">
		<summary>Searches for a node by friendly name</summary>
				<param type="System.String" name="name" summary="Friendly name of the node to find" />
			</method>
	<method type="BrightWire.INode" name="FindById">
		<summary>Searches for a node by id</summary>
				<param type="System.String" name="id" summary="Unique id of the node" />
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;BrightWire.INode&gt;" name="SubNodes">
		<summary>Sub-nodes of the current node</summary>
	</property>
	<method type="BrightWire.Models.ExecutionGraphModel.Node" name="SerialiseTo">
		<summary>Serialise the node</summary>
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.INode&gt;" name="existing" summary="Set of nodes that have already been serialised in the current context" />
				<param type="System.Collections.Generic.List&lt;BrightWire.Models.ExecutionGraphModel.Node&gt;" name="connectedTo" summary="List of nodes this node is connected to" />
				<param type="System.Collections.Generic.HashSet&lt;BrightWire.Models.ExecutionGraphModel.Wire&gt;" name="wireList" summary="List of wires between all connected nodes" />
			</method>
	<method type="System.Void" name="OnDeserialise">
		<summary>Called after the graph has been completely deserialised</summary>
				<param type="System.Collections.Generic.IReadOnlyDictionary&lt;System.String, BrightWire.INode&gt;" name="graph" summary="Dictionary of nodes with their associated unique ids" />
			</method>
	<method type="System.Void" name="LoadParameters">
		<summary>Loads parameters into an existing node</summary>
				<param type="BrightWire.Models.ExecutionGraphModel.Node" name="nodeData" summary="Serialised node parameters" />
			</method>
</interface>
<interface name="BrightData.INonNegativeDiscreteDistribution" base="BrightData.IDistribution&lt;System.UInt32&gt;">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightData.INormalize" base="">
	<summary>
		
	</summary>
		<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary></summary>
	</property>
	<property type="System.Double" name="Divide">
		<summary></summary>
	</property>
	<property type="System.Double" name="Subtract">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.INumericComputation&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="BrightData.ITensorSegment&lt;T&gt;" name="Abs">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Add">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="System.Void" name="AddInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="System.Void" name="ConstrainInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="minValue" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="maxValue" summary="" />
			</method>
	<method type="T" name="Average">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="T" name="CosineDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="T" name="DotProduct">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="T" name="EuclideanDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Exp">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="L1Norm">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="T" name="L2Norm">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Log">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="ManhattanDistance">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="MultiplyInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Multiply">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="T" name="scalar" summary="" />
			</method>
	<method type="T" name="NextRandom">
		<summary></summary>
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="PointwiseDivide">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="PointwiseDivideInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="PointwiseMultiply">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="PointwiseMultiplyInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Nullable&lt;System.UInt32&gt;" name="Search">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Sqrt">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Squared">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="T" name="StdDev">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.Nullable&lt;T&gt;" name="mean" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Subtract">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor1" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor2" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
			</method>
	<method type="System.Void" name="SubtractInPlace">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="target" summary="" />
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="other" summary="" />
				<param type="T" name="coefficient1" summary="" />
				<param type="T" name="coefficient2" summary="" />
			</method>
	<method type="T" name="Sum">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="tensor" summary="" />
			</method>
	<method type="(T Min, T Max, System.UInt32 MinIndex, System.UInt32 MaxIndex)" name="GetMinAndMaxValues">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Boolean" name="IsEntirelyFinite">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Reverse">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="System.Collections.Generic.List&lt;BrightData.ITensorSegment&lt;T&gt;&gt;" name="Split">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="System.UInt32" name="blockCount" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Sigmoid">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="SigmoidDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Tanh">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="TanhDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Relu">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="ReluDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="LeakyRelu">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="LeakyReluDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Softmax">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="SoftmaxDerivative">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
	<method type="BrightData.ITensorSegment&lt;T&gt;" name="Pow">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
				<param type="T" name="power" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.UInt32" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Single" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Double" name="val" summary="" />
			</method>
	<method type="T" name="Get">
		<summary></summary>
				<param type="System.Decimal" name="val" summary="" />
			</method>
</interface>
<interface name="BrightWire.IPropertySet" base="">
	<summary>
		The current set of graph initialisation parameters
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary>The linear algebra provider to use</summary>
	</property>
	<property type="BrightWire.IWeightInitialisation" name="WeightInitialisation">
		<summary>The weight initialiser to use</summary>
	</property>
	<property type="BrightWire.IGradientDescentOptimisation" name="GradientDescent">
		<summary>The gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateTemplateBasedGradientDescent" name="TemplateGradientDescentDescriptor">
		<summary>The template based gradient descent optimisation to use</summary>
	</property>
	<property type="BrightWire.ICreateGradientDescent" name="GradientDescentDescriptor">
		<summary>The descriptor to create new gradient descent optimisations</summary>
	</property>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified template based gradient descent optimisation</summary>
				<param type="BrightWire.ICreateTemplateBasedGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.ICreateGradientDescent" name="descriptor" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified gradient descent optimisation</summary>
				<param type="BrightWire.IGradientDescentOptimisation" name="optimisation" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Use">
		<summary>Use the specified weight initialiser</summary>
				<param type="BrightWire.IWeightInitialisation" name="weightInit" summary="" />
			</method>
	<method type="BrightWire.IPropertySet" name="Clone">
		<summary>Clones the current property set</summary>
			</method>
	<method type="T" name="Get">
		<summary>Gets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="defaultValue" summary="The value to use if the property has not been supplied" />
			</method>
	<method type="BrightWire.IPropertySet" name="Set">
		<summary>Sets a named property</summary>
				<param type="System.String" name="name" summary="The property name" />
				<param type="T" name="obj" summary="The property value" />
			</method>
	<method type="System.Void" name="Clear">
		<summary>Clears the named property</summary>
				<param type="System.String" name="name" summary="The property name" />
			</method>
</interface>
<interface name="BrightData.IProvideTempStreams" base="System.IDisposable">
	<summary>
		
	</summary>
		<method type="System.IO.Stream" name="Get">
		<summary></summary>
				<param type="System.String" name="uniqueId" summary="" />
			</method>
	<method type="System.Boolean" name="HasStream">
		<summary></summary>
				<param type="System.String" name="uniqueId" summary="" />
			</method>
</interface>
<interface name="BrightWire.IRandomProjection" base="System.IDisposable">
	<summary>
		Random projection
	</summary>
		<property type="System.UInt32" name="Size">
		<summary>The size to reduce to</summary>
	</property>
	<property type="BrightData.IFloatMatrix" name="Matrix">
		<summary>The transformation matrix</summary>
	</property>
	<method type="BrightData.IFloatVector" name="Compute">
		<summary>Reduces a vector</summary>
				<param type="BrightData.IFloatVector" name="vector" summary="" />
			</method>
	<method type="BrightData.IFloatMatrix" name="Compute">
		<summary>Reduces a matrix</summary>
				<param type="BrightData.IFloatMatrix" name="matrix" summary="" />
			</method>
</interface>
<interface name="BrightData.IReferenceCountedMemory" base="">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<method type="System.Int32" name="AddRef">
		<summary></summary>
			</method>
	<method type="System.Int32" name="Release">
		<summary></summary>
			</method>
	<property type="System.Int64" name="AllocationIndex">
		<summary></summary>
	</property>
	<property type="System.Boolean" name="IsValid">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.IRowClassifier" base="">
	<summary>
		
	</summary>
		<method type="(System.String Label, System.Single Weight)[]" name="Classify">
		<summary></summary>
				<param type="BrightTable.IConvertibleRow" name="row" summary="" />
			</method>
</interface>
<interface name="BrightTable.IRowOrientedDataTable" base="BrightTable.IDataTable">
	<summary>
		
	</summary>
		<method type="BrightTable.IColumnOrientedDataTable" name="AsColumnOriented">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="" />
			</method>
	<method type="System.Void" name="ForEachRow">
		<summary></summary>
				<param type="System.Collections.Generic.IEnumerable&lt;System.UInt32&gt;" name="rowIndices" summary="" />
				<param type="System.Action&lt;System.Object[]&gt;" name="callback" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Bag">
		<summary></summary>
				<param type="System.UInt32" name="sampleCount" summary="" />
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IDataTableSegment" name="Row">
		<summary></summary>
				<param type="System.UInt32" name="rowIndex" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;BrightTable.IDataTableSegment&gt;" name="Rows">
		<summary></summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Concat">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Concat">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="BrightTable.IRowOrientedDataTable[]" name="others" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Mutate">
		<summary></summary>
				<param type="System.Func&lt;System.Object[], System.Object[]&gt;" name="projector" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="SelectRows">
		<summary></summary>
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="SelectRows">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
				<param type="System.UInt32[]" name="rowIndices" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Shuffle">
		<summary></summary>
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="BrightTable.IRowOrientedDataTable" name="Sort">
		<summary></summary>
				<param type="System.Boolean" name="ascending" summary="" />
				<param type="System.UInt32" name="columnIndex" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
	<method type="System.Collections.Generic.IEnumerable&lt;(System.String Label, BrightTable.IRowOrientedDataTable Table)&gt;" name="GroupBy">
		<summary></summary>
				<param type="System.UInt32" name="columnIndex" summary="" />
			</method>
	<property type="System.String" name="FirstRow">
		<summary></summary>
	</property>
	<property type="System.String" name="SecondRow">
		<summary></summary>
	</property>
	<property type="System.String" name="ThirdRow">
		<summary></summary>
	</property>
	<property type="System.String" name="LastRow">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ISerializable" base="BrightData.ICanWriteToBinaryWriter">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightData.ISetLinearAlgebraProvider" base="">
	<summary>
		
	</summary>
		<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.ISingleTypeTableSegment" base="BrightData.IHaveMetaData">
	<summary>
		
	</summary>
		<property type="BrightTable.ColumnType" name="SingleType">
		<summary></summary>
	</property>
	<method type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" name="Enumerate">
		<summary></summary>
			</method>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
</interface>
<interface name="BrightWire.ITableClassifier" base="">
	<summary>
		
	</summary>
		<method type="System.Collections.Generic.IEnumerable&lt;(System.UInt32 RowIndex, (System.String Classification, System.Single Weight)[] Predictions)&gt;" name="Classify">
		<summary></summary>
				<param type="BrightTable.IDataTable" name="table" summary="" />
			</method>
</interface>
<interface name="BrightData.ITensor" base="System.IDisposable">
	<summary>
		
	</summary>
		<property type="System.UInt32[]" name="Shape">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Size">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Rank">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ITensor&lt;T&gt;" base="BrightData.ITensor">
	<summary>
		
	</summary>
		<method type="BrightData.ITensorSegment&lt;T&gt;" name="GetDataCopy">
		<summary></summary>
			</method>
	<property type="BrightData.ITensorSegment&lt;T&gt;" name="Segment">
		<summary></summary>
	</property>
	<property type="BrightData.INumericComputation&lt;T&gt;" name="Computation">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ITensorComputation&lt;T&gt;" base="">
	<summary>
		
	</summary>
		<method type="BrightData.Matrix&lt;T&gt;" name="Transpose">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="Multiply">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="m2" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="TransposeAndMultiply">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="m2" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="TransposeThisAndMultiply">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m1" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="m2" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="RowSums">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
			</method>
	<method type="BrightData.Vector&lt;T&gt;" name="ColumnSums">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
			</method>
	<method type="System.Void" name="AddToEachRowInPlace">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
				<param type="BrightData.Vector&lt;T&gt;" name="v" summary="" />
			</method>
	<method type="System.Void" name="AddToEachColumnInPlace">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="m" summary="" />
				<param type="BrightData.Vector&lt;T&gt;" name="v" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="ConcatRows">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="left" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="right" summary="" />
			</method>
	<method type="BrightData.Matrix&lt;T&gt;" name="ConcatColumns">
		<summary></summary>
				<param type="BrightData.Matrix&lt;T&gt;" name="top" summary="" />
				<param type="BrightData.Matrix&lt;T&gt;" name="bottom" summary="" />
			</method>
</interface>
<interface name="BrightData.ITensorPool" base="">
	<summary>
		
	</summary>
		<method type="T[]" name="Get">
		<summary></summary>
				<param type="System.UInt32" name="size" summary="" />
			</method>
	<method type="System.Void" name="Reuse">
		<summary></summary>
				<param type="T[]" name="block" summary="" />
			</method>
	<property type="System.Int64" name="MaxCacheSize">
		<summary></summary>
	</property>
	<property type="System.Int64" name="CacheSize">
		<summary></summary>
	</property>
</interface>
<interface name="BrightData.ITensorSegment&lt;T&gt;" base="BrightData.IReferenceCountedMemory">
	<summary>
		
	</summary>
		<property type="BrightData.IBrightDataContext" name="Context">
		<summary></summary>
	</property>
	<method type="(T[] Block, System.Boolean IsNewCopy)" name="GetBlock">
		<summary></summary>
				<param type="BrightData.ITensorPool" name="pool" summary="" />
			</method>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<property type="T" name="this">
		<summary></summary>
	</property>
	<method type="T[]" name="ToArray">
		<summary></summary>
			</method>
	<property type="System.Collections.Generic.IEnumerable&lt;T&gt;" name="Values">
		<summary></summary>
	</property>
	<method type="System.Void" name="InitializeFrom">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="System.Func&lt;System.UInt32, T&gt;" name="initializer" summary="" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="T" name="initializer" summary="" />
			</method>
	<method type="System.Void" name="Initialize">
		<summary></summary>
				<param type="T[]" name="initialData" summary="" />
			</method>
	<method type="System.Void" name="WriteTo">
		<summary></summary>
				<param type="System.IO.Stream" name="writerBaseStream" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="T[]" name="array" summary="" />
			</method>
	<method type="System.Void" name="CopyTo">
		<summary></summary>
				<param type="BrightData.ITensorSegment&lt;T&gt;" name="segment" summary="" />
			</method>
</interface>
<interface name="BrightTable.ITransformColumnOrientedDataTable" base="">
	<summary>
		
	</summary>
		<method type="BrightTable.IColumnOrientedDataTable" name="Transform">
		<summary></summary>
				<param type="BrightTable.IColumnOrientedDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
</interface>
<interface name="BrightTable.ITransformRowOrientedDataTable" base="">
	<summary>
		
	</summary>
		<method type="BrightTable.IRowOrientedDataTable" name="Transform">
		<summary></summary>
				<param type="BrightTable.IRowOrientedDataTable" name="dataTable" summary="" />
				<param type="System.String" name="filePath" summary="" />
			</method>
</interface>
<interface name="BrightTable.ITypedRowConsumer" base="">
	<summary>
		
	</summary>
		<property type="System.UInt32" name="ColumnIndex">
		<summary></summary>
	</property>
	<property type="BrightTable.ColumnType" name="ColumnType">
		<summary></summary>
	</property>
</interface>
<interface name="BrightTable.ITypedRowConsumer&lt;T&gt;" base="BrightTable.ITypedRowConsumer">
	<summary>
		
	</summary>
	</interface>
<interface name="BrightWire.IVolumeDataSource" base="">
	<summary>
		Volume (3D tensor) based data sources
	</summary>
		<property type="System.UInt32" name="Width">
		<summary>Width of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Height">
		<summary>Height of each input volume</summary>
	</property>
	<property type="System.UInt32" name="Depth">
		<summary>Depth of each input volume</summary>
	</property>
</interface>
<interface name="BrightWire.IWeightedIndexListEncoder" base="">
	<summary>
		Encodes weighted index lists to dense vectors
	</summary>
		<method type="System.Single[]" name="Encode">
		<summary>Encodes the weighted index list to a dense vector</summary>
				<param type="BrightData.WeightedIndexList" name="indexList" summary="" />
			</method>
</interface>
<interface name="BrightWire.IWeightInitialisation" base="">
	<summary>
		Neural network weight initialiser
	</summary>
		<method type="BrightData.IFloatVector" name="CreateBias">
		<summary>Creates the bias vector</summary>
				<param type="System.UInt32" name="size" summary="The size of the vector" />
			</method>
	<method type="BrightData.IFloatMatrix" name="CreateWeight">
		<summary>Creates the weight matrix</summary>
				<param type="System.UInt32" name="rows" summary="Row count" />
				<param type="System.UInt32" name="columns" summary="Column count" />
			</method>
</interface>
<interface name="BrightWire.IWire" base="">
	<summary>
		Wires connect nodes in the graph
	</summary>
		<property type="BrightWire.INode" name="SendTo">
		<summary>The node to send a signal to</summary>
	</property>
	<property type="System.UInt32" name="Channel">
		<summary>The channel</summary>
	</property>
</interface>
<interface name="BrightData.IWriteToMetaData" base="">
	<summary>
		
	</summary>
		<method type="System.Void" name="WriteTo">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</interface>

<class name="BrightWire.Models.ConfusionMatrix.ActualClassification" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Int32" name="ClassificationIndex">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="Count">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.TrainingData.Artificial.And" base="" is-static="true" is-abstract="false">
	<summary>
		Simple AND training data
	</summary>
	<method type="BrightTable.IRowOrientedDataTable" name="Get" is-static="true">
		<summary>Generates a data table containing AND training data</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.BackpropagationBase&lt;T&gt;" base="" is-static="false" is-abstract="true">
	<summary>
		Base class for node backpropagation
	</summary>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary>Dispose</summary>
			</method>
	<method type="System.Void" name="Backward" is-static="false">
		<summary>Called when backpropagating</summary>
				<param type="BrightWire.INode" name="fromNode" summary="The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="Parents of the current node" />
			</method>
	<method type="System.Void" name="_Backward" is-static="false">
		<summary>Called when a valid error signal has been received</summary>
				<param type="BrightWire.INode" name="fromNode" summary=">The node that sent the backpropagation signal" />
				<param type="BrightWire.IGraphData" name="errorSignal" summary="The backpropagating error" />
				<param type="BrightWire.IContext" name="context" summary="Graph context" />
				<param type="BrightWire.INode[]" name="parents" summary="Parents of the current node" />
			</method>
</class>
<class name="BrightData.Distributions.BernoulliDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BernoulliDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
			</method>
	<property type="System.Single" name="Probability">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes" base="" is-static="false" is-abstract="false">
	<summary>
		A bernoulli naive bayes model
	</summary>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class[]" name="ClassData">
		<summary>Classification data</summary>
	</property>
	<property type="System.UInt32[]" name="Vocabulary">
		<summary>The list of string indexes that were in the training set</summary>
	</property>
	<method type="BrightWire.IIndexListClassifier" name="CreateClassifier" is-static="false">
		<summary>Creates a classifier from this model</summary>
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.TrainingData.Helper.BigEndianBinaryReader" base="System.IO.BinaryReader" is-static="false" is-abstract="false">
	<summary>
		Binary reader for big endian streams
	</summary>
	<method type="System.Void" name="BigEndianBinaryReader" is-static="false">
		<summary>Creates a new big endian binary reader</summary>
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
	<method type="System.Int32" name="ReadInt32" is-static="false">
		<summary>Reads an int</summary>
			</method>
	<method type="System.Int16" name="ReadInt16" is-static="false">
		<summary>Reads a short</summary>
			</method>
	<method type="System.Int64" name="ReadInt64" is-static="false">
		<summary>Reads a long</summary>
			</method>
	<method type="System.UInt32" name="ReadUInt32" is-static="false">
		<summary>Reads a ulong</summary>
			</method>
</class>
<class name="BrightData.BinaryData" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BinaryData" is-static="false">
		<summary></summary>
				<param type="System.Byte[]" name="data" summary="" />
			</method>
	<method type="System.Void" name="BinaryData" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<property type="System.Byte[]" name="Data">
		<summary></summary>
	</property>
	<method type="System.String" name="ToString" is-static="false">
		<summary></summary>
			</method>
	<method type="System.Boolean" name="Equals" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Int32" name="GetHashCode" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.ExecutionGraph.Node.Gate.BinaryGateBase" base="BrightWire.ExecutionGraph.Node.NodeBase" is-static="false" is-abstract="true">
	<summary>
		Base class for nodes that accept two input signals and output one signal
	</summary>
	<method type="System.Void" name="ExecuteForward" is-static="false">
		<summary>Executes on the primary channel</summary>
				<param type="BrightWire.IContext" name="context" summary="The graph context" />
			</method>
</class>
<class name="BrightWire.TrainingData.Artificial.BinaryIntegers" base="" is-static="false" is-abstract="false">
	<summary>
		Creates random integers and returns feature vectors against binary mathematical logic
	</summary>
	<method type="BrightTable.IRowOrientedDataTable" name="Addition" is-static="true">
		<summary>Creates random integers added together as feature vectors
The input feature contains two features, one for each bit at that position
The output feature contains a single feature: 1 or 0 if that bit is set in the result</summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Int32" name="sampleCount" summary="How many samples to generate" />
			</method>
</class>
<class name="BrightData.Distributions.BinomialDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BinomialDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="probability" summary="" />
				<param type="System.UInt32" name="numTrials" summary="" />
			</method>
	<property type="BrightData.Distributions.BernoulliDistribution" name="BaseDistribution">
		<summary></summary>
	</property>
	<property type="System.UInt32" name="NumTrials">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightData.BrightDataContext" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="BrightDataContext" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.Int32&gt;" name="randomSeed" summary="" />
				<param type="System.Int64" name="maxCacheSize" summary="" />
			</method>
	<method type="System.Void" name="Dispose" is-static="false">
		<summary></summary>
			</method>
	<property type="System.Random" name="Random">
		<summary></summary>
	</property>
	<property type="BrightData.ITensorPool" name="TensorPool">
		<summary></summary>
	</property>
	<property type="BrightData.IDisposableLayers" name="MemoryLayer">
		<summary></summary>
	</property>
	<property type="BrightData.IDataReader" name="DataReader">
		<summary></summary>
	</property>
	<method type="BrightData.INumericComputation&lt;T&gt;" name="GetComputation" is-static="false">
		<summary></summary>
			</method>
	<property type="BrightData.ILinearAlgebraProvider" name="LinearAlgebraProvider">
		<summary></summary>
	</property>
	<property type="BrightData.IProvideTempStreams" name="TempStreamProvider">
		<summary></summary>
	</property>
	<method type="T" name="Get" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="T" name="value" summary="" />
			</method>
	<method type="T" name="Set" is-static="false">
		<summary></summary>
				<param type="System.String" name="name" summary="" />
				<param type="System.Func&lt;T&gt;" name="valueCreator" summary="" />
			</method>
	<property type="System.Boolean" name="IsStochastic">
		<summary></summary>
	</property>
</class>
<class name="BrightData.Buffers.BufferedStreamReader" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.ICanEnumerate&lt;T&gt;" name="GetReader" is-static="true">
		<summary></summary>
				<param type="System.IO.Stream" name="stream" summary="" />
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.UInt32" name="inMemorySize" summary="" />
			</method>
</class>
<class name="BrightData.Buffers.BufferWriter" base="" is-static="true" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CopyTo" is-static="true">
		<summary></summary>
				<param type="BrightData.IHybridBuffer&lt;T&gt;" name="buffer" summary="" />
				<param type="System.IO.Stream" name="stream" summary="" />
			</method>
</class>
<class name="BrightData.Analysis.CastToDoubleNumericAnalysis&lt;T&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CastToDoubleNumericAnalysis" is-static="false">
		<summary></summary>
				<param type="System.Int32" name="writeCount" summary="" />
			</method>
	<property type="BrightData.Analysis.NumericAnalyser" name="Analysis">
		<summary></summary>
	</property>
	<method type="System.Void" name="Add" is-static="false">
		<summary></summary>
				<param type="T" name="obj" summary="" />
			</method>
	<method type="System.Void" name="AddObject" is-static="false">
		<summary></summary>
				<param type="System.Object" name="obj" summary="" />
			</method>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metadata" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability" base="" is-static="false" is-abstract="false">
	<summary>
		A category and its associated log probability
	</summary>
	<property type="System.String" name="Category">
		<summary>The category label</summary>
	</property>
	<property type="System.Double" name="LogProbability">
		<summary>The natural log of the category's probability</summary>
	</property>
	<property type="System.Double" name="Probability">
		<summary>The category's probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightData.Distributions.CategoricalDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="CategoricalDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" name="categoricalValues" summary="" />
			</method>
	<property type="System.Single[]" name="CumulativeValues">
		<summary></summary>
	</property>
	<property type="System.Single" name="CumulativeTotal">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightWire.Models.Bayesian.BernoulliNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		A classification
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The log of the prior probablilty for this classification</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The log of the missing probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.BernoulliNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of probabilities for each string index</summary>
	</property>
	<property type="System.Double" name="InverseMissingProbability">
		<summary>The log of the inverse missing probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.MultinomialNaiveBayes.Class" base="" is-static="false" is-abstract="false">
	<summary>
		Classification data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification's prior log probability</summary>
	</property>
	<property type="System.Double" name="MissingProbability">
		<summary>The classifications missing log probability</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.MultinomialNaiveBayes.StringIndexProbability[]" name="Index">
		<summary>The list of string indexes and their probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.ClassSummary" base="" is-static="false" is-abstract="false">
	<summary>
		A classification and its associated data
	</summary>
	<property type="System.String" name="Label">
		<summary>The classification label</summary>
	</property>
	<property type="System.Double" name="LogPrior">
		<summary>The natural log of the prior</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.Column[]" name="ColumnSummary">
		<summary>The column data associated with this classification</summary>
	</property>
	<property type="System.Double" name="Prior">
		<summary>The classification prior probability</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightWire.Models.Bayesian.NaiveBayes.Column" base="" is-static="false" is-abstract="false">
	<summary>
		A column within the naive bayes model
	</summary>
	<property type="System.UInt32" name="ColumnIndex">
		<summary>Index within the data set</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.ColumnType" name="Type">
		<summary>Type of column (categorical or continuous)</summary>
	</property>
	<property type="System.Double" name="Variance">
		<summary>The variance of the column values (continuous only)</summary>
	</property>
	<property type="System.Double" name="Mean">
		<summary>The mean of the column values (continuous only)</summary>
	</property>
	<property type="BrightWire.Models.Bayesian.NaiveBayes.CategorialProbability[]" name="Probability">
		<summary>The list of categories within the column and their probability (categorical only)</summary>
	</property>
	<method type="System.Void" name="WriteTo" is-static="false">
		<summary></summary>
				<param type="System.IO.BinaryWriter" name="writer" summary="" />
			</method>
	<method type="System.Void" name="Initialize" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.IO.BinaryReader" name="reader" summary="" />
			</method>
</class>
<class name="BrightTable.Transformations.ColumnConversion" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ColumnConversion" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="" />
				<param type="BrightTable.ColumnConversionType" name="type" summary="" />
			</method>
	<method type="System.Void" name="ColumnConversion" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="columnIndex" summary="" />
				<param type="BrightData.ICanConvert" name="converter" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="Index">
		<summary></summary>
	</property>
	<method type="BrightData.ICanConvert" name="GetConverter" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="fromType" summary="" />
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.Helper.TempStreamManager" name="tempStreams" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="implicit operator ColumnConversion" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnConversionType" name="type" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="implicit operator ColumnConversion" is-static="true">
		<summary></summary>
				<param type="(System.UInt32 Index, BrightTable.ColumnConversionType Type)" name="column" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="implicit operator ColumnConversion" is-static="true">
		<summary></summary>
				<param type="(System.UInt32 Index, BrightData.ICanConvert Converter)" name="column" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnConversion" name="Create" is-static="true">
		<summary></summary>
				<param type="System.UInt32" name="index" summary="" />
				<param type="System.Func&lt;TF, TT&gt;" name="converter" summary="" />
			</method>
</class>
<class name="BrightTable.Transformations.ColumnNormalization" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="BrightData.ICanConvert" name="GetConverter" is-static="false">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="fromType" summary="" />
				<param type="BrightTable.ISingleTypeTableSegment" name="column" summary="" />
				<param type="BrightData.Helper.TempStreamManager" name="tempStreams" summary="" />
				<param type="System.UInt32" name="inMemoryRowCount" summary="" />
			</method>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="Index">
		<summary></summary>
	</property>
	<property type="BrightData.NormalizationType" name="NormalizationType">
		<summary></summary>
	</property>
	<method type="System.Void" name="ColumnNormalization" is-static="false">
		<summary></summary>
				<param type="System.Nullable&lt;System.UInt32&gt;" name="index" summary="" />
				<param type="BrightData.NormalizationType" name="type" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnNormalization" name="implicit operator ColumnNormalization" is-static="true">
		<summary></summary>
				<param type="BrightData.NormalizationType" name="type" summary="" />
			</method>
	<method type="BrightTable.Transformations.ColumnNormalization" name="implicit operator ColumnNormalization" is-static="true">
		<summary></summary>
				<param type="(System.UInt32 Index, BrightData.NormalizationType Type)" name="column" summary="" />
			</method>
</class>
<class name="BrightTable.Helper.ColumnTypeClassifier" base="" is-static="true" is-abstract="false">
	<summary>
		Classifies data table column types
	</summary>
	<method type="System.Boolean" name="IsDecimal" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsNumeric" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsContinuous" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsCategorical" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
	<method type="System.Boolean" name="IsStructable" is-static="true">
		<summary></summary>
				<param type="BrightTable.ColumnType" name="columnType" summary="" />
			</method>
</class>
<class name="BrightWire.TreeBased.Training.DecisionTreeTrainer.Config" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="FeatureBagCount">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MinDataPerNode">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Int32&gt;" name="MaxDepth">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.Double&gt;" name="MinInformationGain">
		<summary></summary>
	</property>
	<property type="System.Nullable&lt;System.UInt32&gt;" name="MaxAttributes">
		<summary></summary>
	</property>
</class>
<class name="BrightWire.Models.ConfusionMatrix" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<property type="System.String[]" name="ClassificationLabels">
		<summary></summary>
	</property>
	<property type="BrightWire.Models.ConfusionMatrix.ExpectedClassification[]" name="Classifications">
		<summary></summary>
	</property>
	<property type="System.String" name="AsXml">
		<summary></summary>
	</property>
	<method type="System.UInt32" name="GetCount" is-static="false">
		<summary>Returns the count of the expected vs actual classifications</summary>
				<param type="System.String" name="expected" summary="Expected classification label" />
				<param type="System.String" name="actual" summary="Actual classification label" />
			</method>
</class>
<class name="BrightData.Consts" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
</class>
<class name="BrightData.Distributions.ContinuousDistribution" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="ContinuousDistribution" is-static="false">
		<summary></summary>
				<param type="BrightData.IBrightDataContext" name="context" summary="" />
				<param type="System.Single" name="inclusiveLowerBound" summary="" />
				<param type="System.Single" name="exclusiveUpperBound" summary="" />
			</method>
	<property type="System.Single" name="From">
		<summary></summary>
	</property>
	<property type="System.Single" name="Size">
		<summary></summary>
	</property>
	<method type="System.Single" name="Sample" is-static="false">
		<summary></summary>
			</method>
</class>
<class name="BrightTable.Transformations.ColumnConversion.Converter&lt;TF, TT&gt;" base="" is-static="false" is-abstract="false">
	<summary>
		
	</summary>
	<method type="System.Void" name="Converter" is-static="false">
		<summary></summary>
				<param type="System.Func&lt;TF, TT&gt;" name="converter" summary="" />
			</method>
	<method type="System.Boolean" name="Convert" is-static="false">
		<summary></summary>
				<param type="TF" name="input" summary="" />
				<param type="BrightData.IHybridBuffer&lt;TT&gt;" name="buffer" summary="" />
			</method>
	<method type="System.Void" name="Finalise" is-static="false">
		<summary></summary>
				<param type="BrightData.IMetaData" name="metaData" summary="" />
			</method>
	<property type="System.Type" name="From">
		<summary></summary>
	</property>
	<property type="System.Type" name="To">
		<summary></summary>
	</property>
</class>
